/*! For license information please see CoCreate-twilio.js.LICENSE.txt */
!function(n,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.CoCreate=e():(n.CoCreate=n.CoCreate||{},n.CoCreate.twilio=e())}(this,(function(){return(()=>{var __webpack_modules__={"./node_modules/@twilio/audioplayer/es5/AudioPlayer.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nvar _regenerator = __webpack_require__(/*! babel-runtime/regenerator */ "./node_modules/babel-runtime/regenerator/index.js");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator["throw"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : new P(function (resolve) {\n                resolve(result.value);\n            }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nvar Deferred_1 = __webpack_require__(/*! ./Deferred */ "./node_modules/@twilio/audioplayer/es5/Deferred.js");\nvar EventTarget_1 = __webpack_require__(/*! ./EventTarget */ "./node_modules/@twilio/audioplayer/es5/EventTarget.js");\n/**\n * An {@link AudioPlayer} is an HTMLAudioElement-like object that uses AudioContext\n *   to circumvent browser limitations.\n */\n\nvar AudioPlayer = function (_EventTarget_1$defaul) {\n    _inherits(AudioPlayer, _EventTarget_1$defaul);\n\n    /**\n     * @private\n     */\n    function AudioPlayer(audioContext) {\n        var srcOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n        _classCallCheck(this, AudioPlayer);\n\n        /**\n         * The AudioBufferSourceNode of the actively loaded sound. Null if a sound\n         *   has not been loaded yet. This is re-used for each time the sound is\n         *   played.\n         */\n        var _this = _possibleConstructorReturn(this, (AudioPlayer.__proto__ || Object.getPrototypeOf(AudioPlayer)).call(this));\n\n        _this._audioNode = null;\n        /**\n         * An Array of deferred-like objects for each pending `play` Promise. When\n         *   .pause() is called or .src is set, all pending play Promises are\n         *   immediately rejected.\n         */\n        _this._pendingPlayDeferreds = [];\n        /**\n         * Whether or not the audio element should loop. If disabled during playback,\n         *   playing continues until the sound ends and then stops looping.\n         */\n        _this._loop = false;\n        /**\n         * The source URL of the sound to play. When set, the currently playing sound will stop.\n         */\n        _this._src = \'\';\n        /**\n         * The current sinkId of the device audio is being played through.\n         */\n        _this._sinkId = \'default\';\n        if (typeof srcOrOptions !== \'string\') {\n            options = srcOrOptions;\n        }\n        _this._audioContext = audioContext;\n        _this._audioElement = new (options.AudioFactory || Audio)();\n        _this._bufferPromise = _this._createPlayDeferred().promise;\n        _this._destination = _this._audioContext.destination;\n        _this._gainNode = _this._audioContext.createGain();\n        _this._gainNode.connect(_this._destination);\n        _this._XMLHttpRequest = options.XMLHttpRequestFactory || XMLHttpRequest;\n        _this.addEventListener(\'canplaythrough\', function () {\n            _this._resolvePlayDeferreds();\n        });\n        if (typeof srcOrOptions === \'string\') {\n            _this.src = srcOrOptions;\n        }\n        return _this;\n    }\n\n    _createClass(AudioPlayer, [{\n        key: "load",\n\n        /**\n         * Stop any ongoing playback and reload the source file.\n         */\n        value: function load() {\n            this._load(this._src);\n        }\n        /**\n         * Pause the audio coming from this AudioPlayer. This will reject any pending\n         *   play Promises.\n         */\n\n    }, {\n        key: "pause",\n        value: function pause() {\n            if (this.paused) {\n                return;\n            }\n            this._audioElement.pause();\n            this._audioNode.stop();\n            this._audioNode.disconnect(this._gainNode);\n            this._audioNode = null;\n            this._rejectPlayDeferreds(new Error(\'The play() request was interrupted by a call to pause().\'));\n        }\n        /**\n         * Play the sound. If the buffer hasn\'t loaded yet, wait for the buffer to load. If\n         *   the source URL is not set yet, this Promise will remain pending until a source\n         *   URL is set.\n         */\n\n    }, {\n        key: "play",\n        value: function play() {\n            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n                var _this2 = this;\n\n                var buffer;\n                return _regenerator2.default.wrap(function _callee$(_context) {\n                    while (1) {\n                        switch (_context.prev = _context.next) {\n                            case 0:\n                                if (this.paused) {\n                                    _context.next = 6;\n                                    break;\n                                }\n\n                                _context.next = 3;\n                                return this._bufferPromise;\n\n                            case 3:\n                                if (this.paused) {\n                                    _context.next = 5;\n                                    break;\n                                }\n\n                                return _context.abrupt("return");\n\n                            case 5:\n                                throw new Error(\'The play() request was interrupted by a call to pause().\');\n\n                            case 6:\n                                this._audioNode = this._audioContext.createBufferSource();\n                                this._audioNode.loop = this.loop;\n                                this._audioNode.addEventListener(\'ended\', function () {\n                                    if (_this2._audioNode && _this2._audioNode.loop) {\n                                        return;\n                                    }\n                                    _this2.dispatchEvent(\'ended\');\n                                });\n                                _context.next = 11;\n                                return this._bufferPromise;\n\n                            case 11:\n                                buffer = _context.sent;\n\n                                if (!this.paused) {\n                                    _context.next = 14;\n                                    break;\n                                }\n\n                                throw new Error(\'The play() request was interrupted by a call to pause().\');\n\n                            case 14:\n                                this._audioNode.buffer = buffer;\n                                this._audioNode.connect(this._gainNode);\n                                this._audioNode.start();\n\n                                if (!this._audioElement.srcObject) {\n                                    _context.next = 19;\n                                    break;\n                                }\n\n                                return _context.abrupt("return", this._audioElement.play());\n\n                            case 19:\n                            case "end":\n                                return _context.stop();\n                        }\n                    }\n                }, _callee, this);\n            }));\n        }\n        /**\n         * Change which device the sound should play through.\n         * @param sinkId - The sink of the device to play sound through.\n         */\n\n    }, {\n        key: "setSinkId",\n        value: function setSinkId(sinkId) {\n            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n                return _regenerator2.default.wrap(function _callee2$(_context2) {\n                    while (1) {\n                        switch (_context2.prev = _context2.next) {\n                            case 0:\n                                if (!(typeof this._audioElement.setSinkId !== \'function\')) {\n                                    _context2.next = 2;\n                                    break;\n                                }\n\n                                throw new Error(\'This browser does not support setSinkId.\');\n\n                            case 2:\n                                if (!(sinkId === this.sinkId)) {\n                                    _context2.next = 4;\n                                    break;\n                                }\n\n                                return _context2.abrupt("return");\n\n                            case 4:\n                                if (!(sinkId === \'default\')) {\n                                    _context2.next = 11;\n                                    break;\n                                }\n\n                                if (!this.paused) {\n                                    this._gainNode.disconnect(this._destination);\n                                }\n                                this._audioElement.srcObject = null;\n                                this._destination = this._audioContext.destination;\n                                this._gainNode.connect(this._destination);\n                                this._sinkId = sinkId;\n                                return _context2.abrupt("return");\n\n                            case 11:\n                                _context2.next = 13;\n                                return this._audioElement.setSinkId(sinkId);\n\n                            case 13:\n                                if (!this._audioElement.srcObject) {\n                                    _context2.next = 15;\n                                    break;\n                                }\n\n                                return _context2.abrupt("return");\n\n                            case 15:\n                                this._gainNode.disconnect(this._audioContext.destination);\n                                this._destination = this._audioContext.createMediaStreamDestination();\n                                this._audioElement.srcObject = this._destination.stream;\n                                this._sinkId = sinkId;\n                                this._gainNode.connect(this._destination);\n\n                            case 20:\n                            case "end":\n                                return _context2.stop();\n                        }\n                    }\n                }, _callee2, this);\n            }));\n        }\n        /**\n         * Create a Deferred for a Promise that will be resolved when .src is set or rejected\n         *   when .pause is called.\n         */\n\n    }, {\n        key: "_createPlayDeferred",\n        value: function _createPlayDeferred() {\n            var deferred = new Deferred_1.default();\n            this._pendingPlayDeferreds.push(deferred);\n            return deferred;\n        }\n        /**\n         * Stop current playback and load a sound file.\n         * @param src - The source URL of the file to load\n         */\n\n    }, {\n        key: "_load",\n        value: function _load(src) {\n            var _this3 = this;\n\n            if (this._src && this._src !== src) {\n                this.pause();\n            }\n            this._src = src;\n            this._bufferPromise = new Promise(function (resolve, reject) {\n                return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {\n                    var buffer;\n                    return _regenerator2.default.wrap(function _callee3$(_context3) {\n                        while (1) {\n                            switch (_context3.prev = _context3.next) {\n                                case 0:\n                                    if (src) {\n                                        _context3.next = 2;\n                                        break;\n                                    }\n\n                                    return _context3.abrupt("return", this._createPlayDeferred().promise);\n\n                                case 2:\n                                    _context3.next = 4;\n                                    return bufferSound(this._audioContext, this._XMLHttpRequest, src);\n\n                                case 4:\n                                    buffer = _context3.sent;\n\n                                    this.dispatchEvent(\'canplaythrough\');\n                                    resolve(buffer);\n\n                                case 7:\n                                case "end":\n                                    return _context3.stop();\n                            }\n                        }\n                    }, _callee3, this);\n                }));\n            });\n        }\n        /**\n         * Reject all deferreds for the Play promise.\n         * @param reason\n         */\n\n    }, {\n        key: "_rejectPlayDeferreds",\n        value: function _rejectPlayDeferreds(reason) {\n            var deferreds = this._pendingPlayDeferreds;\n            deferreds.splice(0, deferreds.length).forEach(function (_ref) {\n                var reject = _ref.reject;\n                return reject(reason);\n            });\n        }\n        /**\n         * Resolve all deferreds for the Play promise.\n         * @param result\n         */\n\n    }, {\n        key: "_resolvePlayDeferreds",\n        value: function _resolvePlayDeferreds(result) {\n            var deferreds = this._pendingPlayDeferreds;\n            deferreds.splice(0, deferreds.length).forEach(function (_ref2) {\n                var resolve = _ref2.resolve;\n                return resolve(result);\n            });\n        }\n    }, {\n        key: "destination",\n        get: function get() {\n            return this._destination;\n        }\n    }, {\n        key: "loop",\n        get: function get() {\n            return this._loop;\n        },\n        set: function set(shouldLoop) {\n            // If a sound is already looping, it should continue playing\n            //   the current playthrough and then stop.\n            if (!shouldLoop && this.loop && !this.paused) {\n                var _pauseAfterPlaythrough = function _pauseAfterPlaythrough() {\n                    self._audioNode.removeEventListener(\'ended\', _pauseAfterPlaythrough);\n                    self.pause();\n                };\n\n                var self = this;\n\n                this._audioNode.addEventListener(\'ended\', _pauseAfterPlaythrough);\n            }\n            this._loop = shouldLoop;\n        }\n        /**\n         * Whether the audio element is muted.\n         */\n\n    }, {\n        key: "muted",\n        get: function get() {\n            return this._gainNode.gain.value === 0;\n        },\n        set: function set(shouldBeMuted) {\n            this._gainNode.gain.value = shouldBeMuted ? 0 : 1;\n        }\n        /**\n         * Whether the sound is paused. this._audioNode only exists when sound is playing;\n         *   otherwise AudioPlayer is considered paused.\n         */\n\n    }, {\n        key: "paused",\n        get: function get() {\n            return this._audioNode === null;\n        }\n    }, {\n        key: "src",\n        get: function get() {\n            return this._src;\n        },\n        set: function set(src) {\n            this._load(src);\n        }\n        /**\n         * The srcObject of the HTMLMediaElement\n         */\n\n    }, {\n        key: "srcObject",\n        get: function get() {\n            return this._audioElement.srcObject;\n        },\n        set: function set(srcObject) {\n            this._audioElement.srcObject = srcObject;\n        }\n    }, {\n        key: "sinkId",\n        get: function get() {\n            return this._sinkId;\n        }\n    }]);\n\n    return AudioPlayer;\n}(EventTarget_1.default);\n\nexports.default = AudioPlayer;\n/**\n * Use XMLHttpRequest to load the AudioBuffer of a remote audio asset.\n * @private\n * @param context - The AudioContext to use to decode the audio data\n * @param RequestFactory - The XMLHttpRequest factory to build\n * @param src - The URL of the audio asset to load.\n * @returns A Promise containing the decoded AudioBuffer.\n */\n// tslint:disable-next-line:variable-name\nfunction bufferSound(context, RequestFactory, src) {\n    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {\n        var request, event;\n        return _regenerator2.default.wrap(function _callee4$(_context4) {\n            while (1) {\n                switch (_context4.prev = _context4.next) {\n                    case 0:\n                        request = new RequestFactory();\n\n                        request.open(\'GET\', src, true);\n                        request.responseType = \'arraybuffer\';\n                        _context4.next = 5;\n                        return new Promise(function (resolve) {\n                            request.addEventListener(\'load\', resolve);\n                            request.send();\n                        });\n\n                    case 5:\n                        event = _context4.sent;\n                        _context4.prev = 6;\n                        return _context4.abrupt("return", context.decodeAudioData(event.target.response));\n\n                    case 10:\n                        _context4.prev = 10;\n                        _context4.t0 = _context4["catch"](6);\n                        return _context4.abrupt("return", new Promise(function (resolve) {\n                            context.decodeAudioData(event.target.response, resolve);\n                        }));\n\n                    case 13:\n                    case "end":\n                        return _context4.stop();\n                }\n            }\n        }, _callee4, this, [[6, 10]]);\n    }));\n}\n//# sourceMappingURL=AudioPlayer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvQXVkaW9QbGF5ZXIuanM/ZTExZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyxvRkFBMkI7O0FBRXREOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixzQ0FBc0MsdUNBQXVDLGdCQUFnQjs7QUFFN0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxDQUFDLGNBQWMsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBWTtBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBZTtBQUMzQztBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxDQUFDOztBQUVELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9AdHdpbGlvL2F1ZGlvcGxheWVyL2VzNS9BdWRpb1BsYXllci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvcmVnZW5lcmF0b3JcIik7XG5cbnZhciBfcmVnZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVnZW5lcmF0b3IpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfX2F3YWl0ZXIgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlciB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGVmZXJyZWRfMSA9IHJlcXVpcmUoXCIuL0RlZmVycmVkXCIpO1xudmFyIEV2ZW50VGFyZ2V0XzEgPSByZXF1aXJlKFwiLi9FdmVudFRhcmdldFwiKTtcbi8qKlxuICogQW4ge0BsaW5rIEF1ZGlvUGxheWVyfSBpcyBhbiBIVE1MQXVkaW9FbGVtZW50LWxpa2Ugb2JqZWN0IHRoYXQgdXNlcyBBdWRpb0NvbnRleHRcbiAqICAgdG8gY2lyY3VtdmVudCBicm93c2VyIGxpbWl0YXRpb25zLlxuICovXG5cbnZhciBBdWRpb1BsYXllciA9IGZ1bmN0aW9uIChfRXZlbnRUYXJnZXRfMSRkZWZhdWwpIHtcbiAgICBfaW5oZXJpdHMoQXVkaW9QbGF5ZXIsIF9FdmVudFRhcmdldF8xJGRlZmF1bCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvUGxheWVyKGF1ZGlvQ29udGV4dCkge1xuICAgICAgICB2YXIgc3JjT3JPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdWRpb1BsYXllcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgb2YgdGhlIGFjdGl2ZWx5IGxvYWRlZCBzb3VuZC4gTnVsbCBpZiBhIHNvdW5kXG4gICAgICAgICAqICAgaGFzIG5vdCBiZWVuIGxvYWRlZCB5ZXQuIFRoaXMgaXMgcmUtdXNlZCBmb3IgZWFjaCB0aW1lIHRoZSBzb3VuZCBpc1xuICAgICAgICAgKiAgIHBsYXllZC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdWRpb1BsYXllci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF1ZGlvUGxheWVyKSkuY2FsbCh0aGlzKSk7XG5cbiAgICAgICAgX3RoaXMuX2F1ZGlvTm9kZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBBcnJheSBvZiBkZWZlcnJlZC1saWtlIG9iamVjdHMgZm9yIGVhY2ggcGVuZGluZyBgcGxheWAgUHJvbWlzZS4gV2hlblxuICAgICAgICAgKiAgIC5wYXVzZSgpIGlzIGNhbGxlZCBvciAuc3JjIGlzIHNldCwgYWxsIHBlbmRpbmcgcGxheSBQcm9taXNlcyBhcmVcbiAgICAgICAgICogICBpbW1lZGlhdGVseSByZWplY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9wZW5kaW5nUGxheURlZmVycmVkcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIGF1ZGlvIGVsZW1lbnQgc2hvdWxkIGxvb3AuIElmIGRpc2FibGVkIGR1cmluZyBwbGF5YmFjayxcbiAgICAgICAgICogICBwbGF5aW5nIGNvbnRpbnVlcyB1bnRpbCB0aGUgc291bmQgZW5kcyBhbmQgdGhlbiBzdG9wcyBsb29waW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzb3VyY2UgVVJMIG9mIHRoZSBzb3VuZCB0byBwbGF5LiBXaGVuIHNldCwgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNvdW5kIHdpbGwgc3RvcC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zcmMgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHNpbmtJZCBvZiB0aGUgZGV2aWNlIGF1ZGlvIGlzIGJlaW5nIHBsYXllZCB0aHJvdWdoLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3NpbmtJZCA9ICdkZWZhdWx0JztcbiAgICAgICAgaWYgKHR5cGVvZiBzcmNPck9wdGlvbnMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gc3JjT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gICAgICAgIF90aGlzLl9hdWRpb0VsZW1lbnQgPSBuZXcgKG9wdGlvbnMuQXVkaW9GYWN0b3J5IHx8IEF1ZGlvKSgpO1xuICAgICAgICBfdGhpcy5fYnVmZmVyUHJvbWlzZSA9IF90aGlzLl9jcmVhdGVQbGF5RGVmZXJyZWQoKS5wcm9taXNlO1xuICAgICAgICBfdGhpcy5fZGVzdGluYXRpb24gPSBfdGhpcy5fYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uO1xuICAgICAgICBfdGhpcy5fZ2Fpbk5vZGUgPSBfdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgX3RoaXMuX2dhaW5Ob2RlLmNvbm5lY3QoX3RoaXMuX2Rlc3RpbmF0aW9uKTtcbiAgICAgICAgX3RoaXMuX1hNTEh0dHBSZXF1ZXN0ID0gb3B0aW9ucy5YTUxIdHRwUmVxdWVzdEZhY3RvcnkgfHwgWE1MSHR0cFJlcXVlc3Q7XG4gICAgICAgIF90aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3Jlc29sdmVQbGF5RGVmZXJyZWRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHNyY09yT3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF90aGlzLnNyYyA9IHNyY09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF1ZGlvUGxheWVyLCBbe1xuICAgICAgICBrZXk6IFwibG9hZFwiLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGFueSBvbmdvaW5nIHBsYXliYWNrIGFuZCByZWxvYWQgdGhlIHNvdXJjZSBmaWxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkKHRoaXMuX3NyYyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhdXNlIHRoZSBhdWRpbyBjb21pbmcgZnJvbSB0aGlzIEF1ZGlvUGxheWVyLiBUaGlzIHdpbGwgcmVqZWN0IGFueSBwZW5kaW5nXG4gICAgICAgICAqICAgcGxheSBQcm9taXNlcy5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJwYXVzZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXVzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9hdWRpb0VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvTm9kZS5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUuZGlzY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVqZWN0UGxheURlZmVycmVkcyhuZXcgRXJyb3IoJ1RoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlKCkuJykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbGF5IHRoZSBzb3VuZC4gSWYgdGhlIGJ1ZmZlciBoYXNuJ3QgbG9hZGVkIHlldCwgd2FpdCBmb3IgdGhlIGJ1ZmZlciB0byBsb2FkLiBJZlxuICAgICAgICAgKiAgIHRoZSBzb3VyY2UgVVJMIGlzIG5vdCBzZXQgeWV0LCB0aGlzIFByb21pc2Ugd2lsbCByZW1haW4gcGVuZGluZyB1bnRpbCBhIHNvdXJjZVxuICAgICAgICAgKiAgIFVSTCBpcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicGxheVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yMi5kZWZhdWx0LndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyUHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcGxheSgpIHJlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZSgpLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvTm9kZS5sb29wID0gdGhpcy5sb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMyLl9hdWRpb05vZGUgJiYgX3RoaXMyLl9hdWRpb05vZGUubG9vcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMi5kaXNwYXRjaEV2ZW50KCdlbmRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyUHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBwbGF5KCkgcmVxdWVzdCB3YXMgaW50ZXJydXB0ZWQgYnkgYSBjYWxsIHRvIHBhdXNlKCkuJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdWRpb05vZGUuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvTm9kZS5zdGFydCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYXVkaW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2F1ZGlvRWxlbWVudC5wbGF5KCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlIHdoaWNoIGRldmljZSB0aGUgc291bmQgc2hvdWxkIHBsYXkgdGhyb3VnaC5cbiAgICAgICAgICogQHBhcmFtIHNpbmtJZCAtIFRoZSBzaW5rIG9mIHRoZSBkZXZpY2UgdG8gcGxheSBzb3VuZCB0aHJvdWdoLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNldFNpbmtJZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2lua0lkKHNpbmtJZCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgLyojX19QVVJFX18qL19yZWdlbmVyYXRvcjIuZGVmYXVsdC5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IyLmRlZmF1bHQud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiB0aGlzLl9hdWRpb0VsZW1lbnQuc2V0U2lua0lkICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHNldFNpbmtJZC4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2lua0lkID09PSB0aGlzLnNpbmtJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHNpbmtJZCA9PT0gJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCh0aGlzLl9kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9FbGVtZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3RpbmF0aW9uID0gdGhpcy5fYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5jb25uZWN0KHRoaXMuX2Rlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2lua0lkID0gc2lua0lkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0VsZW1lbnQuc2V0U2lua0lkKHNpbmtJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2F1ZGlvRWxlbWVudC5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuZGlzY29ubmVjdCh0aGlzLl9hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXN0aW5hdGlvbiA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5zcmNPYmplY3QgPSB0aGlzLl9kZXN0aW5hdGlvbi5zdHJlYW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NpbmtJZCA9IHNpbmtJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2Fpbk5vZGUuY29ubmVjdCh0aGlzLl9kZXN0aW5hdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIERlZmVycmVkIGZvciBhIFByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gLnNyYyBpcyBzZXQgb3IgcmVqZWN0ZWRcbiAgICAgICAgICogICB3aGVuIC5wYXVzZSBpcyBjYWxsZWQuXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiX2NyZWF0ZVBsYXlEZWZlcnJlZFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBsYXlEZWZlcnJlZCgpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZF8xLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQbGF5RGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdG9wIGN1cnJlbnQgcGxheWJhY2sgYW5kIGxvYWQgYSBzb3VuZCBmaWxlLlxuICAgICAgICAgKiBAcGFyYW0gc3JjIC0gVGhlIHNvdXJjZSBVUkwgb2YgdGhlIGZpbGUgdG8gbG9hZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9sb2FkXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZChzcmMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3JjICYmIHRoaXMuX3NyYyAhPT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3JjID0gc3JjO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzMywgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IyLmRlZmF1bHQubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMuX2NyZWF0ZVBsYXlEZWZlcnJlZCgpLnByb21pc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBidWZmZXJTb3VuZCh0aGlzLl9hdWRpb0NvbnRleHQsIHRoaXMuX1hNTEh0dHBSZXF1ZXN0LCBzcmMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IF9jb250ZXh0My5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2NhbnBsYXl0aHJvdWdoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGJ1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVqZWN0IGFsbCBkZWZlcnJlZHMgZm9yIHRoZSBQbGF5IHByb21pc2UuXG4gICAgICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJfcmVqZWN0UGxheURlZmVycmVkc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlamVjdFBsYXlEZWZlcnJlZHMocmVhc29uKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWRzID0gdGhpcy5fcGVuZGluZ1BsYXlEZWZlcnJlZHM7XG4gICAgICAgICAgICBkZWZlcnJlZHMuc3BsaWNlKDAsIGRlZmVycmVkcy5sZW5ndGgpLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ID0gX3JlZi5yZWplY3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChyZWFzb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmUgYWxsIGRlZmVycmVkcyBmb3IgdGhlIFBsYXkgcHJvbWlzZS5cbiAgICAgICAgICogQHBhcmFtIHJlc3VsdFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcIl9yZXNvbHZlUGxheURlZmVycmVkc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc29sdmVQbGF5RGVmZXJyZWRzKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGRlZmVycmVkcyA9IHRoaXMuX3BlbmRpbmdQbGF5RGVmZXJyZWRzO1xuICAgICAgICAgICAgZGVmZXJyZWRzLnNwbGljZSgwLCBkZWZlcnJlZHMubGVuZ3RoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gX3JlZjIucmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJkZXN0aW5hdGlvblwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZXN0aW5hdGlvbjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImxvb3BcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoc2hvdWxkTG9vcCkge1xuICAgICAgICAgICAgLy8gSWYgYSBzb3VuZCBpcyBhbHJlYWR5IGxvb3BpbmcsIGl0IHNob3VsZCBjb250aW51ZSBwbGF5aW5nXG4gICAgICAgICAgICAvLyAgIHRoZSBjdXJyZW50IHBsYXl0aHJvdWdoIGFuZCB0aGVuIHN0b3AuXG4gICAgICAgICAgICBpZiAoIXNob3VsZExvb3AgJiYgdGhpcy5sb29wICYmICF0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHZhciBfcGF1c2VBZnRlclBsYXl0aHJvdWdoID0gZnVuY3Rpb24gX3BhdXNlQWZ0ZXJQbGF5dGhyb3VnaCgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fYXVkaW9Ob2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3BhdXNlQWZ0ZXJQbGF5dGhyb3VnaCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXVkaW9Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgX3BhdXNlQWZ0ZXJQbGF5dGhyb3VnaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb29wID0gc2hvdWxkTG9vcDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgYXVkaW8gZWxlbWVudCBpcyBtdXRlZC5cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJtdXRlZFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nYWluTm9kZS5nYWluLnZhbHVlID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzaG91bGRCZU11dGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9nYWluTm9kZS5nYWluLnZhbHVlID0gc2hvdWxkQmVNdXRlZCA/IDAgOiAxO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBzb3VuZCBpcyBwYXVzZWQuIHRoaXMuX2F1ZGlvTm9kZSBvbmx5IGV4aXN0cyB3aGVuIHNvdW5kIGlzIHBsYXlpbmc7XG4gICAgICAgICAqICAgb3RoZXJ3aXNlIEF1ZGlvUGxheWVyIGlzIGNvbnNpZGVyZWQgcGF1c2VkLlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInBhdXNlZFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb05vZGUgPT09IG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzcmNcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3JjO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcmMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWQoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNyY09iamVjdCBvZiB0aGUgSFRNTE1lZGlhRWxlbWVudFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInNyY09iamVjdFwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hdWRpb0VsZW1lbnQuc3JjT2JqZWN0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcmNPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvRWxlbWVudC5zcmNPYmplY3QgPSBzcmNPYmplY3Q7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJzaW5rSWRcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2lua0lkO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEF1ZGlvUGxheWVyO1xufShFdmVudFRhcmdldF8xLmRlZmF1bHQpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBBdWRpb1BsYXllcjtcbi8qKlxuICogVXNlIFhNTEh0dHBSZXF1ZXN0IHRvIGxvYWQgdGhlIEF1ZGlvQnVmZmVyIG9mIGEgcmVtb3RlIGF1ZGlvIGFzc2V0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIEF1ZGlvQ29udGV4dCB0byB1c2UgdG8gZGVjb2RlIHRoZSBhdWRpbyBkYXRhXG4gKiBAcGFyYW0gUmVxdWVzdEZhY3RvcnkgLSBUaGUgWE1MSHR0cFJlcXVlc3QgZmFjdG9yeSB0byBidWlsZFxuICogQHBhcmFtIHNyYyAtIFRoZSBVUkwgb2YgdGhlIGF1ZGlvIGFzc2V0IHRvIGxvYWQuXG4gKiBAcmV0dXJucyBBIFByb21pc2UgY29udGFpbmluZyB0aGUgZGVjb2RlZCBBdWRpb0J1ZmZlci5cbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbmZ1bmN0aW9uIGJ1ZmZlclNvdW5kKGNvbnRleHQsIFJlcXVlc3RGYWN0b3J5LCBzcmMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yMi5kZWZhdWx0Lm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgIHZhciByZXF1ZXN0LCBldmVudDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcjIuZGVmYXVsdC53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0JChfY29udGV4dDQpIHtcbiAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdEZhY3RvcnkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBzcmMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgcmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ0LnByZXYgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoZXZlbnQudGFyZ2V0LnJlc3BvbnNlKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5wcmV2ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDQudDAgPSBfY29udGV4dDRbXCJjYXRjaFwiXSg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kZWNvZGVBdWRpb0RhdGEoZXZlbnQudGFyZ2V0LnJlc3BvbnNlLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0LCB0aGlzLCBbWzYsIDEwXV0pO1xuICAgIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1ZGlvUGxheWVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@twilio/audioplayer/es5/AudioPlayer.js\n')},"./node_modules/@twilio/audioplayer/es5/Deferred.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar Deferred = function () {\n    function Deferred() {\n        var _this = this;\n\n        _classCallCheck(this, Deferred);\n\n        this.promise = new Promise(function (resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n    }\n\n    _createClass(Deferred, [{\n        key: "reject",\n        get: function get() {\n            return this._reject;\n        }\n    }, {\n        key: "resolve",\n        get: function get() {\n            return this._resolve;\n        }\n    }]);\n\n    return Deferred;\n}();\n\nexports.default = Deferred;\n//# sourceMappingURL=Deferred.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvRGVmZXJyZWQuanM/YzFkZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosOENBQTZDLENBQUMsY0FBYyxFQUFDOztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRCxlQUFlO0FBQ2YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvRGVmZXJyZWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgRGVmZXJyZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERlZmVycmVkKTtcblxuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRGVmZXJyZWQsIFt7XG4gICAgICAgIGtleTogXCJyZWplY3RcIixcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVqZWN0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwicmVzb2x2ZVwiLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIERlZmVycmVkO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEZWZlcnJlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmVycmVkLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@twilio/audioplayer/es5/Deferred.js\n')},"./node_modules/@twilio/audioplayer/es5/EventTarget.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nvar events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");\n\nvar EventTarget = function () {\n    function EventTarget() {\n        _classCallCheck(this, EventTarget);\n\n        this._eventEmitter = new events_1.EventEmitter();\n    }\n\n    _createClass(EventTarget, [{\n        key: "addEventListener",\n        value: function addEventListener(name, handler) {\n            return this._eventEmitter.addListener(name, handler);\n        }\n    }, {\n        key: "dispatchEvent",\n        value: function dispatchEvent(name) {\n            var _eventEmitter;\n\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return (_eventEmitter = this._eventEmitter).emit.apply(_eventEmitter, [name].concat(args));\n        }\n    }, {\n        key: "removeEventListener",\n        value: function removeEventListener(name, handler) {\n            return this._eventEmitter.removeListener(name, handler);\n        }\n    }]);\n\n    return EventTarget;\n}();\n\nexports.default = EventTarget;\n//# sourceMappingURL=EventTarget.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvRXZlbnRUYXJnZXQuanM/OGM3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQywrQ0FBUTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQsZUFBZTtBQUNmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0B0d2lsaW8vYXVkaW9wbGF5ZXIvZXM1L0V2ZW50VGFyZ2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5cbnZhciBFdmVudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50VGFyZ2V0KTtcblxuICAgICAgICB0aGlzLl9ldmVudEVtaXR0ZXIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEV2ZW50VGFyZ2V0LCBbe1xuICAgICAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRFbWl0dGVyLmFkZExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZGlzcGF0Y2hFdmVudFwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgX2V2ZW50RW1pdHRlcjtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoX2V2ZW50RW1pdHRlciA9IHRoaXMuX2V2ZW50RW1pdHRlcikuZW1pdC5hcHBseShfZXZlbnRFbWl0dGVyLCBbbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBFdmVudFRhcmdldDtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRUYXJnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudFRhcmdldC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@twilio/audioplayer/es5/EventTarget.js\n')},"./node_modules/@twilio/audioplayer/es5/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar AudioPlayer = __webpack_require__(/*! ./AudioPlayer */ "./node_modules/@twilio/audioplayer/es5/AudioPlayer.js");\n\nmodule.exports = AudioPlayer.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvaW5kZXguanM/NjFkNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBZTs7QUFFekMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHR3aWxpby9hdWRpb3BsYXllci9lczUvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBBdWRpb1BsYXllciA9IHJlcXVpcmUoJy4vQXVkaW9QbGF5ZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdWRpb1BsYXllci5kZWZhdWx0OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@twilio/audioplayer/es5/index.js\n')},"./node_modules/array-filter/index.js":module=>{eval("\n/**\n * Array#filter.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Object=} self\n * @return {Array}\n * @throw TypeError\n */\n\nmodule.exports = function (arr, fn, self) {\n  if (arr.filter) return arr.filter(fn, self);\n  if (void 0 === arr || null === arr) throw new TypeError;\n  if ('function' != typeof fn) throw new TypeError;\n  var ret = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (!hasOwn.call(arr, i)) continue;\n    var val = arr[i];\n    if (fn.call(self, val, i, arr)) ret.push(val);\n  }\n  return ret;\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYXJyYXktZmlsdGVyL2luZGV4LmpzP2IyYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9hcnJheS1maWx0ZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogQXJyYXkjZmlsdGVyLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gc2VsZlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3cgVHlwZUVycm9yXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJyLCBmbiwgc2VsZikge1xuICBpZiAoYXJyLmZpbHRlcikgcmV0dXJuIGFyci5maWx0ZXIoZm4sIHNlbGYpO1xuICBpZiAodm9pZCAwID09PSBhcnIgfHwgbnVsbCA9PT0gYXJyKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBUeXBlRXJyb3I7XG4gIHZhciByZXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093bi5jYWxsKGFyciwgaSkpIGNvbnRpbnVlO1xuICAgIHZhciB2YWwgPSBhcnJbaV07XG4gICAgaWYgKGZuLmNhbGwoc2VsZiwgdmFsLCBpLCBhcnIpKSByZXQucHVzaCh2YWwpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG52YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/array-filter/index.js\n")},"./node_modules/available-typed-arrays/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar filter = __webpack_require__(/*! array-filter */ \"./node_modules/array-filter/index.js\");\n\nmodule.exports = function availableTypedArrays() {\n\treturn filter([\n\t\t'BigInt64Array',\n\t\t'BigUint64Array',\n\t\t'Float32Array',\n\t\t'Float64Array',\n\t\t'Int16Array',\n\t\t'Int32Array',\n\t\t'Int8Array',\n\t\t'Uint16Array',\n\t\t'Uint32Array',\n\t\t'Uint8Array',\n\t\t'Uint8ClampedArray'\n\t], function (typedArray) {\n\t\treturn typeof __webpack_require__.g[typedArray] === 'function';\n\t});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcz83MjI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwREFBYzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBTTtBQUN0QixFQUFFO0FBQ0YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXZhaWxhYmxlLXR5cGVkLWFycmF5cy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGZpbHRlciA9IHJlcXVpcmUoJ2FycmF5LWZpbHRlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF2YWlsYWJsZVR5cGVkQXJyYXlzKCkge1xuXHRyZXR1cm4gZmlsdGVyKFtcblx0XHQnQmlnSW50NjRBcnJheScsXG5cdFx0J0JpZ1VpbnQ2NEFycmF5Jyxcblx0XHQnRmxvYXQzMkFycmF5Jyxcblx0XHQnRmxvYXQ2NEFycmF5Jyxcblx0XHQnSW50MTZBcnJheScsXG5cdFx0J0ludDMyQXJyYXknLFxuXHRcdCdJbnQ4QXJyYXknLFxuXHRcdCdVaW50MTZBcnJheScsXG5cdFx0J1VpbnQzMkFycmF5Jyxcblx0XHQnVWludDhBcnJheScsXG5cdFx0J1VpbnQ4Q2xhbXBlZEFycmF5J1xuXHRdLCBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHRcdHJldHVybiB0eXBlb2YgZ2xvYmFsW3R5cGVkQXJyYXldID09PSAnZnVuY3Rpb24nO1xuXHR9KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/available-typed-arrays/index.js\n")},"../../CoCreate-components/CoCreate-action/src/index.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n// -testing1\nconst CoCreateAction = {\n  attribute: 'data-actions',\n  actions: {},\n  selectedStage: [],\n  stageIndex: 0,\n  selectedElement: null,\n  completedEventName: 'completedEvent',\n  __init: function () {\n    this.actionButtonEvent();\n  },\n  // init: function(container) {\n  //   const __container = container || document\n  //   if (!__container.querySelectorAll) {\n  // \treturn;\n  // }\n  // let buttons = __container.querySelectorAll(\"[data-actions]\");\n  // for (let i = 0; i < buttons.length; i++) {\n  //   this.actionButtonEvent(buttons[i]);\n  // }\n  // },\n  // actionButtonEvent: function(btn) {\n  //   const _this = this;    \n  // let checkActions = btn.getAttribute('data-actions') || \"\";\n  // checkActions = checkActions.replace(/\\s/g, '').split(',');\n  // if (checkActions.length == 0) {\n  //   return;\n  // }\n  //   btn.addEventListener('click', function(event) {\n  //     event.preventDefault();\n  //     let actions = this.getAttribute(_this.attribute) || \"\";\n  //     actions = actions.replace(/\\s/g, '').split(',');\n  //     _this.stageIndex = 0;\n  //     _this.selectedStage = actions;\n  //     //. run function\n  //     _this.selectedElement = btn;\n  //     _this.__runActionFunc();\n  //   })\n  // },\n  actionButtonEvent: function () {\n    const self = this;\n    document.addEventListener('click', function (event) {\n      let btn = event.target;\n\n      if (!btn.getAttribute('data-actions')) {\n        btn = event.target.closest('[data-actions]');\n      }\n\n      if (!btn) return;\n      event.preventDefault();\n      let actions = (btn.getAttribute(self.attribute) || \"\").replace(/\\s/g, '').split(',');\n      if (actions.length == 0) return;\n      self.stageIndex = 0;\n      self.selectedStage = actions; //. run function\n\n      self.selectedElement = btn;\n\n      self.__runActionFunc();\n    });\n  },\n  init: function ({\n    action,\n    callback,\n    endEvent\n  }) {\n    this.registerEvent(action, callback, null, endEvent);\n  },\n\n  /**\n   * key: string\n   * runFunc: function\n   * instance: object\n   * endEvent: string\n   **/\n  registerEvent: function (key, runFunc, instance, endEvent) {\n    if (this.actions[key]) {\n      return;\n    }\n\n    this.actions[key] = {\n      key: key,\n      runFunc: runFunc,\n      instance: instance || window,\n      endEvent: endEvent\n    }; //. register events\n\n    for (let __key in this.actions) {\n      if (__key != key && this.actions[__key]['endEvent'] === endEvent) {\n        return;\n      }\n    } //. register events\n\n\n    const _this = this;\n\n    document.addEventListener(endEvent, function (e) {\n      _this.__nextAction(endEvent, e.detail);\n    });\n  },\n  __runActionFunc: function (data) {\n    if (this.stageIndex >= this.selectedStage.length) {\n      //. if latest case, it will be run aTag\n      if (this.stageIndex == this.selectedStage.length) {\n        this.__runAtag(this.selectedElement);\n      }\n\n      return;\n    }\n\n    const key = this.selectedStage[this.stageIndex]; //. run function\n\n    const action = this.actions[key];\n\n    if (action) {\n      if (action.runFunc) {\n        action.runFunc.call(null, this.selectedElement, data);\n      } else {\n        this.__nextAction(action.endEvent, {});\n      }\n    }\n  },\n  __nextAction: function (eventName, data) {\n    const key = this.selectedStage[this.stageIndex];\n\n    if (!key) {\n      return;\n    }\n\n    if (eventName !== this.actions[key].endEvent) {\n      return;\n    }\n\n    this.stageIndex++;\n\n    this.__runActionFunc(data);\n  },\n  __runAtag: function (button) {\n    var aTag = button.querySelector('a');\n\n    if (aTag) {\n      CoCreate.logic.setLinkProcess(aTag);\n    }\n  }\n};\n\nCoCreateAction.__init();\n\nvar _default = CoCreateAction;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1hY3Rpb24vc3JjL2luZGV4LmpzPzgyNWIiXSwibmFtZXMiOlsiQ29DcmVhdGVBY3Rpb24iLCJhdHRyaWJ1dGUiLCJhY3Rpb25zIiwic2VsZWN0ZWRTdGFnZSIsInN0YWdlSW5kZXgiLCJzZWxlY3RlZEVsZW1lbnQiLCJjb21wbGV0ZWRFdmVudE5hbWUiLCJfX2luaXQiLCJhY3Rpb25CdXR0b25FdmVudCIsInNlbGYiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsImJ0biIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsImNsb3Nlc3QiLCJwcmV2ZW50RGVmYXVsdCIsInJlcGxhY2UiLCJzcGxpdCIsImxlbmd0aCIsIl9fcnVuQWN0aW9uRnVuYyIsImluaXQiLCJhY3Rpb24iLCJjYWxsYmFjayIsImVuZEV2ZW50IiwicmVnaXN0ZXJFdmVudCIsImtleSIsInJ1bkZ1bmMiLCJpbnN0YW5jZSIsIndpbmRvdyIsIl9fa2V5IiwiX3RoaXMiLCJlIiwiX19uZXh0QWN0aW9uIiwiZGV0YWlsIiwiZGF0YSIsIl9fcnVuQXRhZyIsImNhbGwiLCJldmVudE5hbWUiLCJidXR0b24iLCJhVGFnIiwicXVlcnlTZWxlY3RvciIsIkNvQ3JlYXRlIiwibG9naWMiLCJzZXRMaW5rUHJvY2VzcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxNQUFNQSxjQUFjLEdBQUc7QUFDckJDLFdBQVMsRUFBRSxjQURVO0FBRXJCQyxTQUFPLEVBQUUsRUFGWTtBQUdyQkMsZUFBYSxFQUFFLEVBSE07QUFJckJDLFlBQVUsRUFBRSxDQUpTO0FBS3JCQyxpQkFBZSxFQUFFLElBTEk7QUFPckJDLG9CQUFrQixFQUFFLGdCQVBDO0FBU3JCQyxRQUFNLEVBQUUsWUFBVztBQUNqQixTQUFLQyxpQkFBTDtBQUNELEdBWG9CO0FBWXJCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7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bi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtdGVzdGluZzFcbmNvbnN0IENvQ3JlYXRlQWN0aW9uID0ge1xuICBhdHRyaWJ1dGU6ICdkYXRhLWFjdGlvbnMnLFxuICBhY3Rpb25zOiB7fSxcbiAgc2VsZWN0ZWRTdGFnZTogW10sXG4gIHN0YWdlSW5kZXg6IDAsXG4gIHNlbGVjdGVkRWxlbWVudDogbnVsbCxcbiAgXG4gIGNvbXBsZXRlZEV2ZW50TmFtZTogJ2NvbXBsZXRlZEV2ZW50JyxcbiAgXG4gIF9faW5pdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hY3Rpb25CdXR0b25FdmVudCgpXG4gIH0sXG4gIC8vIGluaXQ6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgIFxuICAvLyAgIGNvbnN0IF9fY29udGFpbmVyID0gY29udGFpbmVyIHx8IGRvY3VtZW50XG4gIC8vICAgaWYgKCFfX2NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKSB7XG5cdFx0Ly8gXHRyZXR1cm47XG5cdFx0Ly8gfVxuXHRcdFxuXHRcdC8vIGxldCBidXR0b25zID0gX19jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWFjdGlvbnNdXCIpO1xuXG5cdFx0Ly8gZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gICB0aGlzLmFjdGlvbkJ1dHRvbkV2ZW50KGJ1dHRvbnNbaV0pO1xuXHRcdC8vIH1cbiAgLy8gfSxcbiAgXG4gIC8vIGFjdGlvbkJ1dHRvbkV2ZW50OiBmdW5jdGlvbihidG4pIHtcbiAgLy8gICBjb25zdCBfdGhpcyA9IHRoaXM7ICAgIFxuXHQgLy8gbGV0IGNoZWNrQWN0aW9ucyA9IGJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9ucycpIHx8IFwiXCI7XG5cdCAvLyBjaGVja0FjdGlvbnMgPSBjaGVja0FjdGlvbnMucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpO1xuXHQgIFxuXHQgLy8gaWYgKGNoZWNrQWN0aW9ucy5sZW5ndGggPT0gMCkge1xuXHQgLy8gICByZXR1cm47XG5cdCAvLyB9XG5cbiAgLy8gICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAvLyAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgLy8gICAgIGxldCBhY3Rpb25zID0gdGhpcy5nZXRBdHRyaWJ1dGUoX3RoaXMuYXR0cmlidXRlKSB8fCBcIlwiO1xuICAvLyAgICAgYWN0aW9ucyA9IGFjdGlvbnMucmVwbGFjZSgvXFxzL2csICcnKS5zcGxpdCgnLCcpO1xuICAvLyAgICAgX3RoaXMuc3RhZ2VJbmRleCA9IDA7XG4gIC8vICAgICBfdGhpcy5zZWxlY3RlZFN0YWdlID0gYWN0aW9ucztcbiAgICAgIFxuICAvLyAgICAgLy8uIHJ1biBmdW5jdGlvblxuICAvLyAgICAgX3RoaXMuc2VsZWN0ZWRFbGVtZW50ID0gYnRuO1xuICAvLyAgICAgX3RoaXMuX19ydW5BY3Rpb25GdW5jKCk7XG4gICAgICBcbiAgLy8gICB9KVxuICAvLyB9LFxuICBcbiAgYWN0aW9uQnV0dG9uRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIGxldCBidG4gPSBldmVudC50YXJnZXQ7XG4gICAgICBpZiAoIWJ0bi5nZXRBdHRyaWJ1dGUoJ2RhdGEtYWN0aW9ucycpKSB7XG4gICAgICAgIGJ0biA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KCdbZGF0YS1hY3Rpb25zXScpO1xuICAgICAgfVxuICAgICAgaWYgKCFidG4pIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGxldCBhY3Rpb25zID0gKGJ0bi5nZXRBdHRyaWJ1dGUoc2VsZi5hdHRyaWJ1dGUpIHx8IFwiXCIpLnJlcGxhY2UoL1xccy9nLCAnJykuc3BsaXQoJywnKTtcbiAgICAgIGlmIChhY3Rpb25zLmxlbmd0aCA9PSAwKSByZXR1cm47XG4gICAgICBzZWxmLnN0YWdlSW5kZXggPSAwO1xuICAgICAgc2VsZi5zZWxlY3RlZFN0YWdlID0gYWN0aW9ucztcbiAgICAgIFxuICAgICAgLy8uIHJ1biBmdW5jdGlvblxuICAgICAgc2VsZi5zZWxlY3RlZEVsZW1lbnQgPSBidG47XG4gICAgICBzZWxmLl9fcnVuQWN0aW9uRnVuYygpO1xuICAgIH0pXG4gIH0sXG4gIFxuICBpbml0OiBmdW5jdGlvbih7YWN0aW9uLCBjYWxsYmFjaywgZW5kRXZlbnR9KSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KGFjdGlvbiwgY2FsbGJhY2ssIG51bGwsIGVuZEV2ZW50KTtcbiAgfSxcbiAgXG4gIC8qKlxuICAgKiBrZXk6IHN0cmluZ1xuICAgKiBydW5GdW5jOiBmdW5jdGlvblxuICAgKiBpbnN0YW5jZTogb2JqZWN0XG4gICAqIGVuZEV2ZW50OiBzdHJpbmdcbiAgICoqL1xuICByZWdpc3RlckV2ZW50OiBmdW5jdGlvbihrZXksIHJ1bkZ1bmMsIGluc3RhbmNlLCBlbmRFdmVudCkge1xuICAgIGlmICh0aGlzLmFjdGlvbnNba2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmFjdGlvbnNba2V5XSA9IHtcbiAgICAgIGtleToga2V5LFxuICAgICAgcnVuRnVuYzogcnVuRnVuYyxcbiAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSB8fCB3aW5kb3csXG4gICAgICBlbmRFdmVudDogZW5kRXZlbnRcbiAgICB9XG4gICAgLy8uIHJlZ2lzdGVyIGV2ZW50c1xuICAgIFxuICAgIGZvciAobGV0IF9fa2V5IGluIHRoaXMuYWN0aW9ucykge1xuICAgICAgaWYgKF9fa2V5ICE9IGtleSAmJiB0aGlzLmFjdGlvbnNbX19rZXldWydlbmRFdmVudCddID09PSBlbmRFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vLiByZWdpc3RlciBldmVudHNcbiAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbmRFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgX3RoaXMuX19uZXh0QWN0aW9uKGVuZEV2ZW50LCBlLmRldGFpbClcbiAgICB9KTtcbiAgfSxcbiAgXG4gIF9fcnVuQWN0aW9uRnVuYzogZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgaWYgKHRoaXMuc3RhZ2VJbmRleCA+PSB0aGlzLnNlbGVjdGVkU3RhZ2UubGVuZ3RoKSB7XG5cbiAgICAgIC8vLiBpZiBsYXRlc3QgY2FzZSwgaXQgd2lsbCBiZSBydW4gYVRhZ1xuICAgICAgaWYgKHRoaXMuc3RhZ2VJbmRleCA9PSB0aGlzLnNlbGVjdGVkU3RhZ2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX19ydW5BdGFnKHRoaXMuc2VsZWN0ZWRFbGVtZW50KTsgICAgICAgIFxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNlbGVjdGVkU3RhZ2VbdGhpcy5zdGFnZUluZGV4XTtcbiAgICAvLy4gcnVuIGZ1bmN0aW9uXG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5hY3Rpb25zW2tleV07XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgaWYgKGFjdGlvbi5ydW5GdW5jKSB7XG4gICAgICAgIGFjdGlvbi5ydW5GdW5jLmNhbGwobnVsbCwgdGhpcy5zZWxlY3RlZEVsZW1lbnQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX25leHRBY3Rpb24oYWN0aW9uLmVuZEV2ZW50LCB7fSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcbiAgX19uZXh0QWN0aW9uOiBmdW5jdGlvbihldmVudE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnNlbGVjdGVkU3RhZ2VbdGhpcy5zdGFnZUluZGV4XTtcbiAgICBpZiAoIWtleSkge1xuICAgICAgcmV0dXJuIDtcbiAgICB9XG4gICAgaWYgKGV2ZW50TmFtZSAhPT0gdGhpcy5hY3Rpb25zW2tleV0uZW5kRXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGFnZUluZGV4ICsrO1xuICAgIHRoaXMuX19ydW5BY3Rpb25GdW5jKGRhdGEpO1xuICB9LFxuICBcbiAgX19ydW5BdGFnOiBmdW5jdGlvbihidXR0b24pIHtcbiAgICB2YXIgYVRhZyA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCdhJyk7XG4gICAgICAgICAgXG4gICAgaWYgKGFUYWcpIHtcbiAgICAgIENvQ3JlYXRlLmxvZ2ljLnNldExpbmtQcm9jZXNzKGFUYWcpXG4gICAgfVxuICB9XG59XG5cblxuQ29DcmVhdGVBY3Rpb24uX19pbml0KCk7XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlQWN0aW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreate-components/CoCreate-action/src/index.js\n")},"../../CoCreate-components/CoCreate-api/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = __webpack_require__(/*! ../../../CoCreateJS/src */ "../../CoCreateJS/src/index.js");\n\nvar _src2 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-action/src */ "../../CoCreate-components/CoCreate-action/src/index.js"));\n\nvar _src3 = _interopRequireDefault(__webpack_require__(/*! ../../CoCreate-render/src */ "../../CoCreate-components/CoCreate-render/src/index.js"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst CoCreateApi = {\n  modules: {},\n  init: function ({\n    name,\n    module\n  }) {\n    this.register(name, module);\n  },\n  register: function (name, m_instance) {\n    const self = this;\n\n    if (typeof this.modules[name] === \'undefined\') {\n      this.modules[name] = m_instance;\n\n      _src.socketApi.listen(name, data => {\n        self.__responseProcess(name, data);\n      }); //. register actions\n\n\n      if (Array.isArray(m_instance[\'actions\'])) {\n        m_instance[\'actions\'].forEach(action => {\n          if (typeof m_instance[`action_${action}`] !== \'function\') {\n            m_instance[`action_${action}`] = function (element) {\n              self.__commonAction(m_instance.id, action, element);\n            };\n          }\n\n          _src2.default.init({\n            action: action,\n            endEvent: action,\n            callback: btn => {\n              m_instance[`action_${action}`](btn);\n            }\n          });\n        });\n      }\n    }\n  },\n  __responseProcess: function (m_name, data) {\n    const {\n      type,\n      response\n    } = data;\n    const m_instance = this.modules[m_name];\n\n    if (type && response && m_instance) {\n      if (typeof m_instance[`render_${type}`] === \'function\') {\n        m_instance[`render_${type}`](response);\n      }\n\n      this.render(type, response);\n      document.dispatchEvent(new CustomEvent(type, {\n        detail: {\n          data: response\n        }\n      }));\n    }\n  },\n  __commonAction: function (id, action, element) {\n    const container = element.closest("form") || document;\n    let data = CoCreateApi.getFormData(id, action, container);\n    CoCreateApi.send(id, action, data);\n  },\n  getFormData: function (m_name, action, container) {\n    const mainAttr = `data-${m_name}`;\n    const self = this;\n    const elements = container.querySelectorAll(`[${mainAttr}^="${action}."]`);\n    let data = {};\n    elements.forEach(element => {\n      let name = element.getAttribute(mainAttr);\n      let array_name = element.getAttribute(mainAttr + "_array");\n\n      let value = self.__getElValue(element);\n\n      if (!name) return;\n\n      if (action) {\n        let re = new RegExp(`^${action}.`, \'i\');\n\n        if (re.test(name)) {\n          name = name.replace(re, "");\n        } else {\n          return;\n        }\n      }\n\n      if (array_name) {\n        if (!data[name]) {\n          data[name] = [];\n        }\n\n        data[name].push(self.getFormData(m_name, array_name, element));\n      } else if (value != null) {\n        data[name] = value;\n      }\n    });\n    let keys = Object.keys(data);\n    let objectData = {};\n    keys.forEach(k => {\n      if (k.split(\'.\').length > 1) {\n        let newData = self.__createObject(data[k], k);\n\n        delete data[k];\n        objectData = self.__mergeObject(objectData, newData);\n      } else {\n        objectData[k] = data[k];\n      }\n    });\n    return objectData;\n  },\n  __getElValue: function (element) {\n    let value = null;\n\n    if (typeof element.value !== "undefined") {\n      switch (element.type.toLocaleLowerCase()) {\n        case \'checkbox\':\n          if (element.checked) {\n            value = element.value;\n          }\n\n          break;\n\n        default:\n          value = element.value;\n          break;\n      }\n    } else {\n      value = element.getAttribute(\'value\');\n\n      if (!value) {\n        value = element.innerHTML;\n      }\n    }\n\n    return value;\n  },\n  __mergeObject: function (target, source) {\n    target = target || {};\n\n    for (let key of Object.keys(source)) {\n      if (source[key] instanceof Object) {\n        Object.assign(source[key], this.__mergeObject(target[key], source[key]));\n      }\n    }\n\n    Object.assign(target || {}, source);\n    return target;\n  },\n  __createObject: function (data, path) {\n    if (!path) return data;\n    let keys = path.split(\'.\');\n    let newObject = data;\n\n    for (var i = keys.length - 1; i >= 0; i--) {\n      newObject = {\n        [keys[i]]: newObject\n      };\n    }\n\n    return newObject;\n  },\n  send: function (module, action, data) {\n    let request_data = this.getCommonParamsExtend(data || {});\n    request_data = { ...request_data,\n      data\n    };\n\n    _src.socketApi.send(module, {\n      type: action,\n      data: request_data\n    });\n  },\n  render: function (action, data) {\n    _src3.default.data({\n      selector: `[data-template_id="${action}"]`,\n      data: data\n    });\n  },\n  createApiSocket: function (host, namespace) {\n    if (namespace) {\n      _src.socketApi.create({\n        namespace: namespace,\n        room: null,\n        host: host\n      });\n\n      _src.socketApi.setGlobalScope(namespace);\n    } else {\n      _src.socketApi.create({\n        namespace: null,\n        room: null,\n        host: host\n      });\n    }\n  },\n  getCommonParamsExtend: function (info) {\n    return {\n      "apiKey": info.apiKey || config.apiKey,\n      "securityKey": info.securityKey || config.securityKey,\n      "organization_id": info.organization_id || config.organization_Id\n    };\n  }\n};\nCoCreateApi.createApiSocket(window.config.host ? window.config.host : \'server.cocreate.app\', window.config.organization_Id // window.config.apiKey\n// window.config.securityKey\n);\nvar _default = CoCreateApi;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1hcGkvc3JjL2luZGV4LmpzPzU0MTEiXSwibmFtZXMiOlsiQ29DcmVhdGVBcGkiLCJtb2R1bGVzIiwiaW5pdCIsIm5hbWUiLCJtb2R1bGUiLCJyZWdpc3RlciIsIm1faW5zdGFuY2UiLCJzZWxmIiwic29ja2V0QXBpIiwibGlzdGVuIiwiZGF0YSIsIl9fcmVzcG9uc2VQcm9jZXNzIiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsImFjdGlvbiIsImVsZW1lbnQiLCJfX2NvbW1vbkFjdGlvbiIsImlkIiwiQ29DcmVhdGVBY3Rpb24iLCJlbmRFdmVudCIsImNhbGxiYWNrIiwiYnRuIiwibV9uYW1lIiwidHlwZSIsInJlc3BvbnNlIiwicmVuZGVyIiwiZG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJjb250YWluZXIiLCJjbG9zZXN0IiwiZ2V0Rm9ybURhdGEiLCJzZW5kIiwibWFpbkF0dHIiLCJlbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJnZXRBdHRyaWJ1dGUiLCJhcnJheV9uYW1lIiwidmFsdWUiLCJfX2dldEVsVmFsdWUiLCJyZSIsIlJlZ0V4cCIsInRlc3QiLCJyZXBsYWNlIiwicHVzaCIsImtleXMiLCJPYmplY3QiLCJvYmplY3REYXRhIiwiayIsInNwbGl0IiwibGVuZ3RoIiwibmV3RGF0YSIsIl9fY3JlYXRlT2JqZWN0IiwiX19tZXJnZU9iamVjdCIsInRvTG9jYWxlTG93ZXJDYXNlIiwiY2hlY2tlZCIsImlubmVySFRNTCIsInRhcmdldCIsInNvdXJjZSIsImtleSIsImFzc2lnbiIsInBhdGgiLCJuZXdPYmplY3QiLCJpIiwicmVxdWVzdF9kYXRhIiwiZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kIiwiQ29DcmVhdGVSZW5kZXIiLCJzZWxlY3RvciIsImNyZWF0ZUFwaVNvY2tldCIsImhvc3QiLCJuYW1lc3BhY2UiLCJjcmVhdGUiLCJyb29tIiwic2V0R2xvYmFsU2NvcGUiLCJpbmZvIiwiYXBpS2V5IiwiY29uZmlnIiwic2VjdXJpdHlLZXkiLCJvcmdhbml6YXRpb25faWQiLCJvcmdhbml6YXRpb25fSWQiLCJ3aW5kb3ciXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQU1BLFdBQVcsR0FBRztBQUNuQkMsU0FBTyxFQUFFLEVBRFU7QUFHbkJDLE1BQUksRUFBRSxVQUFTO0FBQUNDLFFBQUQ7QUFBT0M7QUFBUCxHQUFULEVBQXlCO0FBQzlCLFNBQUtDLFFBQUwsQ0FBY0YsSUFBZCxFQUFvQkMsTUFBcEI7QUFDQSxHQUxrQjtBQU9uQkMsVUFBUSxFQUFFLFVBQVNGLElBQVQsRUFBZUcsVUFBZixFQUEyQjtBQUNwQyxVQUFNQyxJQUFJLEdBQUcsSUFBYjs7QUFDQSxRQUFJLE9BQU8sS0FBS04sT0FBTCxDQUFhRSxJQUFiLENBQVAsS0FBOEIsV0FBbEMsRUFBK0M7QUFDOUMsV0FBS0YsT0FBTCxDQUFhRSxJQUFiLElBQXFCRyxVQUFyQjs7QUFFQUUscUJBQVVDLE1BQVYsQ0FBaUJOLElBQWpCLEVBQXdCTyxJQUFELElBQVU7QUFDaENILFlBQUksQ0FBQ0ksaUJBQUwsQ0FBdUJSLElBQXZCLEVBQTZCTyxJQUE3QjtBQUNBLE9BRkQsRUFIOEMsQ0FPOUM7OztBQUVBLFVBQUlFLEtBQUssQ0FBQ0MsT0FBTixDQUFjUCxVQUFVLENBQUMsU0FBRCxDQUF4QixDQUFKLEVBQTBDO0FBQ3pDQSxrQkFBVSxDQUFDLFNBQUQsQ0FBVixDQUFzQlEsT0FBdEIsQ0FBK0JDLE1BQUQsSUFBWTtBQUN6QyxjQUFJLE9BQU9ULFVBQVUsQ0FBRSxVQUFTUyxNQUFPLEVBQWxCLENBQWpCLEtBQTBDLFVBQTlDLEVBQTBEO0FBQ3pEVCxzQkFBVSxDQUFFLFVBQVNTLE1BQU8sRUFBbEIsQ0FBVixHQUFpQyxVQUFTQyxPQUFULEVBQWtCO0FBQ2xEVCxrQkFBSSxDQUFDVSxjQUFMLENBQW9CWCxV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QWpCOztBQUtBL0QscUJBQVVtRSxjQUFWLENBQXlCSCxTQUF6QjtBQUNBLEtBUEQsTUFPTztBQUNOaEUscUJBQVVpRSxNQUFWLENBQWlCO0FBQ2hCRCxpQkFBUyxFQUFFLElBREs7QUFFaEJFLFlBQUksRUFBRSxJQUZVO0FBR2hCSCxZQUFJLEVBQUVBO0FBSFUsT0FBakI7QUFLQTtBQUNELEdBMUxrQjtBQTRMbkJKLHVCQUFxQixFQUFFLFVBQVNTLElBQVQsRUFDdkI7QUFDQyxXQUFPO0FBQ04sZ0JBQW9CQSxJQUFJLENBQUNDLE1BQUwsSUFBZUMsTUFBTSxDQUFDRCxNQURwQztBQUVOLHFCQUFvQkQsSUFBSSxDQUFDRyxXQUFMLElBQW9CRCxNQUFNLENBQUNDLFdBRnpDO0FBR04seUJBQW9CSCxJQUFJLENBQUNJLGVBQUwsSUFBd0JGLE1BQU0sQ0FBQ0c7QUFIN0MsS0FBUDtBQUtBO0FBbk1rQixDQUFwQjtBQXNNQWpGLFdBQVcsQ0FBQ3NFLGVBQVosQ0FDQ1ksTUFBTSxDQUFDSixNQUFQLENBQWNQLElBQWQsR0FBcUJXLE1BQU0sQ0FBQ0osTUFBUCxDQUFjUCxJQUFuQyxHQUEwQyxxQkFEM0MsRUFFQ1csTUFBTSxDQUFDSixNQUFQLENBQWNHLGVBRmYsQ0FHQztBQUNBO0FBSkQ7ZUFPZWpGLFciLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1hcGkvc3JjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtzb2NrZXRBcGl9IGZyb20gJy4uLy4uLy4uL0NvQ3JlYXRlSlMvc3JjJztcbmltcG9ydCBDb0NyZWF0ZUFjdGlvbiBmcm9tICcuLi8uLi9Db0NyZWF0ZS1hY3Rpb24vc3JjJ1xuaW1wb3J0IENvQ3JlYXRlUmVuZGVyIGZyb20gJy4uLy4uL0NvQ3JlYXRlLXJlbmRlci9zcmMnXG5cbmNvbnN0IENvQ3JlYXRlQXBpID0geyBcblx0bW9kdWxlczogeyB9LFxuXHRcblx0aW5pdDogZnVuY3Rpb24oe25hbWUsIG1vZHVsZX0pIHtcblx0XHR0aGlzLnJlZ2lzdGVyKG5hbWUsIG1vZHVsZSlcdFxuXHR9LFxuXHRcblx0cmVnaXN0ZXI6IGZ1bmN0aW9uKG5hbWUsIG1faW5zdGFuY2UpIHtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRpZiAodHlwZW9mIHRoaXMubW9kdWxlc1tuYW1lXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMubW9kdWxlc1tuYW1lXSA9IG1faW5zdGFuY2U7XG5cdFx0XHRcblx0XHRcdHNvY2tldEFwaS5saXN0ZW4obmFtZSwgKGRhdGEpID0+IHtcblx0XHRcdFx0c2VsZi5fX3Jlc3BvbnNlUHJvY2VzcyhuYW1lLCBkYXRhKTtcblx0XHRcdH0pXG5cdFx0XHRcblx0XHRcdC8vLiByZWdpc3RlciBhY3Rpb25zXG5cdFx0XHRcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KG1faW5zdGFuY2VbJ2FjdGlvbnMnXSkpIHtcblx0XHRcdFx0bV9pbnN0YW5jZVsnYWN0aW9ucyddLmZvckVhY2goKGFjdGlvbikgPT4ge1xuXHRcdFx0XHRcdGlmICh0eXBlb2YgbV9pbnN0YW5jZVtgYWN0aW9uXyR7YWN0aW9ufWBdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHRtX2luc3RhbmNlW2BhY3Rpb25fJHthY3Rpb259YF0gPSBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYuX19jb21tb25BY3Rpb24obV9pbnN0YW5jZS5pZCwgYWN0aW9uLCBlbGVtZW50KVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0Q29DcmVhdGVBY3Rpb24uaW5pdCh7XG5cdFx0XHRcdFx0XHRhY3Rpb246IGFjdGlvbixcblx0XHRcdFx0XHRcdGVuZEV2ZW50OiBhY3Rpb24sXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogKGJ0bikgPT4ge1xuXHRcdFx0XHRcdFx0XHRtX2luc3RhbmNlW2BhY3Rpb25fJHthY3Rpb259YF0oYnRuKTtcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdFxuXHRfX3Jlc3BvbnNlUHJvY2VzczogZnVuY3Rpb24obV9uYW1lLCBkYXRhKSB7XG5cdFx0Y29uc3Qge3R5cGUsIHJlc3BvbnNlfSA9IGRhdGE7XG5cdFx0Y29uc3QgbV9pbnN0YW5jZSA9IHRoaXMubW9kdWxlc1ttX25hbWVdXG5cdFx0XG5cdFx0aWYgKHR5cGUgJiYgcmVzcG9uc2UgJiYgbV9pbnN0YW5jZSkge1xuXHRcdFxuXHRcdFx0aWYgKCB0eXBlb2YgbV9pbnN0YW5jZVtgcmVuZGVyXyR7dHlwZX1gXSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRtX2luc3RhbmNlW2ByZW5kZXJfJHt0eXBlfWBdKHJlc3BvbnNlKTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dGhpcy5yZW5kZXIodHlwZSwgcmVzcG9uc2UpO1xuXHRcdFx0XG5cdFx0XHRkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG5cdFx0XHRcdGRldGFpbDoge1xuXHRcdFx0XHRcdGRhdGE6IHJlc3BvbnNlXG5cdFx0XHRcdH1cblx0XHRcdH0pKVxuXHRcdH1cblx0fSxcblx0XG5cdF9fY29tbW9uQWN0aW9uOiBmdW5jdGlvbihpZCwgYWN0aW9uLCBlbGVtZW50KSB7XG5cdFx0Y29uc3QgY29udGFpbmVyID0gZWxlbWVudC5jbG9zZXN0KFwiZm9ybVwiKSB8fCBkb2N1bWVudDtcblx0XHRsZXQgZGF0YSA9IENvQ3JlYXRlQXBpLmdldEZvcm1EYXRhKGlkLCBhY3Rpb24sICBjb250YWluZXIpO1xuXHRcdENvQ3JlYXRlQXBpLnNlbmQoaWQsIGFjdGlvbiwgZGF0YSk7XG5cdH0sXG5cdFxuXHRcblx0Z2V0Rm9ybURhdGEgOiBmdW5jdGlvbihtX25hbWUsIGFjdGlvbiwgY29udGFpbmVyKXtcblx0XHRjb25zdCBtYWluQXR0ciA9IGBkYXRhLSR7bV9uYW1lfWA7XG5cdFx0Y29uc3Qgc2VsZiA9IHRoaXM7XG5cdFx0Y29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChgWyR7bWFpbkF0dHJ9Xj1cIiR7YWN0aW9ufS5cIl1gKTtcblxuXHRcdGxldCBkYXRhID0ge31cblx0XHRlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuXHRcdFx0bGV0IG5hbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShtYWluQXR0cik7XG5cdFx0XHRsZXQgYXJyYXlfbmFtZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKG1haW5BdHRyICsgXCJfYXJyYXlcIik7XG5cdFx0XHRsZXQgdmFsdWUgPSBzZWxmLl9fZ2V0RWxWYWx1ZShlbGVtZW50KTtcblx0XHRcdFxuXHRcdFx0aWYgKCFuYW1lKSByZXR1cm5cblxuXHRcdFx0aWYgKGFjdGlvbikge1xuXHRcdFx0XHRsZXQgcmUgPSBuZXcgUmVnRXhwKGBeJHthY3Rpb259LmAsICdpJyk7XG5cdFx0XHRcdGlmIChyZS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZShyZSwgXCJcIik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmIChhcnJheV9uYW1lKSB7XG5cdFx0XHRcdGlmICghZGF0YVtuYW1lXSkge1xuXHRcdFx0XHRcdGRhdGFbbmFtZV0gPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhW25hbWVdLnB1c2goc2VsZi5nZXRGb3JtRGF0YShtX25hbWUsIGFycmF5X25hbWUsIGVsZW1lbnQpKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRkYXRhW25hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0XG5cdFx0bGV0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKVxuXHRcdGxldCBvYmplY3REYXRhID0ge307XG5cdFx0a2V5cy5mb3JFYWNoKChrKSA9PiB7XG5cdFx0XHRpZiAoay5zcGxpdCgnLicpLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0bGV0IG5ld0RhdGEgPSBzZWxmLl9fY3JlYXRlT2JqZWN0KGRhdGFba10sIGspO1xuXHRcdFx0XHRkZWxldGUgZGF0YVtrXVxuXHRcdFx0XHRcblx0XHRcdFx0b2JqZWN0RGF0YSA9IHNlbGYuX19tZXJnZU9iamVjdChvYmplY3REYXRhLCBuZXdEYXRhKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9iamVjdERhdGFba10gPSBkYXRhW2tdO1xuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIG9iamVjdERhdGE7XG5cdH0sXG5cdFxuXHRfX2dldEVsVmFsdWU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRsZXQgdmFsdWUgPSBudWxsO1xuXHRcdGlmICh0eXBlb2YgZWxlbWVudC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0c3dpdGNoIChlbGVtZW50LnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkge1xuXHRcdFx0XHRjYXNlICdjaGVja2JveCc6XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQuY2hlY2tlZCkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBlbGVtZW50LnZhbHVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHZhbHVlID0gZWxlbWVudC52YWx1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcblx0XHRcdGlmICghdmFsdWUpIHtcblx0XHRcdFx0dmFsdWUgPSBlbGVtZW50LmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRcblx0X19tZXJnZU9iamVjdDogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcblx0XHR0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cdFx0Zm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkpIHtcblx0XHRcdGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCkge1xuXHRcdFx0XHRPYmplY3QuYXNzaWduKHNvdXJjZVtrZXldLCB0aGlzLl9fbWVyZ2VPYmplY3QodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKSlcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0T2JqZWN0LmFzc2lnbih0YXJnZXQgfHwge30sIHNvdXJjZSlcblx0XHRyZXR1cm4gdGFyZ2V0XG5cdH0sXG5cdFxuXHRfX2NyZWF0ZU9iamVjdDogZnVuY3Rpb24gKGRhdGEsIHBhdGgpIHtcblx0XHRpZiAoIXBhdGgpIHJldHVybiBkYXRhO1xuXHRcdFxuXHRcdGxldCBrZXlzID0gcGF0aC5zcGxpdCgnLicpXG5cdFx0bGV0IG5ld09iamVjdCA9IGRhdGE7XG5cblx0XHRmb3IgKHZhciAgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG5ld09iamVjdCA9IHtba2V5c1tpXV06IG5ld09iamVjdH1cdFx0XHRcdFxuXHRcdH1cblx0XHRyZXR1cm4gbmV3T2JqZWN0O1xuXHR9LFxuXHRcblx0c2VuZCA6IGZ1bmN0aW9uKG1vZHVsZSwgYWN0aW9uLCBkYXRhKXsgXG5cdFx0bGV0IHJlcXVlc3RfZGF0YSA9IHRoaXMuZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kKGRhdGEgfHwge30pO1xuXHRcdHJlcXVlc3RfZGF0YSA9IHsuLi5yZXF1ZXN0X2RhdGEsIGRhdGF9O1xuXHRcdHNvY2tldEFwaS5zZW5kKG1vZHVsZSwge3R5cGU6IGFjdGlvbiwgZGF0YTogcmVxdWVzdF9kYXRhfSk7XG5cdH0sXG5cdFxuXHRyZW5kZXI6IGZ1bmN0aW9uKGFjdGlvbiwgZGF0YSkge1xuXHRcdENvQ3JlYXRlUmVuZGVyLmRhdGEoe1xuXHRcdFx0c2VsZWN0b3I6IGBbZGF0YS10ZW1wbGF0ZV9pZD1cIiR7YWN0aW9ufVwiXWAsIFxuXHRcdFx0ZGF0YTogZGF0YVxuXHRcdH0pO1xuXHR9LFxuXHRcblx0Y3JlYXRlQXBpU29ja2V0OiBmdW5jdGlvbihob3N0LCBuYW1lc3BhY2UpIHtcblx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRzb2NrZXRBcGkuY3JlYXRlKHtcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsIFxuXHRcdFx0XHRyb29tOiBudWxsLFxuXHRcdFx0XHRob3N0OiBob3N0XG5cdFx0XHR9KTtcblx0XHRcdHNvY2tldEFwaS5zZXRHbG9iYWxTY29wZShuYW1lc3BhY2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzb2NrZXRBcGkuY3JlYXRlKHtcblx0XHRcdFx0bmFtZXNwYWNlOiBudWxsLCBcblx0XHRcdFx0cm9vbTogbnVsbCxcblx0XHRcdFx0aG9zdDogaG9zdFxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXHRcblx0Z2V0Q29tbW9uUGFyYW1zRXh0ZW5kOiBmdW5jdGlvbihpbmZvKSBcblx0e1xuXHRcdHJldHVybiB7XG5cdFx0XHRcImFwaUtleVwiOiAgICAgICAgICAgaW5mby5hcGlLZXkgfHwgY29uZmlnLmFwaUtleSxcblx0XHRcdFwic2VjdXJpdHlLZXlcIjogICAgICBpbmZvLnNlY3VyaXR5S2V5IHx8IGNvbmZpZy5zZWN1cml0eUtleSxcblx0XHRcdFwib3JnYW5pemF0aW9uX2lkXCI6ICBpbmZvLm9yZ2FuaXphdGlvbl9pZCB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkLFxuXHRcdH1cblx0fVxufVxuXG5Db0NyZWF0ZUFwaS5jcmVhdGVBcGlTb2NrZXQoXG5cdHdpbmRvdy5jb25maWcuaG9zdCA/IHdpbmRvdy5jb25maWcuaG9zdCA6ICdzZXJ2ZXIuY29jcmVhdGUuYXBwJyxcblx0d2luZG93LmNvbmZpZy5vcmdhbml6YXRpb25fSWRcblx0Ly8gd2luZG93LmNvbmZpZy5hcGlLZXlcblx0Ly8gd2luZG93LmNvbmZpZy5zZWN1cml0eUtleVxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQ29DcmVhdGVBcGk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreate-components/CoCreate-api/src/index.js\n')},"../../CoCreate-components/CoCreate-render/src/index.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\n/**\n * change name Class\n * add functionality to add value on any attr of each elements into template\n */\nconst CoCreateRender = {\n  __getValueFromObject: function (json, path) {\n    try {\n      if (typeof json == 'undefined' || !path) return false;\n      let jsonData = json,\n          subpath = path.split('.');\n\n      for (let i = 0; i < subpath.length; i++) {\n        jsonData = jsonData[subpath[i]];\n        if (!jsonData) return false;\n      }\n\n      return jsonData;\n    } catch (error) {\n      console.log(\"Error in getValueFromObject\", error);\n      return false;\n    }\n  },\n  __getValue: function (data, attrValue) {\n    let result = /{{\\s*([\\w\\W]+)\\s*}}/g.exec(attrValue);\n\n    if (result) {\n      return this.__getValueFromObject(data, result[1].trim());\n    }\n\n    return false;\n  },\n  __createObject: function (data, path) {\n    try {\n      if (!path) return data;\n      let keys = path.split('.');\n      let newObject = data;\n\n      for (var i = keys.length - 1; i >= 0; i--) {\n        newObject = {\n          [keys[i]]: newObject\n        };\n      }\n\n      return newObject;\n    } catch (error) {\n      console.log(\"Error in getValueFromObject\", error);\n      return false;\n    }\n  },\n  __replaceValue: function (data, inputValue) {\n    let isPass = false;\n    let self = this;\n    let resultValue = null; // let variables = inputValue.match(/{{\\s*(\\S+)\\s*}}/g);\n\n    let variables = inputValue.match(/{{([A-Za-z0-9_.,\\- ]*)}}/g);\n\n    if (variables) {\n      variables.forEach(attr => {\n        let value = self.__getValue(data, attr);\n\n        if (value && typeof value !== \"object\") {\n          isPass = true;\n          inputValue = inputValue.replace(attr, value);\n        }\n      });\n\n      if (isPass) {\n        resultValue = inputValue;\n      }\n    }\n\n    return resultValue;\n  },\n  setArray: function (template, data) {\n    const type = template.getAttribute('data-render_array') || \"data\";\n    const render_key = template.getAttribute('data-render_key') || type;\n    const self = this;\n\n    const arrayData = this.__getValueFromObject(data, type);\n\n    if (type && Array.isArray(arrayData)) {\n      arrayData.forEach((item, index) => {\n        let cloneEl = template.cloneNode(true);\n        cloneEl.classList.remove('template');\n        cloneEl.classList.add('clone_' + type);\n\n        if (typeof item !== 'object') {\n          item = {\n            \"--\": item\n          };\n        } else {\n          item['index'] = index;\n        }\n\n        let r_data = self.__createObject(item, render_key);\n\n        self.setValue([cloneEl], r_data);\n        template.insertAdjacentHTML('beforebegin', cloneEl.outerHTML);\n      });\n    }\n  },\n  setValue: function (els, data, passTo, template) {\n    if (!data) return;\n    const that = this;\n    Array.from(els).forEach(e => {\n      let passId = e.getAttribute('data-pass_id');\n\n      if (passTo && passId != passTo) {\n        return;\n      }\n\n      Array.from(e.attributes).forEach(attr => {\n        let attr_name = attr.name.toLowerCase();\n        let isPass = false;\n        let attrValue = attr.value;\n        attrValue = that.__replaceValue(data, attrValue);\n\n        if (attrValue) {\n          if (attr_name == 'value') {\n            let tag = e.tagName.toLowerCase();\n\n            switch (tag) {\n              case 'input':\n                e.setAttribute(attr_name, attrValue);\n                break;\n\n              case 'textarea':\n                e.setAttribute(attr_name, attrValue);\n                e.textContent = attrValue;\n                break;\n\n              default:\n                if (e.children.length === 0) {\n                  e.innerHTML = attrValue;\n                }\n\n            }\n          }\n\n          e.setAttribute(attr_name, attrValue);\n        }\n      });\n\n      if (e.children.length == 0 && e.textContent) {\n        let textContent = e.textContent;\n        textContent = that.__replaceValue(data, textContent);\n\n        if (textContent) {\n          e.textContent = textContent;\n        }\n      }\n\n      if (e.children.length > 0) {\n        that.setValue(e.children, data);\n\n        if (e.classList.contains('template')) {\n          that.setArray(e, data);\n        }\n      }\n    });\n  },\n  data: function ({\n    selector,\n    data,\n    elements,\n    passTo\n  }) {\n    if (selector) {\n      this.render(selector, data);\n    } else if (elements) {\n      this.setValue(elements, data, passTo);\n    }\n  },\n  render: function (selector, dataResult) {\n    let template_div = document.querySelector(selector);\n\n    if (!template_div) {\n      return;\n    }\n\n    if (Array.isArray(dataResult)) {\n      template_div.setAttribute('data-render_array', 'test');\n      this.setValue([template_div], {\n        test: dataResult\n      });\n    } else {\n      this.setValue(template_div.children, dataResult);\n    }\n  }\n};\nvar _default = CoCreateRender;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1yZW5kZXIvc3JjL2luZGV4LmpzPzdmZDgiXSwibmFtZXMiOlsiQ29DcmVhdGVSZW5kZXIiLCJfX2dldFZhbHVlRnJvbU9iamVjdCIsImpzb24iLCJwYXRoIiwianNvbkRhdGEiLCJzdWJwYXRoIiwic3BsaXQiLCJpIiwibGVuZ3RoIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiX19nZXRWYWx1ZSIsImRhdGEiLCJhdHRyVmFsdWUiLCJyZXN1bHQiLCJleGVjIiwidHJpbSIsIl9fY3JlYXRlT2JqZWN0Iiwia2V5cyIsIm5ld09iamVjdCIsIl9fcmVwbGFjZVZhbHVlIiwiaW5wdXRWYWx1ZSIsImlzUGFzcyIsInNlbGYiLCJyZXN1bHRWYWx1ZSIsInZhcmlhYmxlcyIsIm1hdGNoIiwiZm9yRWFjaCIsImF0dHIiLCJ2YWx1ZSIsInJlcGxhY2UiLCJzZXRBcnJheSIsInRlbXBsYXRlIiwidHlwZSIsImdldEF0dHJpYnV0ZSIsInJlbmRlcl9rZXkiLCJhcnJheURhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJpdGVtIiwiaW5kZXgiLCJjbG9uZUVsIiwiY2xvbmVOb2RlIiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiYWRkIiwicl9kYXRhIiwic2V0VmFsdWUiLCJpbnNlcnRBZGphY2VudEhUTUwiLCJvdXRlckhUTUwiLCJlbHMiLCJwYXNzVG8iLCJ0aGF0IiwiZnJvbSIsImUiLCJwYXNzSWQiLCJhdHRyaWJ1dGVzIiwiYXR0cl9uYW1lIiwibmFtZSIsInRvTG93ZXJDYXNlIiwidGFnIiwidGFnTmFtZSIsInNldEF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwiY2hpbGRyZW4iLCJpbm5lckhUTUwiLCJjb250YWlucyIsInNlbGVjdG9yIiwiZWxlbWVudHMiLCJyZW5kZXIiLCJkYXRhUmVzdWx0IiwidGVtcGxhdGVfZGl2IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9y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QVlGLFFBQVosRUFBc0J2RCxJQUF0QjtBQUNBLEtBRkQsTUFFTyxJQUFJd0QsUUFBSixFQUFjO0FBQ3BCLFdBQUtyQixRQUFMLENBQWNxQixRQUFkLEVBQXdCeEQsSUFBeEIsRUFBOEJ1QyxNQUE5QjtBQUNBO0FBQ0QsR0ExSnFCO0FBNEp0QmtCLFFBQU0sRUFBRyxVQUFTRixRQUFULEVBQW1CRyxVQUFuQixFQUErQjtBQUN2QyxRQUFJQyxZQUFZLEdBQUdDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1Qk4sUUFBdkIsQ0FBbkI7O0FBQ0EsUUFBSSxDQUFDSSxZQUFMLEVBQW1CO0FBQ2xCO0FBQ0E7O0FBQ0QsUUFBSWxDLEtBQUssQ0FBQ0MsT0FBTixDQUFjZ0MsVUFBZCxDQUFKLEVBQStCO0FBQzlCQyxrQkFBWSxDQUFDVCxZQUFiLENBQTBCLG1CQUExQixFQUErQyxNQUEvQztBQUNBLFdBQUtmLFFBQUwsQ0FBYyxDQUFDd0IsWUFBRCxDQUFkLEVBQThCO0FBQUNHLFlBQUksRUFBRUo7QUFBUCxPQUE5QjtBQUNBLEtBSEQsTUFHTztBQUNOLFdBQUt2QixRQUFMLENBQWN3QixZQUFZLENBQUNQLFFBQTNCLEVBQXFDTSxVQUFyQztBQUNBO0FBQ0Q7QUF2S3FCLENBQXZCO2VBMEtldkUsYyIsImZpbGUiOiIuLi8uLi9Db0NyZWF0ZS1jb21wb25lbnRzL0NvQ3JlYXRlLXJlbmRlci9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGNoYW5nZSBuYW1lIENsYXNzXG4gKiBhZGQgZnVuY3Rpb25hbGl0eSB0byBhZGQgdmFsdWUgb24gYW55IGF0dHIgb2YgZWFjaCBlbGVtZW50cyBpbnRvIHRlbXBsYXRlXG4gKi9cbmNvbnN0IENvQ3JlYXRlUmVuZGVyID0ge1xuXG5cdF9fZ2V0VmFsdWVGcm9tT2JqZWN0IDogZnVuY3Rpb24oanNvbiwgcGF0aCkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZih0eXBlb2YganNvbiA9PSAndW5kZWZpbmVkJyB8fCAhcGF0aClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0bGV0IGpzb25EYXRhID0ganNvbiwgc3VicGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcblx0XHRcdFxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdWJwYXRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGpzb25EYXRhID0ganNvbkRhdGFbc3VicGF0aFtpXV07XG5cdFx0XHRcdGlmICghanNvbkRhdGEpIHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBqc29uRGF0YTtcblx0XHR9Y2F0Y2goZXJyb3Ipe1xuXHRcdFx0Y29uc29sZS5sb2coXCJFcnJvciBpbiBnZXRWYWx1ZUZyb21PYmplY3RcIiwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblx0XG5cdF9fZ2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGEsIGF0dHJWYWx1ZSkge1xuXHRcdGxldCByZXN1bHQgPSAve3tcXHMqKFtcXHdcXFddKylcXHMqfX0vZy5leGVjKGF0dHJWYWx1ZSk7XG5cdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX19nZXRWYWx1ZUZyb21PYmplY3QoZGF0YSwgcmVzdWx0WzFdLnRyaW0oKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0XHRcblx0fSxcblx0XG5cdF9fY3JlYXRlT2JqZWN0OiBmdW5jdGlvbiAoZGF0YSwgcGF0aCkge1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAoIXBhdGgpIHJldHVybiBkYXRhO1xuXHRcdFx0XG5cdFx0XHRsZXQga2V5cyA9IHBhdGguc3BsaXQoJy4nKVxuXHRcdFx0bGV0IG5ld09iamVjdCA9IGRhdGE7XG5cblx0XHRcdGZvciAodmFyICBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRuZXdPYmplY3QgPSB7W2tleXNbaV1dOiBuZXdPYmplY3R9XHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdHJldHVybiBuZXdPYmplY3Q7XG5cdFx0XHRcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0Y29uc29sZS5sb2coXCJFcnJvciBpbiBnZXRWYWx1ZUZyb21PYmplY3RcIiwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fSxcblx0XG5cdF9fcmVwbGFjZVZhbHVlOiBmdW5jdGlvbihkYXRhLCBpbnB1dFZhbHVlKSB7XG5cdFx0bGV0IGlzUGFzcyA9IGZhbHNlO1xuXHRcdGxldCBzZWxmID0gdGhpcztcblx0XHRsZXQgcmVzdWx0VmFsdWUgPSBudWxsO1xuXHRcdC8vIGxldCB2YXJpYWJsZXMgPSBpbnB1dFZhbHVlLm1hdGNoKC97e1xccyooXFxTKylcXHMqfX0vZyk7XG5cdFx0bGV0IHZhcmlhYmxlcyA9IGlucHV0VmFsdWUubWF0Y2goL3t7KFtBLVphLXowLTlfLixcXC0gXSopfX0vZyk7XG5cdFx0aWYgKHZhcmlhYmxlcykge1xuXHRcdFx0dmFyaWFibGVzLmZvckVhY2goKGF0dHIpID0+IHtcblx0XHRcdFx0bGV0IHZhbHVlID0gc2VsZi5fX2dldFZhbHVlKGRhdGEsIGF0dHIpXG5cdFx0XHRcdGlmICh2YWx1ZSAmJiB0eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRcdFx0aXNQYXNzID0gdHJ1ZTtcblx0XHRcdFx0XHRpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKGF0dHIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHRcdFxuXHRcdFx0aWYgKGlzUGFzcykge1xuXHRcdFx0XHRyZXN1bHRWYWx1ZSA9IGlucHV0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHRWYWx1ZTtcblx0fSxcblx0XG5cdHNldEFycmF5OiBmdW5jdGlvbih0ZW1wbGF0ZSwgZGF0YSkge1xuXHRcdGNvbnN0IHR5cGUgPSB0ZW1wbGF0ZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVuZGVyX2FycmF5JykgfHwgXCJkYXRhXCI7XG5cdFx0Y29uc3QgcmVuZGVyX2tleSA9IHRlbXBsYXRlLmdldEF0dHJpYnV0ZSgnZGF0YS1yZW5kZXJfa2V5JykgfHwgdHlwZTtcblx0XHRjb25zdCBzZWxmID0gdGhpcztcblx0XHRjb25zdCBhcnJheURhdGEgPSB0aGlzLl9fZ2V0VmFsdWVGcm9tT2JqZWN0KGRhdGEsIHR5cGUpO1xuXG5cdFx0aWYgKHR5cGUgJiYgQXJyYXkuaXNBcnJheShhcnJheURhdGEpKSB7XG5cdFx0XHRhcnJheURhdGEuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBjbG9uZUVsID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuXHRcdFx0XHRjbG9uZUVsLmNsYXNzTGlzdC5yZW1vdmUoJ3RlbXBsYXRlJyk7XG5cdFx0XHRcdGNsb25lRWwuY2xhc3NMaXN0LmFkZCgnY2xvbmVfJyArIHR5cGUpO1xuXHRcdFx0XHRpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aXRlbSA9IHtcIi0tXCI6IGl0ZW19O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGl0ZW1bJ2luZGV4J10gPSBpbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgcl9kYXRhID0gc2VsZi5fX2NyZWF0ZU9iamVjdChpdGVtLCByZW5kZXJfa2V5KTtcblxuXHRcdFx0XHRzZWxmLnNldFZhbHVlKFtjbG9uZUVsXSwgcl9kYXRhKTtcblx0XHRcdFx0dGVtcGxhdGUuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmViZWdpbicsIGNsb25lRWwub3V0ZXJIVE1MKTtcblx0XHRcdH0pXG5cdFx0fVxuXHR9LFxuIFxuXHRzZXRWYWx1ZTpmdW5jdGlvbihlbHMsIGRhdGEsIHBhc3NUbywgdGVtcGxhdGUpe1xuXHRcdGlmICghZGF0YSkgcmV0dXJuO1xuXHRcdGNvbnN0IHRoYXQgPSB0aGlzO1xuXHRcdEFycmF5LmZyb20oZWxzKS5mb3JFYWNoKGUgPT4ge1xuXHRcdFx0bGV0IHBhc3NJZCA9IGUuZ2V0QXR0cmlidXRlKCdkYXRhLXBhc3NfaWQnKTtcblx0XHRcdGlmIChwYXNzVG8gJiYgcGFzc0lkICE9IHBhc3NUbykge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRBcnJheS5mcm9tKGUuYXR0cmlidXRlcykuZm9yRWFjaChhdHRyPT57XG5cdFx0XHRcdGxldCBhdHRyX25hbWUgPSBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0bGV0ICBpc1Bhc3MgPSBmYWxzZTtcblx0XHRcdFx0bGV0IGF0dHJWYWx1ZSA9IGF0dHIudmFsdWU7XG5cdFx0XHRcdGF0dHJWYWx1ZSA9IHRoYXQuX19yZXBsYWNlVmFsdWUoZGF0YSwgYXR0clZhbHVlKTtcblx0XHRcdFx0XG5cdFx0XHRcdGlmIChhdHRyVmFsdWUpIHtcblx0XHRcdFx0XHRpZihhdHRyX25hbWUgPT0gJ3ZhbHVlJyl7XG5cdFx0XHRcdFx0XHRsZXQgdGFnID0gZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKHRhZykge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdpbnB1dCc6XG5cdFx0XHRcdFx0XHRcdFx0IGUuc2V0QXR0cmlidXRlKGF0dHJfbmFtZSwgYXR0clZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAndGV4dGFyZWEnOlxuXHRcdFx0XHRcdFx0XHRcdGUuc2V0QXR0cmlidXRlKGF0dHJfbmFtZSwgYXR0clZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRlLnRleHRDb250ZW50ID0gYXR0clZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGlmIChlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5pbm5lckhUTUwgPSAgYXR0clZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZS5zZXRBdHRyaWJ1dGUoYXR0cl9uYW1lLCBhdHRyVmFsdWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdFxuXHRcdFx0aWYgKGUuY2hpbGRyZW4ubGVuZ3RoID09IDAgJiYgZS50ZXh0Q29udGVudCkge1xuXHRcdFx0XHRsZXQgdGV4dENvbnRlbnQgPSBlLnRleHRDb250ZW50O1xuXHRcdFx0XHR0ZXh0Q29udGVudCA9IHRoYXQuX19yZXBsYWNlVmFsdWUoZGF0YSwgdGV4dENvbnRlbnQpO1xuXHRcdFx0XHRpZiAodGV4dENvbnRlbnQpIHtcblx0XHRcdFx0XHRlLnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0XG5cdFx0XHRcblx0XHRcdGlmKGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR0aGF0LnNldFZhbHVlKGUuY2hpbGRyZW4sIGRhdGEpXG5cdFx0XHRcdFxuXHRcdFx0XHRpZiAoZS5jbGFzc0xpc3QuY29udGFpbnMoJ3RlbXBsYXRlJykpIHtcblx0XHRcdFx0XHR0aGF0LnNldEFycmF5KGUsIGRhdGEpO1xuXHRcdFx0XHR9IFxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXHRcblx0ZGF0YTogZnVuY3Rpb24oe3NlbGVjdG9yLCBkYXRhLCBlbGVtZW50cywgcGFzc1RvfSkge1xuXHRcdGlmIChzZWxlY3Rvcikge1xuXHRcdFx0dGhpcy5yZW5kZXIoc2VsZWN0b3IsIGRhdGEpO1xuXHRcdH0gZWxzZSBpZiAoZWxlbWVudHMpIHtcblx0XHRcdHRoaXMuc2V0VmFsdWUoZWxlbWVudHMsIGRhdGEsIHBhc3NUbyk7XG5cdFx0fVxuXHR9LFxuXHRcblx0cmVuZGVyIDogZnVuY3Rpb24oc2VsZWN0b3IsIGRhdGFSZXN1bHQpIHtcblx0XHRsZXQgdGVtcGxhdGVfZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcilcblx0XHRpZiAoIXRlbXBsYXRlX2Rpdikge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShkYXRhUmVzdWx0KSkge1xuXHRcdFx0dGVtcGxhdGVfZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1yZW5kZXJfYXJyYXknLCAndGVzdCcpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZShbdGVtcGxhdGVfZGl2XSwge3Rlc3Q6IGRhdGFSZXN1bHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSh0ZW1wbGF0ZV9kaXYuY2hpbGRyZW4sIGRhdGFSZXN1bHQpO1xuXHRcdH1cblx0fVxuXG59XG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZVJlbmRlcjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../CoCreate-components/CoCreate-render/src/index.js\n")},"./src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nvar _src = _interopRequireDefault(__webpack_require__(/*! ../../../CoCreate-components/CoCreate-api/src */ \"../../CoCreate-components/CoCreate-api/src/index.js\"));\n\nvar _src2 = __webpack_require__(/*! ../../../CoCreateJS/src */ \"../../CoCreateJS/src/index.js\");\n\nvar _twilioClient = __webpack_require__(/*! twilio-client */ \"./node_modules/twilio-client/es5/twilio.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import * as loadTwilio from 'twilio-client-mirror';\n// import Twilio from 'twilio-client';\n// const Device = require('twilio-client').Device;\n// hello\nlet URL_TWILIO = \"https://server.cocreate.app:8088/api_/twilio\";\nconst device = new _twilioClient.Device(); // const device = new Twilio.Device();\n\nlet myConnection = '';\nlet debug_twilio = false;\nlet myStorage = window.localStorage;\nlet user = myStorage.getItem('user_id') ? myStorage.getItem('user_id') : '5ff49ec8421c2c14653a1a39';\nif (document.querySelector('[data-twilio=\"setUserNameLocalStorage.user_id\"]')) document.querySelector('[data-twilio=\"setUserNameLocalStorage.user_id\"]').value = user;\nfetch(URL_TWILIO + '/token/' + user, {\n  'mode': 'cors',\n  'headers': {\n    'Access-Control-Allow-Origin': '*'\n  }\n}).then(response => response.json()).then(data => {\n  let token = data.token;\n  device.setup(token, {\n    enableRingingState: true,\n    debug: debug_twilio\n  });\n  device.on('ready', conn => {\n    console.log(\"REady \");\n  });\n  device.on('offline', conn => {\n    console.log(\"Offline \");\n  });\n  device.on('busy', conn => {\n    console.log(\"busy \");\n  }); //Events\n\n  device.on('cancel', connection => {\n    //This is triggered when an incoming connection is canceled by the caller before it is accepted by the Twilio Client device.\n    console.log(\"Cancel Call incomming\");\n  });\n  device.on('connect', conn => {\n    //This is triggered when a connection is opened, whether initiated using .connect()\n    console.log(\" Connect  call Front\");\n    myConnection = conn;\n    let CallSid = myConnection.parameters.CallSid; // //document.querySelector(\"[data-twilio='holdCall.CallSid']\").value=CallSid;\n\n    console.log(\" Sendind Render to -> createCall\", {\n      render2: myConnection\n    });\n\n    _src.default.render(`[data-template_id=createCall]`, {\n      render2: myConnection\n    });\n  });\n  device.on('disconnect', connection => {\n    //Fired any time a Connection is closed\n    console.log(\"Disconnect Call\");\n    /*Hide Btns*/\n  });\n  device.on('error', error => {\n    console.log(\"Errorr \", error); //Emitted when any device error occurs.\n  });\n  device.on('ringing', conn => {\n    console.log(\"rinngin\");\n  });\n  device.on('outgoing', conn => {\n    //      let  CallSid = conn.parameters.CallSid\n    console.log(\" Outgoin conn \", conn);\n  });\n  device.on('incoming', conn => {\n    myConnection = conn;\n    document.querySelector(\"[data-actions='answerCall']\").style.display = 'initial';\n    document.querySelector(\"[data-id='dialConference']\").style.display = 'initial';\n    let CallSid = myConnection.parameters.CallSid;\n    console.log('incomming => ', CallSid, {\n      render2: myConnection\n    }); //render in form\n\n    _src.default.render('createCall', {\n      render2: myConnection\n    });\n  }); //end FTECH\n}).catch(function (error) {\n  console.log('ERROR Fetch [token]:' + error.message);\n}); //end FTECH URL TWILIO BACKEND NODE\n\nconst CoCreateTwilio = {\n  id: 'twilio',\n  actions: ['deleteQueue', 'getListQueues', 'dialEnqueue', 'dialQueue', 'dialTransfer', 'setUserNameLocalStorage', 'callRecordingCreate', 'callRecordingPause', 'callRecordingResume', 'callRecordingList', 'holdParticipantConference', 'unholdParticipantConference', 'muteParticipantsConference', 'unmuteParticipantsConference', 'delParticipantsConference', 'getParticipantsConference', 'holdConference', 'unholdConference', 'joinConference', 'endConference', 'createCall', 'hangupCall', 'dialConference', 'answerCall', 'getConferences', 'createConference', 'twilioListSubAccounts', 'twilioPurchasePhoneNumber', 'twiliofetchAvailbleNumbers', 'twilioCreateSubAccount', 'twilioDeleteSubAccount', 'twilioGetUsage', 'twilioPhoneNumberList', 'twilioGetIncommingPhoneNumbers', 'twilioGetBillingUsages', 'twilioDeletePhoneNumber', 'updateIncomingPhoneNumber', 'response'],\n  render_callRecordingList: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    data = {\n      data: data\n    };\n    console.log(\"data \", data);\n\n    _src.default.render('callRecordingList', data);\n  },\n  render_holdParticipantConference: function (data) {\n    let id_participante = data;\n    let action = 'holdParticipantConference';\n    let btn_holdParticipante = document.querySelector('[data-actions=\"' + action + '\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_holdParticipante.style.display = 'none';\n    let btn_unholdParticipante = document.querySelector('[data-actions=\"un' + action + '\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_unholdParticipante.style.display = 'initial';\n  },\n  render_unholdParticipantConference: function (data) {\n    let id_participante = data;\n    let action = 'holdParticipantConference';\n    let btn_holdParticipante = document.querySelector('[data-actions=\"' + action + '\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_holdParticipante.style.display = 'initial';\n    let btn_unholdParticipante = document.querySelector('[data-actions=\"un' + action + '\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_unholdParticipante.style.display = 'none';\n  },\n  render_muteParticipantsConference: function (data) {\n    let id_participante = data;\n    let btn_mute = document.querySelector('[data-actions=\"muteParticipantsConference\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_mute.style.display = 'none';\n    let btn_unmute = document.querySelector('[data-actions=\"unmuteParticipantsConference\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_unmute.style.display = 'initial';\n  },\n  render_unmuteParticipantsConference: function (data) {\n    let id_participante = data;\n    let btn_mute = document.querySelector('[data-actions=\"muteParticipantsConference\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_mute.style.display = 'initial';\n    let btn_unmute = document.querySelector('[data-actions=\"unmuteParticipantsConference\"][data-idparticipant=\"' + id_participante + '\"]');\n    btn_unmute.style.display = 'none';\n  },\n  render_getParticipantsConference: function (data) {\n    console.log(data);\n    let id_conference = data.idconference;\n    data = {\n      participant: data.participants\n    };\n\n    _src.default.render('getParticipantsConferences_' + id_conference, data);\n  },\n  action_hangupCall: function (data) {\n    console.log(\" hangupCall \");\n    device.disconnectAll();\n    if (myConnection) myConnection.reject();\n  },\n  render_dialConference: async function (data) {\n    console.log(\"Dial\", data);\n\n    if (data.create_conference) {\n      //createConference\n      let friendlyName = data.data.friendlyName ? data.data.friendlyName : 'CocreateConference';\n      myConnection = device.connect({\n        'opt': 'joinConference',\n        'friendlyname': friendlyName\n      });\n      let CallSid = myConnection.parameters.CallSid;\n      console.log(\"CallSid, createConference \", CallSid);\n    }\n\n    await new Promise(r => setTimeout(r, 2000)); //dispatch('action_getConferences')\n  },\n  render_getConferences: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    data = {\n      data: data\n    };\n\n    _src.default.render('getConferences', data);\n  },\n  action_joinConference: function (element, data) {\n    console.log('data', data);\n    console.log(element.dataset);\n    myConnection = device.connect({\n      'opt': 'joinConference',\n      'friendlyname': element.dataset['friendlyname']\n    });\n    let CallSid = myConnection.parameters.CallSid;\n  },\n  action_createCall: function (element, data) {\n    var data = _src.default.getFormData('twilio', 'dial', document);\n\n    myConnection = device.connect(data);\n    let CallSid = myConnection.parameters.CallSid;\n    console.log(\"createCall \", myConnection);\n\n    _src.default.render(this.id, 'createCall', {\n      render2: myConnection\n    });\n  },\n  action_answerCall: function (element, data) {\n    myConnection.accept();\n  },\n  action_dialQueue: async function (element, data) {\n    //alert('unhold')\n    //myConnection = device.connect({'unhold':true,'queue':'support'});\n\n    /*var data = api.getFormData('twilio', 'dialQueue', element)\n    console.log(\"dialQueue\",data)\n    */\n    console.log(\"dialQueue \", element.dataset['friendlyname']);\n    myConnection = device.connect({\n      'opt': 'queue',\n      'friendlyname': element.dataset['friendlyname']\n    });\n    await new Promise(r => setTimeout(r, 2000));\n  },\n  render_getListQueues: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    data = {\n      data: data\n    };\n    console.log(\"DAta \", data);\n\n    _src.default.render('getListQueues', data);\n  },\n  action_unholdCall: function (element, data) {\n    var data = _src.default.getFormData('twilio', 'holdCall', document);\n\n    data[\"unhold\"] = true;\n    console.log(\" DAta unhold \", data);\n    myConnection = device.connect(data);\n  },\n  action_setUserNameLocalStorage: function (element, data) {\n    var data = _src.default.getFormData('twilio', 'setUserNameLocalStorage', document);\n\n    myStorage.setItem('user_id', data['user_id']);\n  },\n\n  /*new features*/\n  render_twilioListSubAccounts: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data); // api.render('randermsg', data);\n  },\n  render_twilioCreateSubAccount: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twilioDeleteSubAccount: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twilioPurchasePhoneNumber: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twilioGetIncommingPhoneNumbers: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twiliofetchAvailbleNumbers: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twilioGetUsage: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n    console.table(data.data);\n  },\n  render_twilioPhoneNumberList: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_twilioGetBillingUsages: function (data) {\n    if (data.object == \"error\") {\n      alert(data.data);\n    }\n\n    console.log(data);\n  },\n  render_response: function (data) {\n    console.log(data);\n  } // \taction_twilioListSubAccounts: function(element, data) {\n  // \t\t//. data rendering by cocreate-render\n  // \t\tconsole.log('rander',data)\n  // \t    api.render(this.id, 'xxxCreateCard', {render2: data});\n  // \t}\n  // END CreacteCard endpoint\t\n\n};\n\n_src.default.init({\n  name: CoCreateTwilio.id,\n  module: CoCreateTwilio\n});\n\nvar _default = CoCreateTwilio;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJVUkxfVFdJTElPIiwiZGV2aWNlIiwiRGV2aWNlIiwibXlDb25uZWN0aW9uIiwiZGVidWdfdHdpbGlvIiwibXlTdG9yYWdlIiwid2luZG93IiwibG9jYWxTdG9yYWdlIiwidXNlciIsImdldEl0ZW0iLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ2YWx1ZSIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwianNvbiIsImRhdGEiLCJ0b2tlbiIsInNldHVwIiwiZW5hYmxlUmluZ2luZ1N0YXRlIiwiZGVidWciLCJvbiIsImNvbm4iLCJjb25zb2xlIiwibG9nIiwiY29ubmVjdGlvbiIsIkNhbGxTaWQiLCJwYXJhbWV0ZXJzIiwicmVuZGVyMiIsImFwaSIsInJlbmRlciIsImVycm9yIiwic3R5bGUiLCJkaXNwbGF5IiwiY2F0Y2giLCJtZXNzYWdlIiwiQ29DcmVhdGVUd2lsaW8iLCJpZCIsImFjdGlvbnMiLCJyZW5kZXJfY2FsbFJlY29yZGluZ0xpc3QiLCJvYmplY3QiLCJhbGVydCIsInJlbmRlcl9ob2xkUGFydGljaXBhbnRDb25mZXJlbmNlIiwiaWRfcGFydGljaXBhbnRlIiwiYWN0aW9uIiwiYnRuX2hvbGRQYXJ0aWNpcGFudGUiLCJidG5fdW5ob2xkUGFydGljaXBhbnRlIiwicmVuZGVyX3VuaG9sZFBhcnRpY2lwYW50Q29uZmVyZW5jZSIsInJlbmRlcl9tdXRlUGFydGljaXBhbnRzQ29uZmVyZW5jZSIsImJ0bl9tdXRlIiwiYnRuX3VubXV0ZSIsInJlbmRlcl91bm11dGVQYXJ0aWNpcGFudHNDb25mZXJlbmNlIiwicmVuZGVyX2dldFBhcnRpY2lwYW50c0NvbmZlcmVuY2UiLCJpZF9jb25mZXJlbmNlIiwiaWRjb25mZXJlbmNlIiwicGFydGljaXBhbnQiLCJwYXJ0aWNpcGFudHMiLCJhY3Rpb25faGFuZ3VwQ2FsbCIsImRpc2Nvbm5lY3RBbGwiLCJyZWplY3QiLCJyZW5kZXJfZGlhbENvbmZlcmVuY2UiLCJjcmVhdGVfY29uZmVyZW5jZSIsImZyaWVuZGx5TmFtZSIsImNvbm5lY3QiLCJQcm9taXNlIiwiciIsInNldFRpbWVvdXQiLCJyZW5kZXJfZ2V0Q29uZmVyZW5jZXMiLCJhY3Rpb25fam9pbkNvbmZlcmVuY2UiLCJlbGVtZW50IiwiZGF0YXNldCIsImFjdGlvbl9jcmVhdGVDYWxsIiwiZ2V0Rm9ybURhdGEiLCJhY3Rpb25fYW5zd2VyQ2FsbCIsImFjY2VwdCIsImFjdGlvbl9kaWFsUXVldWUiLCJyZW5kZXJfZ2V0TGlzdFF1ZXVlcyIsImFjdGlvbl91bmhvbGRDYWxsIiwiYWN0aW9uX3NldFVzZXJOYW1lTG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsInJlbmRlcl90d2lsaW9MaXN0U3ViQWNjb3VudHMiLCJyZW5kZXJfdHdpbGlvQ3JlYXRlU3ViQWNjb3VudCIsInJlbmRlcl90d2lsaW9EZWxldGVTdWJBY2NvdW50IiwicmVuZGVyX3R3aWxpb1B1cmNoYXNlUGhvbmVOdW1iZXIiLCJyZW5kZXJfdHdpbGlvR2V0SW5jb21taW5nUGhvbmVOdW1iZXJzIiwicmVuZGVyX3R3aWxpb2ZldGNoQXZhaWxibGVOdW1iZXJzIiwicmVuZGVyX3R3aWxpb0dldFVzYWdlIiwidGFibGUiLCJyZW5kZXJfdHdpbGlvUGhvbmVOdW1iZXJMaXN0IiwicmVuZGVyX3R3aWxpb0dldEJpbGxpbmdVc2FnZXMiLCJyZW5kZXJfcmVzcG9uc2UiLCJpbml0IiwibmFtZSIsIm1vZHVsZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUVBOzs7O0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFFQSxJQUFJQSxVQUFVLEdBQUcsOENBQWpCO0FBQ0EsTUFBTUMsTUFBTSxHQUFHLElBQUlDLG9CQUFKLEVBQWYsQyxDQUNBOztBQUNBLElBQUlDLFlBQVksR0FBRyxFQUFuQjtBQUNBLElBQUlDLFlBQVksR0FBRyxLQUFuQjtBQUNBLElBQUlDLFNBQVMsR0FBR0MsTUFBTSxD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QUFDQSxJQUFOLENBQUw7QUFDSDs7QUFDRE8sV0FBTyxDQUFDQyxHQUFSLENBQVlSLElBQVo7QUFDTixHQXBPcUI7QUFzT3RCeUUsK0JBQTZCLEVBQUUsVUFBU3pFLElBQVQsRUFBZTtBQUN2QyxRQUFJQSxJQUFJLENBQUN3QixNQUFMLElBQWUsT0FBbkIsRUFBNEI7QUFDeEJDLFdBQUssQ0FBQ3pCLElBQUksQ0FBQ0EsSUFBTixDQUFMO0FBQ0g7O0FBQ0RPLFdBQU8sQ0FBQ0MsR0FBUixDQUFZUixJQUFaO0FBQ04sR0EzT3FCO0FBNk90QjBFLGlCQUFlLEVBQUUsVUFBUzFFLElBQVQsRUFBZTtBQUMvQk8sV0FBTyxDQUFDQyxHQUFSLENBQVlSLElBQVo7QUFDQSxHQS9PcUIsQ0FpUHRCO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFRDs7QUF4UHVCLENBQXZCOztBQThQQWEsYUFBSThELElBQUosQ0FBUztBQUNSQyxNQUFJLEVBQUV4RCxjQUFjLENBQUNDLEVBRGI7QUFFUndELFFBQU0sRUFBRXpEO0FBRkEsQ0FBVDs7ZUFLZUEsYyIsImZpbGUiOiIuL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSAnLi4vLi4vLi4vQ29DcmVhdGUtY29tcG9uZW50cy9Db0NyZWF0ZS1hcGkvc3JjJ1xuaW1wb3J0IHtzb2NrZXQsIGNydWR9IGZyb20gJy4uLy4uLy4uL0NvQ3JlYXRlSlMvc3JjJztcbi8vIGltcG9ydCAqIGFzIGxvYWRUd2lsaW8gZnJvbSAndHdpbGlvLWNsaWVudC1taXJyb3InO1xuaW1wb3J0IHsgRGV2aWNlIH0gZnJvbSAndHdpbGlvLWNsaWVudCc7IFxuLy8gaW1wb3J0IFR3aWxpbyBmcm9tICd0d2lsaW8tY2xpZW50Jztcbi8vIGNvbnN0IERldmljZSA9IHJlcXVpcmUoJ3R3aWxpby1jbGllbnQnKS5EZXZpY2U7XG4vLyBoZWxsb1xuXG5sZXQgVVJMX1RXSUxJTyA9IFwiaHR0cHM6Ly9zZXJ2ZXIuY29jcmVhdGUuYXBwOjgwODgvYXBpXy90d2lsaW9cIjtcbmNvbnN0IGRldmljZSA9IG5ldyBEZXZpY2UoKTtcbi8vIGNvbnN0IGRldmljZSA9IG5ldyBUd2lsaW8uRGV2aWNlKCk7XG5sZXQgbXlDb25uZWN0aW9uID0gJyc7XG5sZXQgZGVidWdfdHdpbGlvID0gZmFsc2U7XG5sZXQgbXlTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcblxubGV0IHVzZXIgPSBteVN0b3JhZ2UuZ2V0SXRlbSgndXNlcl9pZCcpID8gbXlTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfaWQnKSA6ICc1ZmY0OWVjODQyMWMyYzE0NjUzYTFhMzknO1xuXG5pZihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS10d2lsaW89XCJzZXRVc2VyTmFtZUxvY2FsU3RvcmFnZS51c2VyX2lkXCJdJykpXG5cdGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXR3aWxpbz1cInNldFVzZXJOYW1lTG9jYWxTdG9yYWdlLnVzZXJfaWRcIl0nKS52YWx1ZT11c2VyO1xuXG5mZXRjaChVUkxfVFdJTElPKycvdG9rZW4vJyt1c2VyLCB7XG5cdCAgICAgICAgJ21vZGUnOiAnY29ycycsXG5cdCAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICBcdCdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOiAnKicsXG4gICAgICAgIFx0fVxuICAgIFx0fSlcbiAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gLnRoZW4oZGF0YSA9PiB7XG4gICAgbGV0IHRva2VuID0gZGF0YS50b2tlbjtcblxuICAgIGRldmljZS5zZXR1cCh0b2tlbiwgeyBcbiAgICAgICAgZW5hYmxlUmluZ2luZ1N0YXRlOiB0cnVlLFxuICAgICAgICBkZWJ1ZzogZGVidWdfdHdpbGlvXG4gICAgfSk7XG4gICAgICAgIFxuICAgIGRldmljZS5vbigncmVhZHknLChjb25uKT0+e1xuICAgICAgY29uc29sZS5sb2coXCJSRWFkeSBcIilcbiAgICB9KVxuICAgIFxuICAgIGRldmljZS5vbignb2ZmbGluZScsKGNvbm4pPT57XG4gICAgICBjb25zb2xlLmxvZyhcIk9mZmxpbmUgXCIpXG4gICAgfSlcbiAgICBcbiAgICBkZXZpY2Uub24oJ2J1c3knLChjb25uKT0+e1xuICAgICAgY29uc29sZS5sb2coXCJidXN5IFwiKVxuICAgIH0pXG4gICAgXG4gICAgLy9FdmVudHNcbiAgICBkZXZpY2Uub24oJ2NhbmNlbCcsIChjb25uZWN0aW9uKT0+e1xuICAgICAgLy9UaGlzIGlzIHRyaWdnZXJlZCB3aGVuIGFuIGluY29taW5nIGNvbm5lY3Rpb24gaXMgY2FuY2VsZWQgYnkgdGhlIGNhbGxlciBiZWZvcmUgaXQgaXMgYWNjZXB0ZWQgYnkgdGhlIFR3aWxpbyBDbGllbnQgZGV2aWNlLlxuICAgICAgY29uc29sZS5sb2coXCJDYW5jZWwgQ2FsbCBpbmNvbW1pbmdcIilcbiAgICB9KTtcbiAgICBcbiAgICBkZXZpY2Uub24oJ2Nvbm5lY3QnLCAoY29ubik9PntcbiAgICAgIC8vVGhpcyBpcyB0cmlnZ2VyZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgb3BlbmVkLCB3aGV0aGVyIGluaXRpYXRlZCB1c2luZyAuY29ubmVjdCgpXG4gICAgICBjb25zb2xlLmxvZyhcIiBDb25uZWN0ICBjYWxsIEZyb250XCIpXG4gICAgICBteUNvbm5lY3Rpb24gPSBjb25uO1xuICAgICAgbGV0ICBDYWxsU2lkID0gbXlDb25uZWN0aW9uLnBhcmFtZXRlcnMuQ2FsbFNpZDtcbiAgICAgIC8vIC8vZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLXR3aWxpbz0naG9sZENhbGwuQ2FsbFNpZCddXCIpLnZhbHVlPUNhbGxTaWQ7XG4gICAgICBjb25zb2xlLmxvZyhcIiBTZW5kaW5kIFJlbmRlciB0byAtPiBjcmVhdGVDYWxsXCIse3JlbmRlcjI6IG15Q29ubmVjdGlvbn0pXG4gICAgICBhcGkucmVuZGVyKGBbZGF0YS10ZW1wbGF0ZV9pZD1jcmVhdGVDYWxsXWAsIHtyZW5kZXIyOiBteUNvbm5lY3Rpb259KTtcbiAgICB9KVxuICAgIFxuICAgIGRldmljZS5vbignZGlzY29ubmVjdCcsIChjb25uZWN0aW9uKT0+e1xuICAgICAgLy9GaXJlZCBhbnkgdGltZSBhIENvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAgICBjb25zb2xlLmxvZyhcIkRpc2Nvbm5lY3QgQ2FsbFwiKVxuICAgICAgLypIaWRlIEJ0bnMqL1xuICAgIH0pXG4gICAgXG4gICAgZGV2aWNlLm9uKCdlcnJvcicsIChlcnJvcik9PntcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3JyIFwiLGVycm9yKVxuICAgICAgLy9FbWl0dGVkIHdoZW4gYW55IGRldmljZSBlcnJvciBvY2N1cnMuXG4gICAgfSlcbiAgICBcbiAgICBkZXZpY2Uub24oJ3JpbmdpbmcnLCBjb25uID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwicmlubmdpblwiKVxuICAgIH0pO1xuICAgIFxuICAgIGRldmljZS5vbignb3V0Z29pbmcnLCBjb25uID0+IHtcbi8vICAgICAgbGV0ICBDYWxsU2lkID0gY29ubi5wYXJhbWV0ZXJzLkNhbGxTaWRcbiAgICAgIGNvbnNvbGUubG9nKFwiIE91dGdvaW4gY29ubiBcIixjb25uKVxuICAgIH0pO1xuICAgIGRldmljZS5vbignaW5jb21pbmcnLCBjb25uID0+IHtcbiAgICAgICAgbXlDb25uZWN0aW9uID0gY29ublxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtYWN0aW9ucz0nYW5zd2VyQ2FsbCddXCIpLnN0eWxlLmRpc3BsYXkgPSAnaW5pdGlhbCdcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLWlkPSdkaWFsQ29uZmVyZW5jZSddXCIpLnN0eWxlLmRpc3BsYXkgPSAnaW5pdGlhbCdcbiAgICAgICAgbGV0ICBDYWxsU2lkID0gbXlDb25uZWN0aW9uLnBhcmFtZXRlcnMuQ2FsbFNpZFxuICAgICAgICBjb25zb2xlLmxvZygnaW5jb21taW5nID0+ICcsQ2FsbFNpZCx7cmVuZGVyMjogbXlDb25uZWN0aW9ufSkgIFxuICAgICAgICAvL3JlbmRlciBpbiBmb3JtXG4gICAgICAgIGFwaS5yZW5kZXIoICdjcmVhdGVDYWxsJywge3JlbmRlcjI6IG15Q29ubmVjdGlvbn0pO1xuICAgIH0pO1xuICAgICAgLy9lbmQgRlRFQ0hcbiB9KVxuICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZygnRVJST1IgRmV0Y2ggW3Rva2VuXTonICsgZXJyb3IubWVzc2FnZSk7XG59KTsvL2VuZCBGVEVDSCBVUkwgVFdJTElPIEJBQ0tFTkQgTk9ERVxuXG5cbmNvbnN0IENvQ3JlYXRlVHdpbGlvID0ge1xuXHRpZDogJ3R3aWxpbycsXG5cdGFjdGlvbnM6IFtcblx0ICAnZGVsZXRlUXVldWUnLFxuXHQgICdnZXRMaXN0UXVldWVzJyxcblx0ICAnZGlhbEVucXVldWUnLFxuXHQgICdkaWFsUXVldWUnLFxuXHQgICdkaWFsVHJhbnNmZXInLFxuXHQgICdzZXRVc2VyTmFtZUxvY2FsU3RvcmFnZScsXG5cdCAgJ2NhbGxSZWNvcmRpbmdDcmVhdGUnLFxuXHQgICdjYWxsUmVjb3JkaW5nUGF1c2UnLFxuXHQgICdjYWxsUmVjb3JkaW5nUmVzdW1lJyxcblx0ICAnY2FsbFJlY29yZGluZ0xpc3QnLFxuXHQgICdob2xkUGFydGljaXBhbnRDb25mZXJlbmNlJyxcblx0ICAndW5ob2xkUGFydGljaXBhbnRDb25mZXJlbmNlJyxcblx0ICAnbXV0ZVBhcnRpY2lwYW50c0NvbmZlcmVuY2UnLFxuXHQgICd1bm11dGVQYXJ0aWNpcGFudHNDb25mZXJlbmNlJyxcblx0ICAnZGVsUGFydGljaXBhbnRzQ29uZmVyZW5jZScsXG5cdCAgJ2dldFBhcnRpY2lwYW50c0NvbmZlcmVuY2UnLFxuXHQgICdob2xkQ29uZmVyZW5jZScsXG5cdCAgJ3VuaG9sZENvbmZlcmVuY2UnLFxuXHQgICdqb2luQ29uZmVyZW5jZScsXG5cdCAgJ2VuZENvbmZlcmVuY2UnLFxuXHRcdCdjcmVhdGVDYWxsJyxcblx0XHQnaGFuZ3VwQ2FsbCcsXG5cdFx0J2RpYWxDb25mZXJlbmNlJyxcblx0XHQnYW5zd2VyQ2FsbCcsXG5cdFx0J2dldENvbmZlcmVuY2VzJyxcblx0XHQnY3JlYXRlQ29uZmVyZW5jZScsXG5cdFx0XG5cdFx0J3R3aWxpb0xpc3RTdWJBY2NvdW50cycsXG5cdFx0J3R3aWxpb1B1cmNoYXNlUGhvbmVOdW1iZXInLFxuXHRcdCd0d2lsaW9mZXRjaEF2YWlsYmxlTnVtYmVycycsXG5cdFx0J3R3aWxpb0NyZWF0ZVN1YkFjY291bnQnLFxuXHRcdCd0d2lsaW9EZWxldGVTdWJBY2NvdW50Jyxcblx0XHQndHdpbGlvR2V0VXNhZ2UnLFxuXHRcdCd0d2lsaW9QaG9uZU51bWJlckxpc3QnLFxuXHRcdCd0d2lsaW9HZXRJbmNvbW1pbmdQaG9uZU51bWJlcnMnLFxuXHRcdCd0d2lsaW9HZXRCaWxsaW5nVXNhZ2VzJyxcblx0XHQndHdpbGlvRGVsZXRlUGhvbmVOdW1iZXInLFxuXHRcdCd1cGRhdGVJbmNvbWluZ1Bob25lTnVtYmVyJyxcblx0XHQncmVzcG9uc2UnXG5cdF0sXG5cdFxuXHRcblx0cmVuZGVyX2NhbGxSZWNvcmRpbmdMaXN0OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgaWYgKGRhdGEub2JqZWN0ID09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgYWxlcnQoZGF0YS5kYXRhKVxuICAgICAgICB9XG4gICAgICAgZGF0YSA9IHtkYXRhOiBkYXRhfTtcbiAgICAgICBjb25zb2xlLmxvZyhcImRhdGEgXCIsZGF0YSlcbiAgICAgIGFwaS5yZW5kZXIoJ2NhbGxSZWNvcmRpbmdMaXN0JywgZGF0YSk7XG5cdH0sXG5cdHJlbmRlcl9ob2xkUGFydGljaXBhbnRDb25mZXJlbmNlOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgbGV0IGlkX3BhcnRpY2lwYW50ZSA9IGRhdGE7XG5cdCAgbGV0IGFjdGlvbiA9ICdob2xkUGFydGljaXBhbnRDb25mZXJlbmNlJztcblx0ICBsZXQgYnRuX2hvbGRQYXJ0aWNpcGFudGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY3Rpb25zPVwiJythY3Rpb24rJ1wiXVtkYXRhLWlkcGFydGljaXBhbnQ9XCInK2lkX3BhcnRpY2lwYW50ZSsnXCJdJylcblx0ICBidG5faG9sZFBhcnRpY2lwYW50ZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHQgIGxldCBidG5fdW5ob2xkUGFydGljaXBhbnRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYWN0aW9ucz1cInVuJythY3Rpb24rJ1wiXVtkYXRhLWlkcGFydGljaXBhbnQ9XCInK2lkX3BhcnRpY2lwYW50ZSsnXCJdJylcblx0ICBidG5fdW5ob2xkUGFydGljaXBhbnRlLnN0eWxlLmRpc3BsYXkgPSAnaW5pdGlhbCc7XG5cblx0fSxcblx0cmVuZGVyX3VuaG9sZFBhcnRpY2lwYW50Q29uZmVyZW5jZTogZnVuY3Rpb24oZGF0YSkge1xuXHQgIGxldCBpZF9wYXJ0aWNpcGFudGUgPSBkYXRhO1xuXHQgIGxldCBhY3Rpb24gPSAnaG9sZFBhcnRpY2lwYW50Q29uZmVyZW5jZSc7XG5cdCAgbGV0IGJ0bl9ob2xkUGFydGljaXBhbnRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYWN0aW9ucz1cIicrYWN0aW9uKydcIl1bZGF0YS1pZHBhcnRpY2lwYW50PVwiJytpZF9wYXJ0aWNpcGFudGUrJ1wiXScpXG5cdCAgYnRuX2hvbGRQYXJ0aWNpcGFudGUuc3R5bGUuZGlzcGxheSA9ICdpbml0aWFsJztcblx0ICBsZXQgYnRuX3VuaG9sZFBhcnRpY2lwYW50ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFjdGlvbnM9XCJ1bicrYWN0aW9uKydcIl1bZGF0YS1pZHBhcnRpY2lwYW50PVwiJytpZF9wYXJ0aWNpcGFudGUrJ1wiXScpXG5cdCAgYnRuX3VuaG9sZFBhcnRpY2lwYW50ZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHR9LFxuXHRcblx0cmVuZGVyX211dGVQYXJ0aWNpcGFudHNDb25mZXJlbmNlOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgbGV0IGlkX3BhcnRpY2lwYW50ZSA9IGRhdGE7XG5cdCAgbGV0IGJ0bl9tdXRlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtYWN0aW9ucz1cIm11dGVQYXJ0aWNpcGFudHNDb25mZXJlbmNlXCJdW2RhdGEtaWRwYXJ0aWNpcGFudD1cIicraWRfcGFydGljaXBhbnRlKydcIl0nKVxuXHQgIGJ0bl9tdXRlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdCAgbGV0IGJ0bl91bm11dGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY3Rpb25zPVwidW5tdXRlUGFydGljaXBhbnRzQ29uZmVyZW5jZVwiXVtkYXRhLWlkcGFydGljaXBhbnQ9XCInK2lkX3BhcnRpY2lwYW50ZSsnXCJdJylcblx0ICBidG5fdW5tdXRlLnN0eWxlLmRpc3BsYXkgPSAnaW5pdGlhbCc7XG5cblx0fSxcblx0cmVuZGVyX3VubXV0ZVBhcnRpY2lwYW50c0NvbmZlcmVuY2U6IGZ1bmN0aW9uKGRhdGEpIHtcblx0ICBsZXQgaWRfcGFydGljaXBhbnRlID0gZGF0YTtcblx0ICBsZXQgYnRuX211dGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1hY3Rpb25zPVwibXV0ZVBhcnRpY2lwYW50c0NvbmZlcmVuY2VcIl1bZGF0YS1pZHBhcnRpY2lwYW50PVwiJytpZF9wYXJ0aWNpcGFudGUrJ1wiXScpXG5cdCAgYnRuX211dGUuc3R5bGUuZGlzcGxheSA9ICdpbml0aWFsJztcblx0ICBsZXQgYnRuX3VubXV0ZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWFjdGlvbnM9XCJ1bm11dGVQYXJ0aWNpcGFudHNDb25mZXJlbmNlXCJdW2RhdGEtaWRwYXJ0aWNpcGFudD1cIicraWRfcGFydGljaXBhbnRlKydcIl0nKVxuXHQgIGJ0bl91bm11dGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0fSxcblx0XG5cdHJlbmRlcl9nZXRQYXJ0aWNpcGFudHNDb25mZXJlbmNlOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgY29uc29sZS5sb2coZGF0YSlcblx0ICBsZXQgaWRfY29uZmVyZW5jZSA9IGRhdGEuaWRjb25mZXJlbmNlO1xuXHQgIGRhdGEgPSB7cGFydGljaXBhbnQ6IGRhdGEucGFydGljaXBhbnRzfTtcblx0ICBhcGkucmVuZGVyKCdnZXRQYXJ0aWNpcGFudHNDb25mZXJlbmNlc18nK2lkX2NvbmZlcmVuY2UsIGRhdGEpO1xuXHR9LFxuXHRhY3Rpb25faGFuZ3VwQ2FsbDogZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0Y29uc29sZS5sb2coXCIgaGFuZ3VwQ2FsbCBcIilcbiAgXHRcdGRldmljZS5kaXNjb25uZWN0QWxsKCk7XG4gICAgICAgICAgIGlmIChteUNvbm5lY3Rpb24pXG4gICAgICAgICAgICAgICAgbXlDb25uZWN0aW9uLnJlamVjdCgpO1xuXHR9LFxuXG5cdFxuXHRyZW5kZXJfZGlhbENvbmZlcmVuY2U6IGFzeW5jIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRjb25zb2xlLmxvZyhcIkRpYWxcIixkYXRhKVxuXHRcdGlmKGRhdGEuY3JlYXRlX2NvbmZlcmVuY2Upe1xuXHRcdFx0Ly9jcmVhdGVDb25mZXJlbmNlXG5cdFx0XHRsZXQgZnJpZW5kbHlOYW1lID0gZGF0YS5kYXRhLmZyaWVuZGx5TmFtZSA/IGRhdGEuZGF0YS5mcmllbmRseU5hbWUgOiAnQ29jcmVhdGVDb25mZXJlbmNlJ1xuXHRcdFx0bXlDb25uZWN0aW9uID0gZGV2aWNlLmNvbm5lY3QoeydvcHQnOidqb2luQ29uZmVyZW5jZScsJ2ZyaWVuZGx5bmFtZSc6ZnJpZW5kbHlOYW1lfSk7XG5cdFx0ICAgICAgbGV0ICBDYWxsU2lkID0gbXlDb25uZWN0aW9uLnBhcmFtZXRlcnMuQ2FsbFNpZDtcblx0XHQgICAgICBjb25zb2xlLmxvZyhcIkNhbGxTaWQsIGNyZWF0ZUNvbmZlcmVuY2UgXCIsQ2FsbFNpZClcblx0XHR9XG5cdFx0XHRhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMjAwMCkpO1xuXHQgIC8vZGlzcGF0Y2goJ2FjdGlvbl9nZXRDb25mZXJlbmNlcycpXG5cdH0sXG5cdHJlbmRlcl9nZXRDb25mZXJlbmNlczogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgIGlmIChkYXRhLm9iamVjdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgIGRhdGEgPSB7ZGF0YTogZGF0YX07XG4gICAgICBhcGkucmVuZGVyKCdnZXRDb25mZXJlbmNlcycsIGRhdGEpO1xuXHR9LFxuXHRcblx0YWN0aW9uX2pvaW5Db25mZXJlbmNlOiBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG5cdCAgY29uc29sZS5sb2coJ2RhdGEnLGRhdGEpXG5cdCAgY29uc29sZS5sb2coZWxlbWVudC5kYXRhc2V0KVxuXHQgIG15Q29ubmVjdGlvbiA9IGRldmljZS5jb25uZWN0KHsnb3B0Jzonam9pbkNvbmZlcmVuY2UnLCdmcmllbmRseW5hbWUnOmVsZW1lbnQuZGF0YXNldFsnZnJpZW5kbHluYW1lJ119KTtcbiAgICBsZXQgIENhbGxTaWQgPSBteUNvbm5lY3Rpb24ucGFyYW1ldGVycy5DYWxsU2lkO1xuXHR9LFxuXHRcblx0YWN0aW9uX2NyZWF0ZUNhbGw6IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcblx0XHR2YXIgZGF0YSA9IGFwaS5nZXRGb3JtRGF0YSgndHdpbGlvJywgJ2RpYWwnLCBkb2N1bWVudClcbiAgICBcdG15Q29ubmVjdGlvbiA9IGRldmljZS5jb25uZWN0KGRhdGEpO1xuICAgIFx0bGV0ICBDYWxsU2lkID0gbXlDb25uZWN0aW9uLnBhcmFtZXRlcnMuQ2FsbFNpZDtcbiAgICBcdGNvbnNvbGUubG9nKFwiY3JlYXRlQ2FsbCBcIixteUNvbm5lY3Rpb24pXG4gICAgXHRhcGkucmVuZGVyKHRoaXMuaWQsICdjcmVhdGVDYWxsJywge3JlbmRlcjI6IG15Q29ubmVjdGlvbn0pO1xuXHR9LFxuXHRcblx0YWN0aW9uX2Fuc3dlckNhbGw6IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcbiAgICAgIG15Q29ubmVjdGlvbi5hY2NlcHQoKTtcblx0fSxcblx0XG5cdGFjdGlvbl9kaWFsUXVldWU6IGFzeW5jIGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcblx0ICAvL2FsZXJ0KCd1bmhvbGQnKVxuXHQgIC8vbXlDb25uZWN0aW9uID0gZGV2aWNlLmNvbm5lY3Qoeyd1bmhvbGQnOnRydWUsJ3F1ZXVlJzonc3VwcG9ydCd9KTtcblx0ICAvKnZhciBkYXRhID0gYXBpLmdldEZvcm1EYXRhKCd0d2lsaW8nLCAnZGlhbFF1ZXVlJywgZWxlbWVudClcblx0ICBjb25zb2xlLmxvZyhcImRpYWxRdWV1ZVwiLGRhdGEpXG5cdCAgKi9cblx0ICBjb25zb2xlLmxvZyhcImRpYWxRdWV1ZSBcIixlbGVtZW50LmRhdGFzZXRbJ2ZyaWVuZGx5bmFtZSddKVxuXHQgIG15Q29ubmVjdGlvbiA9IGRldmljZS5jb25uZWN0KHsnb3B0JzoncXVldWUnLCdmcmllbmRseW5hbWUnOmVsZW1lbnQuZGF0YXNldFsnZnJpZW5kbHluYW1lJ119KTtcblx0ICBhd2FpdCBuZXcgUHJvbWlzZShyID0+IHNldFRpbWVvdXQociwgMjAwMCkpO1xuXHR9LFxuXHRyZW5kZXJfZ2V0TGlzdFF1ZXVlczogZnVuY3Rpb24oZGF0YSkge1xuXHRcdGlmIChkYXRhLm9iamVjdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgIGRhdGEgPSB7ZGF0YTogZGF0YX07XG4gICAgICAgY29uc29sZS5sb2coXCJEQXRhIFwiLGRhdGEpXG4gICAgICBhcGkucmVuZGVyKCdnZXRMaXN0UXVldWVzJywgZGF0YSk7XHRcblx0fSxcblx0XG5cdGFjdGlvbl91bmhvbGRDYWxsOiBmdW5jdGlvbihlbGVtZW50LCBkYXRhKSB7XG5cdCAgdmFyIGRhdGEgPSBhcGkuZ2V0Rm9ybURhdGEoJ3R3aWxpbycsICdob2xkQ2FsbCcsIGRvY3VtZW50KVxuXHQgIGRhdGFbXCJ1bmhvbGRcIl09dHJ1ZTtcblx0ICBjb25zb2xlLmxvZyhcIiBEQXRhIHVuaG9sZCBcIixkYXRhKVxuXHQgIG15Q29ubmVjdGlvbiA9IGRldmljZS5jb25uZWN0KGRhdGEpO1xuXHR9LFxuXHRhY3Rpb25fc2V0VXNlck5hbWVMb2NhbFN0b3JhZ2U6IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcblx0XHR2YXIgZGF0YSA9IGFwaS5nZXRGb3JtRGF0YSgndHdpbGlvJywgJ3NldFVzZXJOYW1lTG9jYWxTdG9yYWdlJywgZG9jdW1lbnQpXG5cdFx0bXlTdG9yYWdlLnNldEl0ZW0oJ3VzZXJfaWQnLGRhdGFbJ3VzZXJfaWQnXSk7XG5cdH0sXG5cblx0LypuZXcgZmVhdHVyZXMqL1xuXHRcblx0cmVuZGVyX3R3aWxpb0xpc3RTdWJBY2NvdW50czogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5vYmplY3QgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBhbGVydChkYXRhLmRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIC8vIGFwaS5yZW5kZXIoJ3JhbmRlcm1zZycsIGRhdGEpO1xuICAgIH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvQ3JlYXRlU3ViQWNjb3VudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5vYmplY3QgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBhbGVydChkYXRhLmRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cdH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvRGVsZXRlU3ViQWNjb3VudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5vYmplY3QgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBhbGVydChkYXRhLmRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cdH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvUHVyY2hhc2VQaG9uZU51bWJlcjogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5vYmplY3QgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBhbGVydChkYXRhLmRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cdH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvR2V0SW5jb21taW5nUGhvbmVOdW1iZXJzIDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5vYmplY3QgPT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBhbGVydChkYXRhLmRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG5cdH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvZmV0Y2hBdmFpbGJsZU51bWJlcnM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEub2JqZWN0ID09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgYWxlcnQoZGF0YS5kYXRhKVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuXHR9LFxuXHRcblx0cmVuZGVyX3R3aWxpb0dldFVzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLm9iamVjdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgY29uc29sZS50YWJsZShkYXRhLmRhdGEpXG5cdH0sXG5cdFxuXHRyZW5kZXJfdHdpbGlvUGhvbmVOdW1iZXJMaXN0OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLm9iamVjdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcblx0fSxcblx0XG5cdHJlbmRlcl90d2lsaW9HZXRCaWxsaW5nVXNhZ2VzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLm9iamVjdCA9PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIGFsZXJ0KGRhdGEuZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcblx0fSxcblx0XG5cdHJlbmRlcl9yZXNwb25zZTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdGNvbnNvbGUubG9nKGRhdGEpO1xuXHR9XG5cdFxuXHQvLyBcdGFjdGlvbl90d2lsaW9MaXN0U3ViQWNjb3VudHM6IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGEpIHtcblx0Ly8gXHRcdC8vLiBkYXRhIHJlbmRlcmluZyBieSBjb2NyZWF0ZS1yZW5kZXJcblx0Ly8gXHRcdGNvbnNvbGUubG9nKCdyYW5kZXInLGRhdGEpXG5cdC8vIFx0ICAgIGFwaS5yZW5kZXIodGhpcy5pZCwgJ3h4eENyZWF0ZUNhcmQnLCB7cmVuZGVyMjogZGF0YX0pO1xuXHRcblx0Ly8gXHR9XG5cbi8vIEVORCBDcmVhY3RlQ2FyZCBlbmRwb2ludFx0XG5cblxuXG59XG5cbmFwaS5pbml0KHtcblx0bmFtZTogQ29DcmVhdGVUd2lsaW8uaWQsIFxuXHRtb2R1bGU6XHRDb0NyZWF0ZVR3aWxpbyxcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBDb0NyZWF0ZVR3aWxpbzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.js\n")},"../../CoCreateJS/src/common-fun.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.getCommonParams = getCommonParams;\nexports.getCommonParamsExtend = getCommonParamsExtend;\nexports.generateSocketClient = generateSocketClient;\n\nfunction getCommonParams() {\n  return {\n    "apiKey": config.apiKey,\n    "securityKey": config.securityKey,\n    "organization_id": config.organization_Id\n  };\n}\n\nfunction getCommonParamsExtend(info) {\n  return {\n    "apiKey": info.apiKey || config.apiKey,\n    "securityKey": info.securityKey || config.securityKey,\n    "organization_id": info.organization_id || config.organization_Id\n  };\n}\n\nfunction generateSocketClient(namespace, room) {\n  let ns = namespace || config.organization_Id;\n  let rr = room || \'\';\n\n  if (rr) {\n    return `${ns}/${rr}`;\n  } else {\n    return ns;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvY29tbW9uLWZ1bi5qcz9iODlmIl0sIm5hbWVzIjpbImdldENvbW1vblBhcmFtcyIsImNvbmZpZyIsImFwaUtleSIsInNlY3VyaXR5S2V5Iiwib3JnYW5pemF0aW9uX0lkIiwiZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kIiwiaW5mbyIsIm9yZ2FuaXphdGlvbl9pZCIsImdlbmVyYXRlU29ja2V0Q2xpZW50IiwibmFtZXNwYWNlIiwicm9vbSIsIm5zIiwicnIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLFNBQVNBLGVBQVQsR0FDQTtBQUNFLFNBQU87QUFDTCxjQUFvQkMsTUFBTSxDQUFDQyxNQUR0QjtBQUVMLG1CQUFvQkQsTUFBTSxDQUFDRSxXQUZ0QjtBQUdMLHVCQUFvQkYsTUFBTSxDQUFDRztBQUh0QixHQUFQO0FBS0Q7O0FBRUQsU0FBU0MscUJBQVQsQ0FBK0JDLElBQS9CLEVBQ0E7QUFDRSxTQUFPO0FBQ0wsY0FBb0JBLElBQUksQ0FBQ0osTUFBTCxJQUFlRCxNQUFNLENBQUNDLE1BRHJDO0FBRUwsbUJBQW9CSSxJQUFJLENBQUNILFdBQUwsSUFBb0JGLE1BQU0sQ0FBQ0UsV0FGMUM7QUFHTCx1QkFBb0JHLElBQUksQ0FBQ0MsZUFBTCxJQUF3Qk4sTUFBTSxDQUFDRztBQUg5QyxHQUFQO0FBS0Q7O0FBRUQsU0FBU0ksb0JBQVQsQ0FBK0JDLFNBQS9CLEVBQTBDQyxJQUExQyxFQUNBO0FBQ0UsTUFBSUMsRUFBRSxHQUFHRixTQUFTLElBQUlSLE1BQU0sQ0FBQ0csZUFBN0I7QUFDQSxNQUFJUSxFQUFFLEdBQUdGLElBQUksSUFBSSxFQUFqQjs7QUFDQSxNQUFJRSxFQUFKLEVBQVE7QUFDTixXQUFRLEdBQUVELEVBQUcsSUFBR0MsRUFBRyxFQUFuQjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9ELEVBQVA7QUFDRDtBQUNGIiwiZmlsZSI6Ii4uLy4uL0NvQ3JlYXRlSlMvc3JjL2NvbW1vbi1mdW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRDb21tb25QYXJhbXMoKSBcbntcbiAgcmV0dXJuIHtcbiAgICBcImFwaUtleVwiOiAgICAgICAgICAgY29uZmlnLmFwaUtleSxcbiAgICBcInNlY3VyaXR5S2V5XCI6ICAgICAgY29uZmlnLnNlY3VyaXR5S2V5LFxuICAgIFwib3JnYW5pemF0aW9uX2lkXCI6ICBjb25maWcub3JnYW5pemF0aW9uX0lkLFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKSBcbntcbiAgcmV0dXJuIHtcbiAgICBcImFwaUtleVwiOiAgICAgICAgICAgaW5mby5hcGlLZXkgfHwgY29uZmlnLmFwaUtleSxcbiAgICBcInNlY3VyaXR5S2V5XCI6ICAgICAgaW5mby5zZWN1cml0eUtleSB8fCBjb25maWcuc2VjdXJpdHlLZXksXG4gICAgXCJvcmdhbml6YXRpb25faWRcIjogIGluZm8ub3JnYW5pemF0aW9uX2lkIHx8IGNvbmZpZy5vcmdhbml6YXRpb25fSWQsXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVTb2NrZXRDbGllbnQgKG5hbWVzcGFjZSwgcm9vbSkgXG57XG4gIGxldCBucyA9IG5hbWVzcGFjZSB8fCBjb25maWcub3JnYW5pemF0aW9uX0lkXG4gIGxldCByciA9IHJvb20gfHwgJyc7XG4gIGlmIChycikge1xuICAgIHJldHVybiBgJHtuc30vJHtycn1gXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5zO1xuICB9XG59XG5cbmV4cG9ydCB7Z2V0Q29tbW9uUGFyYW1zLCBnZXRDb21tb25QYXJhbXNFeHRlbmQsIGdlbmVyYXRlU29ja2V0Q2xpZW50fTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/common-fun.js\n')},"../../CoCreateJS/src/core.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = core;\n// ***********   define variables end ***************** /// \nconst CoCreateCore = {\n  socketInitFuncs: [],\n  moduleSelectors: [],\n  socket: null,\n  host: 'server.cocreate.app',\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n  init: function (host, namespace) {\n    if (host) {\n      this.host = host;\n    }\n\n    this.__setConfig();\n\n    this.createGeneralSocket(host, namespace || config.organization_Id);\n    this.initSocketListener();\n    this.createUserSocket(host);\n  },\n  __setConfig: function () {\n    let orgId = window.localStorage.getItem('organization_id');\n    let securityKey = window.localStorage.getItem('securityKey');\n    let apiKey = window.localStorage.getItem('apiKey');\n    if (orgId) config['organization_Id'] = orgId;\n    if (apiKey) config['apiKey'] = apiKey;\n    if (securityKey) config['securityKey'] = securityKey;\n  },\n  initSocketListener: function () {\n    const self = this;\n    this.socket.listen('connect', function (data, room) {\n      if (room == self.socket.getGlobalScope()) {\n        self.socketInitFuncs.forEach(func => {\n          func.initFunc.call(func.instance);\n        });\n      }\n    });\n    this.socket.listen('readDocument', function (data) {\n      const metadata = data.metadata; // if (metadata && metadata.type == 'crdt') {\n      //   self.initRenderCrdtData(data);\n      // } else {\n      //   // self.renderModules(data)\n      // }\n\n      return data;\n    });\n    this.socket.listen('updateDocument', function (data) {// self.renderModules(data)\n    });\n    this.socket.listen('deletedDocument', function (data) {\n      console.log(data);\n    });\n    this.socket.listen('sendMessage', function (data) {\n      console.log(data);\n    });\n    this.listenMessage('downloadFileInfo', function (data) {\n      self.socket.saveFileName = data.file_name;\n    });\n  },\n  createUserSocket: function (host) {\n    var user_id = window.localStorage.getItem('user_id');\n\n    if (user_id) {\n      this.socket.create({\n        namespace: 'users',\n        room: user_id,\n        host: host\n      });\n    }\n  },\n  createGeneralSocket: function (host, namespace) {\n    if (namespace) {\n      this.socket.create({\n        namespace: namespace,\n        room: null,\n        host: host\n      });\n      this.socket.setGlobalScope(namespace);\n    } else {\n      this.socket.create({\n        namespace: null,\n        room: null,\n        host: host\n      });\n    }\n  },\n  registerInit: function (initFunc, instance) {\n    this.socketInitFuncs.push({\n      initFunc,\n      instance: instance || window\n    });\n  },\n  // registerSelector: function(selector) {\n  //   if (this.moduleSelectors.indexOf(selector) === -1) {\n  //     this.moduleSelectors.push(selector);\n  //   }\n  // },\n  // getSelectors: function(selector) {\n  //   return this.moduleSelectors.join(\",\");\n  // },\n  listenMessage: function (message, fun) {\n    this.socket.listen(message, fun);\n  },\n  createSocket: function (config) {\n    this.socket.create(config);\n  },\n  destroySocket: function (config) {\n    const {\n      namespace,\n      room\n    } = config;\n    const key = this.socket.getKey(namespace, room);\n    let socket = this.socket.sockets.get(key);\n\n    if (!socket) {\n      return;\n    }\n\n    this.socket.destroy(socket, key);\n  }\n};\n\nfunction core(socket) {\n  CoCreateCore.setSocket(socket);\n  return CoCreateCore;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvY29yZS5qcz9jZDFhIl0sIm5hbWVzIjpbIkNvQ3JlYXRlQ29yZSIsInNvY2tldEluaXRGdW5jcyIsIm1vZHVsZVNlbGVjdG9ycyIsInNvY2tldCIsImhvc3QiLCJzZXRTb2NrZXQiLCJpbml0IiwibmFtZXNwYWNlIiwiX19zZXRDb25maWciLCJjcmVhdGVHZW5lcmFsU29ja2V0IiwiY29uZmlnIiwib3JnYW5pemF0aW9uX0lkIiwiaW5pdFNvY2tldExpc3RlbmVyIiwiY3JlYXRlVXNlclNvY2tldCIsIm9yZ0lkIiwid2luZG93IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInNlY3VyaXR5S2V5IiwiYXBpS2V5Iiwic2VsZiIsImxpc3RlbiIsImRhdGEiLCJyb29tIiwiZ2V0R2xvYmFsU2NvcGUiLCJmb3JFYWNoIiwiZnVuYyIsImluaXRGdW5jIiwiY2FsbCIsImluc3RhbmNlIiwibWV0YWRhdGEiLCJjb25zb2xlIiwibG9nIiwibGlzdGVuTWVzc2FnZSIsInNhdmVGaWxlTmFtZSIsImZpbGVfbmFtZSIsInVzZXJfaWQiLCJjcmVhdGUiLCJzZXRHbG9iYWxTY29wZSIsInJlZ2lzdGVySW5pdCIsInB1c2giLCJtZXNzYWdlIiwiZnVuIiwiY3JlYXRlU29ja2V0IiwiZGVzdHJveVNvY2tldCIsImtleSIsImdldEtleSIsInNvY2tldHMiLCJnZXQiLCJkZXN0cm95IiwiY29yZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFFQSxNQUFNQSxZQUFZLEdBQUc7QUFDbkJDLGlCQUFlLEVBQUUsRUFERTtBQUVuQkMsaUJBQWUsRUFBRSxFQUZFO0FBR25CQyxRQUFNLEVBQUUsSUFIVztBQUluQkMsTUFBSSxFQUFFLHFCQUphO0FBTW5CQyxXQUFTLEVBQUUsVUFBU0YsTUFBVCxFQUFpQjtBQUMxQixTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDRCxHQVJrQjtBQVduQkcsTUFBSSxFQUFF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LE1BQUwsQ0FBWTJDLE1BQVosQ0FBbUJ2QyxTQUFuQixFQUE4QmdCLElBQTlCLENBQVo7QUFDQSxRQUFJcEIsTUFBTSxHQUFHLEtBQUtBLE1BQUwsQ0FBWTRDLE9BQVosQ0FBb0JDLEdBQXBCLENBQXdCSCxHQUF4QixDQUFiOztBQUVBLFFBQUksQ0FBQzFDLE1BQUwsRUFBYTtBQUNYO0FBQ0Q7O0FBQ0QsU0FBS0EsTUFBTCxDQUFZOEMsT0FBWixDQUFvQjlDLE1BQXBCLEVBQTRCMEMsR0FBNUI7QUFDRDtBQXJJbUIsQ0FBckI7O0FBd0llLFNBQVNLLElBQVQsQ0FBYy9DLE1BQWQsRUFBc0I7QUFDbkNILGNBQVksQ0FBQ0ssU0FBYixDQUF1QkYsTUFBdkI7QUFDQSxTQUFPSCxZQUFQO0FBQ0QiLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGVKUy9zcmMvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICoqKioqKioqKioqICAgZGVmaW5lIHZhcmlhYmxlcyBlbmQgKioqKioqKioqKioqKioqKiogLy8vIFxuXG5jb25zdCBDb0NyZWF0ZUNvcmUgPSB7XG4gIHNvY2tldEluaXRGdW5jczogW10sXG4gIG1vZHVsZVNlbGVjdG9yczogW10sXG4gIHNvY2tldDogbnVsbCxcbiAgaG9zdDogJ3NlcnZlci5jb2NyZWF0ZS5hcHAnLFxuICBcbiAgc2V0U29ja2V0OiBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgfSxcblxuICBcbiAgaW5pdDogZnVuY3Rpb24oaG9zdCwgbmFtZXNwYWNlKSB7XG4gICAgaWYgKGhvc3QpIHtcbiAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuX19zZXRDb25maWcoKVxuICAgIHRoaXMuY3JlYXRlR2VuZXJhbFNvY2tldChob3N0LCBuYW1lc3BhY2UgfHwgY29uZmlnLm9yZ2FuaXphdGlvbl9JZCk7XG4gICAgdGhpcy5pbml0U29ja2V0TGlzdGVuZXIoKTtcbiAgICB0aGlzLmNyZWF0ZVVzZXJTb2NrZXQoaG9zdCk7XG4gIH0sXG4gIFxuICBfX3NldENvbmZpZzogZnVuY3Rpb24oKSB7XG5cdFx0bGV0IG9yZ0lkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdvcmdhbml6YXRpb25faWQnKTtcblx0XHRsZXQgc2VjdXJpdHlLZXkgPSB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NlY3VyaXR5S2V5Jyk7XG5cdFx0bGV0IGFwaUtleSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYXBpS2V5Jyk7XG5cdFx0XG5cdFx0aWYgKG9yZ0lkKSAgICAgICAgY29uZmlnWydvcmdhbml6YXRpb25fSWQnXSA9IG9yZ0lkXG5cdFx0aWYgKGFwaUtleSkgICAgICAgY29uZmlnWydhcGlLZXknXSA9IGFwaUtleVxuXHRcdGlmIChzZWN1cml0eUtleSkgIGNvbmZpZ1snc2VjdXJpdHlLZXknXSA9IHNlY3VyaXR5S2V5O1xuICB9LFxuICBcbiAgaW5pdFNvY2tldExpc3RlbmVyOiBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoZGF0YSwgcm9vbSkge1xuICAgICAgXG4gICAgICBpZiAocm9vbSA9PSBzZWxmLnNvY2tldC5nZXRHbG9iYWxTY29wZSgpKSB7XG4gICAgICAgIHNlbGYuc29ja2V0SW5pdEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHtcbiAgICAgICAgICBmdW5jLmluaXRGdW5jLmNhbGwoZnVuYy5pbnN0YW5jZSk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oJ3JlYWREb2N1bWVudCcsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBkYXRhLm1ldGFkYXRhO1xuICAgICAgLy8gaWYgKG1ldGFkYXRhICYmIG1ldGFkYXRhLnR5cGUgPT0gJ2NyZHQnKSB7XG4gICAgICAvLyAgIHNlbGYuaW5pdFJlbmRlckNyZHREYXRhKGRhdGEpO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgLy8gc2VsZi5yZW5kZXJNb2R1bGVzKGRhdGEpXG4gICAgICAvLyB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KVxuICAgIFxuICAgIHRoaXMuc29ja2V0Lmxpc3RlbigndXBkYXRlRG9jdW1lbnQnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAvLyBzZWxmLnJlbmRlck1vZHVsZXMoZGF0YSlcbiAgICB9KVxuICAgIFxuICAgIHRoaXMuc29ja2V0Lmxpc3RlbignZGVsZXRlZERvY3VtZW50JywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgfSlcbiAgICBcbiAgICB0aGlzLnNvY2tldC5saXN0ZW4oJ3NlbmRNZXNzYWdlJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgfSlcbiAgICBcbiAgICB0aGlzLmxpc3Rlbk1lc3NhZ2UoJ2Rvd25sb2FkRmlsZUluZm8nLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBzZWxmLnNvY2tldC5zYXZlRmlsZU5hbWUgPSBkYXRhLmZpbGVfbmFtZTtcbiAgICB9KVxuICAgIFxuICB9LFxuICBcbiAgY3JlYXRlVXNlclNvY2tldDogZnVuY3Rpb24oaG9zdCkge1xuICAgIHZhciB1c2VyX2lkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VyX2lkJyk7XG4gICAgaWYgKHVzZXJfaWQpIHtcbiAgICAgIHRoaXMuc29ja2V0LmNyZWF0ZSh7XG4gICAgICAgIG5hbWVzcGFjZTogJ3VzZXJzJyxcbiAgICAgICAgcm9vbTogdXNlcl9pZCxcbiAgICAgICAgaG9zdDogaG9zdFxuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIFxuICBjcmVhdGVHZW5lcmFsU29ja2V0OiBmdW5jdGlvbihob3N0LCBuYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgXHR0aGlzLnNvY2tldC5jcmVhdGUoe1xuICAgIFx0ICBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgXG4gICAgXHQgIHJvb206IG51bGwsXG4gICAgXHQgIGhvc3Q6IGhvc3RcbiAgICBcdH0pO1xuICAgIFx0dGhpcy5zb2NrZXQuc2V0R2xvYmFsU2NvcGUobmFtZXNwYWNlKTtcbiAgICB9IGVsc2Uge1xuICAgIFx0dGhpcy5zb2NrZXQuY3JlYXRlKHtcbiAgICBcdCAgbmFtZXNwYWNlOiBudWxsLCBcbiAgICBcdCAgcm9vbTogbnVsbCxcbiAgICBcdCAgaG9zdDogaG9zdFxuICAgIFx0fSk7XG4gICAgfVxuICB9LFxuICBcbiAgcmVnaXN0ZXJJbml0OiBmdW5jdGlvbihpbml0RnVuYywgaW5zdGFuY2UpIHtcbiAgICB0aGlzLnNvY2tldEluaXRGdW5jcy5wdXNoKHtcbiAgICAgIGluaXRGdW5jLFxuICAgICAgaW5zdGFuY2UgOiBpbnN0YW5jZSB8fCB3aW5kb3dcbiAgICB9KTtcbiAgfSxcbiAgLy8gcmVnaXN0ZXJTZWxlY3RvcjogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgLy8gICBpZiAodGhpcy5tb2R1bGVTZWxlY3RvcnMuaW5kZXhPZihzZWxlY3RvcikgPT09IC0xKSB7XG4gIC8vICAgICB0aGlzLm1vZHVsZVNlbGVjdG9ycy5wdXNoKHNlbGVjdG9yKTtcbiAgLy8gICB9XG4gIC8vIH0sXG4gIFxuICAvLyBnZXRTZWxlY3RvcnM6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMubW9kdWxlU2VsZWN0b3JzLmpvaW4oXCIsXCIpO1xuICAvLyB9LFxuXG4gIGxpc3Rlbk1lc3NhZ2U6IGZ1bmN0aW9uKG1lc3NhZ2UsIGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihtZXNzYWdlLCBmdW4pO1xuICB9LFxuIFxuIGNyZWF0ZVNvY2tldDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICB0aGlzLnNvY2tldC5jcmVhdGUoY29uZmlnKTtcbiB9LFxuIFxuIGRlc3Ryb3lTb2NrZXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgY29uc3Qge25hbWVzcGFjZSwgcm9vbX0gPSBjb25maWc7XG4gICBjb25zdCBrZXkgPSB0aGlzLnNvY2tldC5nZXRLZXkobmFtZXNwYWNlLCByb29tKTtcbiAgIGxldCBzb2NrZXQgPSB0aGlzLnNvY2tldC5zb2NrZXRzLmdldChrZXkpO1xuICAgXG4gICBpZiAoIXNvY2tldCkge1xuICAgICByZXR1cm5cbiAgIH1cbiAgIHRoaXMuc29ja2V0LmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvcmUoc29ja2V0KSB7XG4gIENvQ3JlYXRlQ29yZS5zZXRTb2NrZXQoc29ja2V0KTtcbiAgcmV0dXJuIENvQ3JlYXRlQ29yZTtcbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/core.js\n")},"../../CoCreateJS/src/crud.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = CRUD;\n\nvar _commonFun = __webpack_require__(/*! ./common-fun.js */ \"../../CoCreateJS/src/common-fun.js\");\n\nvar _utilsCrud = _interopRequireDefault(__webpack_require__(/*! ./utils.crud.js */ \"../../CoCreateJS/src/utils.crud.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// ***********   define variables end ***************** /// \nvar data = {\n  \"org_id\": \"xxx\",\n  \"customer.name\": \"Jin\",\n  \"customer.fristname\": \"Jin\",\n  \"customer.lastname\": \"CF\",\n  \"customer.address.line1\": \"line1\",\n  \"customer.address.line2\": \"line2\",\n  'scope[0]': 'testing',\n  'scope[1]': '---',\n  \"customer.orders[0]\": 123,\n  \"customer.orders[1]\": 243\n};\nvar obj = {\n  test: {\n    \"name\": '123',\n    \"address\": 'address',\n    \"customer\": {\n      \"name\": 'tttt'\n    },\n    \"orders\": [1, 2, 3]\n  }\n};\nconsole.log('----- convert object -----');\nconsole.log(_utilsCrud.default.decodeObject(data));\nconsole.log(_utilsCrud.default.encodeObject(obj));\nconst CoCreateCRUD = {\n  socket: null,\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n\n  /*\n   \n    CoCreate.crud.readDcoumentList {\n      collection: \"modules\",\n      element: \"xxxx\",\n      metadata: \"\",\n      operator: {\n        fetch: {\n          name: 'xxxx',\n          value: 'xxxxx'\n        },\n        filters: [{\n          name: 'field1',\n          operator: \"contain | range | eq | ne | lt | lte | gt | gte | in | nin\",\n          value: [v1, v2, ...]\n        }, {\n          name: \"_id\",\n          opreator: \"in\",\n          value: [\"id1\"]\n        }, {\n          ....\n        }],\n        orders: [{\n          name: 'field-x',\n          type: 1 | -1\n        }],\n        search: {\n          type: 'or | and',\n          value: [value1, value2]\n        },\n        \n        startIndex: 0 (integer),\n        count: 0 (integer)\n      },\n      \n      is_collection: true | false,\n      //. case fetch document case\n      created_ids : [id1, id2, ...],\n      \n      \n      -------- additional response data -----------\n      data: [] // array\n    }\n  */\n  readDocumentList(info) {\n    if (!info) return;\n    let request_data = (0, _commonFun.getCommonParams)();\n\n    if (!info.collection || !info.operator) {\n      return;\n    }\n\n    request_data = { ...request_data,\n      ...info\n    };\n    this.socket.send('readDocumentList', request_data);\n  },\n\n  /*\n  CoCreate.crud.createDocument({\n    namespace:'',\n    room:'',\n    broadcast: true/false, (default=ture)\n    broadcast_sender: true/false, (default=true) \n    \n    collection: \"test123\",\n    data:{\n    \tname1:hello,\n    \tname2:  hello1\n    },\n    element: xxxx,\n    metaData: \"xxxx\"\n  }),\n  */\n  // data param needs organization_id field added to pass security check\n  createDocument: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'] || 'module_activities';\n    let data = info.data || {};\n\n    if (!data['organization_id']) {\n      data['organization_id'] = config.organization_Id;\n    }\n\n    if (info['data']) {\n      data = { ...data,\n        ...info['data']\n      };\n    } //. rebuild data\n\n\n    request_data['data'] = data;\n\n    if (info['metadata']) {\n      request_data['metadata'] = info['metadata'];\n    }\n\n    request_data['element'] = info['element'];\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (info['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('createDocument', request_data, room);\n  },\n\n  /*\n  CoCreate.crud.updateDocument({\n    namespace: '',\n    room: '',\n    broadcast: true/false,\n    broadcast_sender: true/false,\n    \n    collection: \"test123\",\n    document_id: \"document_id\",\n    data:{\n    \tname1:hello,\n    \tname2:  hello1\n    },\n    delete_fields:[\"name3\", \"name4\"],\n    element: xxxx,\n    metaData: \"xxxx\"\n  }),\n  */\n  updateDocument: function (info) {\n    if (!info || !info['document_id']) return;\n    let request_data = (0, _commonFun.getCommonParamsExtend)(info);\n    request_data['collection'] = info['collection'] || 'module_activities';\n    request_data['document_id'] = info['document_id'];\n\n    if (typeof info['data'] === 'object') {\n      request_data['set'] = info['data'];\n    }\n\n    if (Array.isArray(info['delete_fields'])) request_data['unset'] = info['delete_fields'];\n    if (!request_data['set'] && !request_data['unset']) return;\n    request_data['element'] = info['element'];\n    request_data['metadata'] = info['metadata'];\n\n    if (info.upsert) {\n      request_data['upsert'] = true;\n    }\n\n    if (info.broadcast === false) {\n      request_data['broadcast'] = false;\n    }\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n\n\n    request_data['broadcast_sender'] = info.broadcast_sender;\n\n    if (info['broadcast_sender'] === undefined) {\n      request_data['broadcast_sender'] = true;\n    }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('updateDocument', request_data, room);\n  },\n\n  /*\n  CoCreate.crud.readDocument({\n    collection: \"test123\",\n    document_id: \"document_id\",\n    element: xxxx,\n    metaData: \"xxxx\",\n    exclude_fields: [] \n  }),\n  */\n  readDocument: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    if (!info['document_id'] || !info) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['document_id'] = info['document_id'];\n\n    if (info['exclude_fields']) {\n      request_data['exclude_fields'] = info['exclude_fields'];\n    }\n\n    if (info['element']) {\n      request_data['element'] = info['element'];\n    }\n\n    request_data['metadata'] = info['metadata'];\n    this.socket.send('readDocument', request_data);\n  },\n\n  /*\n  CoCreate.crud.deleteDocument({\n    namespace: '',\n    room: '',\n    broadcast: true/false,\n    broadcast_sender: true/false,\n    \n    collection: \"module\",\n    document_id: \"\",\n    element: xxxx,\n    metadata: \"xxxx\"\n  }),\n  */\n  deleteDocument: function (info) {\n    if (!info['document_id'] || !info) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['document_id'] = info['document_id'];\n\n    if (info['element']) {\n      request_data['element'] = info['element'];\n    }\n\n    request_data['metadata'] = info['metadata'];\n    /** socket parameters **/\n    // if (info['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (info['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(info.namespace, info.room);\n    this.socket.send('deleteDocument', request_data, room);\n  },\n\n  /** export / import db functions **/\n\n  /*\n  readDocument({\n   collection: \"test123\",\n   element: xxxx,\n   metaData: \"xxxx\",\n  }),\n  */\n  exportCollection: function (info) {\n    if (info === null) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['export_type'] = info['export_type'];\n    request_data['metadata'] = info['metadata'];\n    this.socket.send('exportDB', request_data);\n  },\n\n  /*\n  readDocument({\n    collection: \"test123\",\n    file: file\n  }),\n  */\n  importCollection: function (info) {\n    const {\n      file\n    } = info;\n\n    if (info === null || !(file instanceof File)) {\n      return;\n    }\n\n    const extension = file.name.split(\".\").pop();\n\n    if (!['json', 'csv'].some(item => item === extension)) {\n      return;\n    }\n\n    let request_data = (0, _commonFun.getCommonParams)();\n    request_data['collection'] = info['collection'];\n    request_data['import_type'] = extension;\n    this.socket.send('importDB', request_data);\n    this.socket.sendFile(file);\n  },\n  //. message listener\n  listenMessage: function (message, fun) {\n    this.socket.listen(message, fun);\n  },\n  listenerReadDocument: function (fun) {\n    this.socket.listen(\"readDocument\", fun);\n  },\n  listenerCreateDocument: function (fun) {\n    this.socket.listen(\"createDocument\", fun);\n  },\n  listenerDeleteDocument: function (fun) {\n    this.socket.listen(\"deleteDocument\", fun);\n  },\n  listenerUpdateDocument: function (fun) {\n    this.socket.listen(\"updateDocument\", fun);\n  },\n  listenerReadDocumentList: function (fun) {\n    this.socket.listen(\"readDocumentList\", fun);\n  }\n};\n\nfunction CRUD(socket) {\n  CoCreateCRUD.setSocket(socket);\n  return CoCreateCRUD;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvY3J1ZC5qcz84MjE5Il0sIm5hbWVzIjpbImRhdGEiLCJvYmoiLCJ0ZXN0IiwiY29uc29sZSIsImxvZyIsInV0aWxzQ3J1ZCIsImRlY29kZU9iamVjdCIsImVuY29kZU9iamVjdCIsIkNvQ3JlYXRlQ1JVRCIsInNvY2tldCIsInNldFNvY2tldCIsInJlYWREb2N1bWVudExpc3QiLCJpbmZvIiwicmVxdWVzdF9kYXRhIiwiY29sbGVjdGlvbiIsIm9wZXJhdG9yIiwic2VuZCIsImNyZWF0ZURvY3VtZW50IiwiY29uZmlnIiwib3JnYW5pemF0aW9uX0lkIiwicm9vbSIsIm5hbWVzcGFjZSIsInVwZGF0ZURvY3VtZW50IiwiQXJyYXkiLCJpc0FycmF5IiwidXBzZXJ0IiwiYnJvYWRjYXN0IiwiYnJvYWRjYXN0X3NlbmRlciIsInVuZGVmaW5lZCIsInJlYWREb2N1bWVudCIsImRlbGV0ZURvY3VtZW50IiwiZXhwb3J0Q29sbGVjdGlvbiIsImltcG9ydENvbGxlY3Rpb24iLCJmaWxlIiwiRmlsZSIsImV4dGVuc2lvbiIsIm5hbWUiLCJzcGxpdCIsInBvcCIsInNvbWUiLCJpdGVtIiwic2VuZEZpbGUiLCJsaXN0ZW5NZXNzYWdlIiwibWVzc2FnZSIsImZ1biIsImxpc3RlbiIsImxpc3RlbmVyUmVhZERvY3VtZW50IiwibGlzdGVuZXJDcmVhdGVEb2N1bWVudCIsImxpc3RlbmVyRGVsZXRlRG9jdW1lbnQiLCJsaXN0ZW5lclVwZGF0ZURvY3VtZW50IiwibGlzdGVuZXJSZWFkRG9jdW1lbnRMaXN0IiwiQ1JVRCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVBOztBQUNBOzs7O0FBSEE7QUFLQSxJQUFJQSxJQUFJLEdBQUc7QUFDVCxZQUFVLEtBREQ7QUFFVCxtQkFBaUIsS0FGUjtBQUdULHdCQUFzQixLQUhiO0FBSVQsdUJBQXFCLElBSlo7QUFLVCw0QkFBMEIsT0FMakI7QUFNVCw0QkFBMEIs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WU8sSUFBWixDQUFpQixVQUFqQixFQUE2QkgsWUFBN0I7QUFDQSxTQUFLSixNQUFMLENBQVlnQyxRQUFaLENBQXFCUixJQUFyQjtBQUNELEdBMVNrQjtBQTZTbkI7QUFDQVMsZUFBYSxFQUFFLFVBQVNDLE9BQVQsRUFBa0JDLEdBQWxCLEVBQXVCO0FBQ3BDLFNBQUtuQyxNQUFMLENBQVlvQyxNQUFaLENBQW1CRixPQUFuQixFQUE0QkMsR0FBNUI7QUFDRCxHQWhUa0I7QUFrVG5CRSxzQkFBb0IsRUFBRSxVQUFTRixHQUFULEVBQWM7QUFDbEMsU0FBS25DLE1BQUwsQ0FBWW9DLE1BQVosQ0FBbUIsY0FBbkIsRUFBbUNELEdBQW5DO0FBQ0QsR0FwVGtCO0FBcVRuQkcsd0JBQXNCLEVBQUUsVUFBU0gsR0FBVCxFQUFjO0FBQ3BDLFNBQUtuQyxNQUFMLENBQVlvQyxNQUFaLENBQW1CLGdCQUFuQixFQUFxQ0QsR0FBckM7QUFDRCxHQXZUa0I7QUF3VG5CSSx3QkFBc0IsRUFBRSxVQUFTSixHQUFULEVBQWM7QUFDcEMsU0FBS25DLE1BQUwsQ0FBWW9DLE1BQVosQ0FBbUIsZ0JBQW5CLEVBQXFDRCxHQUFyQztBQUNELEdBMVRrQjtBQTJUbkJLLHdCQUFzQixFQUFFLFVBQVNMLEdBQVQsRUFBYztBQUNwQyxTQUFLbkMsTUFBTCxDQUFZb0MsTUFBWixDQUFtQixnQkFBbkIsRUFBcUNELEdBQXJDO0FBQ0QsR0E3VGtCO0FBOFRuQk0sMEJBQXdCLEVBQUUsVUFBU04sR0FBVCxFQUFjO0FBQ3RDLFNBQUtuQyxNQUFMLENBQVlvQyxNQUFaLENBQW1CLGtCQUFuQixFQUF1Q0QsR0FBdkM7QUFDRDtBQWhVa0IsQ0FBckI7O0FBbVVlLFNBQVNPLElBQVQsQ0FBYzFDLE1BQWQsRUFBc0I7QUFDbkNELGNBQVksQ0FBQ0UsU0FBYixDQUF1QkQsTUFBdkI7QUFDQSxTQUFPRCxZQUFQO0FBQ0QiLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGVKUy9zcmMvY3J1ZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICoqKioqKioqKioqICAgZGVmaW5lIHZhcmlhYmxlcyBlbmQgKioqKioqKioqKioqKioqKiogLy8vIFxuXG5pbXBvcnQge2dldENvbW1vblBhcmFtcywgZ2V0Q29tbW9uUGFyYW1zRXh0ZW5kLCBnZW5lcmF0ZVNvY2tldENsaWVudH0gZnJvbSBcIi4vY29tbW9uLWZ1bi5qc1wiXG5pbXBvcnQgdXRpbHNDcnVkIGZyb20gXCIuL3V0aWxzLmNydWQuanNcIlxuXG52YXIgZGF0YSA9IHtcbiAgXCJvcmdfaWRcIjogXCJ4eHhcIixcbiAgXCJjdXN0b21lci5uYW1lXCI6IFwiSmluXCIsXG4gIFwiY3VzdG9tZXIuZnJpc3RuYW1lXCI6IFwiSmluXCIsXG4gIFwiY3VzdG9tZXIubGFzdG5hbWVcIjogXCJDRlwiLFxuICBcImN1c3RvbWVyLmFkZHJlc3MubGluZTFcIjogXCJsaW5lMVwiLFxuICBcImN1c3RvbWVyLmFkZHJlc3MubGluZTJcIjogXCJsaW5lMlwiLFxuICAnc2NvcGVbMF0nOiAndGVzdGluZycsXG4gICdzY29wZVsxXSc6ICctLS0nLFxuICBcImN1c3RvbWVyLm9yZGVyc1swXVwiOiAxMjMsXG4gIFwiY3VzdG9tZXIub3JkZXJzWzFdXCI6IDI0Myxcbn1cblxudmFyIG9iaiA9IHtcbiAgdGVzdDoge1xuICAgIFwibmFtZVwiOiAnMTIzJyxcbiAgICBcImFkZHJlc3NcIjogJ2FkZHJlc3MnLFxuICAgIFwiY3VzdG9tZXJcIjoge1xuICAgICAgXCJuYW1lXCI6ICd0dHR0J1xuICAgIH0sXG4gICAgXCJvcmRlcnNcIjogWzEsMiwzXVxuICB9XG59XG5jb25zb2xlLmxvZygnLS0tLS0gY29udmVydCBvYmplY3QgLS0tLS0nKVxuY29uc29sZS5sb2codXRpbHNDcnVkLmRlY29kZU9iamVjdChkYXRhKSk7XG5jb25zb2xlLmxvZyh1dGlsc0NydWQuZW5jb2RlT2JqZWN0KG9iaikpO1xuXG5jb25zdCBDb0NyZWF0ZUNSVUQgPSB7XG4gIHNvY2tldDogbnVsbCxcbiAgc2V0U29ja2V0OiBmdW5jdGlvbihzb2NrZXQpIHtcbiAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgfSxcbiAgLypcbiAgIFxuICAgIENvQ3JlYXRlLmNydWQucmVhZERjb3VtZW50TGlzdCB7XG4gICAgICBjb2xsZWN0aW9uOiBcIm1vZHVsZXNcIixcbiAgICAgIGVsZW1lbnQ6IFwieHh4eFwiLFxuICAgICAgbWV0YWRhdGE6IFwiXCIsXG4gICAgICBvcGVyYXRvcjoge1xuICAgICAgICBmZXRjaDoge1xuICAgICAgICAgIG5hbWU6ICd4eHh4JyxcbiAgICAgICAgICB2YWx1ZTogJ3h4eHh4J1xuICAgICAgICB9LFxuICAgICAgICBmaWx0ZXJzOiBbe1xuICAgICAgICAgIG5hbWU6ICdmaWVsZDEnLFxuICAgICAgICAgIG9wZXJhdG9yOiBcImNvbnRhaW4gfCByYW5nZSB8IGVxIHwgbmUgfCBsdCB8IGx0ZSB8IGd0IHwgZ3RlIHwgaW4gfCBuaW5cIixcbiAgICAgICAgICB2YWx1ZTogW3YxLCB2MiwgLi4uXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJfaWRcIixcbiAgICAgICAgICBvcHJlYXRvcjogXCJpblwiLFxuICAgICAgICAgIHZhbHVlOiBbXCJpZDFcIl1cbiAgICAgICAgfSwge1xuICAgICAgICAgIC4uLi5cbiAgICAgICAgfV0sXG4gICAgICAgIG9yZGVyczogW3tcbiAgICAgICAgICBuYW1lOiAnZmllbGQteCcsXG4gICAgICAgICAgdHlwZTogMSB8IC0xXG4gICAgICAgIH1dLFxuICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICB0eXBlOiAnb3IgfCBhbmQnLFxuICAgICAgICAgIHZhbHVlOiBbdmFsdWUxLCB2YWx1ZTJdXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzdGFydEluZGV4OiAwIChpbnRlZ2VyKSxcbiAgICAgICAgY291bnQ6IDAgKGludGVnZXIpXG4gICAgICB9LFxuICAgICAgXG4gICAgICBpc19jb2xsZWN0aW9uOiB0cnVlIHwgZmFsc2UsXG4gICAgICAvLy4gY2FzZSBmZXRjaCBkb2N1bWVudCBjYXNlXG4gICAgICBjcmVhdGVkX2lkcyA6IFtpZDEsIGlkMiwgLi4uXSxcbiAgICAgIFxuICAgICAgXG4gICAgICAtLS0tLS0tLSBhZGRpdGlvbmFsIHJlc3BvbnNlIGRhdGEgLS0tLS0tLS0tLS1cbiAgICAgIGRhdGE6IFtdIC8vIGFycmF5XG4gICAgfVxuICAqL1xuICBcbiAgcmVhZERvY3VtZW50TGlzdChpbmZvKXtcbiAgICBpZiggIWluZm8gKSByZXR1cm47XG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpO1xuICAgIFxuICAgIGlmICghaW5mby5jb2xsZWN0aW9uIHx8ICFpbmZvLm9wZXJhdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHJlcXVlc3RfZGF0YSA9IHsuLi5yZXF1ZXN0X2RhdGEsIC4uLmluZm99O1xuICAgIFxuICAgIHRoaXMuc29ja2V0LnNlbmQoJ3JlYWREb2N1bWVudExpc3QnLCByZXF1ZXN0X2RhdGEpO1xuICB9LFxuICBcbiAgXG4gIC8qXG4gIENvQ3JlYXRlLmNydWQuY3JlYXRlRG9jdW1lbnQoe1xuICAgIG5hbWVzcGFjZTonJyxcbiAgICByb29tOicnLFxuICAgIGJyb2FkY2FzdDogdHJ1ZS9mYWxzZSwgKGRlZmF1bHQ9dHVyZSlcbiAgICBicm9hZGNhc3Rfc2VuZGVyOiB0cnVlL2ZhbHNlLCAoZGVmYXVsdD10cnVlKSBcbiAgICBcbiAgICBjb2xsZWN0aW9uOiBcInRlc3QxMjNcIixcbiAgICBkYXRhOntcbiAgICBcdG5hbWUxOuKAnGhlbGxv4oCdLFxuICAgIFx0bmFtZTI6ICDigJxoZWxsbzHigJ1cbiAgICB9LFxuICAgIGVsZW1lbnQ6IOKAnHh4eHjigJ0sXG4gICAgbWV0YURhdGE6IFwieHh4eFwiXG4gIH0pLFxuICAqL1xuICAvLyBkYXRhIHBhcmFtIG5lZWRzIG9yZ2FuaXphdGlvbl9pZCBmaWVsZCBhZGRlZCB0byBwYXNzIHNlY3VyaXR5IGNoZWNrXG4gIGNyZWF0ZURvY3VtZW50OiBmdW5jdGlvbihpbmZvKSB7XG4gICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpXG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ10gfHwgJ21vZHVsZV9hY3Rpdml0aWVzJztcbiAgICBcbiAgICBsZXQgZGF0YSA9IGluZm8uZGF0YSB8fCB7fTtcbiAgICBcbiAgICBpZiAoIWRhdGFbJ29yZ2FuaXphdGlvbl9pZCddKSB7XG4gICAgICBkYXRhWydvcmdhbml6YXRpb25faWQnXSA9IGNvbmZpZy5vcmdhbml6YXRpb25fSWRcbiAgICB9XG4gICAgaWYgKGluZm9bJ2RhdGEnXSkge1xuICAgICAgZGF0YSA9IHsuLi5kYXRhLCAuLi5pbmZvWydkYXRhJ119XG4gICAgfVxuICAgIFxuICAgIC8vLiByZWJ1aWxkIGRhdGFcbiAgICBcbiAgICByZXF1ZXN0X2RhdGFbJ2RhdGEnXSA9IGRhdGE7XG4gICAgaWYgKGluZm9bJ21ldGFkYXRhJ10pIHtcbiAgICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICB9XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydlbGVtZW50J10gPSBpbmZvWydlbGVtZW50J107XG4gICAgXG4gICAgLyoqIHNvY2tldCBwYXJhbWV0ZXJzICoqL1xuICAgIC8vIGlmIChpbmZvWydicm9hZGNhc3QnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdCddID0gdHJ1ZTtcbiAgICAvLyB9XG4gICAgLy8gaWYgKGluZm9bJ2Jyb2FkY2FzdF9zZW5kZXInXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdF9zZW5kZXInXSA9IHRydWU7XG4gICAgLy8gfVxuICAgIFxuICAgIGNvbnN0IHJvb20gPSBnZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICB0aGlzLnNvY2tldC5zZW5kKCdjcmVhdGVEb2N1bWVudCcsIHJlcXVlc3RfZGF0YSwgcm9vbSk7XG4gIH0sXG4gIFxuXG4gIFxuXG4gIC8qXG4gIENvQ3JlYXRlLmNydWQudXBkYXRlRG9jdW1lbnQoe1xuICAgIG5hbWVzcGFjZTogJycsXG4gICAgcm9vbTogJycsXG4gICAgYnJvYWRjYXN0OiB0cnVlL2ZhbHNlLFxuICAgIGJyb2FkY2FzdF9zZW5kZXI6IHRydWUvZmFsc2UsXG4gICAgXG4gICAgY29sbGVjdGlvbjogXCJ0ZXN0MTIzXCIsXG4gICAgZG9jdW1lbnRfaWQ6IFwiZG9jdW1lbnRfaWRcIixcbiAgICBkYXRhOntcbiAgICBcdG5hbWUxOuKAnGhlbGxv4oCdLFxuICAgIFx0bmFtZTI6ICDigJxoZWxsbzHigJ1cbiAgICB9LFxuICAgIGRlbGV0ZV9maWVsZHM6W1wibmFtZTNcIiwgXCJuYW1lNFwiXSxcbiAgICBlbGVtZW50OiDigJx4eHh44oCdLFxuICAgIG1ldGFEYXRhOiBcInh4eHhcIlxuICB9KSxcbiAgKi9cbiAgdXBkYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGluZm8pIHtcbiAgICBpZiggIWluZm8gfHwgIWluZm9bJ2RvY3VtZW50X2lkJ10gKSByZXR1cm47XG4gICAgXG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtc0V4dGVuZChpbmZvKTtcbiAgICBcbiAgICByZXF1ZXN0X2RhdGFbJ2NvbGxlY3Rpb24nXSA9IGluZm9bJ2NvbGxlY3Rpb24nXSB8fCAnbW9kdWxlX2FjdGl2aXRpZXMnO1xuICAgIHJlcXVlc3RfZGF0YVsnZG9jdW1lbnRfaWQnXSA9IGluZm9bJ2RvY3VtZW50X2lkJ107XG4gICAgXG4gICAgaWYoIHR5cGVvZiBpbmZvWydkYXRhJ10gPT09ICdvYmplY3QnICkge1xuICAgICAgcmVxdWVzdF9kYXRhWydzZXQnXSA9IGluZm9bJ2RhdGEnXVxuICAgIH1cbiAgICBpZiggQXJyYXkuaXNBcnJheShpbmZvWydkZWxldGVfZmllbGRzJ10pICkgcmVxdWVzdF9kYXRhWyd1bnNldCddID0gaW5mb1snZGVsZXRlX2ZpZWxkcyddO1xuICAgIFxuICAgIGlmKCFyZXF1ZXN0X2RhdGFbJ3NldCddICYmICFyZXF1ZXN0X2RhdGFbJ3Vuc2V0J10pIHJldHVybjtcbiAgICBcbiAgICByZXF1ZXN0X2RhdGFbJ2VsZW1lbnQnXSA9IGluZm9bJ2VsZW1lbnQnXTtcbiAgICByZXF1ZXN0X2RhdGFbJ21ldGFkYXRhJ10gPSBpbmZvWydtZXRhZGF0YSddO1xuICAgIFxuICAgIGlmIChpbmZvLnVwc2VydCkge1xuICAgICAgcmVxdWVzdF9kYXRhWyd1cHNlcnQnXSA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChpbmZvLmJyb2FkY2FzdCA9PT0gZmFsc2UpIHtcbiAgICAgIHJlcXVlc3RfZGF0YVsnYnJvYWRjYXN0J10gPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLyoqIHNvY2tldCBwYXJhbWV0ZXJzICoqL1xuICAgIC8vIGlmIChpbmZvWydicm9hZGNhc3QnXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdCddID0gdHJ1ZTtcbiAgICAvLyB9XG4gICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSBpbmZvLmJyb2FkY2FzdF9zZW5kZXI7XG4gICAgaWYgKGluZm9bJ2Jyb2FkY2FzdF9zZW5kZXInXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ2Jyb2FkY2FzdF9zZW5kZXInXSA9IHRydWU7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJvb20gPSBnZW5lcmF0ZVNvY2tldENsaWVudChpbmZvLm5hbWVzcGFjZSwgaW5mby5yb29tKTtcbiAgICB0aGlzLnNvY2tldC5zZW5kKCd1cGRhdGVEb2N1bWVudCcsIHJlcXVlc3RfZGF0YSwgcm9vbSk7XG4gIH0sXG4gIFxuICBcbiAgLypcbiAgQ29DcmVhdGUuY3J1ZC5yZWFkRG9jdW1lbnQoe1xuICAgIGNvbGxlY3Rpb246IFwidGVzdDEyM1wiLFxuICAgIGRvY3VtZW50X2lkOiBcImRvY3VtZW50X2lkXCIsXG4gICAgZWxlbWVudDog4oCceHh4eOKAnSxcbiAgICBtZXRhRGF0YTogXCJ4eHh4XCIsXG4gICAgZXhjbHVkZV9maWVsZHM6IFtdIFxuICB9KSxcbiAgKi9cbiAgcmVhZERvY3VtZW50OiBmdW5jdGlvbihpbmZvKSB7XG4gICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpbmZvWydkb2N1bWVudF9pZCddIHx8ICFpbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGxldCByZXF1ZXN0X2RhdGEgPSBnZXRDb21tb25QYXJhbXMoKTtcbiAgICByZXF1ZXN0X2RhdGFbJ2NvbGxlY3Rpb24nXSA9IGluZm9bJ2NvbGxlY3Rpb24nXTtcbiAgICByZXF1ZXN0X2RhdGFbJ2RvY3VtZW50X2lkJ10gPSBpbmZvWydkb2N1bWVudF9pZCddO1xuICAgIGlmIChpbmZvWydleGNsdWRlX2ZpZWxkcyddKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ2V4Y2x1ZGVfZmllbGRzJ10gPSBpbmZvWydleGNsdWRlX2ZpZWxkcyddO1xuICAgIH1cbiAgICBcbiAgICBpZiAoaW5mb1snZWxlbWVudCddKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ2VsZW1lbnQnXSA9IGluZm9bJ2VsZW1lbnQnXTtcbiAgICB9XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydtZXRhZGF0YSddID0gaW5mb1snbWV0YWRhdGEnXVxuICAgIHRoaXMuc29ja2V0LnNlbmQoJ3JlYWREb2N1bWVudCcsIHJlcXVlc3RfZGF0YSk7XG4gIH0sXG4gIFxuICBcbiAgLypcbiAgQ29DcmVhdGUuY3J1ZC5kZWxldGVEb2N1bWVudCh7XG4gICAgbmFtZXNwYWNlOiAnJyxcbiAgICByb29tOiAnJyxcbiAgICBicm9hZGNhc3Q6IHRydWUvZmFsc2UsXG4gICAgYnJvYWRjYXN0X3NlbmRlcjogdHJ1ZS9mYWxzZSxcbiAgICBcbiAgICBjb2xsZWN0aW9uOiBcIm1vZHVsZVwiLFxuICAgIGRvY3VtZW50X2lkOiBcIlwiLFxuICAgIGVsZW1lbnQ6IOKAnHh4eHjigJ0sXG4gICAgbWV0YWRhdGE6IFwieHh4eFwiXG4gIH0pLFxuICAqL1xuICBkZWxldGVEb2N1bWVudDogZnVuY3Rpb24oaW5mbykge1xuICAgIGlmICghaW5mb1snZG9jdW1lbnRfaWQnXSB8fCAhaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBsZXQgcmVxdWVzdF9kYXRhID0gZ2V0Q29tbW9uUGFyYW1zKCk7XG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ107XG4gICAgcmVxdWVzdF9kYXRhWydkb2N1bWVudF9pZCddID0gaW5mb1snZG9jdW1lbnRfaWQnXTtcbiAgICBcbiAgICBpZiAoaW5mb1snZWxlbWVudCddKSB7XG4gICAgICByZXF1ZXN0X2RhdGFbJ2VsZW1lbnQnXSA9IGluZm9bJ2VsZW1lbnQnXTtcbiAgICB9XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhWydtZXRhZGF0YSddID0gaW5mb1snbWV0YWRhdGEnXVxuICAgIFxuICAgIC8qKiBzb2NrZXQgcGFyYW1ldGVycyAqKi9cbiAgICAvLyBpZiAoaW5mb1snYnJvYWRjYXN0J10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3QnXSA9IHRydWU7XG4gICAgLy8gfVxuICAgIC8vIGlmIChpbmZvWydicm9hZGNhc3Rfc2VuZGVyJ10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSB0cnVlO1xuICAgIC8vIH1cbiAgICBcbiAgICBjb25zdCByb29tID0gZ2VuZXJhdGVTb2NrZXRDbGllbnQoaW5mby5uYW1lc3BhY2UsIGluZm8ucm9vbSk7XG4gICAgdGhpcy5zb2NrZXQuc2VuZCgnZGVsZXRlRG9jdW1lbnQnLCByZXF1ZXN0X2RhdGEsIHJvb20pO1xuICB9LFxuXG5cbiAvKiogZXhwb3J0IC8gaW1wb3J0IGRiIGZ1bmN0aW9ucyAqKi9cbiBcbiAgIC8qXG4gIHJlYWREb2N1bWVudCh7XG4gICAgY29sbGVjdGlvbjogXCJ0ZXN0MTIzXCIsXG4gICAgZWxlbWVudDog4oCceHh4eOKAnSxcbiAgICBtZXRhRGF0YTogXCJ4eHh4XCIsXG4gIH0pLFxuICAqL1xuICBleHBvcnRDb2xsZWN0aW9uOiBmdW5jdGlvbihpbmZvKSB7XG4gICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVxdWVzdF9kYXRhID0gZ2V0Q29tbW9uUGFyYW1zKCk7XG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ107XG4gICAgcmVxdWVzdF9kYXRhWydleHBvcnRfdHlwZSddID0gaW5mb1snZXhwb3J0X3R5cGUnXTtcblxuICAgIHJlcXVlc3RfZGF0YVsnbWV0YWRhdGEnXSA9IGluZm9bJ21ldGFkYXRhJ11cbiAgICB0aGlzLnNvY2tldC5zZW5kKCdleHBvcnREQicsIHJlcXVlc3RfZGF0YSk7XG4gIH0sXG4gIFxuICAvKlxuICByZWFkRG9jdW1lbnQoe1xuICAgIGNvbGxlY3Rpb246IFwidGVzdDEyM1wiLFxuICAgIGZpbGU6IGZpbGVcbiAgfSksXG4gICovXG4gIGltcG9ydENvbGxlY3Rpb246IGZ1bmN0aW9uKGluZm8pIHtcbiAgICBjb25zdCB7ZmlsZX0gPSBpbmZvO1xuICAgIGlmIChpbmZvID09PSBudWxsIHx8ICEoZmlsZSBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZS5uYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICBcbiAgICBpZiAoIVsnanNvbicsJ2NzdiddLnNvbWUoKGl0ZW0pID0+IGl0ZW0gPT09IGV4dGVuc2lvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgbGV0IHJlcXVlc3RfZGF0YSA9IGdldENvbW1vblBhcmFtcygpXG4gICAgcmVxdWVzdF9kYXRhWydjb2xsZWN0aW9uJ10gPSBpbmZvWydjb2xsZWN0aW9uJ11cbiAgICByZXF1ZXN0X2RhdGFbJ2ltcG9ydF90eXBlJ10gPSBleHRlbnNpb247XG4gICAgdGhpcy5zb2NrZXQuc2VuZCgnaW1wb3J0REInLCByZXF1ZXN0X2RhdGEpXG4gICAgdGhpcy5zb2NrZXQuc2VuZEZpbGUoZmlsZSk7XG4gIH0sXG4gIFxuICBcbiAgLy8uIG1lc3NhZ2UgbGlzdGVuZXJcbiAgbGlzdGVuTWVzc2FnZTogZnVuY3Rpb24obWVzc2FnZSwgZnVuKSB7XG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKG1lc3NhZ2UsIGZ1bik7XG4gIH0sXG4gIFxuICBsaXN0ZW5lclJlYWREb2N1bWVudDogZnVuY3Rpb24oZnVuKSB7XG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKFwicmVhZERvY3VtZW50XCIsIGZ1bik7XG4gIH0sXG4gIGxpc3RlbmVyQ3JlYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihcImNyZWF0ZURvY3VtZW50XCIsIGZ1bik7XG4gIH0sXG4gIGxpc3RlbmVyRGVsZXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihcImRlbGV0ZURvY3VtZW50XCIsIGZ1bik7XG4gIH0sXG4gIGxpc3RlbmVyVXBkYXRlRG9jdW1lbnQ6IGZ1bmN0aW9uKGZ1bikge1xuICAgIHRoaXMuc29ja2V0Lmxpc3RlbihcInVwZGF0ZURvY3VtZW50XCIsIGZ1bik7XG4gIH0sXG4gIGxpc3RlbmVyUmVhZERvY3VtZW50TGlzdDogZnVuY3Rpb24oZnVuKSB7XG4gICAgdGhpcy5zb2NrZXQubGlzdGVuKFwicmVhZERvY3VtZW50TGlzdFwiLCBmdW4pO1xuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUlVEKHNvY2tldCkge1xuICBDb0NyZWF0ZUNSVUQuc2V0U29ja2V0KHNvY2tldCk7XG4gIHJldHVybiBDb0NyZWF0ZUNSVUQ7XG59XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/crud.js\n")},"../../CoCreateJS/src/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.addComponent = addComponent;\nexports.removeComponent = removeComponent;\nexports.utils = exports.message = exports.crud = exports.socketApi = exports.socket = exports.core = void 0;\n\nvar _socket = _interopRequireDefault(__webpack_require__(/*! ./socket.js */ "../../CoCreateJS/src/socket.js"));\n\nvar _crud = _interopRequireDefault(__webpack_require__(/*! ./crud.js */ "../../CoCreateJS/src/crud.js"));\n\nvar _core = _interopRequireDefault(__webpack_require__(/*! ./core.js */ "../../CoCreateJS/src/core.js"));\n\nvar utils = _interopRequireWildcard(__webpack_require__(/*! ./utils.js */ "../../CoCreateJS/src/utils.js"));\n\nexports.utils = utils;\n\nvar _message = _interopRequireDefault(__webpack_require__(/*! ./message.js */ "../../CoCreateJS/src/message.js"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// import CRDT from "./crdt.js"\nlet socket = new _socket.default(\'ws\');\nexports.socket = socket;\nlet socketApi = new _socket.default(\'api\');\nexports.socketApi = socketApi;\nlet core = (0, _core.default)(socket);\nexports.core = core;\nlet crud = (0, _crud.default)(socket);\nexports.crud = crud;\nlet message = (0, _message.default)(socket);\nexports.message = message;\ncore.init(window.config.host ? window.config.host : \'server.cocreate.app\');\n\nfunction addComponent(key, component) {\n  this[key] = component;\n}\n\nfunction removeComponent(key) {\n  if (this[key]) {}\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvaW5kZXguanM/Mjg5YSJdLCJuYW1lcyI6WyJzb2NrZXQiLCJDb0NyZWF0ZVNvY2tldCIsInNvY2tldEFwaSIsImNvcmUiLCJjcnVkIiwibWVzc2FnZSIsImluaXQiLCJ3aW5kb3ciLCJjb25maWciLCJob3N0IiwiYWRkQ29tcG9uZW50Iiwia2V5IiwiY29tcG9uZW50IiwicmVtb3ZlQ29tcG9uZW50Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQUNBOzs7Ozs7OztBQUVBO0FBQ0EsSUFBSUEsTUFBTSxHQUFHLElBQUlDLGVBQUosQ0FBbUIsSUFBbkIsQ0FBYjs7QUFDQSxJQUFJQyxTQUFTLEdBQUcsSUFBSUQsZUFBSixDQUFtQixLQUFuQixDQUFoQjs7QUFFQSxJQUFJRSxJQUFJLEdBQUcsbUJBQUtILE1BQUwsQ0FBWDs7QUFDQSxJQUFJSSxJQUFJLEdBQUcsbUJBQUtKLE1BQUwsQ0FBWDs7QUFDQSxJQUFJSyxPQUFPLEdBQUcsc0JBQVFMLE1BQVIsQ0FBZDs7QUFFQUcsSUFBSSxDQUFDRyxJQUFMLENBQVVDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjQyxJQUFkLEdBQXFCRixNQUFNLENBQUNDLE1BQVAsQ0FBY0MsSUFBbkMsR0FBMEMscUJBQXBEOztBQUVBLFNBQVNDLFlBQVQsQ0FBc0JDLEdBQXRCLEVBQTJCQyxTQUEzQixFQUFzQztBQUNsQyxPQUFLRCxHQUFMLElBQVlDLFNBQVo7QUFDSDs7QUFFRCxTQUFTQyxlQUFULENBQXlCRixHQUF6QixFQUE4QjtBQUMxQixNQUFJLEtBQUtBLEdBQUwsQ0FBSixFQUFlLENBRWQ7QUFDSiIsImZpbGUiOiIuLi8uLi9Db0NyZWF0ZUpTL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb0NyZWF0ZVNvY2tldCBmcm9tIFwiLi9zb2NrZXQuanNcIlxuaW1wb3J0IENSVUQgZnJvbSBcIi4vY3J1ZC5qc1wiXG5pbXBvcnQgQ29yZSBmcm9tIFwiLi9jb3JlLmpzXCJcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuL3V0aWxzLmpzXCJcbmltcG9ydCBNZXNzYWdlIGZyb20gXCIuL21lc3NhZ2UuanNcIlxuXG4vLyBpbXBvcnQgQ1JEVCBmcm9tIFwiLi9jcmR0LmpzXCJcbmxldCBzb2NrZXQgPSBuZXcgQ29DcmVhdGVTb2NrZXQoJ3dzJyk7XG5sZXQgc29ja2V0QXBpID0gbmV3IENvQ3JlYXRlU29ja2V0KCdhcGknKTtcblxubGV0IGNvcmUgPSBDb3JlKHNvY2tldClcbmxldCBjcnVkID0gQ1JVRChzb2NrZXQpXG5sZXQgbWVzc2FnZSA9IE1lc3NhZ2Uoc29ja2V0KVxuXG5jb3JlLmluaXQod2luZG93LmNvbmZpZy5ob3N0ID8gd2luZG93LmNvbmZpZy5ob3N0IDogJ3NlcnZlci5jb2NyZWF0ZS5hcHAnKTtcblxuZnVuY3Rpb24gYWRkQ29tcG9uZW50KGtleSwgY29tcG9uZW50KSB7XG4gICAgdGhpc1trZXldID0gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDb21wb25lbnQoa2V5KSB7XG4gICAgaWYgKHRoaXNba2V5XSkge1xuXG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIGNvcmUsXG4gICAgc29ja2V0LFxuICAgIHNvY2tldEFwaSxcbiAgICBjcnVkLFxuICAgIHV0aWxzLFxuICAgIG1lc3NhZ2UsXG4gICAgYWRkQ29tcG9uZW50LFxuICAgIHJlbW92ZUNvbXBvbmVudFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/index.js\n')},"../../CoCreateJS/src/message.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = Message;\n\nvar _commonFun = __webpack_require__(/*! ./common-fun.js */ \"../../CoCreateJS/src/common-fun.js\");\n\nconst CoCreateMessage = {\n  socket: null,\n  setSocket: function (socket) {\n    this.socket = socket;\n  },\n\n  /*\n  CoCreate.message.send({\n     namespace: '',\n     room: '',\n     broadcast: true/false,\n     broadcast_sender: true/false\n     \n     rooms: [r1, r2],\n     emit: {\n       message': 'nice game',\n       data': 'let's play a game ....'\n     }\n   })\n  */\n  send: function (data) {\n    let request_data = (0, _commonFun.getCommonParams)();\n\n    if (!data || !data.emit) {\n      return;\n    }\n\n    request_data = { ...request_data,\n      ...data\n    };\n    /** socket parameters **/\n    // if (data['broadcast'] === undefined) {\n    //   request_data['broadcast'] = true;\n    // }\n    // if (data['broadcast_sender'] === undefined) {\n    //   request_data['broadcast_sender'] = true;\n    // }\n\n    const room = (0, _commonFun.generateSocketClient)(data.namespace, data.room);\n    this.socket.send('sendMessage', request_data, room);\n  },\n  receive: function (message, fun) {\n    this.socket.listen(message, fun);\n  }\n};\n\nfunction Message(socket) {\n  CoCreateMessage.setSocket(socket);\n  return CoCreateMessage;\n}\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvbWVzc2FnZS5qcz83ODQyIl0sIm5hbWVzIjpbIkNvQ3JlYXRlTWVzc2FnZSIsInNvY2tldCIsInNldFNvY2tldCIsInNlbmQiLCJkYXRhIiwicmVxdWVzdF9kYXRhIiwiZW1pdCIsInJvb20iLCJuYW1lc3BhY2UiLCJyZWNlaXZlIiwibWVzc2FnZSIsImZ1biIsImxpc3RlbiIsIk1lc3NhZ2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFFQSxNQUFNQSxlQUFlLEdBQUc7QUFDdEJDLFFBQU0sRUFBRSxJQURjO0FBRXRCQyxXQUFTLEVBQUUsVUFBU0QsTUFBVCxFQUFpQjtBQUMxQixTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDRCxHQUpxQjs7QUFLdkI7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNDRSxNQUFJLEVBQUUsVUFBU0MsSUFBVCxFQUFlO0FBQ2xCLFFBQUlDLFlBQVksR0FBRyxpQ0FBbkI7O0FBRUEsUUFBSSxDQUFDRCxJQUFELElBQVMsQ0FBQ0EsSUFBSSxDQUFDRSxJQUFuQixFQUF5QjtBQUN2QjtBQUNEOztBQUNERCxnQkFBWSxHQUFHLEVBQUMsR0FBR0EsWUFBSjtBQUFrQixTQUFHRDtBQUFyQixLQUFmO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTUcsSUFBSSxHQUFHLHFDQUFxQkgsSUFBSSxDQUFDSSxTQUExQixFQUFxQ0osSUFBSSxDQUFDRyxJQUExQyxDQUFiO0FBRUEsU0FBS04sTUFBTCxDQUFZRSxJQUFaLENBQWlCLGFBQWpCLEVBQWdDRSxZQUFoQyxFQUE4Q0UsSUFBOUM7QUFDRixHQXJDc0I7QUF1Q3ZCRSxTQUFPLEVBQUUsVUFBU0MsT0FBVCxFQUFrQkMsR0FBbEIsRUFBdUI7QUFDOUIsU0FBS1YsTUFBTCxDQUFZVyxNQUFaLENBQW1CRixPQUFuQixFQUE0QkMsR0FBNUI7QUFDRDtBQXpDc0IsQ0FBeEI7O0FBNENlLFNBQVNFLE9BQVQsQ0FBaUJaLE1BQWpCLEVBQXlCO0FBQ3RDRCxpQkFBZSxDQUFDRSxTQUFoQixDQUEwQkQsTUFBMUI7QUFDQSxTQUFPRCxlQUFQO0FBQ0Q7O0FBQUEiLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGVKUy9zcmMvbWVzc2FnZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Z2V0Q29tbW9uUGFyYW1zLCBnZXRDb21tb25QYXJhbXNFeHRlbmQsIGdlbmVyYXRlU29ja2V0Q2xpZW50fSBmcm9tIFwiLi9jb21tb24tZnVuLmpzXCJcblxuY29uc3QgQ29DcmVhdGVNZXNzYWdlID0ge1xuICBzb2NrZXQ6IG51bGwsXG4gIHNldFNvY2tldDogZnVuY3Rpb24oc29ja2V0KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gIH0sXG4gLypcbiBDb0NyZWF0ZS5tZXNzYWdlLnNlbmQoe1xuICAgIG5hbWVzcGFjZTogJycsXG4gICAgcm9vbTogJycsXG4gICAgYnJvYWRjYXN0OiB0cnVlL2ZhbHNlLFxuICAgIGJyb2FkY2FzdF9zZW5kZXI6IHRydWUvZmFsc2VcbiAgICBcbiAgICByb29tczogW3IxLCByMl0sXG4gICAgZW1pdDoge1xuICAgICAgbWVzc2FnZSc6ICduaWNlIGdhbWUnLFxuICAgICAgZGF0YSc6ICdsZXQncyBwbGF5IGEgZ2FtZSAuLi4uJ1xuICAgIH1cbiAgfSlcbiAqL1xuIHNlbmQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBsZXQgcmVxdWVzdF9kYXRhID0gZ2V0Q29tbW9uUGFyYW1zKCk7XG4gICAgXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmVtaXQpIHtcbiAgICAgIHJldHVybjsgICAgIFxuICAgIH1cbiAgICByZXF1ZXN0X2RhdGEgPSB7Li4ucmVxdWVzdF9kYXRhLCAuLi5kYXRhfVxuICAgIFxuICAgIC8qKiBzb2NrZXQgcGFyYW1ldGVycyAqKi9cbiAgICAvLyBpZiAoZGF0YVsnYnJvYWRjYXN0J10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3QnXSA9IHRydWU7XG4gICAgLy8gfVxuICAgIC8vIGlmIChkYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgcmVxdWVzdF9kYXRhWydicm9hZGNhc3Rfc2VuZGVyJ10gPSB0cnVlO1xuICAgIC8vIH1cbiAgICBjb25zdCByb29tID0gZ2VuZXJhdGVTb2NrZXRDbGllbnQoZGF0YS5uYW1lc3BhY2UsIGRhdGEucm9vbSk7XG4gICAgXG4gICAgdGhpcy5zb2NrZXQuc2VuZCgnc2VuZE1lc3NhZ2UnLCByZXF1ZXN0X2RhdGEsIHJvb20pXG4gfSxcbiBcbiByZWNlaXZlOiBmdW5jdGlvbihtZXNzYWdlLCBmdW4pIHtcbiAgIHRoaXMuc29ja2V0Lmxpc3RlbihtZXNzYWdlLCBmdW4pO1xuIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lc3NhZ2Uoc29ja2V0KSB7XG4gIENvQ3JlYXRlTWVzc2FnZS5zZXRTb2NrZXQoc29ja2V0KVxuICByZXR1cm4gQ29DcmVhdGVNZXNzYWdlO1xufTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/message.js\n")},"../../CoCreateJS/src/socket.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nclass CoCreateSocket {\n  constructor(prefix = \"crud\") {\n    this.prefix = prefix || \"crud\";\n    this.sockets = new Map();\n    this.listeners = new Map();\n    this.messageQueue = new Map();\n    this.saveFileName = '';\n    this.globalScope = \"\";\n  }\n\n  setGlobalScope(scope) {\n    this.globalScope = `${this.prefix}/${scope}`;\n  }\n\n  getGlobalScope() {\n    return this.globalScope;\n  }\n  /**\n   * config: {namespace, room, host}\n   */\n\n\n  create(config) {\n    const {\n      namespace,\n      room\n    } = config;\n    const key = this.getKey(namespace, room);\n\n    let _this = this;\n\n    let socket;\n\n    if (this.sockets.get(key)) {\n      socket = this.sockets.get(key);\n      console.log('SOcket already has been register');\n      return;\n    }\n\n    let w_protocol = window.location.protocol;\n\n    if (window.location.protocol === \"about:\") {\n      w_protocol = window.parent.location.protocol;\n    }\n\n    let protocol = w_protocol === 'http:' ? 'ws' : 'wss';\n    const port = config.port ? config.port : 8088;\n    let socket_url = `${protocol}://${window.location.host}:${port}/${key}`;\n\n    if (config.host) {\n      if (config.host.includes(\"://\")) {\n        socket_url = `${config.host}/${key}`;\n      } else {\n        socket_url = `${protocol}://${config.host}:${port}/${key}`;\n      }\n    }\n\n    socket = new WebSocket(socket_url);\n\n    socket.onopen = function (event) {\n      console.log('created socket: ' + key);\n      const messages = _this.messageQueue.get(key) || [];\n      console.log(messages);\n      messages.forEach(msg => socket.send(JSON.stringify(msg)));\n\n      _this.sockets.set(key, socket);\n\n      _this.messageQueue.set(key, []);\n    };\n\n    socket.onclose = function (event) {\n      switch (event.code) {\n        case 1000:\n          // close normal\n          console.log(\"websocket: closed\");\n          break;\n\n        default:\n          _this.destroy(socket, key);\n\n          _this.reconnect(socket, config);\n\n          break;\n      }\n    };\n\n    socket.onerror = function (err) {\n      console.log('Socket error');\n\n      _this.destroy(socket, key);\n\n      _this.reconnect(socket, config);\n    };\n\n    socket.onmessage = function (data) {\n      try {\n        if (data.data instanceof Blob) {\n          _this.saveFile(data.data);\n\n          return;\n        }\n\n        let rev_data = JSON.parse(data.data);\n        let action = rev_data.action; // if (['readDocument', 'createDocument', 'updateDocument'].includes(action)) {\n        // \trev_data.data.data = utilsCrud.encodeObject(rev_data.data.data);\n        // }\n\n        const listeners = _this.listeners.get(rev_data.action);\n\n        if (!listeners) {\n          return;\n        }\n\n        listeners.forEach(listener => {\n          listener(rev_data.data, key);\n        });\n      } catch (e) {\n        console.log(e);\n      }\n    };\n  }\n  /**\n   * \n   */\n\n\n  send(action, data, room) {\n    const obj = {\n      action: action,\n      data: data\n    };\n    const key = this.getKeyByRoom(room);\n    const socket = this.getByRoom(room);\n\n    if (socket) {\n      socket.send(JSON.stringify(obj));\n    } else {\n      if (this.messageQueue.get(key)) {\n        this.messageQueue.get(key).push(obj);\n      } else {\n        this.messageQueue.set(key, [obj]);\n      }\n    }\n  }\n\n  sendFile(file, room) {\n    const socket = this.getByRoom(room);\n\n    if (socket) {\n      socket.send(file);\n    }\n  }\n  /**\n   * scope: ns/room\n   */\n\n\n  listen(type, callback) {\n    if (!this.listeners.get(type)) {\n      this.listeners.set(type, [callback]);\n    } else {\n      this.listeners.get(type).push(callback);\n    }\n  }\n\n  reconnect(socket, config) {\n    let _this = this;\n\n    setTimeout(function () {\n      _this.create(config);\n    }, 1000);\n  }\n\n  destroy(socket, key) {\n    if (socket) {\n      socket.onerror = socket.onopen = socket.onclose = null;\n      socket.close();\n      socket = null;\n    }\n\n    if (this.sockets.get(key)) {\n      this.sockets.delete(key);\n    }\n  }\n\n  getKey(namespace, room) {\n    let key = `${this.prefix}`;\n\n    if (namespace && namespace != '') {\n      if (room && room != '') {\n        key += `/${namespace}/${room}`;\n      } else {\n        key += `/${namespace}`;\n      }\n    }\n\n    return key;\n  }\n\n  getByRoom(room) {\n    let key = this.getKeyByRoom(room);\n    return this.sockets.get(key);\n  }\n\n  getKeyByRoom(room) {\n    let key = this.globalScope;\n\n    if (room) {\n      key = `${this.prefix}/${room}`;\n    }\n\n    return key;\n  }\n\n  saveFile(blob) {\n    // const {filename} = window.saveFileInfo;\n    const file_name = this.saveFileName || 'downloadFile';\n    var a = document.createElement(\"a\");\n    document.body.appendChild(a);\n    a.style = \"display: none\";\n    let url = window.URL.createObjectURL(blob);\n    a.href = url;\n    a.download = file_name;\n    a.click();\n    window.URL.revokeObjectURL(url);\n    this.saveFileName = '';\n  }\n\n}\n\nvar _default = CoCreateSocket;\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvc29ja2V0LmpzPzE3YmQiXSwibmFtZXMiOlsiQ29DcmVhdGVTb2NrZXQiLCJjb25zdHJ1Y3RvciIsInByZWZpeCIsInNvY2tldHMiLCJNYXAiLCJsaXN0ZW5lcnMiLCJtZXNzYWdlUXVldWUiLCJzYXZlRmlsZU5hbWUiLCJnbG9iYWxTY29wZSIsInNldEdsb2JhbFNjb3BlIiwic2NvcGUiLCJnZXRHbG9iYWxTY29wZSIsImNyZWF0ZSIsImNvbmZpZyIsIm5hbWVzcGFjZSIsInJvb20iLCJrZXkiLCJnZXRLZXkiLCJfdGhpcyIsInNvY2tldCIsImdldCIsImNvbnNvbGUiLCJsb2ciLCJ3X3Byb3RvY29sIiwid2luZG93IiwibG9jYXRpb24iLCJwcm90b2NvbCIsInBhcmVudCIsInBvcnQiLCJzb2NrZXRfdXJsIiwiaG9zdCIsImluY2x1ZGVzIiwiV2ViU29ja2V0Iiwib25vcGVuIiwiZXZlbnQiLCJtZXNzYWdlcyIsImZvckVhY2giLCJtc2ciLCJzZW5kIiwiSlNPTiIsInN0cmluZ2lmeSIsInNldCIsIm9uY2xvc2UiLCJjb2RlIiwiZGVzdHJveSIsInJlY29ubmVjdCIsIm9uZXJyb3IiLCJlcnIiLCJvbm1lc3NhZ2UiLCJkYXRhIiwiQmxvYiIsInNhdmVGaWxlIiwicmV2X2RhdGEiLCJwYXJzZSIsImFjdGlvbiIsImxpc3RlbmVyIiwiZSIsIm9iaiIsImdldEtleUJ5Um9vbSIsImdldEJ5Um9vbSIsInB1c2giLCJzZW5kRmlsZSIsImZpbGUiLCJsaXN0ZW4iLCJ0eXBlIiwiY2FsbGJhY2siLCJzZXRUaW1lb3V0IiwiY2xvc2UiLCJkZWxldGUiLCJibG9iIiwiZmlsZV9uYW1lIiwiYSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwiaHJlZiIsImRvd25sb2FkIiwiY2xpY2siLCJyZXZva2VPYmplY3RVUkwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxNQUFNQSxjQUFOLENBQ0E7QUFDQ0MsYUFBVyxDQUFDQyxNQUFNLEdBQUcsTUFBVixFQUFrQjtBQUM1QixTQUFLQSxNQUFMLEdBQWNBLE1BQU0sSUFBSSxNQUF4QjtBQUNBLFNBQUtDLE9BQUwsR0FBZSxJQUFJQyxHQUFKLEVBQWY7QUFDQSxTQUFLQyxTQUFMLEdBQWlCLElBQUlELEdBQUosRUFBakI7QUFDQSxTQUFLRSxZQUFMLEdBQXFCLElBQUlGLEdBQUosRUFBckI7QUFDQSxTQUFLRyxZQUFMLEdBQXFCLEVBQXJCO0FBQ0EsU0FBS0MsV0FBTCxHQUFvQixFQUFwQjtBQUNBOztBQUVEQyxnQkFBYyxDQUFDQyxLQUFELEVBQVE7QUFDckIsU0FBS0YsV0FBTCxHQUFvQixHQUFFLEtBQUtOLE1BQU8sSUFBR1EsS0FBTSxFQUEzQztBQUNBOztBQUVEQyxnQkFBYyxHQUFHO0FBQ2hCLFdBQU8sS0FBS0gsV0FBWjtBQUNBO0FBRUQ7QUFDRDtBQUNBOzs7QUFDQ0ksUUFBTSxDQUFFQyxNQUFGLEVBQVU7QUFDZixVQUFNO0FBQUNDLGVBQUQ7QUFBWUM7QUFBWixRQUFvQkYsTUFBMUI7QUFDQSxVQUFNRyxHQUFHLEdBQUcsS0FBS0MsTUFBTCxDQUFZSCxTQUFaLEVBQXVCQyxJQUF2QixDQUFaOztBQUNBLFFBQUlHLEtBQUssR0FBRyxJQUFaOztBQUNBLFFBQUlDLE1BQUo7O0FBQ0EsUUFBSSxLQUFLaEIsT0FBTCxDQUFhaUIsR0FBYixDQUFpQkosR0FBakIsQ0FBSixFQUEyQjtBQUMxQkcsWUFBTSxHQUFHLEtBQUtoQixPQUFMLENBQWFpQixHQUFiLENBQWlCSixHQUFqQixDQUFUO0FBQ0FLLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLGtDQUFaO0FBQ0E7QUFDQTs7QUFFRCxRQUFJQyxVQUFVLEdBQUdDLE1BQU0sQ0FBQ0MsUUFBUCxDQUFnQkMsUUFBakM7O0FBQ0EsUUFBSUYsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxRQUFoQixLQUE2QixRQUFqQyxFQUEyQztBQUMxQ0gsZ0JBQVUsR0FBR0MsTUFBTSxDQUFDRyxNQUFQLENBQWNGLFFBQWQsQ0FBdUJDLFFBQXBDO0FBQ0E7O0FBQ0QsUUFBSUEsUUFBUSxHQUFHSCxVQUFVLEtBQUssT0FBZixHQUF5QixJQUF6QixHQUFnQyxLQUEvQztBQUVBLFVBQU1LLElBQUksR0FBR2YsTUFBTSxDQUFDZSxJQUFQLEdBQWNmLE1BQU0sQ0FBQ2UsSUFBckIsR0FBNEIsSUFBekM7QUFFQSxRQUFJQyxVQUFVLEdBQUksR0FBRUgsUUFBUyxNQUFLRixNQUFNLENBQUNDLFFBQVAsQ0FBZ0JLLElBQUssSUFBR0YsSUFBSyxJQUFHWixHQUFJLEVBQXRFOztBQUVBLFFBQUlILE1BQU0sQ0FBQ2lCLElBQVgsRUFBaUI7QUFDaEIsVUFBSWpCLE1BQU0sQ0FBQ2lCLElBQVAsQ0FBWUMsUUFBWixDQUFxQixLQUFyQixDQUFKLEVBQWlDO0FBQ2hDRixrQkFBVSxHQUFJLEdBQUVoQixNQUFNLENBQUNpQixJQUFLLElBQUdkLEdBQUksRUFBbkM7QUFDQSxPQUZELE1BRU87QUFDTmEsa0JBQVUsR0FBSSxHQUFFSCxRQUFTLE1BQUtiLE1BQU0sQ0FBQ2lCLElBQUssSUFBR0YsSUFBSyxJQUFHWixHQUFJLEVBQXpEO0FBQ0E7QUFDRDs7QUFFREcsVUFBTSxHQUFHLElBQUlhLFNBQUosQ0FBY0gsVUFBZCxDQUFUOztBQUVBVixVQUFNLENBQUNjLE1BQVAsR0FBZ0IsVUFBU0MsS0FBVCxFQUFnQjtBQUMvQmIsYUFBTyxDQUFDQyxHQUFSLENBQVkscUJBQXFCTixHQUFqQztBQUNBLFlBQU1tQixRQUFRLEdBQUdqQixLQUFLLENBQUNaLFlBQU4sQ0FBbUJjLEdBQW5CLENBQXVCSixHQUF2QixLQUErQixFQUFoRDtBQUNBSyxhQUFPLENBQUNDLEdBQVIsQ0FBWWEsUUFBWjtBQUNBQSxjQUFRLENBQUNDLE9BQVQsQ0FBaUJDLEdBQUcsSUFBSWxCLE1BQU0sQ0FBQ21CLElBQVAsQ0FBWUMsSUFBSSxDQUFDQyxTQUFMLENBQWVILEdBQWYsQ0FBWixDQUF4Qjs7QUFFQW5CLFdBQUssQ0FBQ2YsT0FBTixDQUFjc0MsR0FBZCxDQUFrQnpCLEdBQWxCLEVBQXVCRyxNQUF2Qjs7QUFDQUQsV0FBSyxDQUFDWixZQUFOLENBQW1CbUMsR0FBbkIsQ0FBdUJ6QixHQUF2QixFQUE0QixFQUE1QjtBQUNBLEtBUkQ7O0FBVUFHLFVBQU0sQ0FBQ3VCLE9BQVAsR0FBaUIsVUFBU1IsS0FBVCxFQUFnQjtBQUNoQyxjQUFPQSxLQUFLLENBQUNTLElBQWI7QUFDQyxhQUFLLElBQUw7QUFBVztBQUNWdEIsaUJBQU8sQ0FBQ0MsR0FBUixDQUFZLG1CQUFaO0FBQ0E7O0FBQ0Q7QUFDQ0osZUFBSyxDQUFDMEIsT0FBTixDQUFjekIsTUFBZCxFQUFzQkgsR0FBdEI7O0FBQ0FFLGVBQUssQ0FBQzJCLFNBQU4sQ0FBZ0IxQixNQUFoQixFQUF3Qk4sTUFBeEI7O0FBQ0E7QUFQRjtBQVNBLEtBVkQ7O0FBWUFNLFVBQU0sQ0FBQzJCLE9BQVAsR0FBaUIsVUFBU0MsR0FBVCxFQUFjO0FBQzlCMUIsYUFBTyxDQUFDQyxHQUFSLENBQVksY0FBWjs7QUFDQUosV0FBSyxDQUFDMEIsT0FBTixDQUFjekIsTUFBZCxFQUFzQkgsR0FBdEI7O0FBQ0FFLFdBQUssQ0FBQzJCLFNBQU4sQ0FBZ0IxQixNQUFoQixFQUF3Qk4sTUFBeEI7QUFDQSxLQUpEOztBQU1BTSxVQUFNLENBQUM2QixTQUFQLEdBQW1CLFVBQVNDLElBQVQsRUFBZTtBQUVqQyxVQUFJO0FBQ0gsWUFBSUEsSUFBSSxDQUFDQSxJQUFMLFlBQXFCQyxJQUF6QixFQUErQjtBQUM5QmhDLGVBQUssQ0FBQ2lDLFFBQU4sQ0FBZUYsSUFBSSxDQUFDQSxJQUFwQjs7QUFDQTtBQUNBOztBQUNELFlBQUlHLFFBQVEsR0FBR2IsSUFBSSxDQUFDYyxLQUFMLENBQVdKLElBQUksQ0FBQ0EsSUFBaEIsQ0FBZjtBQUNBLFlBQUlLLE1BQU0sR0FBR0YsUUFBUSxDQUFDRSxNQUF0QixDQU5HLENBUUg7QUFDQTtBQUNBOztBQUdBLGNBQU1qRCxTQUFTLEdBQUdhLEtBQUssQ0FBQ2IsU0FBTixDQUFnQmUsR0FBaEIsQ0FBb0JnQyxRQUFRLENBQUNFLE1BQTdCLENBQWxCOztBQUNBLFlBQUksQ0FBQ2pELFNBQUwsRUFBZ0I7QUFDZjtBQUNBOztBQUNEQSxpQkFBUyxDQUFDK0IsT0FBVixDQUFrQm1CLFFBQVEsSUFBSTtBQUM3QkEsa0JBQVEsQ0FBQ0gsUUFBUSxDQUFDSCxJQUFWLEVBQWdCakMsR0FBaEIsQ0FBUjtBQUNBLFNBRkQ7QUFHQSxPQXBCRCxDQW9CRSxPQUFPd0MsQ0FBUCxFQUFVO0FBQ1huQyxlQUFPLENBQUNDLEdBQVIsQ0FBWWtDLENBQVo7QUFDQTtBQUNELEtBekJEO0FBMEJBO0FBRUQ7QUFDRDtBQUNBOzs7QUFDQ2xCLE1BQUksQ0FBRWdCLE1BQUYsRUFBVUwsSUFBVixFQUFnQmxDLElBQWhCLEVBQXNCO0FBQ3pCLFVBQU0wQyxHQUFHLEdBQUc7QUFDWEgsWUFBTSxFQUFFQSxNQURHO0FBRVhMLFVBQUksRUFBRUE7QUFGSyxLQUFaO0FBSUEsVUFBTWpDLEdBQUcsR0FBRyxLQUFLMEMsWUFBTCxDQUFrQjNDLElBQWxCLENBQVo7QUFDQSxVQUFNSSxNQUFNLEdBQUcsS0FBS3dDLFNBQUwsQ0FBZTVDLElBQWYsQ0FBZjs7QUFFQSxRQUFJSSxNQUFKLEVBQVk7QUFDWEEsWUFBTSxDQUFDbUIsSUFBUCxDQUFZQyxJQUFJLENBQUNDLFNBQUwsQ0FBZWlCLEdBQWYsQ0FBWjtBQUNBLEtBRkQsTUFFTztBQUNOLFVBQUksS0FBS25ELFlBQUwsQ0FBa0JjLEdBQWxCLENBQXNCSixHQUF0QixDQUFKLEVBQWdDO0FBQy9CLGFBQUtWLFlBQUwsQ0FBa0JjLEdBQWxCLENBQXNCSixHQUF0QixFQUEyQjRDLElBQTNCLENBQWdDSCxHQUFoQztBQUNBLE9BRkQsTUFFTztBQUNOLGFBQUtuRCxZQUFMLENBQWtCbUMsR0FBbEIsQ0FBc0J6QixHQUF0QixFQUEyQixDQUFDeUMsR0FBRCxDQUEzQjtBQUNBO0FBQ0Q7QUFDRDs7QUFFREksVUFBUSxDQUFFQyxJQUFGLEVBQVEvQyxJQUFSLEVBQWM7QUFDckIsVUFBTUksTUFBTSxHQUFHLEtBQUt3QyxTQUFMLENBQWU1QyxJQUFmLENBQWY7O0FBQ0EsUUFBSUksTUFBSixFQUFZO0FBQ1hBLFlBQU0sQ0FBQ21CLElBQVAsQ0FBWXdCLElBQVo7QUFDQTtBQUNEO0FBRUQ7QUFDRDtBQUNBOzs7QUFDQ0MsUUFBTSxDQUFDQyxJQUFELEVBQU9DLFFBQVAsRUFBaUI7QUFDdEIsUUFBSSxDQUFDLEtBQUs1RCxTQUFMLENBQWVlLEdBQWYsQ0FBbUI0QyxJQUFuQixDQUFMLEVBQStCO0FBQzlCLFdBQUszRCxTQUFMLENBQWVvQyxHQUFmLENBQW1CdUIsSUFBbkIsRUFBeUIsQ0FBQ0MsUUFBRCxDQUF6QjtBQUNBLEtBRkQsTUFFTztBQUNOLFdBQUs1RCxTQUFMLENBQWVlLEdBQWYsQ0FBbUI0QyxJQUFuQixFQUF5QkosSUFBekIsQ0FBOEJLLFFBQTlCO0FBQ0E7QUFDRDs7QUFFRHBCLFdBQVMsQ0FBQzFCLE1BQUQsRUFBU04sTUFBVCxFQUFpQjtBQUN6QixRQUFJSyxLQUFLLEdBQUcsSUFBWjs7QUFDQWdELGNBQVUsQ0FBQyxZQUFXO0FBQ3JCaEQsV0FBSyxDQUFDTixNQUFOLENBQWFDLE1BQWI7QUFDQSxLQUZTLEVBRVAsSUFGTyxDQUFWO0FBR0E7O0FBRUQrQixTQUFPLENBQUN6QixNQUFELEVBQVNILEdBQVQsRUFBYztBQUNwQixRQUFJRyxNQUFKLEVBQVk7QUFDWEEsWUFBTSxDQUFDMkIsT0FBUCxHQUFpQjNCLE1BQU0sQ0FBQ2MsTUFBUCxHQUFnQmQsTUFBTSxDQUFDdUIsT0FBUCxHQUFpQixJQUFsRDtBQUNBdkIsWUFBTSxDQUFDZ0QsS0FBUDtBQUNBaEQsWUFBTSxHQUFHLElBQVQ7QUFDQTs7QUFFRCxRQUFJLEtBQUtoQixPQUFMLENBQWFpQixHQUFiLENBQWlCSixHQUFqQixDQUFKLEVBQTJCO0FBQzFCLFdBQUtiLE9BQUwsQ0FBYWlFLE1BQWIsQ0FBb0JwRCxHQUFwQjtBQUNBO0FBQ0Q7O0FBRURDLFFBQU0sQ0FBQ0gsU0FBRCxFQUFZQyxJQUFaLEVBQWtCO0FBQ3ZCLFFBQUlDLEdBQUcsR0FBSSxHQUFFLEtBQUtkLE1BQU8sRUFBekI7O0FBQ0EsUUFBSVksU0FBUyxJQUFJQSxTQUFTLElBQUksRUFBOUIsRUFBa0M7QUFDakMsVUFBSUMsSUFBSSxJQUFLQSxJQUFJLElBQUksRUFBckIsRUFBeUI7QUFDeEJDLFdBQUcsSUFBSyxJQUFHRixTQUFVLElBQUdDLElBQUssRUFBN0I7QUFDQSxPQUZELE1BRU87QUFDTkMsV0FBRyxJQUFJLElBQUdGLFNBQVUsRUFBcEI7QUFDQTtBQUNEOztBQUNELFdBQU9FLEdBQVA7QUFDQTs7QUFFRDJDLFdBQVMsQ0FBQzVDLElBQUQsRUFBTztBQUNmLFFBQUlDLEdBQUcsR0FBRyxLQUFLMEMsWUFBTCxDQUFrQjNDLElBQWxCLENBQVY7QUFDQSxXQUFPLEtBQUtaLE9BQUwsQ0FBYWlCLEdBQWIsQ0FBaUJKLEdBQWpCLENBQVA7QUFDQTs7QUFFRDBDLGNBQVksQ0FBQzNDLElBQUQsRUFBTztBQUNsQixRQUFJQyxHQUFHLEdBQUcsS0FBS1IsV0FBZjs7QUFDQSxRQUFJTyxJQUFKLEVBQVU7QUFDVEMsU0FBRyxHQUFJLEdBQUUsS0FBS2QsTUFBTyxJQUFHYSxJQUFLLEVBQTdCO0FBQ0E7O0FBQ0QsV0FBT0MsR0FBUDtBQUNBOztBQUdEbUMsVUFBUSxDQUFDa0IsSUFBRCxFQUFPO0FBQ2Q7QUFFQSxVQUFNQyxTQUFTLEdBQUcsS0FBSy9ELFlBQUwsSUFBcUIsY0FBdkM7QUFDQSxRQUFJZ0UsQ0FBQyxHQUFHQyxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsR0FBdkIsQ0FBUjtBQUNNRCxZQUFRLENBQUNFLElBQVQsQ0FBY0MsV0FBZCxDQUEwQkosQ0FBMUI7QUFDQUEsS0FBQyxDQUFDSyxLQUFGLEdBQVUsZUFBVjtBQUVBLFFBQUlDLEdBQUcsR0FBR3JELE1BQU0sQ0FBQ3NELEdBQVAsQ0FBV0MsZUFBWCxDQUEyQlYsSUFBM0IsQ0FBVjtBQUNBRSxLQUFDLENBQUNTLElBQUYsR0FBU0gsR0FBVDtBQUNBTixLQUFDLENBQUNVLFFBQUYsR0FBYVgsU0FBYjtBQUNBQyxLQUFDLENBQUNXLEtBQUY7QUFDQTFELFVBQU0sQ0FBQ3NELEdBQVAsQ0FBV0ssZUFBWCxDQUEyQk4sR0FBM0I7QUFFQSxTQUFLdEUsWUFBTCxHQUFvQixFQUFwQjtBQUNOOztBQWhORjs7ZUFtTmVQLGMiLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGVKUy9zcmMvc29ja2V0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgQ29DcmVhdGVTb2NrZXRcbntcblx0Y29uc3RydWN0b3IocHJlZml4ID0gXCJjcnVkXCIpIHtcblx0XHR0aGlzLnByZWZpeCA9IHByZWZpeCB8fCBcImNydWRcIjtcblx0XHR0aGlzLnNvY2tldHMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUgPSAgbmV3IE1hcCgpO1xuXHRcdHRoaXMuc2F2ZUZpbGVOYW1lID0gICcnO1xuXHRcdHRoaXMuZ2xvYmFsU2NvcGUgPSAgXCJcIjtcblx0fVxuXG5cdHNldEdsb2JhbFNjb3BlKHNjb3BlKSB7XG5cdFx0dGhpcy5nbG9iYWxTY29wZSA9IGAke3RoaXMucHJlZml4fS8ke3Njb3BlfWA7XG5cdH1cblx0XG5cdGdldEdsb2JhbFNjb3BlKCkge1xuXHRcdHJldHVybiB0aGlzLmdsb2JhbFNjb3BlO1xuXHR9XG5cdFxuXHQvKipcblx0ICogY29uZmlnOiB7bmFtZXNwYWNlLCByb29tLCBob3N0fVxuXHQgKi9cblx0Y3JlYXRlIChjb25maWcpIHtcblx0XHRjb25zdCB7bmFtZXNwYWNlLCByb29tfSA9IGNvbmZpZztcblx0XHRjb25zdCBrZXkgPSB0aGlzLmdldEtleShuYW1lc3BhY2UsIHJvb20pO1xuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0bGV0IHNvY2tldDtcblx0XHRpZiAodGhpcy5zb2NrZXRzLmdldChrZXkpKSB7XG5cdFx0XHRzb2NrZXQgPSB0aGlzLnNvY2tldHMuZ2V0KGtleSk7XG5cdFx0XHRjb25zb2xlLmxvZygnU09ja2V0IGFscmVhZHkgaGFzIGJlZW4gcmVnaXN0ZXInKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0XG5cdFx0bGV0IHdfcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XHRcdFxuXHRcdGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiYWJvdXQ6XCIpIHtcblx0XHRcdHdfcHJvdG9jb2wgPSB3aW5kb3cucGFyZW50LmxvY2F0aW9uLnByb3RvY29sO1xuXHRcdH1cblx0XHRsZXQgcHJvdG9jb2wgPSB3X3Byb3RvY29sID09PSAnaHR0cDonID8gJ3dzJyA6ICd3c3MnO1xuXHRcdFxuXHRcdGNvbnN0IHBvcnQgPSBjb25maWcucG9ydCA/IGNvbmZpZy5wb3J0IDogODA4ODtcblx0XHRcblx0XHRsZXQgc29ja2V0X3VybCA9IGAke3Byb3RvY29sfTovLyR7d2luZG93LmxvY2F0aW9uLmhvc3R9OiR7cG9ydH0vJHtrZXl9YDtcblx0XHRcblx0XHRpZiAoY29uZmlnLmhvc3QpIHtcblx0XHRcdGlmIChjb25maWcuaG9zdC5pbmNsdWRlcyhcIjovL1wiKSkge1xuXHRcdFx0XHRzb2NrZXRfdXJsID0gYCR7Y29uZmlnLmhvc3R9LyR7a2V5fWA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzb2NrZXRfdXJsID0gYCR7cHJvdG9jb2x9Oi8vJHtjb25maWcuaG9zdH06JHtwb3J0fS8ke2tleX1gO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRcblx0XHRzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHNvY2tldF91cmwpO1xuXHRcdFxuXHRcdHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Y29uc29sZS5sb2coJ2NyZWF0ZWQgc29ja2V0OiAnICsga2V5KTtcblx0XHRcdGNvbnN0IG1lc3NhZ2VzID0gX3RoaXMubWVzc2FnZVF1ZXVlLmdldChrZXkpIHx8IFtdO1xuXHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZXMpXG5cdFx0XHRtZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtc2cpKSk7XG5cdFx0XHRcblx0XHRcdF90aGlzLnNvY2tldHMuc2V0KGtleSwgc29ja2V0KTtcblx0XHRcdF90aGlzLm1lc3NhZ2VRdWV1ZS5zZXQoa2V5LCBbXSk7XG5cdFx0fVxuXHRcdFxuXHRcdHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHN3aXRjaChldmVudC5jb2RlKSB7XG5cdFx0XHRcdGNhc2UgMTAwMDogLy8gY2xvc2Ugbm9ybWFsXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJ3ZWJzb2NrZXQ6IGNsb3NlZFwiKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDogXG5cdFx0XHRcdFx0X3RoaXMuZGVzdHJveShzb2NrZXQsIGtleSk7XG5cdFx0XHRcdFx0X3RoaXMucmVjb25uZWN0KHNvY2tldCwgY29uZmlnKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0c29ja2V0Lm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdGNvbnNvbGUubG9nKCdTb2NrZXQgZXJyb3InKTtcblx0XHRcdF90aGlzLmRlc3Ryb3koc29ja2V0LCBrZXkpO1xuXHRcdFx0X3RoaXMucmVjb25uZWN0KHNvY2tldCwgY29uZmlnKTtcblx0XHR9XG5cblx0XHRzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoZGF0YS5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRcdF90aGlzLnNhdmVGaWxlKGRhdGEuZGF0YSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCByZXZfZGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKTtcblx0XHRcdFx0bGV0IGFjdGlvbiA9IHJldl9kYXRhLmFjdGlvbjtcblx0XHRcdFx0XG5cdFx0XHRcdC8vIGlmIChbJ3JlYWREb2N1bWVudCcsICdjcmVhdGVEb2N1bWVudCcsICd1cGRhdGVEb2N1bWVudCddLmluY2x1ZGVzKGFjdGlvbikpIHtcblx0XHRcdFx0Ly8gXHRyZXZfZGF0YS5kYXRhLmRhdGEgPSB1dGlsc0NydWQuZW5jb2RlT2JqZWN0KHJldl9kYXRhLmRhdGEuZGF0YSk7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0XG5cdFx0XHRcdFxuXHRcdFx0XHRjb25zdCBsaXN0ZW5lcnMgPSBfdGhpcy5saXN0ZW5lcnMuZ2V0KHJldl9kYXRhLmFjdGlvbik7XG5cdFx0XHRcdGlmICghbGlzdGVuZXJzKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcblx0XHRcdFx0XHRsaXN0ZW5lcihyZXZfZGF0YS5kYXRhLCBrZXkpO1xuXHRcdFx0XHR9KVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdC8qKlxuXHQgKiBcblx0ICovXG5cdHNlbmQgKGFjdGlvbiwgZGF0YSwgcm9vbSkge1xuXHRcdGNvbnN0IG9iaiA9IHtcblx0XHRcdGFjdGlvbjogYWN0aW9uLFxuXHRcdFx0ZGF0YTogZGF0YVxuXHRcdH1cblx0XHRjb25zdCBrZXkgPSB0aGlzLmdldEtleUJ5Um9vbShyb29tKTtcblx0XHRjb25zdCBzb2NrZXQgPSB0aGlzLmdldEJ5Um9vbShyb29tKTtcblx0XHRcblx0XHRpZiAoc29ja2V0KSB7XG5cdFx0XHRzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShvYmopKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMubWVzc2FnZVF1ZXVlLmdldChrZXkpKSB7XG5cdFx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlLmdldChrZXkpLnB1c2gob2JqKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlLnNldChrZXksIFtvYmpdKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHNlbmRGaWxlIChmaWxlLCByb29tKSB7XG5cdFx0Y29uc3Qgc29ja2V0ID0gdGhpcy5nZXRCeVJvb20ocm9vbSk7XG5cdFx0aWYgKHNvY2tldCkge1xuXHRcdFx0c29ja2V0LnNlbmQoZmlsZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIHNjb3BlOiBucy9yb29tXG5cdCAqL1xuXHRsaXN0ZW4odHlwZSwgY2FsbGJhY2spIHtcblx0XHRpZiAoIXRoaXMubGlzdGVuZXJzLmdldCh0eXBlKSkge1xuXHRcdFx0dGhpcy5saXN0ZW5lcnMuc2V0KHR5cGUsIFtjYWxsYmFja10pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmxpc3RlbmVycy5nZXQodHlwZSkucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHR9XG5cdFxuXHRyZWNvbm5lY3Qoc29ja2V0LCBjb25maWcpIHtcblx0XHRsZXQgX3RoaXMgPSB0aGlzO1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRfdGhpcy5jcmVhdGUoY29uZmlnKTtcblx0XHR9LCAxMDAwKVxuXHR9XG5cdFxuXHRkZXN0cm95KHNvY2tldCwga2V5KSB7XG5cdFx0aWYgKHNvY2tldCkge1xuXHRcdFx0c29ja2V0Lm9uZXJyb3IgPSBzb2NrZXQub25vcGVuID0gc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuXHRcdFx0c29ja2V0LmNsb3NlKCk7XG5cdFx0XHRzb2NrZXQgPSBudWxsO1xuXHRcdH1cblx0XHRcblx0XHRpZiAodGhpcy5zb2NrZXRzLmdldChrZXkpKSB7XG5cdFx0XHR0aGlzLnNvY2tldHMuZGVsZXRlKGtleSk7XG5cdFx0fVxuXHR9XG5cdFxuXHRnZXRLZXkobmFtZXNwYWNlLCByb29tKSB7XG5cdFx0bGV0IGtleSA9IGAke3RoaXMucHJlZml4fWA7XG5cdFx0aWYgKG5hbWVzcGFjZSAmJiBuYW1lc3BhY2UgIT0gJycpIHtcblx0XHRcdGlmIChyb29tICYmICByb29tICE9ICcnKSB7XG5cdFx0XHRcdGtleSArPSBgLyR7bmFtZXNwYWNlfS8ke3Jvb219YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSArPWAvJHtuYW1lc3BhY2V9YDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGtleTtcblx0fVxuXHRcblx0Z2V0QnlSb29tKHJvb20pIHtcblx0XHRsZXQga2V5ID0gdGhpcy5nZXRLZXlCeVJvb20ocm9vbSlcblx0XHRyZXR1cm4gdGhpcy5zb2NrZXRzLmdldChrZXkpO1x0XG5cdH1cblx0XG5cdGdldEtleUJ5Um9vbShyb29tKSB7XG5cdFx0bGV0IGtleSA9IHRoaXMuZ2xvYmFsU2NvcGU7XG5cdFx0aWYgKHJvb20pIHtcblx0XHRcdGtleSA9IGAke3RoaXMucHJlZml4fS8ke3Jvb219YDtcblx0XHR9XG5cdFx0cmV0dXJuIGtleTtcdFx0XG5cdH1cblx0XG5cdFxuXHRzYXZlRmlsZShibG9iKSB7XG5cdFx0Ly8gY29uc3Qge2ZpbGVuYW1lfSA9IHdpbmRvdy5zYXZlRmlsZUluZm87XG5cdFx0XG5cdFx0Y29uc3QgZmlsZV9uYW1lID0gdGhpcy5zYXZlRmlsZU5hbWUgfHwgJ2Rvd25sb2FkRmlsZSc7XG5cdFx0dmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgICAgICAgYS5zdHlsZSA9IFwiZGlzcGxheTogbm9uZVwiO1xuXG4gICAgICAgIGxldCB1cmwgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgICBhLmRvd25sb2FkID0gZmlsZV9uYW1lO1xuICAgICAgICBhLmNsaWNrKCk7XG4gICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG5cbiAgICAgICAgdGhpcy5zYXZlRmlsZU5hbWUgPSAnJ1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvQ3JlYXRlU29ja2V0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/socket.js\n")},"../../CoCreateJS/src/utils.crud.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction __mergeObject(target, source) {\n  target = target || {};\n\n  for (let key of Object.keys(source)) {\n    if (source[key] instanceof Object) {\n      Object.assign(source[key], __mergeObject(target[key], source[key]));\n    }\n  }\n\n  Object.assign(target || {}, source);\n  return target;\n}\n\nfunction __createObject(data, path) {\n  if (!path) return data;\n  let keys = path.split('.');\n  let newObject = data;\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    newObject = {\n      [keys[i]]: newObject\n    };\n  }\n\n  return newObject;\n}\n\nfunction __createArray(key, data) {\n  try {\n    let item = /([\\w\\W]+)\\[(\\d+)\\]/gm.exec(key);\n\n    if (item && item.length == 3) {\n      let arrayKey = item[1];\n      let index = parseInt(item[2]);\n\n      if (!data[arrayKey] || !Array.isArray(data[arrayKey])) {\n        data[arrayKey] = [];\n      }\n\n      data[arrayKey][index] = data[key];\n      delete data[key];\n      key = arrayKey;\n    }\n  } catch {\n    console.log('create array error');\n  }\n\n  return key;\n}\n\nfunction isObject(item) {\n  return !!item && item.constructor === Object;\n}\n\nfunction isArray(item) {\n  return !!item && item.constructor === Array;\n}\n\nfunction decodeObject(data) {\n  let keys = Object.keys(data);\n  let objectData = {};\n  keys.forEach(k => {\n    k = __createArray(k, data);\n\n    if (k.split('.').length > 1) {\n      let newData = __createObject(data[k], k);\n\n      delete data[k];\n      objectData = __mergeObject(objectData, newData);\n    } else {\n      objectData[k] = data[k];\n    }\n  });\n  return objectData;\n}\n\nfunction encodeObject(data) {\n  let keys = Object.keys(data);\n  let newData = {};\n  keys.forEach(k => {\n    let data_value = data[k];\n\n    if (isObject(data[k])) {\n      let new_obj = encodeObject(data[k]);\n      let newKeys = Object.keys(new_obj);\n      newKeys.forEach(newKey => {\n        let value = new_obj[newKey];\n        newKey = k + \".\" + newKey;\n        newData[newKey] = value;\n      });\n    } else if (isArray(data_value)) {\n      data_value.forEach((v, index) => {\n        newData[`${k}[${index}]`] = v;\n      });\n    } else {\n      newData[k] = data[k];\n    }\n  });\n  return newData;\n}\n\nvar _default = {\n  decodeObject,\n  encodeObject\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvdXRpbHMuY3J1ZC5qcz9hNjBjIl0sIm5hbWVzIjpbIl9fbWVyZ2VPYmplY3QiLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJPYmplY3QiLCJrZXlzIiwiYXNzaWduIiwiX19jcmVhdGVPYmplY3QiLCJkYXRhIiwicGF0aCIsInNwbGl0IiwibmV3T2JqZWN0IiwiaSIsImxlbmd0aCIsIl9fY3JlYXRlQXJyYXkiLCJpdGVtIiwiZXhlYyIsImFycmF5S2V5IiwiaW5kZXgiLCJwYXJzZUludCIsIkFycmF5IiwiaXNBcnJheSIsImNvbnNvbGUiLCJsb2ciLCJpc09iamVjdCIsImNvbnN0cnVjdG9yIiwiZGVjb2RlT2JqZWN0Iiwib2JqZWN0RGF0YSIsImZvckVhY2giLCJrIiwibmV3RGF0YSIsImVuY29kZU9iamVjdCIsImRhdGFfdmFsdWUiLCJuZXdfb2JqIiwibmV3S2V5cyIsIm5ld0tleSIsInZhbHVlIiwidiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLFNBQVVBLGFBQVYsQ0FBd0JDLE1BQXhCLEVBQWdDQyxNQUFoQyxFQUNBO0FBQ0NELFFBQU0sR0FBR0EsTUFBTSxJQUFJLEVBQW5COztBQUNBLE9BQUssSUFBSUUsR0FBVCxJQUFnQkMsTUFBTSxDQUFDQyxJQUFQLENBQVlILE1BQVosQ0FBaEIsRUFBcUM7QUFDcEMsUUFBSUEsTUFBTSxDQUFDQyxHQUFELENBQU4sWUFBdUJDLE1BQTNCLEVBQW1DO0FBQ2xDQSxZQUFNLENBQUNFLE1BQVAsQ0FBY0osTUFBTSxDQUFDQyxHQUFELENBQXBCLEVBQTJCSCxhQUFhLENBQUNDLE1BQU0sQ0FBQ0UsR0FBRCxDQUFQLEVBQWNELE1BQU0sQ0FBQ0MsR0FBRCxDQUFwQixDQUF4QztBQUNBO0FBQ0Q7O0FBRURDLFFBQU0sQ0FBQ0UsTUFBUCxDQUFjTCxNQUFNLElBQUksRUFBeEIsRUFBNEJDLE1BQTVCO0FBQ0EsU0FBT0QsTUFBUDtBQUNB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dW5jdGlvbiBcdF9fbWVyZ2VPYmplY3QodGFyZ2V0LCBzb3VyY2UpIFxue1xuXHR0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cdGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG5cdFx0aWYgKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgT2JqZWN0KSB7XG5cdFx0XHRPYmplY3QuYXNzaWduKHNvdXJjZVtrZXldLCBfX21lcmdlT2JqZWN0KHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpXG5cdFx0fVxuXHR9XG5cdFxuXHRPYmplY3QuYXNzaWduKHRhcmdldCB8fCB7fSwgc291cmNlKVxuXHRyZXR1cm4gdGFyZ2V0XG59XG5cbmZ1bmN0aW9uIF9fY3JlYXRlT2JqZWN0KGRhdGEsIHBhdGgpIFxue1xuXHRpZiAoIXBhdGgpIHJldHVybiBkYXRhO1xuXHRcblx0bGV0IGtleXMgPSBwYXRoLnNwbGl0KCcuJylcblx0bGV0IG5ld09iamVjdCA9IGRhdGE7XG5cblx0Zm9yICh2YXIgIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0bmV3T2JqZWN0ID0ge1trZXlzW2ldXTogbmV3T2JqZWN0fVx0XHRcdFx0XG5cdH1cblx0cmV0dXJuIG5ld09iamVjdDtcbn1cblxuZnVuY3Rpb24gX19jcmVhdGVBcnJheShrZXksIGRhdGEpXG57XG4gIHRyeSB7XG4gICAgbGV0IGl0ZW0gPSAvKFtcXHdcXFddKylcXFsoXFxkKylcXF0vZ20uZXhlYyhrZXkpXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGggPT0gMykge1xuICAgICAgbGV0IGFycmF5S2V5ID0gaXRlbVsxXTtcbiAgICAgIGxldCBpbmRleCA9IHBhcnNlSW50KGl0ZW1bMl0pO1xuICAgICAgXG4gICAgICBpZiAoIWRhdGFbYXJyYXlLZXldIHx8ICFBcnJheS5pc0FycmF5KGRhdGFbYXJyYXlLZXldKSkge1xuICAgICAgICBkYXRhW2FycmF5S2V5XSA9IFtdO1xuICAgICAgfSBcbiAgICAgIGRhdGFbYXJyYXlLZXldW2luZGV4XSA9IGRhdGFba2V5XTtcbiAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICBrZXkgPSBhcnJheUtleTtcbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIGNvbnNvbGUubG9nKCdjcmVhdGUgYXJyYXkgZXJyb3InKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuXG5cblxuZnVuY3Rpb24gaXNPYmplY3QoaXRlbSkge1xuICByZXR1cm4gKCEhaXRlbSkgJiYgKGl0ZW0uY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG59XG5mdW5jdGlvbiBpc0FycmF5KGl0ZW0pIHtcbiAgcmV0dXJuICghIWl0ZW0pICYmIChpdGVtLmNvbnN0cnVjdG9yID09PSBBcnJheSk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZU9iamVjdChkYXRhKSB7XG4gIGxldCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgbGV0IG9iamVjdERhdGEgPSB7fTtcbiAgXG4gIGtleXMuZm9yRWFjaCgoaykgPT4ge1xuICAgIGsgPSBfX2NyZWF0ZUFycmF5KGssIGRhdGEpO1xuICAgIGlmIChrLnNwbGl0KCcuJykubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IG5ld0RhdGEgPSBfX2NyZWF0ZU9iamVjdChkYXRhW2tdLCBrKTtcbiAgICAgIGRlbGV0ZSBkYXRhW2tdO1xuICAgICAgXG4gICAgICBvYmplY3REYXRhID0gX19tZXJnZU9iamVjdChvYmplY3REYXRhLCBuZXdEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0RGF0YVtrXSA9IGRhdGFba107XG4gICAgfVxuICB9KVxuICByZXR1cm4gb2JqZWN0RGF0YTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlT2JqZWN0KGRhdGEpIHtcbiAgbGV0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgbGV0IG5ld0RhdGEgPSB7fTtcbiAga2V5cy5mb3JFYWNoKChrKSA9PiB7XG4gICAgbGV0IGRhdGFfdmFsdWUgPSBkYXRhW2tdO1xuICAgIGlmIChpc09iamVjdChkYXRhW2tdKSkge1xuICAgICAgbGV0IG5ld19vYmogPSBlbmNvZGVPYmplY3QoZGF0YVtrXSk7XG4gICAgICBcbiAgICAgIGxldCBuZXdLZXlzID0gT2JqZWN0LmtleXMobmV3X29iaik7XG4gICAgICBuZXdLZXlzLmZvckVhY2goKG5ld0tleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBuZXdfb2JqW25ld0tleV07XG4gICAgICAgIG5ld0tleSA9IGsgKyBcIi5cIiArIG5ld0tleTtcbiAgICAgICAgbmV3RGF0YVtuZXdLZXldID0gdmFsdWU7XG4gICAgICB9KVxuICAgICAgXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGFfdmFsdWUpKXtcbiAgICAgIGRhdGFfdmFsdWUuZm9yRWFjaCgodiwgaW5kZXgpID0+IHtcbiAgICAgICAgbmV3RGF0YVtgJHtrfVske2luZGV4fV1gXSA9IHY7XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdEYXRhW2tdID0gZGF0YVtrXTtcbiAgICB9XG4gIH0pXG4gIHJldHVybiBuZXdEYXRhO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGRlY29kZU9iamVjdCxcbiAgZW5jb2RlT2JqZWN0XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/utils.crud.js\n")},"../../CoCreateJS/src/utils.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.generateUUID = generateUUID;\nexports.isRealTime = isRealTime;\nexports.getParentFromElement = getParentFromElement;\nexports.isReadValue = isReadValue;\nexports.isUpdateValue = isUpdateValue;\nexports.isJsonString = isJsonString;\nexports.getAttributes = getAttributes;\nexports.checkValue = checkValue;\nexports.allFrame = allFrame;\nexports.cssPath = cssPath;\nexports.getTopMostWindow = getTopMostWindow;\nexports.findIframeFromElement = findIframeFromElement;\nexports.getIframeFromPath = getIframeFromPath;\nexports.configMatch2 = configMatch2;\nexports.configExecuter = configExecuter;\nexports.UUID = UUID;\nexports.parseTextToHtml = parseTextToHtml;\nexports.splitBydelimiter = splitBydelimiter;\nexports.joinBydelimiter = joinBydelimiter;\nexports.isValidSelector = isValidSelector;\nexports.getElementPath = getElementPath;\nexports.isUsageY = isUsageY;\nexports.default = void 0;\n\n/**\n * Created by jin\n * 2020-04-03\n */\nfunction generateUUID(length = 36) {\n  // if (length == 10) {\n  //   var result           = \'\';\n  //   var characters       = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\';\n  //   var charactersLength = characters.length;\n  //   for ( var i = 0; i < length; i++ ) {\n  //     result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  //   }\n  //   var dd = new Date().toTimeString();\n  //   var random = dd.replace(/[\\W_]+/g, "").substr(0,6);\n  //   result += random;\n  //   return result;\n  // }\n  let d = new Date().getTime();\n  let d2 = window.performance && window.performance.now && window.performance.now() * 1000 || 0;\n  let pattern = "uxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";\n\n  if (length <= pattern.length) {\n    pattern = pattern.substr(0, length);\n  } else {\n    let add_len = length - pattern.length;\n    let sub_pattern = "-xxxyyxxx";\n    let group_n = Math.floor(add_len / sub_pattern.length);\n\n    for (let i = 0; i < group_n; i++) {\n      pattern += sub_pattern;\n    }\n\n    group_n = add_len - group_n * sub_pattern.length;\n    pattern += sub_pattern.substr(0, group_n);\n  }\n\n  let uuid = pattern.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16;\n\n    if (d > 0) {\n      var r = (d + r) % 16 | 0;\n      d = Math.floor(d / 16);\n    } else {\n      var r = (d2 + r) % 16 | 0;\n      d2 = Math.floor(d2 / 16);\n    }\n\n    return (c == "x" ? r : r & 0x7 | 0x8).toString(16);\n  });\n  return uuid;\n}\n\nfunction isRealTime(element, parent_realTime) {\n  let realtime = element.getAttribute("data-realtime") || parent_realTime;\n\n  if (realtime === "false") {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getParentFromElement(element, parent_class, attributes) {\n  if (parent_class) {\n    if (element.classList.contains(parent_class)) {\n      return element;\n    }\n\n    let node = element.parentNode;\n\n    while (node != null && node.classList) {\n      if (node.classList.contains(parent_class)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n  } else if (attributes) {\n    if (attributes.every(attr => element.attributes.hasOwnProperty(attr))) {\n      return element;\n    }\n\n    let node = element.parentNode;\n\n    while (node != null && node.attributes) {\n      if (attributes.every(attr => node.attributes.hasOwnProperty(attr))) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n  }\n\n  return false;\n}\n\nfunction isReadValue(element) {\n  return element.getAttribute("data-read_value") != "false";\n}\n\nfunction isUpdateValue(element) {\n  return element.getAttribute("data-update_value") != "false";\n}\n\nfunction isJsonString(str_data) {\n  try {\n    let json_data = JSON.parse(str_data);\n\n    if (typeof json_data === "object" && json_data != null) {\n      return true;\n    } else {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction getAttributes(element) {\n  return element.getAttributeNames().reduce((attrMap, name) => {\n    attrMap[name] = element.getAttribute(name);\n    return attrMap;\n  }, {});\n}\n\nfunction checkValue(value) {\n  if (!value) return false;\n\n  if (/{{\\s*([\\w\\W]+)\\s*}}/g.test(value)) {\n    return false;\n  }\n\n  return true;\n} // hosseins utills\n// function to go through all frames\n\n\nfunction allFrame(callback) {\n  let allFrames = [{\n    document,\n    window\n  }];\n\n  for (let frame of document.querySelectorAll("iframe")) {\n    let frameDocument = frame.contentDocument || frame.contentWindow.document;\n    let frameWindow = frame.contentWindow;\n    allFrames.push({\n      document: frameDocument,\n      window: frameWindow,\n      frameElement: frame\n    });\n  }\n\n  let result = new Set();\n\n  for (let frame of allFrames) {\n    let callbackResult = callback(frame);\n    if (callbackResult && typeof callbackResult[Symbol.iterator] === "function") callbackResult.forEach(el => result.add(el));else if (callbackResult) result.add(callbackResult);\n  }\n\n  return Array.from(result);\n}\n\nfunction cssPath(node) {\n  let pathSplits = [];\n\n  do {\n    if (!node || !node.tagName) return false;\n    let pathSplit = node.tagName.toLowerCase();\n    if (node.id && node.tagName !== "BODY") pathSplit += "#" + node.id;\n\n    if (node.classList.length && node.tagName !== "BODY") {\n      node.classList.forEach(item => {\n        if (item.indexOf(":") === -1) pathSplit += "." + item;\n      });\n    }\n\n    if (node.tagName !== "BODY" && node.parentNode) {\n      let index = Array.prototype.indexOf.call(node.parentNode.children, node);\n      pathSplit += `:nth-child(${index + 1})`;\n    }\n\n    pathSplits.unshift(pathSplit);\n    node = node.parentNode;\n  } while (node.tagName !== "HTML");\n\n  return pathSplits.join(" > ");\n}\n\nfunction getTopMostWindow() {\n  let parentWindow = window;\n\n  while (parentWindow !== window.parent) parentWindow = window.parent;\n\n  return parentWindow;\n}\n\nfunction findIframeFromElement(windowObject, element) {\n  let frameElement;\n  allFrame(frame => {\n    if (frame.document.contains(element)) frameElement = frame.frameElement; // window.cc.findIframeFromElement(frame.window, element);\n  });\n  return frameElement;\n}\n\nfunction getIframeFromPath(path) {\n  let topWindow = getTopMostWindow;\n  path.forEach(selector => {\n    if (topWindow) topWindow = topWindow.querySelector(selector);\n  });\n  return topWindow;\n} // DO NOT REMOVE\n// configMatch: function* configMatch(elementConfig, element) {\n//   for (let config of elementConfig) {\n//     // if (!Array.isArray(config.selector))\n//     //   config.selector = [config.selector];\n//     if (config.selector && element.matches(config.selector)) yield config;\n//   }\n//   return;\n// },\n\n\nfunction configMatch2(elementConfig, element) {\n  let result = [];\n\n  for (let config of elementConfig) {\n    if (config.selector && element.matches(config.selector)) result.push(config);\n  }\n\n  return result;\n} // DO NOT REMOVE\n// an opiniated function uses configMatch2 to read configs\n// WARNING: the config iterated from top to bottom. for deseired effect elementConfig should be reveresed\n// typeof elementConfig: array of objects and every objects containing keys as false, true or a selector \n// element: the element to read attributes\n// key: the key in which is in elementConfig and on match onSuccess callback will be called\n\n\nfunction configExecuter(element, key, onSuccess, elementConfig) {\n  for (let config of configMatch2(elementConfig || window.elementConfig, element)) if (config[key] === true) return onSuccess(element, config);else if (config[key] === false) return false;else if (config[key] === undefined) continue;else if (isValidSelector(config[key])) return onSuccess(element, config, true);else console.warn("builder: wrong element config ", config);\n\n  return false;\n}\n\nfunction UUID(length = 10) {\n  var result = "";\n  var characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";\n  var charactersLength = characters.length;\n\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n\n  var d = new Date().toTimeString();\n  var random = d.replace(/[\\W_]+/g, "").substr(0, 6);\n  result += random;\n  return result;\n}\n\nfunction parseTextToHtml(text) {\n  let doc = new DOMParser().parseFromString(text, "text/html");\n  if (doc.head.children[0]) return doc.head.children[0];else return doc.body.children[0];\n}\n\nfunction splitBydelimiter(str, delimiter) {\n  return str.split(delimiter).map(s => s.trim());\n}\n\nfunction joinBydelimiter(str, delimiter) {\n  return str.map(s => s.trim()).join(delimiter);\n}\n\nfunction isValidSelector(selector) {\n  try {\n    document.createDocumentFragment().querySelector(selector);\n  } catch (error) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getElementPath(element, returnContext) {\n  let path = [];\n  let topWindow = window;\n  let iframeElement = findIframeFromElement(topWindow, element);\n  let p = cssPath(iframeElement);\n  if (p) path.unshift(p);\n  return returnContext ? {\n    path,\n    document: iframeElement || document\n  } : path; //todo: support for nested iframe\n  // while(iframeElement !== findIframeFromElement(topWindow,iframeElement))\n  // {\n  //   iframeElement = findIframeFromElement(topWindow,iframeElement);\n  //   path.unshift(cssPath(iframeElement))\n  // }\n}\n\nfunction isUsageY(input) {\n  if (this.isJsonString(input.getAttribute(\'data-collection\'))) {\n    return false;\n  }\n\n  if (this.isJsonString(input.getAttribute(\'name\'))) {\n    return false;\n  }\n\n  if (input.tagName === "INPUT" && ["text", "email", "tel", "url"].includes(input.type) || input.tagName === "TEXTAREA") {\n    if (!input.getAttribute(\'name\')) {\n      return false;\n    }\n\n    if (input.getAttribute("data-realtime") == "false") {\n      return false;\n    }\n\n    if (input.getAttribute("data-unique") === "true") {\n      return false;\n    }\n\n    if (input.type === \'password\') {\n      return false;\n    }\n\n    if (!this.isReadValue(input)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar _default = {\n  isUsageY,\n  getElementPath,\n  isValidSelector,\n  joinBydelimiter,\n  splitBydelimiter,\n  parseTextToHtml,\n  UUID,\n  configExecuter,\n  configMatch2,\n  getIframeFromPath,\n  findIframeFromElement,\n  getTopMostWindow,\n  cssPath,\n  allFrame,\n  checkValue,\n  getAttributes,\n  isJsonString,\n  isUpdateValue,\n  isReadValue,\n  getParentFromElement,\n  isRealTime,\n  generateUUID\n};\nexports.default = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi4vQ29DcmVhdGVKUy9zcmMvdXRpbHMuanM/MzI0NSJdLCJuYW1lcyI6WyJnZW5lcmF0ZVVVSUQiLCJsZW5ndGgiLCJkIiwiRGF0ZSIsImdldFRpbWUiLCJkMiIsIndpbmRvdyIsInBlcmZvcm1hbmNlIiwibm93IiwicGF0dGVybiIsInN1YnN0ciIsImFkZF9sZW4iLCJzdWJfcGF0dGVybiIsImdyb3VwX24iLCJNYXRoIiwiZmxvb3IiLCJpIiwidXVpZCIsInJlcGxhY2UiLCJjIiwiciIsInJhbmRvbSIsInRvU3RyaW5nIiwiaXNSZWFsVGltZSIsImVsZW1lbnQiLCJwYXJlbnRfcmVhbFRpbWUiLCJyZWFsdGltZSIsImdldEF0dHJpYnV0ZSIsImdldFBhcmVudEZyb21FbGVtZW50IiwicGFyZW50X2NsYXNzIiwiYXR0cmlidXRlcyIsImNsYXNzTGlzdCIsImNvbnRhaW5zIiwibm9kZSIsInBhcmVudE5vZGUiLCJldmVyeSIsImF0dHIiLCJoYXNPd25Qcm9wZXJ0eSIsImlzUmVhZFZhbHVlIiwiaXNVcGRhdGVWYWx1ZSIsImlzSnNvblN0cmluZyIsInN0cl9kYXRhIiwianNvbl9kYXRhIiwiSlNPTiIsInBhcnNlIiwiZSIsImdldEF0dHJpYnV0ZXMiLCJnZXRBdHRyaWJ1dGVOYW1lcyIsInJlZHVjZSIsImF0dHJNYXAiLCJuYW1lIiwiY2hlY2tWYWx1ZSIsInZhbHVlIiwidGVzdCIsImFsbEZyYW1lIiwiY2FsbGJhY2siLCJhbGxGcmFtZXMiLCJkb2N1bWVudCIsImZyYW1lIiwicXVlcnlTZWxlY3RvckFsbCIsImZyYW1lRG9jdW1lbnQiLCJjb250ZW50RG9jdW1lbnQiLCJjb250ZW50V2luZG93IiwiZnJhbWVXaW5kb3ciLCJwdXNoIiwiZnJhbWVFbGVtZW50IiwicmVzdWx0IiwiU2V0IiwiY2FsbGJhY2tSZXN1bHQiLCJTeW1ib2wiLCJpdGVyYXRvciIsImZvckVhY2giLCJlbCIsImFkZCIsIkFycmF5IiwiZnJvbSIsImNzc1BhdGgiLCJwYXRoU3BsaXRzIiwidGFnTmFtZSIsInBhdGhTcGxpdCIsInRvTG93ZXJDYXNlIiwiaWQiLCJpdGVtIiwiaW5kZXhPZiIsImluZGV4IiwicHJvdG90eXBlIiwiY2FsbCIsImNoaWxkcmVuIiwidW5zaGlmdCIsImpvaW4iLCJnZXRUb3BNb3N0V2luZG93IiwicGFyZW50V2luZG93IiwicGFyZW50IiwiZmluZElmcmFtZUZyb21FbGVtZW50Iiwid2luZG93T2JqZWN0IiwiZ2V0SWZyYW1lRnJvbVBhdGgiLCJwYXRoIiwidG9wV2luZG93Iiwic2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yIiwiY29uZmlnTWF0Y2gyIiwiZWxlbWVudENvbmZpZyIsImNvbmZpZyIsIm1hdGNoZXMiLCJjb25maWdFeGVjdXRlciIsImtleSIsIm9uU3VjY2VzcyIsInVuZGVmaW5lZCIsImlzVmFsaWRTZWxlY3RvciIsImNvbnNvbGUiLCJ3YXJuIiwiVVVJRCIsImNoYXJhY3RlcnMiLCJjaGFyYWN0ZXJzTGVuZ3RoIiwiY2hhckF0IiwidG9UaW1lU3RyaW5nIiwicGFyc2VUZXh0VG9IdG1sIiwidGV4dCIsImRvYyIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImhlYWQiLCJib2R5Iiwic3BsaXRCeWRlbGltaXRlciIsInN0ciIsImRlbGltaXRlciIsInNwbGl0IiwibWFwIiwicyIsInRyaW0iLCJqb2luQnlkZWxpbWl0ZXIiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiZXJyb3IiLCJnZXRFbGVtZW50UGF0aCIsInJldHVybkNvbnRleHQiLCJpZnJhbWVFbGVtZW50IiwicCIsImlzVXNhZ2VZIiwiaW5wdXQiLCJpbmNsdWRlcyIsInR5cGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFHTyxTQUFTQSxZQUFULENBQXNCQyxNQUFNLEdBQUcsRUFBL0IsRUFBbUM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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UDtBQUNEOztlQUVjO0FBQ2JELFVBRGE7QUFFYkosZ0JBRmE7QUFHYnpCLGlCQUhhO0FBSWJzQixpQkFKYTtBQUtiUCxrQkFMYTtBQU1iUCxpQkFOYTtBQU9iTCxNQVBhO0FBUWJQLGdCQVJhO0FBU2JKLGNBVGE7QUFVYkwsbUJBVmE7QUFXYkYsdUJBWGE7QUFZYkgsa0JBWmE7QUFhYmQsU0FiYTtBQWNidEIsVUFkYTtBQWViSCxZQWZhO0FBZ0JiTCxlQWhCYTtBQWlCYk4sY0FqQmE7QUFrQmJELGVBbEJhO0FBbUJiRCxhQW5CYTtBQW9CYlYsc0JBcEJhO0FBcUJiTCxZQXJCYTtBQXNCYnZCO0FBdEJhLEMiLCJmaWxlIjoiLi4vLi4vQ29DcmVhdGVKUy9zcmMvdXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZWQgYnkgamluXG4gKiAyMDIwLTA0LTAzXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKGxlbmd0aCA9IDM2KSB7XG4gIC8vIGlmIChsZW5ndGggPT0gMTApIHtcbiAgLy8gICB2YXIgcmVzdWx0ICAgICAgICAgICA9ICcnO1xuICAvLyAgIHZhciBjaGFyYWN0ZXJzICAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcbiAgLy8gICB2YXIgY2hhcmFjdGVyc0xlbmd0aCA9IGNoYXJhY3RlcnMubGVuZ3RoO1xuICAvLyAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAvLyAgICAgcmVzdWx0ICs9IGNoYXJhY3RlcnMuY2hhckF0KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnNMZW5ndGgpKTtcbiAgLy8gICB9XG5cbiAgLy8gICB2YXIgZGQgPSBuZXcgRGF0ZSgpLnRvVGltZVN0cmluZygpO1xuICAvLyAgIHZhciByYW5kb20gPSBkZC5yZXBsYWNlKC9bXFxXX10rL2csIFwiXCIpLnN1YnN0cigwLDYpO1xuICAvLyAgIHJlc3VsdCArPSByYW5kb207XG4gIC8vICAgcmV0dXJuIHJlc3VsdDtcbiAgLy8gfVxuXG4gIGxldCBkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIGxldCBkMiA9XG4gICAgKHdpbmRvdy5wZXJmb3JtYW5jZSAmJlxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdyAmJlxuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpICogMTAwMCkgfHxcbiAgICAwO1xuICBsZXQgcGF0dGVybiA9IFwidXh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCI7XG5cbiAgaWYgKGxlbmd0aCA8PSBwYXR0ZXJuLmxlbmd0aCkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigwLCBsZW5ndGgpO1xuICB9XG4gIGVsc2Uge1xuICAgIGxldCBhZGRfbGVuID0gbGVuZ3RoIC0gcGF0dGVybi5sZW5ndGg7XG4gICAgbGV0IHN1Yl9wYXR0ZXJuID0gXCIteHh4eXl4eHhcIjtcblxuICAgIGxldCBncm91cF9uID0gTWF0aC5mbG9vcihhZGRfbGVuIC8gc3ViX3BhdHRlcm4ubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JvdXBfbjsgaSsrKSB7XG4gICAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuO1xuICAgIH1cblxuICAgIGdyb3VwX24gPSBhZGRfbGVuIC0gZ3JvdXBfbiAqIHN1Yl9wYXR0ZXJuLmxlbmd0aDtcbiAgICBwYXR0ZXJuICs9IHN1Yl9wYXR0ZXJuLnN1YnN0cigwLCBncm91cF9uKTtcbiAgfVxuXG4gIGxldCB1dWlkID0gcGF0dGVybi5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNjtcbiAgICBpZiAoZCA+IDApIHtcbiAgICAgIHZhciByID0gKGQgKyByKSAlIDE2IHwgMDtcbiAgICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHIgPSAoZDIgKyByKSAlIDE2IHwgMDtcbiAgICAgIGQyID0gTWF0aC5mbG9vcihkMiAvIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIChjID09IFwieFwiID8gciA6IChyICYgMHg3KSB8IDB4OCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlYWxUaW1lKGVsZW1lbnQsIHBhcmVudF9yZWFsVGltZSkge1xuICBsZXQgcmVhbHRpbWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcmVhbHRpbWVcIikgfHwgcGFyZW50X3JlYWxUaW1lO1xuICBpZiAocmVhbHRpbWUgPT09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50RnJvbUVsZW1lbnQoZWxlbWVudCwgcGFyZW50X2NsYXNzLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChwYXJlbnRfY2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMocGFyZW50X2NsYXNzKSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT0gbnVsbCAmJiBub2RlLmNsYXNzTGlzdCkge1xuICAgICAgaWYgKG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKHBhcmVudF9jbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMuZXZlcnkoKGF0dHIpID0+IGVsZW1lbnQuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIGxldCBub2RlID0gZWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgbm9kZS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoYXR0cmlidXRlcy5ldmVyeSgoYXR0cikgPT4gbm9kZS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWFkVmFsdWUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXJlYWRfdmFsdWVcIikgIT0gXCJmYWxzZVwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNVcGRhdGVWYWx1ZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdXBkYXRlX3ZhbHVlXCIpICE9IFwiZmFsc2VcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvblN0cmluZyhzdHJfZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBqc29uX2RhdGEgPSBKU09OLnBhcnNlKHN0cl9kYXRhKTtcbiAgICBpZiAodHlwZW9mIGpzb25fZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBqc29uX2RhdGEgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzKCkucmVkdWNlKChhdHRyTWFwLCBuYW1lKSA9PiB7XG4gICAgYXR0ck1hcFtuYW1lXSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiBhdHRyTWFwO1xuICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ZhbHVlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgaWYgKC97e1xccyooW1xcd1xcV10rKVxccyp9fS9nLnRlc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vLyBob3NzZWlucyB1dGlsbHNcblxuLy8gZnVuY3Rpb24gdG8gZ28gdGhyb3VnaCBhbGwgZnJhbWVzXG5leHBvcnQgZnVuY3Rpb24gYWxsRnJhbWUoY2FsbGJhY2spIHtcbiAgbGV0IGFsbEZyYW1lcyA9IFt7IGRvY3VtZW50LCB3aW5kb3cgfV07XG4gIGZvciAobGV0IGZyYW1lIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJpZnJhbWVcIikpIHtcbiAgICBsZXQgZnJhbWVEb2N1bWVudCA9IGZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCBmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgIGxldCBmcmFtZVdpbmRvdyA9IGZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgYWxsRnJhbWVzLnB1c2goe1xuICAgICAgZG9jdW1lbnQ6IGZyYW1lRG9jdW1lbnQsXG4gICAgICB3aW5kb3c6IGZyYW1lV2luZG93LFxuICAgICAgZnJhbWVFbGVtZW50OiBmcmFtZSxcbiAgICB9KTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gbmV3IFNldCgpO1xuICBmb3IgKGxldCBmcmFtZSBvZiBhbGxGcmFtZXMpIHtcbiAgICBsZXQgY2FsbGJhY2tSZXN1bHQgPSBjYWxsYmFjayhmcmFtZSk7XG4gICAgaWYgKFxuICAgICAgY2FsbGJhY2tSZXN1bHQgJiZcbiAgICAgIHR5cGVvZiBjYWxsYmFja1Jlc3VsdFtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCJcbiAgICApXG4gICAgICBjYWxsYmFja1Jlc3VsdC5mb3JFYWNoKChlbCkgPT4gcmVzdWx0LmFkZChlbCkpO1xuICAgIGVsc2UgaWYgKGNhbGxiYWNrUmVzdWx0KSByZXN1bHQuYWRkKGNhbGxiYWNrUmVzdWx0KTtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHJlc3VsdCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NQYXRoKG5vZGUpIHtcbiAgbGV0IHBhdGhTcGxpdHMgPSBbXTtcbiAgZG8ge1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS50YWdOYW1lKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHBhdGhTcGxpdCA9IG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChub2RlLmlkICYmIG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHBhdGhTcGxpdCArPSBcIiNcIiArIG5vZGUuaWQ7XG5cbiAgICBpZiAobm9kZS5jbGFzc0xpc3QubGVuZ3RoICYmIG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcbiAgICAgIG5vZGUuY2xhc3NMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uaW5kZXhPZihcIjpcIikgPT09IC0xKSBwYXRoU3BsaXQgKz0gXCIuXCIgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnTmFtZSAhPT0gXCJCT0RZXCIgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICBsZXQgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKFxuICAgICAgICBub2RlLnBhcmVudE5vZGUuY2hpbGRyZW4sXG4gICAgICAgIG5vZGVcbiAgICAgICk7XG4gICAgICBwYXRoU3BsaXQgKz0gYDpudGgtY2hpbGQoJHtpbmRleCArIDF9KWA7XG4gICAgfVxuXG4gICAgcGF0aFNwbGl0cy51bnNoaWZ0KHBhdGhTcGxpdCk7XG4gICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgfSB3aGlsZSAobm9kZS50YWdOYW1lICE9PSBcIkhUTUxcIik7XG5cbiAgcmV0dXJuIHBhdGhTcGxpdHMuam9pbihcIiA+IFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcE1vc3RXaW5kb3coKSB7XG4gIGxldCBwYXJlbnRXaW5kb3cgPSB3aW5kb3c7XG4gIHdoaWxlIChwYXJlbnRXaW5kb3cgIT09IHdpbmRvdy5wYXJlbnQpIHBhcmVudFdpbmRvdyA9IHdpbmRvdy5wYXJlbnQ7XG4gIHJldHVybiBwYXJlbnRXaW5kb3c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSWZyYW1lRnJvbUVsZW1lbnQod2luZG93T2JqZWN0LCBlbGVtZW50KSB7XG4gIGxldCBmcmFtZUVsZW1lbnQ7XG4gIGFsbEZyYW1lKChmcmFtZSkgPT4ge1xuICAgIGlmIChmcmFtZS5kb2N1bWVudC5jb250YWlucyhlbGVtZW50KSkgZnJhbWVFbGVtZW50ID0gZnJhbWUuZnJhbWVFbGVtZW50O1xuICAgIC8vIHdpbmRvdy5jYy5maW5kSWZyYW1lRnJvbUVsZW1lbnQoZnJhbWUud2luZG93LCBlbGVtZW50KTtcbiAgfSk7XG4gIHJldHVybiBmcmFtZUVsZW1lbnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJZnJhbWVGcm9tUGF0aChwYXRoKSB7XG4gIGxldCB0b3BXaW5kb3cgPSBnZXRUb3BNb3N0V2luZG93O1xuXG4gIHBhdGguZm9yRWFjaCgoc2VsZWN0b3IpID0+IHtcbiAgICBpZiAodG9wV2luZG93KSB0b3BXaW5kb3cgPSB0b3BXaW5kb3cucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gIH0pO1xuICByZXR1cm4gdG9wV2luZG93O1xufVxuLy8gRE8gTk9UIFJFTU9WRVxuXG4vLyBjb25maWdNYXRjaDogZnVuY3Rpb24qIGNvbmZpZ01hdGNoKGVsZW1lbnRDb25maWcsIGVsZW1lbnQpIHtcbi8vICAgZm9yIChsZXQgY29uZmlnIG9mIGVsZW1lbnRDb25maWcpIHtcbi8vICAgICAvLyBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlnLnNlbGVjdG9yKSlcbi8vICAgICAvLyAgIGNvbmZpZy5zZWxlY3RvciA9IFtjb25maWcuc2VsZWN0b3JdO1xuXG4vLyAgICAgaWYgKGNvbmZpZy5zZWxlY3RvciAmJiBlbGVtZW50Lm1hdGNoZXMoY29uZmlnLnNlbGVjdG9yKSkgeWllbGQgY29uZmlnO1xuLy8gICB9XG4vLyAgIHJldHVybjtcbi8vIH0sXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnTWF0Y2gyKGVsZW1lbnRDb25maWcsIGVsZW1lbnQpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBjb25maWcgb2YgZWxlbWVudENvbmZpZykge1xuICAgIGlmIChjb25maWcuc2VsZWN0b3IgJiYgZWxlbWVudC5tYXRjaGVzKGNvbmZpZy5zZWxlY3RvcikpIHJlc3VsdC5wdXNoKGNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gRE8gTk9UIFJFTU9WRVxuXG4vLyBhbiBvcGluaWF0ZWQgZnVuY3Rpb24gdXNlcyBjb25maWdNYXRjaDIgdG8gcmVhZCBjb25maWdzXG4vLyBXQVJOSU5HOiB0aGUgY29uZmlnIGl0ZXJhdGVkIGZyb20gdG9wIHRvIGJvdHRvbS4gZm9yIGRlc2VpcmVkIGVmZmVjdCBlbGVtZW50Q29uZmlnIHNob3VsZCBiZSByZXZlcmVzZWRcbi8vIHR5cGVvZiBlbGVtZW50Q29uZmlnOiBhcnJheSBvZiBvYmplY3RzIGFuZCBldmVyeSBvYmplY3RzIGNvbnRhaW5pbmcga2V5cyBhcyBmYWxzZSwgdHJ1ZSBvciBhIHNlbGVjdG9yIFxuLy8gZWxlbWVudDogdGhlIGVsZW1lbnQgdG8gcmVhZCBhdHRyaWJ1dGVzXG4vLyBrZXk6IHRoZSBrZXkgaW4gd2hpY2ggaXMgaW4gZWxlbWVudENvbmZpZyBhbmQgb24gbWF0Y2ggb25TdWNjZXNzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG5leHBvcnQgZnVuY3Rpb24gY29uZmlnRXhlY3V0ZXIoZWxlbWVudCwga2V5LCBvblN1Y2Nlc3MsIGVsZW1lbnRDb25maWcpIHtcbiAgZm9yIChsZXQgY29uZmlnIG9mIGNvbmZpZ01hdGNoMihlbGVtZW50Q29uZmlnIHx8IHdpbmRvdy5lbGVtZW50Q29uZmlnLCBlbGVtZW50KSlcbiAgICBpZiAoY29uZmlnW2tleV0gPT09IHRydWUpIHJldHVybiBvblN1Y2Nlc3MoZWxlbWVudCwgY29uZmlnKTtcbiAgICBlbHNlIGlmIChjb25maWdba2V5XSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgZWxzZSBpZiAoY29uZmlnW2tleV0gPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gIGVsc2UgaWYgKGlzVmFsaWRTZWxlY3Rvcihjb25maWdba2V5XSkpXG4gICAgcmV0dXJuIG9uU3VjY2VzcyhlbGVtZW50LCBjb25maWcsIHRydWUpO1xuICBlbHNlIGNvbnNvbGUud2FybihcImJ1aWxkZXI6IHdyb25nIGVsZW1lbnQgY29uZmlnIFwiLCBjb25maWcpO1xuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFVVSUQobGVuZ3RoID0gMTApIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gIHZhciBjaGFyYWN0ZXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG5cbiAgdmFyIGNoYXJhY3RlcnNMZW5ndGggPSBjaGFyYWN0ZXJzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyYWN0ZXJzTGVuZ3RoKSk7XG4gIH1cblxuICB2YXIgZCA9IG5ldyBEYXRlKCkudG9UaW1lU3RyaW5nKCk7XG4gIHZhciByYW5kb20gPSBkLnJlcGxhY2UoL1tcXFdfXSsvZywgXCJcIikuc3Vic3RyKDAsIDYpO1xuICByZXN1bHQgKz0gcmFuZG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUZXh0VG9IdG1sKHRleHQpIHtcbiAgbGV0IGRvYyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodGV4dCwgXCJ0ZXh0L2h0bWxcIik7XG4gIGlmIChkb2MuaGVhZC5jaGlsZHJlblswXSkgcmV0dXJuIGRvYy5oZWFkLmNoaWxkcmVuWzBdO1xuICBlbHNlIHJldHVybiBkb2MuYm9keS5jaGlsZHJlblswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0QnlkZWxpbWl0ZXIoc3RyLCBkZWxpbWl0ZXIpIHtcbiAgcmV0dXJuIHN0ci5zcGxpdChkZWxpbWl0ZXIpLm1hcCgocykgPT4gcy50cmltKCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gam9pbkJ5ZGVsaW1pdGVyKHN0ciwgZGVsaW1pdGVyKSB7XG4gIHJldHVybiBzdHIubWFwKChzKSA9PiBzLnRyaW0oKSkuam9pbihkZWxpbWl0ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gIHRyeSB7XG4gICAgZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICB9XG4gIGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRQYXRoKGVsZW1lbnQsIHJldHVybkNvbnRleHQpIHtcbiAgbGV0IHBhdGggPSBbXTtcblxuICBsZXQgdG9wV2luZG93ID0gd2luZG93O1xuICBsZXQgaWZyYW1lRWxlbWVudCA9IGZpbmRJZnJhbWVGcm9tRWxlbWVudCh0b3BXaW5kb3csIGVsZW1lbnQpO1xuICBsZXQgcCA9IGNzc1BhdGgoaWZyYW1lRWxlbWVudCk7XG4gIGlmIChwKSBwYXRoLnVuc2hpZnQocCk7XG5cbiAgcmV0dXJuIHJldHVybkNvbnRleHQgPyB7IHBhdGgsIGRvY3VtZW50OiBpZnJhbWVFbGVtZW50IHx8IGRvY3VtZW50IH0gOiBwYXRoO1xuICAvL3RvZG86IHN1cHBvcnQgZm9yIG5lc3RlZCBpZnJhbWVcbiAgLy8gd2hpbGUoaWZyYW1lRWxlbWVudCAhPT0gZmluZElmcmFtZUZyb21FbGVtZW50KHRvcFdpbmRvdyxpZnJhbWVFbGVtZW50KSlcbiAgLy8ge1xuICAvLyAgIGlmcmFtZUVsZW1lbnQgPSBmaW5kSWZyYW1lRnJvbUVsZW1lbnQodG9wV2luZG93LGlmcmFtZUVsZW1lbnQpO1xuICAvLyAgIHBhdGgudW5zaGlmdChjc3NQYXRoKGlmcmFtZUVsZW1lbnQpKVxuICAvLyB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VzYWdlWShpbnB1dCkge1xuICBpZiAodGhpcy5pc0pzb25TdHJpbmcoaW5wdXQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbGxlY3Rpb24nKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5pc0pzb25TdHJpbmcoaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJykpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKChpbnB1dC50YWdOYW1lID09PSBcIklOUFVUXCIgJiYgW1widGV4dFwiLCBcImVtYWlsXCIsIFwidGVsXCIsIFwidXJsXCJdLmluY2x1ZGVzKGlucHV0LnR5cGUpKSB8fCBpbnB1dC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcblxuICAgIGlmICghaW5wdXQuZ2V0QXR0cmlidXRlKCduYW1lJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtcmVhbHRpbWVcIikgPT0gXCJmYWxzZVwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlucHV0LmdldEF0dHJpYnV0ZShcImRhdGEtdW5pcXVlXCIpID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpbnB1dC50eXBlID09PSAncGFzc3dvcmQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUmVhZFZhbHVlKGlucHV0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaXNVc2FnZVksXG4gIGdldEVsZW1lbnRQYXRoLFxuICBpc1ZhbGlkU2VsZWN0b3IsXG4gIGpvaW5CeWRlbGltaXRlcixcbiAgc3BsaXRCeWRlbGltaXRlcixcbiAgcGFyc2VUZXh0VG9IdG1sLFxuICBVVUlELFxuICBjb25maWdFeGVjdXRlcixcbiAgY29uZmlnTWF0Y2gyLFxuICBnZXRJZnJhbWVGcm9tUGF0aCxcbiAgZmluZElmcmFtZUZyb21FbGVtZW50LFxuICBnZXRUb3BNb3N0V2luZG93LFxuICBjc3NQYXRoLFxuICBhbGxGcmFtZSxcbiAgY2hlY2tWYWx1ZSxcbiAgZ2V0QXR0cmlidXRlcyxcbiAgaXNKc29uU3RyaW5nLFxuICBpc1VwZGF0ZVZhbHVlLFxuICBpc1JlYWRWYWx1ZSxcbiAgZ2V0UGFyZW50RnJvbUVsZW1lbnQsXG4gIGlzUmVhbFRpbWUsXG4gIGdlbmVyYXRlVVVJRFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../CoCreateJS/src/utils.js\n')},"./node_modules/babel-runtime/regenerator/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime-module.js");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9yZWdlbmVyYXRvci9pbmRleC5qcz9kNzg1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVIQUErQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/babel-runtime/regenerator/index.js\n')},"./node_modules/backoff/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar Backoff = __webpack_require__(/*! ./lib/backoff */ "./node_modules/backoff/lib/backoff.js");\nvar ExponentialBackoffStrategy = __webpack_require__(/*! ./lib/strategy/exponential */ "./node_modules/backoff/lib/strategy/exponential.js");\nvar FibonacciBackoffStrategy = __webpack_require__(/*! ./lib/strategy/fibonacci */ "./node_modules/backoff/lib/strategy/fibonacci.js");\nvar FunctionCall = __webpack_require__(/*! ./lib/function_call.js */ "./node_modules/backoff/lib/function_call.js");\n\nmodule.exports.Backoff = Backoff;\nmodule.exports.FunctionCall = FunctionCall;\nmodule.exports.FibonacciStrategy = FibonacciBackoffStrategy;\nmodule.exports.ExponentialStrategy = ExponentialBackoffStrategy;\n\n// Constructs a Fibonacci backoff.\nmodule.exports.fibonacci = function(options) {\n    return new Backoff(new FibonacciBackoffStrategy(options));\n};\n\n// Constructs an exponential backoff.\nmodule.exports.exponential = function(options) {\n    return new Backoff(new ExponentialBackoffStrategy(options));\n};\n\n// Constructs a FunctionCall for the given function and arguments.\nmodule.exports.call = function(fn, vargs, callback) {\n    var args = Array.prototype.slice.call(arguments);\n    fn = args[0];\n    vargs = args.slice(1, args.length - 1);\n    callback = args[args.length - 1];\n    return new FunctionCall(fn, vargs, callback);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9pbmRleC5qcz8wYjM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLDREQUFlO0FBQ3JDLGlDQUFpQyxtQkFBTyxDQUFDLHNGQUE0QjtBQUNyRSwrQkFBK0IsbUJBQU8sQ0FBQyxrRkFBMEI7QUFDakUsbUJBQW1CLG1CQUFPLENBQUMsMkVBQXdCOztBQUVuRCxzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyxrQ0FBa0M7O0FBRWxDO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFja29mZi9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgQmFja29mZiA9IHJlcXVpcmUoJy4vbGliL2JhY2tvZmYnKTtcbnZhciBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneSA9IHJlcXVpcmUoJy4vbGliL3N0cmF0ZWd5L2V4cG9uZW50aWFsJyk7XG52YXIgRmlib25hY2NpQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9saWIvc3RyYXRlZ3kvZmlib25hY2NpJyk7XG52YXIgRnVuY3Rpb25DYWxsID0gcmVxdWlyZSgnLi9saWIvZnVuY3Rpb25fY2FsbC5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5CYWNrb2ZmID0gQmFja29mZjtcbm1vZHVsZS5leHBvcnRzLkZ1bmN0aW9uQ2FsbCA9IEZ1bmN0aW9uQ2FsbDtcbm1vZHVsZS5leHBvcnRzLkZpYm9uYWNjaVN0cmF0ZWd5ID0gRmlib25hY2NpQmFja29mZlN0cmF0ZWd5O1xubW9kdWxlLmV4cG9ydHMuRXhwb25lbnRpYWxTdHJhdGVneSA9IEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5O1xuXG4vLyBDb25zdHJ1Y3RzIGEgRmlib25hY2NpIGJhY2tvZmYuXG5tb2R1bGUuZXhwb3J0cy5maWJvbmFjY2kgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCYWNrb2ZmKG5ldyBGaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykpO1xufTtcblxuLy8gQ29uc3RydWN0cyBhbiBleHBvbmVudGlhbCBiYWNrb2ZmLlxubW9kdWxlLmV4cG9ydHMuZXhwb25lbnRpYWwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCYWNrb2ZmKG5ldyBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneShvcHRpb25zKSk7XG59O1xuXG4vLyBDb25zdHJ1Y3RzIGEgRnVuY3Rpb25DYWxsIGZvciB0aGUgZ2l2ZW4gZnVuY3Rpb24gYW5kIGFyZ3VtZW50cy5cbm1vZHVsZS5leHBvcnRzLmNhbGwgPSBmdW5jdGlvbihmbiwgdmFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGZuID0gYXJnc1swXTtcbiAgICB2YXJncyA9IGFyZ3Muc2xpY2UoMSwgYXJncy5sZW5ndGggLSAxKTtcbiAgICBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbChmbiwgdmFyZ3MsIGNhbGxiYWNrKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/backoff/index.js\n')},"./node_modules/backoff/lib/backoff.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar precond = __webpack_require__(/*! precond */ \"./node_modules/precond/index.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n// A class to hold the state of a backoff operation. Accepts a backoff strategy\n// to generate the backoff delays.\nfunction Backoff(backoffStrategy) {\n    events.EventEmitter.call(this);\n\n    this.backoffStrategy_ = backoffStrategy;\n    this.maxNumberOfRetry_ = -1;\n    this.backoffNumber_ = 0;\n    this.backoffDelay_ = 0;\n    this.timeoutID_ = -1;\n\n    this.handlers = {\n        backoff: this.onBackoff_.bind(this)\n    };\n}\nutil.inherits(Backoff, events.EventEmitter);\n\n// Sets a limit, greater than 0, on the maximum number of backoffs. A 'fail'\n// event will be emitted when the limit is reached.\nBackoff.prototype.failAfter = function(maxNumberOfRetry) {\n    precond.checkArgument(maxNumberOfRetry > 0,\n        'Expected a maximum number of retry greater than 0 but got %s.',\n        maxNumberOfRetry);\n\n    this.maxNumberOfRetry_ = maxNumberOfRetry;\n};\n\n// Starts a backoff operation. Accepts an optional parameter to let the\n// listeners know why the backoff operation was started.\nBackoff.prototype.backoff = function(err) {\n    precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');\n\n    if (this.backoffNumber_ === this.maxNumberOfRetry_) {\n        this.emit('fail', err);\n        this.reset();\n    } else {\n        this.backoffDelay_ = this.backoffStrategy_.next();\n        this.timeoutID_ = setTimeout(this.handlers.backoff, this.backoffDelay_);\n        this.emit('backoff', this.backoffNumber_, this.backoffDelay_, err);\n    }\n};\n\n// Handles the backoff timeout completion.\nBackoff.prototype.onBackoff_ = function() {\n    this.timeoutID_ = -1;\n    this.emit('ready', this.backoffNumber_, this.backoffDelay_);\n    this.backoffNumber_++;\n};\n\n// Stops any backoff operation and resets the backoff delay to its inital value.\nBackoff.prototype.reset = function() {\n    this.backoffNumber_ = 0;\n    this.backoffStrategy_.reset();\n    clearTimeout(this.timeoutID_);\n    this.timeoutID_ = -1;\n};\n\nmodule.exports = Backoff;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvYmFja29mZi5qcz8yODY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtDQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMseUNBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvYmFja29mZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICAgICAgQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbi8vICAgICAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgcHJlY29uZCA9IHJlcXVpcmUoJ3ByZWNvbmQnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBBIGNsYXNzIHRvIGhvbGQgdGhlIHN0YXRlIG9mIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYSBiYWNrb2ZmIHN0cmF0ZWd5XG4vLyB0byBnZW5lcmF0ZSB0aGUgYmFja29mZiBkZWxheXMuXG5mdW5jdGlvbiBCYWNrb2ZmKGJhY2tvZmZTdHJhdGVneSkge1xuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuYmFja29mZlN0cmF0ZWd5XyA9IGJhY2tvZmZTdHJhdGVneTtcbiAgICB0aGlzLm1heE51bWJlck9mUmV0cnlfID0gLTE7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gMDtcbiAgICB0aGlzLnRpbWVvdXRJRF8gPSAtMTtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7XG4gICAgICAgIGJhY2tvZmY6IHRoaXMub25CYWNrb2ZmXy5iaW5kKHRoaXMpXG4gICAgfTtcbn1cbnV0aWwuaW5oZXJpdHMoQmFja29mZiwgZXZlbnRzLkV2ZW50RW1pdHRlcik7XG5cbi8vIFNldHMgYSBsaW1pdCwgZ3JlYXRlciB0aGFuIDAsIG9uIHRoZSBtYXhpbXVtIG51bWJlciBvZiBiYWNrb2Zmcy4gQSAnZmFpbCdcbi8vIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aGVuIHRoZSBsaW1pdCBpcyByZWFjaGVkLlxuQmFja29mZi5wcm90b3R5cGUuZmFpbEFmdGVyID0gZnVuY3Rpb24obWF4TnVtYmVyT2ZSZXRyeSkge1xuICAgIHByZWNvbmQuY2hlY2tBcmd1bWVudChtYXhOdW1iZXJPZlJldHJ5ID4gMCxcbiAgICAgICAgJ0V4cGVjdGVkIGEgbWF4aW11bSBudW1iZXIgb2YgcmV0cnkgZ3JlYXRlciB0aGFuIDAgYnV0IGdvdCAlcy4nLFxuICAgICAgICBtYXhOdW1iZXJPZlJldHJ5KTtcblxuICAgIHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8gPSBtYXhOdW1iZXJPZlJldHJ5O1xufTtcblxuLy8gU3RhcnRzIGEgYmFja29mZiBvcGVyYXRpb24uIEFjY2VwdHMgYW4gb3B0aW9uYWwgcGFyYW1ldGVyIHRvIGxldCB0aGVcbi8vIGxpc3RlbmVycyBrbm93IHdoeSB0aGUgYmFja29mZiBvcGVyYXRpb24gd2FzIHN0YXJ0ZWQuXG5CYWNrb2ZmLnByb3RvdHlwZS5iYWNrb2ZmID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMudGltZW91dElEXyA9PT0gLTEsICdCYWNrb2ZmIGluIHByb2dyZXNzLicpO1xuXG4gICAgaWYgKHRoaXMuYmFja29mZk51bWJlcl8gPT09IHRoaXMubWF4TnVtYmVyT2ZSZXRyeV8pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdmYWlsJywgZXJyKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IHRoaXMuYmFja29mZlN0cmF0ZWd5Xy5uZXh0KCk7XG4gICAgICAgIHRoaXMudGltZW91dElEXyA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVycy5iYWNrb2ZmLCB0aGlzLmJhY2tvZmZEZWxheV8pO1xuICAgICAgICB0aGlzLmVtaXQoJ2JhY2tvZmYnLCB0aGlzLmJhY2tvZmZOdW1iZXJfLCB0aGlzLmJhY2tvZmZEZWxheV8sIGVycik7XG4gICAgfVxufTtcblxuLy8gSGFuZGxlcyB0aGUgYmFja29mZiB0aW1lb3V0IGNvbXBsZXRpb24uXG5CYWNrb2ZmLnByb3RvdHlwZS5vbkJhY2tvZmZfID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG4gICAgdGhpcy5lbWl0KCdyZWFkeScsIHRoaXMuYmFja29mZk51bWJlcl8sIHRoaXMuYmFja29mZkRlbGF5Xyk7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXysrO1xufTtcblxuLy8gU3RvcHMgYW55IGJhY2tvZmYgb3BlcmF0aW9uIGFuZCByZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gaXRzIGluaXRhbCB2YWx1ZS5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5iYWNrb2ZmTnVtYmVyXyA9IDA7XG4gICAgdGhpcy5iYWNrb2ZmU3RyYXRlZ3lfLnJlc2V0KCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEXyk7XG4gICAgdGhpcy50aW1lb3V0SURfID0gLTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/backoff/lib/backoff.js\n")},"./node_modules/backoff/lib/function_call.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar precond = __webpack_require__(/*! precond */ \"./node_modules/precond/index.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nvar Backoff = __webpack_require__(/*! ./backoff */ \"./node_modules/backoff/lib/backoff.js\");\nvar FibonacciBackoffStrategy = __webpack_require__(/*! ./strategy/fibonacci */ \"./node_modules/backoff/lib/strategy/fibonacci.js\");\n\n// Wraps a function to be called in a backoff loop.\nfunction FunctionCall(fn, args, callback) {\n    events.EventEmitter.call(this);\n\n    precond.checkIsFunction(fn, 'Expected fn to be a function.');\n    precond.checkIsArray(args, 'Expected args to be an array.');\n    precond.checkIsFunction(callback, 'Expected callback to be a function.');\n\n    this.function_ = fn;\n    this.arguments_ = args;\n    this.callback_ = callback;\n    this.lastResult_ = [];\n    this.numRetries_ = 0;\n\n    this.backoff_ = null;\n    this.strategy_ = null;\n    this.failAfter_ = -1;\n    this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;\n\n    this.state_ = FunctionCall.State_.PENDING;\n}\nutil.inherits(FunctionCall, events.EventEmitter);\n\n// States in which the call can be.\nFunctionCall.State_ = {\n    // Call isn't started yet.\n    PENDING: 0,\n    // Call is in progress.\n    RUNNING: 1,\n    // Call completed successfully which means that either the wrapped function\n    // returned successfully or the maximal number of backoffs was reached.\n    COMPLETED: 2,\n    // The call was aborted.\n    ABORTED: 3\n};\n\n// The default retry predicate which considers any error as retriable.\nFunctionCall.DEFAULT_RETRY_PREDICATE_ = function(err) {\n  return true;\n};\n\n// Checks whether the call is pending.\nFunctionCall.prototype.isPending = function() {\n    return this.state_ == FunctionCall.State_.PENDING;\n};\n\n// Checks whether the call is in progress.\nFunctionCall.prototype.isRunning = function() {\n    return this.state_ == FunctionCall.State_.RUNNING;\n};\n\n// Checks whether the call is completed.\nFunctionCall.prototype.isCompleted = function() {\n    return this.state_ == FunctionCall.State_.COMPLETED;\n};\n\n// Checks whether the call is aborted.\nFunctionCall.prototype.isAborted = function() {\n    return this.state_ == FunctionCall.State_.ABORTED;\n};\n\n// Sets the backoff strategy to use. Can only be called before the call is\n// started otherwise an exception will be thrown.\nFunctionCall.prototype.setStrategy = function(strategy) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.strategy_ = strategy;\n    return this; // Return this for chaining.\n};\n\n// Sets the predicate which will be used to determine whether the errors\n// returned from the wrapped function should be retried or not, e.g. a\n// network error would be retriable while a type error would stop the\n// function call.\nFunctionCall.prototype.retryIf = function(retryPredicate) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.retryPredicate_ = retryPredicate;\n    return this;\n};\n\n// Returns all intermediary results returned by the wrapped function since\n// the initial call.\nFunctionCall.prototype.getLastResult = function() {\n    return this.lastResult_.concat();\n};\n\n// Returns the number of times the wrapped function call was retried.\nFunctionCall.prototype.getNumRetries = function() {\n    return this.numRetries_;\n};\n\n// Sets the backoff limit.\nFunctionCall.prototype.failAfter = function(maxNumberOfRetry) {\n    precond.checkState(this.isPending(), 'FunctionCall in progress.');\n    this.failAfter_ = maxNumberOfRetry;\n    return this; // Return this for chaining.\n};\n\n// Aborts the call.\nFunctionCall.prototype.abort = function() {\n    if (this.isCompleted() || this.isAborted()) {\n      return;\n    }\n\n    if (this.isRunning()) {\n        this.backoff_.reset();\n    }\n\n    this.state_ = FunctionCall.State_.ABORTED;\n    this.lastResult_ = [new Error('Backoff aborted.')];\n    this.emit('abort');\n    this.doCallback_();\n};\n\n// Initiates the call to the wrapped function. Accepts an optional factory\n// function used to create the backoff instance; used when testing.\nFunctionCall.prototype.start = function(backoffFactory) {\n    precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');\n    precond.checkState(this.isPending(), 'FunctionCall already started.');\n\n    var strategy = this.strategy_ || new FibonacciBackoffStrategy();\n\n    this.backoff_ = backoffFactory ?\n        backoffFactory(strategy) :\n        new Backoff(strategy);\n\n    this.backoff_.on('ready', this.doCall_.bind(this, true /* isRetry */));\n    this.backoff_.on('fail', this.doCallback_.bind(this));\n    this.backoff_.on('backoff', this.handleBackoff_.bind(this));\n\n    if (this.failAfter_ > 0) {\n        this.backoff_.failAfter(this.failAfter_);\n    }\n\n    this.state_ = FunctionCall.State_.RUNNING;\n    this.doCall_(false /* isRetry */);\n};\n\n// Calls the wrapped function.\nFunctionCall.prototype.doCall_ = function(isRetry) {\n    if (isRetry) {\n        this.numRetries_++;\n    }\n    var eventArgs = ['call'].concat(this.arguments_);\n    events.EventEmitter.prototype.emit.apply(this, eventArgs);\n    var callback = this.handleFunctionCallback_.bind(this);\n    this.function_.apply(null, this.arguments_.concat(callback));\n};\n\n// Calls the wrapped function's callback with the last result returned by the\n// wrapped function.\nFunctionCall.prototype.doCallback_ = function() {\n    this.callback_.apply(null, this.lastResult_);\n};\n\n// Handles wrapped function's completion. This method acts as a replacement\n// for the original callback function.\nFunctionCall.prototype.handleFunctionCallback_ = function() {\n    if (this.isAborted()) {\n        return;\n    }\n\n    var args = Array.prototype.slice.call(arguments);\n    this.lastResult_ = args; // Save last callback arguments.\n    events.EventEmitter.prototype.emit.apply(this, ['callback'].concat(args));\n\n    var err = args[0];\n    if (err && this.retryPredicate_(err)) {\n        this.backoff_.backoff(err);\n    } else {\n        this.state_ = FunctionCall.State_.COMPLETED;\n        this.doCallback_();\n    }\n};\n\n// Handles the backoff event by reemitting it.\nFunctionCall.prototype.handleBackoff_ = function(number, delay, err) {\n    this.emit('backoff', number, delay, err);\n};\n\nmodule.exports = FunctionCall;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvZnVuY3Rpb25fY2FsbC5qcz80MmM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLCtDQUFRO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMseUNBQU07O0FBRXpCLGNBQWMsbUJBQU8sQ0FBQyx3REFBVztBQUNqQywrQkFBK0IsbUJBQU8sQ0FBQyw4RUFBc0I7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYWNrb2ZmL2xpYi9mdW5jdGlvbl9jYWxsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciBwcmVjb25kID0gcmVxdWlyZSgncHJlY29uZCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnLi9iYWNrb2ZmJyk7XG52YXIgRmlib25hY2NpQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9zdHJhdGVneS9maWJvbmFjY2knKTtcblxuLy8gV3JhcHMgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgaW4gYSBiYWNrb2ZmIGxvb3AuXG5mdW5jdGlvbiBGdW5jdGlvbkNhbGwoZm4sIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgZXZlbnRzLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgcHJlY29uZC5jaGVja0lzRnVuY3Rpb24oZm4sICdFeHBlY3RlZCBmbiB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIHByZWNvbmQuY2hlY2tJc0FycmF5KGFyZ3MsICdFeHBlY3RlZCBhcmdzIHRvIGJlIGFuIGFycmF5LicpO1xuICAgIHByZWNvbmQuY2hlY2tJc0Z1bmN0aW9uKGNhbGxiYWNrLCAnRXhwZWN0ZWQgY2FsbGJhY2sgdG8gYmUgYSBmdW5jdGlvbi4nKTtcblxuICAgIHRoaXMuZnVuY3Rpb25fID0gZm47XG4gICAgdGhpcy5hcmd1bWVudHNfID0gYXJncztcbiAgICB0aGlzLmNhbGxiYWNrXyA9IGNhbGxiYWNrO1xuICAgIHRoaXMubGFzdFJlc3VsdF8gPSBbXTtcbiAgICB0aGlzLm51bVJldHJpZXNfID0gMDtcblxuICAgIHRoaXMuYmFja29mZl8gPSBudWxsO1xuICAgIHRoaXMuc3RyYXRlZ3lfID0gbnVsbDtcbiAgICB0aGlzLmZhaWxBZnRlcl8gPSAtMTtcbiAgICB0aGlzLnJldHJ5UHJlZGljYXRlXyA9IEZ1bmN0aW9uQ2FsbC5ERUZBVUxUX1JFVFJZX1BSRURJQ0FURV87XG5cbiAgICB0aGlzLnN0YXRlXyA9IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uUEVORElORztcbn1cbnV0aWwuaW5oZXJpdHMoRnVuY3Rpb25DYWxsLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuLy8gU3RhdGVzIGluIHdoaWNoIHRoZSBjYWxsIGNhbiBiZS5cbkZ1bmN0aW9uQ2FsbC5TdGF0ZV8gPSB7XG4gICAgLy8gQ2FsbCBpc24ndCBzdGFydGVkIHlldC5cbiAgICBQRU5ESU5HOiAwLFxuICAgIC8vIENhbGwgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgUlVOTklORzogMSxcbiAgICAvLyBDYWxsIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkgd2hpY2ggbWVhbnMgdGhhdCBlaXRoZXIgdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAgICAvLyByZXR1cm5lZCBzdWNjZXNzZnVsbHkgb3IgdGhlIG1heGltYWwgbnVtYmVyIG9mIGJhY2tvZmZzIHdhcyByZWFjaGVkLlxuICAgIENPTVBMRVRFRDogMixcbiAgICAvLyBUaGUgY2FsbCB3YXMgYWJvcnRlZC5cbiAgICBBQk9SVEVEOiAzXG59O1xuXG4vLyBUaGUgZGVmYXVsdCByZXRyeSBwcmVkaWNhdGUgd2hpY2ggY29uc2lkZXJzIGFueSBlcnJvciBhcyByZXRyaWFibGUuXG5GdW5jdGlvbkNhbGwuREVGQVVMVF9SRVRSWV9QUkVESUNBVEVfID0gZnVuY3Rpb24oZXJyKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgcGVuZGluZy5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVfID09IEZ1bmN0aW9uQ2FsbC5TdGF0ZV8uUEVORElORztcbn07XG5cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBjYWxsIGlzIGluIHByb2dyZXNzLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pc1J1bm5pbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZV8gPT0gRnVuY3Rpb25DYWxsLlN0YXRlXy5SVU5OSU5HO1xufTtcblxuLy8gQ2hlY2tzIHdoZXRoZXIgdGhlIGNhbGwgaXMgY29tcGxldGVkLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5pc0NvbXBsZXRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXyA9PSBGdW5jdGlvbkNhbGwuU3RhdGVfLkNPTVBMRVRFRDtcbn07XG5cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBjYWxsIGlzIGFib3J0ZWQuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmlzQWJvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlXyA9PSBGdW5jdGlvbkNhbGwuU3RhdGVfLkFCT1JURUQ7XG59O1xuXG4vLyBTZXRzIHRoZSBiYWNrb2ZmIHN0cmF0ZWd5IHRvIHVzZS4gQ2FuIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSB0aGUgY2FsbCBpc1xuLy8gc3RhcnRlZCBvdGhlcndpc2UgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5zZXRTdHJhdGVneSA9IGZ1bmN0aW9uKHN0cmF0ZWd5KSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMuaXNQZW5kaW5nKCksICdGdW5jdGlvbkNhbGwgaW4gcHJvZ3Jlc3MuJyk7XG4gICAgdGhpcy5zdHJhdGVneV8gPSBzdHJhdGVneTtcbiAgICByZXR1cm4gdGhpczsgLy8gUmV0dXJuIHRoaXMgZm9yIGNoYWluaW5nLlxufTtcblxuLy8gU2V0cyB0aGUgcHJlZGljYXRlIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGUgZXJyb3JzXG4vLyByZXR1cm5lZCBmcm9tIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIHNob3VsZCBiZSByZXRyaWVkIG9yIG5vdCwgZS5nLiBhXG4vLyBuZXR3b3JrIGVycm9yIHdvdWxkIGJlIHJldHJpYWJsZSB3aGlsZSBhIHR5cGUgZXJyb3Igd291bGQgc3RvcCB0aGVcbi8vIGZ1bmN0aW9uIGNhbGwuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLnJldHJ5SWYgPSBmdW5jdGlvbihyZXRyeVByZWRpY2F0ZSkge1xuICAgIHByZWNvbmQuY2hlY2tTdGF0ZSh0aGlzLmlzUGVuZGluZygpLCAnRnVuY3Rpb25DYWxsIGluIHByb2dyZXNzLicpO1xuICAgIHRoaXMucmV0cnlQcmVkaWNhdGVfID0gcmV0cnlQcmVkaWNhdGU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBSZXR1cm5zIGFsbCBpbnRlcm1lZGlhcnkgcmVzdWx0cyByZXR1cm5lZCBieSB0aGUgd3JhcHBlZCBmdW5jdGlvbiBzaW5jZVxuLy8gdGhlIGluaXRpYWwgY2FsbC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZ2V0TGFzdFJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHRfLmNvbmNhdCgpO1xufTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSB3cmFwcGVkIGZ1bmN0aW9uIGNhbGwgd2FzIHJldHJpZWQuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmdldE51bVJldHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5udW1SZXRyaWVzXztcbn07XG5cbi8vIFNldHMgdGhlIGJhY2tvZmYgbGltaXQuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmZhaWxBZnRlciA9IGZ1bmN0aW9uKG1heE51bWJlck9mUmV0cnkpIHtcbiAgICBwcmVjb25kLmNoZWNrU3RhdGUodGhpcy5pc1BlbmRpbmcoKSwgJ0Z1bmN0aW9uQ2FsbCBpbiBwcm9ncmVzcy4nKTtcbiAgICB0aGlzLmZhaWxBZnRlcl8gPSBtYXhOdW1iZXJPZlJldHJ5O1xuICAgIHJldHVybiB0aGlzOyAvLyBSZXR1cm4gdGhpcyBmb3IgY2hhaW5pbmcuXG59O1xuXG4vLyBBYm9ydHMgdGhlIGNhbGwuXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNDb21wbGV0ZWQoKSB8fCB0aGlzLmlzQWJvcnRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmXy5yZXNldCgpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGVfID0gRnVuY3Rpb25DYWxsLlN0YXRlXy5BQk9SVEVEO1xuICAgIHRoaXMubGFzdFJlc3VsdF8gPSBbbmV3IEVycm9yKCdCYWNrb2ZmIGFib3J0ZWQuJyldO1xuICAgIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgICB0aGlzLmRvQ2FsbGJhY2tfKCk7XG59O1xuXG4vLyBJbml0aWF0ZXMgdGhlIGNhbGwgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24uIEFjY2VwdHMgYW4gb3B0aW9uYWwgZmFjdG9yeVxuLy8gZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgdGhlIGJhY2tvZmYgaW5zdGFuY2U7IHVzZWQgd2hlbiB0ZXN0aW5nLlxuRnVuY3Rpb25DYWxsLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGJhY2tvZmZGYWN0b3J5KSB7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKCF0aGlzLmlzQWJvcnRlZCgpLCAnRnVuY3Rpb25DYWxsIGlzIGFib3J0ZWQuJyk7XG4gICAgcHJlY29uZC5jaGVja1N0YXRlKHRoaXMuaXNQZW5kaW5nKCksICdGdW5jdGlvbkNhbGwgYWxyZWFkeSBzdGFydGVkLicpO1xuXG4gICAgdmFyIHN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneV8gfHwgbmV3IEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneSgpO1xuXG4gICAgdGhpcy5iYWNrb2ZmXyA9IGJhY2tvZmZGYWN0b3J5ID9cbiAgICAgICAgYmFja29mZkZhY3Rvcnkoc3RyYXRlZ3kpIDpcbiAgICAgICAgbmV3IEJhY2tvZmYoc3RyYXRlZ3kpO1xuXG4gICAgdGhpcy5iYWNrb2ZmXy5vbigncmVhZHknLCB0aGlzLmRvQ2FsbF8uYmluZCh0aGlzLCB0cnVlIC8qIGlzUmV0cnkgKi8pKTtcbiAgICB0aGlzLmJhY2tvZmZfLm9uKCdmYWlsJywgdGhpcy5kb0NhbGxiYWNrXy5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmJhY2tvZmZfLm9uKCdiYWNrb2ZmJywgdGhpcy5oYW5kbGVCYWNrb2ZmXy5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLmZhaWxBZnRlcl8gPiAwKSB7XG4gICAgICAgIHRoaXMuYmFja29mZl8uZmFpbEFmdGVyKHRoaXMuZmFpbEFmdGVyXyk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZV8gPSBGdW5jdGlvbkNhbGwuU3RhdGVfLlJVTk5JTkc7XG4gICAgdGhpcy5kb0NhbGxfKGZhbHNlIC8qIGlzUmV0cnkgKi8pO1xufTtcblxuLy8gQ2FsbHMgdGhlIHdyYXBwZWQgZnVuY3Rpb24uXG5GdW5jdGlvbkNhbGwucHJvdG90eXBlLmRvQ2FsbF8gPSBmdW5jdGlvbihpc1JldHJ5KSB7XG4gICAgaWYgKGlzUmV0cnkpIHtcbiAgICAgICAgdGhpcy5udW1SZXRyaWVzXysrO1xuICAgIH1cbiAgICB2YXIgZXZlbnRBcmdzID0gWydjYWxsJ10uY29uY2F0KHRoaXMuYXJndW1lbnRzXyk7XG4gICAgZXZlbnRzLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdC5hcHBseSh0aGlzLCBldmVudEFyZ3MpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuaGFuZGxlRnVuY3Rpb25DYWxsYmFja18uYmluZCh0aGlzKTtcbiAgICB0aGlzLmZ1bmN0aW9uXy5hcHBseShudWxsLCB0aGlzLmFyZ3VtZW50c18uY29uY2F0KGNhbGxiYWNrKSk7XG59O1xuXG4vLyBDYWxscyB0aGUgd3JhcHBlZCBmdW5jdGlvbidzIGNhbGxiYWNrIHdpdGggdGhlIGxhc3QgcmVzdWx0IHJldHVybmVkIGJ5IHRoZVxuLy8gd3JhcHBlZCBmdW5jdGlvbi5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuZG9DYWxsYmFja18gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNhbGxiYWNrXy5hcHBseShudWxsLCB0aGlzLmxhc3RSZXN1bHRfKTtcbn07XG5cbi8vIEhhbmRsZXMgd3JhcHBlZCBmdW5jdGlvbidzIGNvbXBsZXRpb24uIFRoaXMgbWV0aG9kIGFjdHMgYXMgYSByZXBsYWNlbWVudFxuLy8gZm9yIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbi5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaGFuZGxlRnVuY3Rpb25DYWxsYmFja18gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc0Fib3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHRoaXMubGFzdFJlc3VsdF8gPSBhcmdzOyAvLyBTYXZlIGxhc3QgY2FsbGJhY2sgYXJndW1lbnRzLlxuICAgIGV2ZW50cy5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQuYXBwbHkodGhpcywgWydjYWxsYmFjayddLmNvbmNhdChhcmdzKSk7XG5cbiAgICB2YXIgZXJyID0gYXJnc1swXTtcbiAgICBpZiAoZXJyICYmIHRoaXMucmV0cnlQcmVkaWNhdGVfKGVycikpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmXy5iYWNrb2ZmKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zdGF0ZV8gPSBGdW5jdGlvbkNhbGwuU3RhdGVfLkNPTVBMRVRFRDtcbiAgICAgICAgdGhpcy5kb0NhbGxiYWNrXygpO1xuICAgIH1cbn07XG5cbi8vIEhhbmRsZXMgdGhlIGJhY2tvZmYgZXZlbnQgYnkgcmVlbWl0dGluZyBpdC5cbkZ1bmN0aW9uQ2FsbC5wcm90b3R5cGUuaGFuZGxlQmFja29mZl8gPSBmdW5jdGlvbihudW1iZXIsIGRlbGF5LCBlcnIpIHtcbiAgICB0aGlzLmVtaXQoJ2JhY2tvZmYnLCBudW1iZXIsIGRlbGF5LCBlcnIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbkNhbGw7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/backoff/lib/function_call.js\n")},"./node_modules/backoff/lib/strategy/exponential.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar util = __webpack_require__(/*! util */ "./node_modules/util/util.js");\nvar precond = __webpack_require__(/*! precond */ "./node_modules/precond/index.js");\n\nvar BackoffStrategy = __webpack_require__(/*! ./strategy */ "./node_modules/backoff/lib/strategy/strategy.js");\n\n// Exponential backoff strategy.\nfunction ExponentialBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;\n\n    if (options && options.factor !== undefined) {\n        precond.checkArgument(options.factor > 1,\n            \'Exponential factor should be greater than 1 but got %s.\',\n            options.factor);\n        this.factor_ = options.factor;\n    }\n}\nutil.inherits(ExponentialBackoffStrategy, BackoffStrategy);\n\n// Default multiplication factor used to compute the next backoff delay from\n// the current one. The value can be overridden by passing a custom factor as\n// part of the options.\nExponentialBackoffStrategy.DEFAULT_FACTOR = 2;\n\nExponentialBackoffStrategy.prototype.next_ = function() {\n    this.backoffDelay_ = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;\n    return this.backoffDelay_;\n};\n\nExponentialBackoffStrategy.prototype.reset_ = function() {\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n};\n\nmodule.exports = ExponentialBackoffStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvc3RyYXRlZ3kvZXhwb25lbnRpYWwuanM/ZjNkYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyx5Q0FBTTtBQUN6QixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CLHNCQUFzQixtQkFBTyxDQUFDLG1FQUFZOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JhY2tvZmYvbGliL3N0cmF0ZWd5L2V4cG9uZW50aWFsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIHByZWNvbmQgPSByZXF1aXJlKCdwcmVjb25kJyk7XG5cbnZhciBCYWNrb2ZmU3RyYXRlZ3kgPSByZXF1aXJlKCcuL3N0cmF0ZWd5Jyk7XG5cbi8vIEV4cG9uZW50aWFsIGJhY2tvZmYgc3RyYXRlZ3kuXG5mdW5jdGlvbiBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneShvcHRpb25zKSB7XG4gICAgQmFja29mZlN0cmF0ZWd5LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gMDtcbiAgICB0aGlzLm5leHRCYWNrb2ZmRGVsYXlfID0gdGhpcy5nZXRJbml0aWFsRGVsYXkoKTtcbiAgICB0aGlzLmZhY3Rvcl8gPSBFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneS5ERUZBVUxUX0ZBQ1RPUjtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZmFjdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJlY29uZC5jaGVja0FyZ3VtZW50KG9wdGlvbnMuZmFjdG9yID4gMSxcbiAgICAgICAgICAgICdFeHBvbmVudGlhbCBmYWN0b3Igc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiAxIGJ1dCBnb3QgJXMuJyxcbiAgICAgICAgICAgIG9wdGlvbnMuZmFjdG9yKTtcbiAgICAgICAgdGhpcy5mYWN0b3JfID0gb3B0aW9ucy5mYWN0b3I7XG4gICAgfVxufVxudXRpbC5pbmhlcml0cyhFeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneSwgQmFja29mZlN0cmF0ZWd5KTtcblxuLy8gRGVmYXVsdCBtdWx0aXBsaWNhdGlvbiBmYWN0b3IgdXNlZCB0byBjb21wdXRlIHRoZSBuZXh0IGJhY2tvZmYgZGVsYXkgZnJvbVxuLy8gdGhlIGN1cnJlbnQgb25lLiBUaGUgdmFsdWUgY2FuIGJlIG92ZXJyaWRkZW4gYnkgcGFzc2luZyBhIGN1c3RvbSBmYWN0b3IgYXNcbi8vIHBhcnQgb2YgdGhlIG9wdGlvbnMuXG5FeHBvbmVudGlhbEJhY2tvZmZTdHJhdGVneS5ERUZBVUxUX0ZBQ1RPUiA9IDI7XG5cbkV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5LnByb3RvdHlwZS5uZXh0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IE1hdGgubWluKHRoaXMubmV4dEJhY2tvZmZEZWxheV8sIHRoaXMuZ2V0TWF4RGVsYXkoKSk7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuYmFja29mZkRlbGF5XyAqIHRoaXMuZmFjdG9yXztcbiAgICByZXR1cm4gdGhpcy5iYWNrb2ZmRGVsYXlfO1xufTtcblxuRXhwb25lbnRpYWxCYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyA9IHRoaXMuZ2V0SW5pdGlhbERlbGF5KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/backoff/lib/strategy/exponential.js\n')},"./node_modules/backoff/lib/strategy/fibonacci.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar util = __webpack_require__(/*! util */ "./node_modules/util/util.js");\n\nvar BackoffStrategy = __webpack_require__(/*! ./strategy */ "./node_modules/backoff/lib/strategy/strategy.js");\n\n// Fibonacci backoff strategy.\nfunction FibonacciBackoffStrategy(options) {\n    BackoffStrategy.call(this, options);\n    this.backoffDelay_ = 0;\n    this.nextBackoffDelay_ = this.getInitialDelay();\n}\nutil.inherits(FibonacciBackoffStrategy, BackoffStrategy);\n\nFibonacciBackoffStrategy.prototype.next_ = function() {\n    var backoffDelay = Math.min(this.nextBackoffDelay_, this.getMaxDelay());\n    this.nextBackoffDelay_ += this.backoffDelay_;\n    this.backoffDelay_ = backoffDelay;\n    return backoffDelay;\n};\n\nFibonacciBackoffStrategy.prototype.reset_ = function() {\n    this.nextBackoffDelay_ = this.getInitialDelay();\n    this.backoffDelay_ = 0;\n};\n\nmodule.exports = FibonacciBackoffStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvc3RyYXRlZ3kvZmlib25hY2NpLmpzPzFjZWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMseUNBQU07O0FBRXpCLHNCQUFzQixtQkFBTyxDQUFDLG1FQUFZOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvc3RyYXRlZ3kvZmlib25hY2NpLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG52YXIgQmFja29mZlN0cmF0ZWd5ID0gcmVxdWlyZSgnLi9zdHJhdGVneScpO1xuXG4vLyBGaWJvbmFjY2kgYmFja29mZiBzdHJhdGVneS5cbmZ1bmN0aW9uIEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneShvcHRpb25zKSB7XG4gICAgQmFja29mZlN0cmF0ZWd5LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gMDtcbiAgICB0aGlzLm5leHRCYWNrb2ZmRGVsYXlfID0gdGhpcy5nZXRJbml0aWFsRGVsYXkoKTtcbn1cbnV0aWwuaW5oZXJpdHMoRmlib25hY2NpQmFja29mZlN0cmF0ZWd5LCBCYWNrb2ZmU3RyYXRlZ3kpO1xuXG5GaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLm5leHRfID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhY2tvZmZEZWxheSA9IE1hdGgubWluKHRoaXMubmV4dEJhY2tvZmZEZWxheV8sIHRoaXMuZ2V0TWF4RGVsYXkoKSk7XG4gICAgdGhpcy5uZXh0QmFja29mZkRlbGF5XyArPSB0aGlzLmJhY2tvZmZEZWxheV87XG4gICAgdGhpcy5iYWNrb2ZmRGVsYXlfID0gYmFja29mZkRlbGF5O1xuICAgIHJldHVybiBiYWNrb2ZmRGVsYXk7XG59O1xuXG5GaWJvbmFjY2lCYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0XyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubmV4dEJhY2tvZmZEZWxheV8gPSB0aGlzLmdldEluaXRpYWxEZWxheSgpO1xuICAgIHRoaXMuYmFja29mZkRlbGF5XyA9IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpYm9uYWNjaUJhY2tvZmZTdHJhdGVneTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/backoff/lib/strategy/fibonacci.js\n')},"./node_modules/backoff/lib/strategy/strategy.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("//      Copyright (c) 2012 Mathieu Turcotte\n//      Licensed under the MIT license.\n\nvar events = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nfunction isDef(value) {\n    return value !== undefined && value !== null;\n}\n\n// Abstract class defining the skeleton for the backoff strategies. Accepts an\n// object holding the options for the backoff strategy:\n//\n//  * `randomisationFactor`: The randomisation factor which must be between 0\n//     and 1 where 1 equates to a randomization factor of 100% and 0 to no\n//     randomization.\n//  * `initialDelay`: The backoff initial delay in milliseconds.\n//  * `maxDelay`: The backoff maximal delay in milliseconds.\nfunction BackoffStrategy(options) {\n    options = options || {};\n\n    if (isDef(options.initialDelay) && options.initialDelay < 1) {\n        throw new Error('The initial timeout must be greater than 0.');\n    } else if (isDef(options.maxDelay) && options.maxDelay < 1) {\n        throw new Error('The maximal timeout must be greater than 0.');\n    }\n\n    this.initialDelay_ = options.initialDelay || 100;\n    this.maxDelay_ = options.maxDelay || 10000;\n\n    if (this.maxDelay_ <= this.initialDelay_) {\n        throw new Error('The maximal backoff delay must be ' +\n                        'greater than the initial backoff delay.');\n    }\n\n    if (isDef(options.randomisationFactor) &&\n        (options.randomisationFactor < 0 || options.randomisationFactor > 1)) {\n        throw new Error('The randomisation factor must be between 0 and 1.');\n    }\n\n    this.randomisationFactor_ = options.randomisationFactor || 0;\n}\n\n// Gets the maximal backoff delay.\nBackoffStrategy.prototype.getMaxDelay = function() {\n    return this.maxDelay_;\n};\n\n// Gets the initial backoff delay.\nBackoffStrategy.prototype.getInitialDelay = function() {\n    return this.initialDelay_;\n};\n\n// Template method that computes and returns the next backoff delay in\n// milliseconds.\nBackoffStrategy.prototype.next = function() {\n    var backoffDelay = this.next_();\n    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor_;\n    var randomizedDelay = Math.round(backoffDelay * randomisationMultiple);\n    return randomizedDelay;\n};\n\n// Computes and returns the next backoff delay. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.next_ = function() {\n    throw new Error('BackoffStrategy.next_() unimplemented.');\n};\n\n// Template method that resets the backoff delay to its initial value.\nBackoffStrategy.prototype.reset = function() {\n    this.reset_();\n};\n\n// Resets the backoff delay to its initial value. Intended to be overridden by\n// subclasses.\nBackoffStrategy.prototype.reset_ = function() {\n    throw new Error('BackoffStrategy.reset_() unimplemented.');\n};\n\nmodule.exports = BackoffStrategy;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvYmFja29mZi9saWIvc3RyYXRlZ3kvc3RyYXRlZ3kuanM/OTEzOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQywrQ0FBUTtBQUM3QixXQUFXLG1CQUFPLENBQUMseUNBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2JhY2tvZmYvbGliL3N0cmF0ZWd5L3N0cmF0ZWd5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gICAgICBDb3B5cmlnaHQgKGMpIDIwMTIgTWF0aGlldSBUdXJjb3R0ZVxuLy8gICAgICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBpc0RlZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsO1xufVxuXG4vLyBBYnN0cmFjdCBjbGFzcyBkZWZpbmluZyB0aGUgc2tlbGV0b24gZm9yIHRoZSBiYWNrb2ZmIHN0cmF0ZWdpZXMuIEFjY2VwdHMgYW5cbi8vIG9iamVjdCBob2xkaW5nIHRoZSBvcHRpb25zIGZvciB0aGUgYmFja29mZiBzdHJhdGVneTpcbi8vXG4vLyAgKiBgcmFuZG9taXNhdGlvbkZhY3RvcmA6IFRoZSByYW5kb21pc2F0aW9uIGZhY3RvciB3aGljaCBtdXN0IGJlIGJldHdlZW4gMFxuLy8gICAgIGFuZCAxIHdoZXJlIDEgZXF1YXRlcyB0byBhIHJhbmRvbWl6YXRpb24gZmFjdG9yIG9mIDEwMCUgYW5kIDAgdG8gbm9cbi8vICAgICByYW5kb21pemF0aW9uLlxuLy8gICogYGluaXRpYWxEZWxheWA6IFRoZSBiYWNrb2ZmIGluaXRpYWwgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLlxuLy8gICogYG1heERlbGF5YDogVGhlIGJhY2tvZmYgbWF4aW1hbCBkZWxheSBpbiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiBCYWNrb2ZmU3RyYXRlZ3kob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKGlzRGVmKG9wdGlvbnMuaW5pdGlhbERlbGF5KSAmJiBvcHRpb25zLmluaXRpYWxEZWxheSA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5pdGlhbCB0aW1lb3V0IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuJyk7XG4gICAgfSBlbHNlIGlmIChpc0RlZihvcHRpb25zLm1heERlbGF5KSAmJiBvcHRpb25zLm1heERlbGF5IDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtYXhpbWFsIHRpbWVvdXQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRpYWxEZWxheV8gPSBvcHRpb25zLmluaXRpYWxEZWxheSB8fCAxMDA7XG4gICAgdGhpcy5tYXhEZWxheV8gPSBvcHRpb25zLm1heERlbGF5IHx8IDEwMDAwO1xuXG4gICAgaWYgKHRoaXMubWF4RGVsYXlfIDw9IHRoaXMuaW5pdGlhbERlbGF5Xykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBtYXhpbWFsIGJhY2tvZmYgZGVsYXkgbXVzdCBiZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdncmVhdGVyIHRoYW4gdGhlIGluaXRpYWwgYmFja29mZiBkZWxheS4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZWYob3B0aW9ucy5yYW5kb21pc2F0aW9uRmFjdG9yKSAmJlxuICAgICAgICAob3B0aW9ucy5yYW5kb21pc2F0aW9uRmFjdG9yIDwgMCB8fCBvcHRpb25zLnJhbmRvbWlzYXRpb25GYWN0b3IgPiAxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByYW5kb21pc2F0aW9uIGZhY3RvciBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS4nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJhbmRvbWlzYXRpb25GYWN0b3JfID0gb3B0aW9ucy5yYW5kb21pc2F0aW9uRmFjdG9yIHx8IDA7XG59XG5cbi8vIEdldHMgdGhlIG1heGltYWwgYmFja29mZiBkZWxheS5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUuZ2V0TWF4RGVsYXkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhEZWxheV87XG59O1xuXG4vLyBHZXRzIHRoZSBpbml0aWFsIGJhY2tvZmYgZGVsYXkuXG5CYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLmdldEluaXRpYWxEZWxheSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmluaXRpYWxEZWxheV87XG59O1xuXG4vLyBUZW1wbGF0ZSBtZXRob2QgdGhhdCBjb21wdXRlcyBhbmQgcmV0dXJucyB0aGUgbmV4dCBiYWNrb2ZmIGRlbGF5IGluXG4vLyBtaWxsaXNlY29uZHMuXG5CYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFja29mZkRlbGF5ID0gdGhpcy5uZXh0XygpO1xuICAgIHZhciByYW5kb21pc2F0aW9uTXVsdGlwbGUgPSAxICsgTWF0aC5yYW5kb20oKSAqIHRoaXMucmFuZG9taXNhdGlvbkZhY3Rvcl87XG4gICAgdmFyIHJhbmRvbWl6ZWREZWxheSA9IE1hdGgucm91bmQoYmFja29mZkRlbGF5ICogcmFuZG9taXNhdGlvbk11bHRpcGxlKTtcbiAgICByZXR1cm4gcmFuZG9taXplZERlbGF5O1xufTtcblxuLy8gQ29tcHV0ZXMgYW5kIHJldHVybnMgdGhlIG5leHQgYmFja29mZiBkZWxheS4gSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieVxuLy8gc3ViY2xhc3Nlcy5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUubmV4dF8gPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhY2tvZmZTdHJhdGVneS5uZXh0XygpIHVuaW1wbGVtZW50ZWQuJyk7XG59O1xuXG4vLyBUZW1wbGF0ZSBtZXRob2QgdGhhdCByZXNldHMgdGhlIGJhY2tvZmYgZGVsYXkgdG8gaXRzIGluaXRpYWwgdmFsdWUuXG5CYWNrb2ZmU3RyYXRlZ3kucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZXNldF8oKTtcbn07XG5cbi8vIFJlc2V0cyB0aGUgYmFja29mZiBkZWxheSB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gSW50ZW5kZWQgdG8gYmUgb3ZlcnJpZGRlbiBieVxuLy8gc3ViY2xhc3Nlcy5cbkJhY2tvZmZTdHJhdGVneS5wcm90b3R5cGUucmVzZXRfID0gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCYWNrb2ZmU3RyYXRlZ3kucmVzZXRfKCkgdW5pbXBsZW1lbnRlZC4nKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZlN0cmF0ZWd5O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/backoff/lib/strategy/strategy.js\n")},"./node_modules/call-bind/callBound.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar callBind = __webpack_require__(/*! ./ */ \"./node_modules/call-bind/index.js\");\n\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\n\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\n\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\n\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\n\t\treturn callBind(intrinsic);\n\t}\n\treturn intrinsic;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcz81NDVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixtQkFBTyxDQUFDLDREQUFlOztBQUUxQyxlQUFlLG1CQUFPLENBQUMsNkNBQUk7O0FBRTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9jYWxsQm91bmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJy4vJyk7XG5cbnZhciAkaW5kZXhPZiA9IGNhbGxCaW5kKEdldEludHJpbnNpYygnU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcblx0dmFyIGludHJpbnNpYyA9IEdldEludHJpbnNpYyhuYW1lLCAhIWFsbG93TWlzc2luZyk7XG5cdGlmICh0eXBlb2YgaW50cmluc2ljID09PSAnZnVuY3Rpb24nICYmICRpbmRleE9mKG5hbWUsICcucHJvdG90eXBlLicpID4gLTEpIHtcblx0XHRyZXR1cm4gY2FsbEJpbmQoaW50cmluc2ljKTtcblx0fVxuXHRyZXR1cm4gaW50cmluc2ljO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/call-bind/callBound.js\n")},"./node_modules/call-bind/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\nvar $call = GetIntrinsic('%Function.prototype.call%');\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\nvar $max = GetIntrinsic('%Math.max%');\n\nif ($defineProperty) {\n\ttry {\n\t\t$defineProperty({}, 'a', { value: 1 });\n\t} catch (e) {\n\t\t// IE 8 has a broken defineProperty\n\t\t$defineProperty = null;\n\t}\n}\n\nmodule.exports = function callBind(originalFunction) {\n\tvar func = $reflectApply(bind, $call, arguments);\n\tif ($gOPD && $defineProperty) {\n\t\tvar desc = $gOPD(func, 'length');\n\t\tif (desc.configurable) {\n\t\t\t// original length, plus the receiver, minus any additional arguments (after the receiver)\n\t\t\t$defineProperty(\n\t\t\t\tfunc,\n\t\t\t\t'length',\n\t\t\t\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\n\t\t\t);\n\t\t}\n\t}\n\treturn func;\n};\n\nvar applyBind = function applyBind() {\n\treturn $reflectApply(bind, $apply, arguments);\n};\n\nif ($defineProperty) {\n\t$defineProperty(module.exports, 'apply', { value: applyBind });\n} else {\n\tmodule.exports.apply = applyBind;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2luZGV4LmpzPzNlYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLDREQUFlO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDREQUFlOztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxXQUFXO0FBQ3ZDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsbUJBQW1CO0FBQzlELENBQUM7QUFDRCxDQUFDLG9CQUFvQjtBQUNyQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRhcHBseSA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseSUnKTtcbnZhciAkY2FsbCA9IEdldEludHJpbnNpYygnJUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsJScpO1xudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcblxudmFyICRnT1BEID0gR2V0SW50cmluc2ljKCclT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciUnLCB0cnVlKTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XG52YXIgJG1heCA9IEdldEludHJpbnNpYygnJU1hdGgubWF4JScpO1xuXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdHRyeSB7XG5cdFx0JGRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgdmFsdWU6IDEgfSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBkZWZpbmVQcm9wZXJ0eVxuXHRcdCRkZWZpbmVQcm9wZXJ0eSA9IG51bGw7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XG5cdHZhciBmdW5jID0gJHJlZmxlY3RBcHBseShiaW5kLCAkY2FsbCwgYXJndW1lbnRzKTtcblx0aWYgKCRnT1BEICYmICRkZWZpbmVQcm9wZXJ0eSkge1xuXHRcdHZhciBkZXNjID0gJGdPUEQoZnVuYywgJ2xlbmd0aCcpO1xuXHRcdGlmIChkZXNjLmNvbmZpZ3VyYWJsZSkge1xuXHRcdFx0Ly8gb3JpZ2luYWwgbGVuZ3RoLCBwbHVzIHRoZSByZWNlaXZlciwgbWludXMgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIChhZnRlciB0aGUgcmVjZWl2ZXIpXG5cdFx0XHQkZGVmaW5lUHJvcGVydHkoXG5cdFx0XHRcdGZ1bmMsXG5cdFx0XHRcdCdsZW5ndGgnLFxuXHRcdFx0XHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBmdW5jO1xufTtcblxudmFyIGFwcGx5QmluZCA9IGZ1bmN0aW9uIGFwcGx5QmluZCgpIHtcblx0cmV0dXJuICRyZWZsZWN0QXBwbHkoYmluZCwgJGFwcGx5LCBhcmd1bWVudHMpO1xufTtcblxuaWYgKCRkZWZpbmVQcm9wZXJ0eSkge1xuXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/call-bind/index.js\n")},"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \"./node_modules/get-intrinsic/index.js\");\n\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%');\nif ($gOPD) {\n\ttry {\n\t\t$gOPD([], 'length');\n\t} catch (e) {\n\t\t// IE 8 has a broken gOPD\n\t\t$gOPD = null;\n\t}\n}\n\nmodule.exports = $gOPD;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanM/MWRkMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyw0REFBZTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBHZXRJbnRyaW5zaWMgPSByZXF1aXJlKCdnZXQtaW50cmluc2ljJyk7XG5cbnZhciAkZ09QRCA9IEdldEludHJpbnNpYygnJU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IlJyk7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRChbXSwgJ2xlbmd0aCcpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZ09QRFxuXHRcdCRnT1BEID0gbnVsbDtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9ICRnT1BEO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\n")},"./node_modules/events/events.js":module=>{"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLHlCQUF5QjtBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBLDZEQUE2RCxhQUFhO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/events/events.js\n")},"./node_modules/foreach/index.js":module=>{eval("\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcz9iZmFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKG9iaiwgZm4sIGN0eCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKGZuKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIGwgPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsID09PSArbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwob2JqLCBrKSkge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpba10sIGssIG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/foreach/index.js\n")},"./node_modules/function-bind/implementation.js":module=>{"use strict";eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcz82ODhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBLDhFQUE4RSxxQ0FBcUMsRUFBRTs7QUFFckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IG5vLWludmFsaWQtdGhpczogMSAqL1xuXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKHRoYXQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0b1N0ci5jYWxsKHRhcmdldCkgIT09IGZ1bmNUeXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRVJST1JfTUVTU0FHRSArIHRhcmdldCk7XG4gICAgfVxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gICAgdmFyIGJvdW5kO1xuICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgfVxuXG4gICAgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgdmFyIEVtcHR5ID0gZnVuY3Rpb24gRW1wdHkoKSB7fTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/function-bind/implementation.js\n")},"./node_modules/function-bind/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");\n\nmodule.exports = Function.prototype.bind || implementation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcz8wZjdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHdFQUFrQjs7QUFFL0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/function-bind/index.js\n')},"./node_modules/get-intrinsic/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar undefined;\n\nvar $SyntaxError = SyntaxError;\nvar $Function = Function;\nvar $TypeError = TypeError;\n\n// eslint-disable-next-line consistent-return\nvar getEvalledConstructor = function (expressionSyntax) {\n\ttry {\n\t\treturn $Function('\"use strict\"; return (' + expressionSyntax + ').constructor;')();\n\t} catch (e) {}\n};\n\nvar $gOPD = Object.getOwnPropertyDescriptor;\nif ($gOPD) {\n\ttry {\n\t\t$gOPD({}, '');\n\t} catch (e) {\n\t\t$gOPD = null; // this is IE 8, which has a broken gOPD\n\t}\n}\n\nvar throwTypeError = function () {\n\tthrow new $TypeError();\n};\nvar ThrowTypeError = $gOPD\n\t? (function () {\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\n\t\t\targuments.callee; // IE 8 does not throw here\n\t\t\treturn throwTypeError;\n\t\t} catch (calleeThrows) {\n\t\t\ttry {\n\t\t\t\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\n\t\t\t\treturn $gOPD(arguments, 'callee').get;\n\t\t\t} catch (gOPDthrows) {\n\t\t\t\treturn throwTypeError;\n\t\t\t}\n\t\t}\n\t}())\n\t: throwTypeError;\n\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar needsEval = {};\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\n\t'%Array%': Array,\n\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'%AsyncFromSyncIteratorPrototype%': undefined,\n\t'%AsyncFunction%': needsEval,\n\t'%AsyncGenerator%': needsEval,\n\t'%AsyncGeneratorFunction%': needsEval,\n\t'%AsyncIteratorPrototype%': needsEval,\n\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\n\t'%Boolean%': Boolean,\n\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'%Date%': Date,\n\t'%decodeURI%': decodeURI,\n\t'%decodeURIComponent%': decodeURIComponent,\n\t'%encodeURI%': encodeURI,\n\t'%encodeURIComponent%': encodeURIComponent,\n\t'%Error%': Error,\n\t'%eval%': eval, // eslint-disable-line no-eval\n\t'%EvalError%': EvalError,\n\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\n\t'%Function%': $Function,\n\t'%GeneratorFunction%': needsEval,\n\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'%isFinite%': isFinite,\n\t'%isNaN%': isNaN,\n\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\n\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'%Math%': Math,\n\t'%Number%': Number,\n\t'%Object%': Object,\n\t'%parseFloat%': parseFloat,\n\t'%parseInt%': parseInt,\n\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'%RangeError%': RangeError,\n\t'%ReferenceError%': ReferenceError,\n\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'%RegExp%': RegExp,\n\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'%String%': String,\n\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'%Symbol%': hasSymbols ? Symbol : undefined,\n\t'%SyntaxError%': $SyntaxError,\n\t'%ThrowTypeError%': ThrowTypeError,\n\t'%TypedArray%': TypedArray,\n\t'%TypeError%': $TypeError,\n\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'%URIError%': URIError,\n\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\n\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\n};\n\nvar doEval = function doEval(name) {\n\tvar value;\n\tif (name === '%AsyncFunction%') {\n\t\tvalue = getEvalledConstructor('async function () {}');\n\t} else if (name === '%GeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('function* () {}');\n\t} else if (name === '%AsyncGeneratorFunction%') {\n\t\tvalue = getEvalledConstructor('async function* () {}');\n\t} else if (name === '%AsyncGenerator%') {\n\t\tvar fn = doEval('%AsyncGeneratorFunction%');\n\t\tif (fn) {\n\t\t\tvalue = fn.prototype;\n\t\t}\n\t} else if (name === '%AsyncIteratorPrototype%') {\n\t\tvar gen = doEval('%AsyncGenerator%');\n\t\tif (gen) {\n\t\t\tvalue = getProto(gen.prototype);\n\t\t}\n\t}\n\n\tINTRINSICS[name] = value;\n\n\treturn value;\n};\n\nvar LEGACY_ALIASES = {\n\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\n\t'%ArrayPrototype%': ['Array', 'prototype'],\n\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\n\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\n\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\n\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\n\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\n\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\n\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\n\t'%BooleanPrototype%': ['Boolean', 'prototype'],\n\t'%DataViewPrototype%': ['DataView', 'prototype'],\n\t'%DatePrototype%': ['Date', 'prototype'],\n\t'%ErrorPrototype%': ['Error', 'prototype'],\n\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\n\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\n\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\n\t'%FunctionPrototype%': ['Function', 'prototype'],\n\t'%Generator%': ['GeneratorFunction', 'prototype'],\n\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\n\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\n\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\n\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\n\t'%JSONParse%': ['JSON', 'parse'],\n\t'%JSONStringify%': ['JSON', 'stringify'],\n\t'%MapPrototype%': ['Map', 'prototype'],\n\t'%NumberPrototype%': ['Number', 'prototype'],\n\t'%ObjectPrototype%': ['Object', 'prototype'],\n\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\n\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\n\t'%PromisePrototype%': ['Promise', 'prototype'],\n\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\n\t'%Promise_all%': ['Promise', 'all'],\n\t'%Promise_reject%': ['Promise', 'reject'],\n\t'%Promise_resolve%': ['Promise', 'resolve'],\n\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\n\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\n\t'%RegExpPrototype%': ['RegExp', 'prototype'],\n\t'%SetPrototype%': ['Set', 'prototype'],\n\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\n\t'%StringPrototype%': ['String', 'prototype'],\n\t'%SymbolPrototype%': ['Symbol', 'prototype'],\n\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\n\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\n\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\n\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\n\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\n\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\n\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\n\t'%URIErrorPrototype%': ['URIError', 'prototype'],\n\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\n\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\n};\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar hasOwn = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\nvar $concat = bind.call(Function.call, Array.prototype.concat);\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\nvar $replace = bind.call(Function.call, String.prototype.replace);\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\n\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\nvar rePropName = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\nvar reEscapeChar = /\\\\(\\\\)?/g; /** Used to match backslashes in property paths. */\nvar stringToPath = function stringToPath(string) {\n\tvar first = $strSlice(string, 0, 1);\n\tvar last = $strSlice(string, -1);\n\tif (first === '%' && last !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\n\t} else if (last === '%' && first !== '%') {\n\t\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\n\t}\n\tvar result = [];\n\t$replace(string, rePropName, function (match, number, quote, subString) {\n\t\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\n\t});\n\treturn result;\n};\n/* end adaptation */\n\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\n\tvar intrinsicName = name;\n\tvar alias;\n\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\n\t\talias = LEGACY_ALIASES[intrinsicName];\n\t\tintrinsicName = '%' + alias[0] + '%';\n\t}\n\n\tif (hasOwn(INTRINSICS, intrinsicName)) {\n\t\tvar value = INTRINSICS[intrinsicName];\n\t\tif (value === needsEval) {\n\t\t\tvalue = doEval(intrinsicName);\n\t\t}\n\t\tif (typeof value === 'undefined' && !allowMissing) {\n\t\t\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t\t}\n\n\t\treturn {\n\t\t\talias: alias,\n\t\t\tname: intrinsicName,\n\t\t\tvalue: value\n\t\t};\n\t}\n\n\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (typeof name !== 'string' || name.length === 0) {\n\t\tthrow new $TypeError('intrinsic name must be a non-empty string');\n\t}\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new $TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar parts = stringToPath(name);\n\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\n\n\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\n\tvar intrinsicRealName = intrinsic.name;\n\tvar value = intrinsic.value;\n\tvar skipFurtherCaching = false;\n\n\tvar alias = intrinsic.alias;\n\tif (alias) {\n\t\tintrinsicBaseName = alias[0];\n\t\t$spliceApply(parts, $concat([0, 1], alias));\n\t}\n\n\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\n\t\tvar part = parts[i];\n\t\tvar first = $strSlice(part, 0, 1);\n\t\tvar last = $strSlice(part, -1);\n\t\tif (\n\t\t\t(\n\t\t\t\t(first === '\"' || first === \"'\" || first === '`')\n\t\t\t\t|| (last === '\"' || last === \"'\" || last === '`')\n\t\t\t)\n\t\t\t&& first !== last\n\t\t) {\n\t\t\tthrow new $SyntaxError('property names with quotes must have matching quotes');\n\t\t}\n\t\tif (part === 'constructor' || !isOwn) {\n\t\t\tskipFurtherCaching = true;\n\t\t}\n\n\t\tintrinsicBaseName += '.' + part;\n\t\tintrinsicRealName = '%' + intrinsicBaseName + '%';\n\n\t\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\n\t\t\tvalue = INTRINSICS[intrinsicRealName];\n\t\t} else if (value != null) {\n\t\t\tif (!(part in value)) {\n\t\t\t\tif (!allowMissing) {\n\t\t\t\t\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\n\t\t\t\t}\n\t\t\t\treturn void undefined;\n\t\t\t}\n\t\t\tif ($gOPD && (i + 1) >= parts.length) {\n\t\t\t\tvar desc = $gOPD(value, part);\n\t\t\t\tisOwn = !!desc;\n\n\t\t\t\t// By convention, when a data property is converted to an accessor\n\t\t\t\t// property to emulate a data property that does not suffer from\n\t\t\t\t// the override mistake, that accessor's getter is marked with\n\t\t\t\t// an `originalValue` property. Here, when we detect this, we\n\t\t\t\t// uphold the illusion by pretending to see that original data\n\t\t\t\t// property, i.e., returning the value rather than the getter\n\t\t\t\t// itself.\n\t\t\t\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\n\t\t\t\t\tvalue = desc.get;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = value[part];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tisOwn = hasOwn(value, part);\n\t\t\t\tvalue = value[part];\n\t\t\t}\n\n\t\t\tif (isOwn && !skipFurtherCaching) {\n\t\t\t\tINTRINSICS[intrinsicRealName] = value;\n\t\t\t}\n\t\t}\n\t}\n\treturn value;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcz8wMGNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0NBQStDO0FBQ2hGLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsRUFBRTtBQUNGLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsd0RBQWE7O0FBRXRDLHNEQUFzRCxvQkFBb0IsR0FBRzs7QUFFN0U7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxFQUFFO0FBQ0YsZ0RBQWdEO0FBQ2hELEVBQUU7QUFDRixzREFBc0Q7QUFDdEQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyw0REFBZTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsNENBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixrQkFBa0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2dldC1pbnRyaW5zaWMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciB1bmRlZmluZWQ7XG5cbnZhciAkU3ludGF4RXJyb3IgPSBTeW50YXhFcnJvcjtcbnZhciAkRnVuY3Rpb24gPSBGdW5jdGlvbjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xuXHR0cnkge1xuXHRcdHJldHVybiAkRnVuY3Rpb24oJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcblx0fSBjYXRjaCAoZSkge31cbn07XG5cbnZhciAkZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5pZiAoJGdPUEQpIHtcblx0dHJ5IHtcblx0XHQkZ09QRCh7fSwgJycpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0JGdPUEQgPSBudWxsOyAvLyB0aGlzIGlzIElFIDgsIHdoaWNoIGhhcyBhIGJyb2tlbiBnT1BEXG5cdH1cbn1cblxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xuXHR0aHJvdyBuZXcgJFR5cGVFcnJvcigpO1xufTtcbnZhciBUaHJvd1R5cGVFcnJvciA9ICRnT1BEXG5cdD8gKGZ1bmN0aW9uICgpIHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tY2FsbGVyLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcblx0XHRcdGFyZ3VtZW50cy5jYWxsZWU7IC8vIElFIDggZG9lcyBub3QgdGhyb3cgaGVyZVxuXHRcdFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xuXHRcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxuXHRcdFx0XHRyZXR1cm4gJGdPUEQoYXJndW1lbnRzLCAnY2FsbGVlJykuZ2V0O1xuXHRcdFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xuXHRcdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCkpXG5cdDogdGhyb3dUeXBlRXJyb3I7XG5cbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX19wcm90b19fOyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvXG5cbnZhciBuZWVkc0V2YWwgPSB7fTtcblxudmFyIFR5cGVkQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBnZXRQcm90byhVaW50OEFycmF5KTtcblxudmFyIElOVFJJTlNJQ1MgPSB7XG5cdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxuXHQnJUFycmF5JSc6IEFycmF5LFxuXHQnJUFycmF5QnVmZmVyJSc6IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBcnJheUJ1ZmZlcixcblx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJzogbmVlZHNFdmFsLFxuXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcblx0JyVCaWdJbnQlJzogdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBCaWdJbnQsXG5cdCclQm9vbGVhbiUnOiBCb29sZWFuLFxuXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcblx0JyVEYXRlJSc6IERhdGUsXG5cdCclZGVjb2RlVVJJJSc6IGRlY29kZVVSSSxcblx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxuXHQnJWVuY29kZVVSSSUnOiBlbmNvZGVVUkksXG5cdCclZW5jb2RlVVJJQ29tcG9uZW50JSc6IGVuY29kZVVSSUNvbXBvbmVudCxcblx0JyVFcnJvciUnOiBFcnJvcixcblx0JyVldmFsJSc6IGV2YWwsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuXHQnJUV2YWxFcnJvciUnOiBFdmFsRXJyb3IsXG5cdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxuXHQnJUZsb2F0NjRBcnJheSUnOiB0eXBlb2YgRmxvYXQ2NEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZsb2F0NjRBcnJheSxcblx0JyVGaW5hbGl6YXRpb25SZWdpc3RyeSUnOiB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmluYWxpemF0aW9uUmVnaXN0cnksXG5cdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxuXHQnJUdlbmVyYXRvckZ1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVJbnQ4QXJyYXklJzogdHlwZW9mIEludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQ4QXJyYXksXG5cdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxuXHQnJUludDMyQXJyYXklJzogdHlwZW9mIEludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50MzJBcnJheSxcblx0JyVpc0Zpbml0ZSUnOiBpc0Zpbml0ZSxcblx0JyVpc05hTiUnOiBpc05hTixcblx0JyVJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oZ2V0UHJvdG8oW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkgOiB1bmRlZmluZWQsXG5cdCclSlNPTiUnOiB0eXBlb2YgSlNPTiA9PT0gJ29iamVjdCcgPyBKU09OIDogdW5kZWZpbmVkLFxuXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcblx0JyVNYXBJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBNYXAoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJU1hdGglJzogTWF0aCxcblx0JyVOdW1iZXIlJzogTnVtYmVyLFxuXHQnJU9iamVjdCUnOiBPYmplY3QsXG5cdCclcGFyc2VGbG9hdCUnOiBwYXJzZUZsb2F0LFxuXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxuXHQnJVByb21pc2UlJzogdHlwZW9mIFByb21pc2UgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJvbWlzZSxcblx0JyVQcm94eSUnOiB0eXBlb2YgUHJveHkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUHJveHksXG5cdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxuXHQnJVJlZmVyZW5jZUVycm9yJSc6IFJlZmVyZW5jZUVycm9yLFxuXHQnJVJlZmxlY3QlJzogdHlwZW9mIFJlZmxlY3QgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogUmVmbGVjdCxcblx0JyVSZWdFeHAlJzogUmVnRXhwLFxuXHQnJVNldCUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNldCxcblx0JyVTZXRJdGVyYXRvclByb3RvdHlwZSUnOiB0eXBlb2YgU2V0ID09PSAndW5kZWZpbmVkJyB8fCAhaGFzU3ltYm9scyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKG5ldyBTZXQoKVtTeW1ib2wuaXRlcmF0b3JdKCkpLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcblx0JyVTdHJpbmclJzogU3RyaW5nLFxuXHQnJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90bygnJ1tTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxuXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxuXHQnJVN5bnRheEVycm9yJSc6ICRTeW50YXhFcnJvcixcblx0JyVUaHJvd1R5cGVFcnJvciUnOiBUaHJvd1R5cGVFcnJvcixcblx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXG5cdCclVHlwZUVycm9yJSc6ICRUeXBlRXJyb3IsXG5cdCclVWludDhBcnJheSUnOiB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OEFycmF5LFxuXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcblx0JyVVaW50MTZBcnJheSUnOiB0eXBlb2YgVWludDE2QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDE2QXJyYXksXG5cdCclVWludDMyQXJyYXklJzogdHlwZW9mIFVpbnQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQzMkFycmF5LFxuXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxuXHQnJVdlYWtNYXAlJzogdHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha01hcCxcblx0JyVXZWFrUmVmJSc6IHR5cGVvZiBXZWFrUmVmID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtSZWYsXG5cdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XG59O1xuXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcblx0dmFyIHZhbHVlO1xuXHRpZiAobmFtZSA9PT0gJyVBc3luY0Z1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24gKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpIHtcblx0XHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignYXN5bmMgZnVuY3Rpb24qICgpIHt9Jyk7XG5cdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0dlbmVyYXRvciUnKSB7XG5cdFx0dmFyIGZuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnKTtcblx0XHRpZiAoZm4pIHtcblx0XHRcdHZhbHVlID0gZm4ucHJvdG90eXBlO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlJykge1xuXHRcdHZhciBnZW4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvciUnKTtcblx0XHRpZiAoZ2VuKSB7XG5cdFx0XHR2YWx1ZSA9IGdldFByb3RvKGdlbi5wcm90b3R5cGUpO1xuXHRcdH1cblx0fVxuXG5cdElOVFJJTlNJQ1NbbmFtZV0gPSB2YWx1ZTtcblxuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgTEVHQUNZX0FMSUFTRVMgPSB7XG5cdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcblx0JyVBcnJheVByb3RvdHlwZSUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG9fZW50cmllcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdlbnRyaWVzJ10sXG5cdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcblx0JyVBcnJheVByb3RvX2tleXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAna2V5cyddLFxuXHQnJUFycmF5UHJvdG9fdmFsdWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ3ZhbHVlcyddLFxuXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcblx0JyVBc3luY0dlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxuXHQnJURhdGFWaWV3UHJvdG90eXBlJSc6IFsnRGF0YVZpZXcnLCAncHJvdG90eXBlJ10sXG5cdCclRGF0ZVByb3RvdHlwZSUnOiBbJ0RhdGUnLCAncHJvdG90eXBlJ10sXG5cdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVFdmFsRXJyb3JQcm90b3R5cGUlJzogWydFdmFsRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQzMkFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvciUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQ4QXJyYXlQcm90b3R5cGUlJzogWydJbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ0ludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclSlNPTlBhcnNlJSc6IFsnSlNPTicsICdwYXJzZSddLFxuXHQnJUpTT05TdHJpbmdpZnklJzogWydKU09OJywgJ3N0cmluZ2lmeSddLFxuXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVOdW1iZXJQcm90b3R5cGUlJzogWydOdW1iZXInLCAncHJvdG90eXBlJ10sXG5cdCclT2JqZWN0UHJvdG90eXBlJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZSddLFxuXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxuXHQnJU9ialByb3RvX3ZhbHVlT2YlJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3ZhbHVlT2YnXSxcblx0JyVQcm9taXNlUHJvdG90eXBlJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnXSxcblx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcblx0JyVQcm9taXNlX2FsbCUnOiBbJ1Byb21pc2UnLCAnYWxsJ10sXG5cdCclUHJvbWlzZV9yZWplY3QlJzogWydQcm9taXNlJywgJ3JlamVjdCddLFxuXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxuXHQnJVJhbmdlRXJyb3JQcm90b3R5cGUlJzogWydSYW5nZUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJSc6IFsnUmVmZXJlbmNlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVNldFByb3RvdHlwZSUnOiBbJ1NldCcsICdwcm90b3R5cGUnXSxcblx0JyVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ1NoYXJlZEFycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcblx0JyVTeW1ib2xQcm90b3R5cGUlJzogWydTeW1ib2wnLCAncHJvdG90eXBlJ10sXG5cdCclU3ludGF4RXJyb3JQcm90b3R5cGUlJzogWydTeW50YXhFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVUeXBlRXJyb3JQcm90b3R5cGUlJzogWydUeXBlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50MTZBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnVWludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrTWFwUHJvdG90eXBlJSc6IFsnV2Vha01hcCcsICdwcm90b3R5cGUnXSxcblx0JyVXZWFrU2V0UHJvdG90eXBlJSc6IFsnV2Vha1NldCcsICdwcm90b3R5cGUnXVxufTtcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG52YXIgaGFzT3duID0gcmVxdWlyZSgnaGFzJyk7XG52YXIgJGNvbmNhdCA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBBcnJheS5wcm90b3R5cGUuY29uY2F0KTtcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xudmFyICRyZXBsYWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgJHN0clNsaWNlID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO1xuXG4vKiBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi80LjE3LjE1L2Rpc3QvbG9kYXNoLmpzI0w2NzM1LUw2NzQ0ICovXG52YXIgcmVQcm9wTmFtZSA9IC9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nOyAvKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBmdW5jdGlvbiBzdHJpbmdUb1BhdGgoc3RyaW5nKSB7XG5cdHZhciBmaXJzdCA9ICRzdHJTbGljZShzdHJpbmcsIDAsIDEpO1xuXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcblx0aWYgKGZpcnN0ID09PSAnJScgJiYgbGFzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYCcpO1xuXHR9IGVsc2UgaWYgKGxhc3QgPT09ICclJyAmJiBmaXJzdCAhPT0gJyUnKSB7XG5cdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBvcGVuaW5nIGAlYCcpO1xuXHR9XG5cdHZhciByZXN1bHQgPSBbXTtcblx0JHJlcGxhY2Uoc3RyaW5nLCByZVByb3BOYW1lLCBmdW5jdGlvbiAobWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuXHRcdHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHF1b3RlID8gJHJlcGxhY2Uoc3ViU3RyaW5nLCByZUVzY2FwZUNoYXIsICckMScpIDogbnVtYmVyIHx8IG1hdGNoO1xuXHR9KTtcblx0cmV0dXJuIHJlc3VsdDtcbn07XG4vKiBlbmQgYWRhcHRhdGlvbiAqL1xuXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdHZhciBpbnRyaW5zaWNOYW1lID0gbmFtZTtcblx0dmFyIGFsaWFzO1xuXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XG5cdFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xuXHR9XG5cblx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNOYW1lKSkge1xuXHRcdHZhciB2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljTmFtZV07XG5cdFx0aWYgKHZhbHVlID09PSBuZWVkc0V2YWwpIHtcblx0XHRcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xuXHRcdH1cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XG5cdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSEnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWxpYXM6IGFsaWFzLFxuXHRcdFx0bmFtZTogaW50cmluc2ljTmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH07XG5cdH1cblxuXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnRyaW5zaWMgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0IScpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBHZXRJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XG5cdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcblx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcblx0fVxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIGFsbG93TWlzc2luZyAhPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKTtcblx0fVxuXG5cdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcblx0dmFyIGludHJpbnNpY0Jhc2VOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogJyc7XG5cblx0dmFyIGludHJpbnNpYyA9IGdldEJhc2VJbnRyaW5zaWMoJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJScsIGFsbG93TWlzc2luZyk7XG5cdHZhciBpbnRyaW5zaWNSZWFsTmFtZSA9IGludHJpbnNpYy5uYW1lO1xuXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XG5cdHZhciBza2lwRnVydGhlckNhY2hpbmcgPSBmYWxzZTtcblxuXHR2YXIgYWxpYXMgPSBpbnRyaW5zaWMuYWxpYXM7XG5cdGlmIChhbGlhcykge1xuXHRcdGludHJpbnNpY0Jhc2VOYW1lID0gYWxpYXNbMF07XG5cdFx0JHNwbGljZUFwcGx5KHBhcnRzLCAkY29uY2F0KFswLCAxXSwgYWxpYXMpKTtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHNbaV07XG5cdFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xuXHRcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcblx0XHRpZiAoXG5cdFx0XHQoXG5cdFx0XHRcdChmaXJzdCA9PT0gJ1wiJyB8fCBmaXJzdCA9PT0gXCInXCIgfHwgZmlyc3QgPT09ICdgJylcblx0XHRcdFx0fHwgKGxhc3QgPT09ICdcIicgfHwgbGFzdCA9PT0gXCInXCIgfHwgbGFzdCA9PT0gJ2AnKVxuXHRcdFx0KVxuXHRcdFx0JiYgZmlyc3QgIT09IGxhc3Rcblx0XHQpIHtcblx0XHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ3Byb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXMnKTtcblx0XHR9XG5cdFx0aWYgKHBhcnQgPT09ICdjb25zdHJ1Y3RvcicgfHwgIWlzT3duKSB7XG5cdFx0XHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGludHJpbnNpY0Jhc2VOYW1lICs9ICcuJyArIHBhcnQ7XG5cdFx0aW50cmluc2ljUmVhbE5hbWUgPSAnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJztcblxuXHRcdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljUmVhbE5hbWUpKSB7XG5cdFx0XHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0aWYgKCEocGFydCBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdm9pZCB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0dmFyIGRlc2MgPSAkZ09QRCh2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdGlzT3duID0gISFkZXNjO1xuXG5cdFx0XHRcdC8vIEJ5IGNvbnZlbnRpb24sIHdoZW4gYSBkYXRhIHByb3BlcnR5IGlzIGNvbnZlcnRlZCB0byBhbiBhY2Nlc3NvclxuXHRcdFx0XHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXG5cdFx0XHRcdC8vIHRoZSBvdmVycmlkZSBtaXN0YWtlLCB0aGF0IGFjY2Vzc29yJ3MgZ2V0dGVyIGlzIG1hcmtlZCB3aXRoXG5cdFx0XHRcdC8vIGFuIGBvcmlnaW5hbFZhbHVlYCBwcm9wZXJ0eS4gSGVyZSwgd2hlbiB3ZSBkZXRlY3QgdGhpcywgd2Vcblx0XHRcdFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcblx0XHRcdFx0Ly8gcHJvcGVydHksIGkuZS4sIHJldHVybmluZyB0aGUgdmFsdWUgcmF0aGVyIHRoYW4gdGhlIGdldHRlclxuXHRcdFx0XHQvLyBpdHNlbGYuXG5cdFx0XHRcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xuXHRcdFx0XHRcdHZhbHVlID0gZGVzYy5nZXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZVtwYXJ0XTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXNPd24gPSBoYXNPd24odmFsdWUsIHBhcnQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xuXHRcdFx0XHRJTlRSSU5TSUNTW2ludHJpbnNpY1JlYWxOYW1lXSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gdmFsdWU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/get-intrinsic/index.js\n")},"./node_modules/has-symbols/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \"./node_modules/has-symbols/shams.js\");\n\nmodule.exports = function hasNativeSymbols() {\n\tif (typeof origSymbol !== 'function') { return false; }\n\tif (typeof Symbol !== 'function') { return false; }\n\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\n\tif (typeof Symbol('bar') !== 'symbol') { return false; }\n\n\treturn hasSymbolSham();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvaW5kZXguanM/NTE1NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLG9EQUFTOztBQUVyQztBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELG9DQUFvQyxjQUFjO0FBQ2xELDZDQUE2QyxjQUFjO0FBQzNELHlDQUF5QyxjQUFjOztBQUV2RDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgb3JpZ1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbDtcbnZhciBoYXNTeW1ib2xTaGFtID0gcmVxdWlyZSgnLi9zaGFtcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbCgnYmFyJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHJldHVybiBoYXNTeW1ib2xTaGFtKCk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/has-symbols/index.js\n")},"./node_modules/has-symbols/shams.js":module=>{"use strict";eval("\n\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\nmodule.exports = function hasSymbols() {\n\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\n\tif (typeof Symbol.iterator === 'symbol') { return true; }\n\n\tvar obj = {};\n\tvar sym = Symbol('test');\n\tvar symObj = Object(sym);\n\tif (typeof sym === 'string') { return false; }\n\n\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\n\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\n\n\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\n\t// if (sym instanceof Symbol) { return false; }\n\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\n\t// if (!(symObj instanceof Symbol)) { return false; }\n\n\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\n\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\n\n\tvar symVal = 42;\n\tobj[sym] = symVal;\n\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\n\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\n\n\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\n\n\tvar syms = Object.getOwnPropertySymbols(obj);\n\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\n\n\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\n\n\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\n\t\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\n\t\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\n\t}\n\n\treturn true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/MTY5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsMEZBQTBGLGNBQWM7QUFDeEcsMkNBQTJDLGFBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjOztBQUU3QyxpRUFBaUUsY0FBYztBQUMvRSxvRUFBb0UsY0FBYzs7QUFFbEY7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBLHNDQUFzQyxjQUFjOztBQUVwRCwwREFBMEQsY0FBYztBQUN4RSw4REFBOEQsY0FBYzs7QUFFNUU7QUFDQTtBQUNBLG1CQUFtQixjQUFjLEVBQUU7QUFDbkMsMEVBQTBFLGNBQWM7O0FBRXhGLHdHQUF3RyxjQUFjOztBQUV0SDtBQUNBLDRDQUE0QyxjQUFjOztBQUUxRCw2REFBNkQsY0FBYzs7QUFFM0U7QUFDQTtBQUNBLHNFQUFzRSxjQUFjO0FBQ3BGOztBQUVBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBjb21wbGV4aXR5OiBbMiwgMThdLCBtYXgtc3RhdGVtZW50czogWzIsIDMzXSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7IHJldHVybiB0cnVlOyB9XG5cblx0dmFyIG9iaiA9IHt9O1xuXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XG5cdHZhciBzeW1PYmogPSBPYmplY3Qoc3ltKTtcblx0aWYgKHR5cGVvZiBzeW0gPT09ICdzdHJpbmcnKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xuXHQvLyBpZiAoc3ltIGluc3RhbmNlb2YgU3ltYm9sKSB7IHJldHVybiBmYWxzZTsgfVxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vV2ViUmVmbGVjdGlvbi9nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMvaXNzdWVzLzRcblx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIGlmIChTdHJpbmcoc3ltKSAhPT0gU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0dmFyIHN5bVZhbCA9IDQyO1xuXHRvYmpbc3ltXSA9IHN5bVZhbDtcblx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXG5cdGlmICh0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgT2JqZWN0LmtleXMob2JqKS5sZW5ndGggIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKTtcblx0aWYgKHN5bXMubGVuZ3RoICE9PSAxIHx8IHN5bXNbMF0gIT09IHN5bSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmosIHN5bSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgc3ltKTtcblx0XHRpZiAoZGVzY3JpcHRvci52YWx1ZSAhPT0gc3ltVmFsIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSAhPT0gdHJ1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblx0fVxuXG5cdHJldHVybiB0cnVlO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/has-symbols/shams.js\n")},"./node_modules/has/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcz9hMGQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw0REFBZTs7QUFFbEMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/has/src/index.js\n')},"./node_modules/inherits/inherits_browser.js":module=>{eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/inherits/inherits_browser.js\n")},"./node_modules/is-arguments/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\n\nvar isStandardArguments = function isArguments(value) {\n\tif (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {\n\t\treturn false;\n\t}\n\treturn $toString(value) === '[object Arguments]';\n};\n\nvar isLegacyArguments = function isArguments(value) {\n\tif (isStandardArguments(value)) {\n\t\treturn true;\n\t}\n\treturn value !== null &&\n\t\ttypeof value === 'object' &&\n\t\ttypeof value.length === 'number' &&\n\t\tvalue.length >= 0 &&\n\t\t$toString(value) !== '[object Array]' &&\n\t\t$toString(value.callee) === '[object Function]';\n};\n\nvar supportsStandardArguments = (function () {\n\treturn isStandardArguments(arguments);\n}());\n\nisStandardArguments.isLegacyArguments = isLegacyArguments; // for tests\n\nmodule.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzP2UzOWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxrRUFBcUI7O0FBRTdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELDBEQUEwRDs7QUFFMUQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtYXJndW1lbnRzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGNhbGxCb3VuZCA9IHJlcXVpcmUoJ2NhbGwtYmluZC9jYWxsQm91bmQnKTtcblxudmFyICR0b1N0cmluZyA9IGNhbGxCb3VuZCgnT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZycpO1xuXG52YXIgaXNTdGFuZGFyZEFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG52YXIgaXNMZWdhY3lBcmd1bWVudHMgPSBmdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuXHRpZiAoaXNTdGFuZGFyZEFyZ3VtZW50cyh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRyZXR1cm4gdmFsdWUgIT09IG51bGwgJiZcblx0XHR0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG5cdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHR2YWx1ZS5sZW5ndGggPj0gMCAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZSkgIT09ICdbb2JqZWN0IEFycmF5XScgJiZcblx0XHQkdG9TdHJpbmcodmFsdWUuY2FsbGVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnZhciBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID0gKGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIGlzU3RhbmRhcmRBcmd1bWVudHMoYXJndW1lbnRzKTtcbn0oKSk7XG5cbmlzU3RhbmRhcmRBcmd1bWVudHMuaXNMZWdhY3lBcmd1bWVudHMgPSBpc0xlZ2FjeUFyZ3VtZW50czsgLy8gZm9yIHRlc3RzXG5cbm1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNTdGFuZGFyZEFyZ3VtZW50cyA/IGlzU3RhbmRhcmRBcmd1bWVudHMgOiBpc0xlZ2FjeUFyZ3VtZW50cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-arguments/index.js\n")},"./node_modules/is-generator-function/index.js":module=>{"use strict";eval("\n\nvar toStr = Object.prototype.toString;\nvar fnToStr = Function.prototype.toString;\nvar isFnRegex = /^\\s*(?:function)?\\*/;\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nvar getProto = Object.getPrototypeOf;\nvar getGeneratorFunc = function () { // eslint-disable-line consistent-return\n\tif (!hasToStringTag) {\n\t\treturn false;\n\t}\n\ttry {\n\t\treturn Function('return function*() {}')();\n\t} catch (e) {\n\t}\n};\nvar generatorFunc = getGeneratorFunc();\nvar GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;\n\nmodule.exports = function isGeneratorFunction(fn) {\n\tif (typeof fn !== 'function') {\n\t\treturn false;\n\t}\n\tif (isFnRegex.test(fnToStr.call(fn))) {\n\t\treturn true;\n\t}\n\tif (!hasToStringTag) {\n\t\tvar str = toStr.call(fn);\n\t\treturn str === '[object GeneratorFunction]';\n\t}\n\treturn getProto && getProto(fn) === GeneratorFunction;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzPzBhM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGZuVG9TdHIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGblJlZ2V4ID0gL15cXHMqKD86ZnVuY3Rpb24pP1xcKi87XG52YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnO1xudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIGdldEdlbmVyYXRvckZ1bmMgPSBmdW5jdGlvbiAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiBGdW5jdGlvbigncmV0dXJuIGZ1bmN0aW9uKigpIHt9JykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHR9XG59O1xudmFyIGdlbmVyYXRvckZ1bmMgPSBnZXRHZW5lcmF0b3JGdW5jKCk7XG52YXIgR2VuZXJhdG9yRnVuY3Rpb24gPSBnZXRQcm90byAmJiBnZW5lcmF0b3JGdW5jID8gZ2V0UHJvdG8oZ2VuZXJhdG9yRnVuYykgOiBmYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dlbmVyYXRvckZ1bmN0aW9uKGZuKSB7XG5cdGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0aWYgKGlzRm5SZWdleC50ZXN0KGZuVG9TdHIuY2FsbChmbikpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKCFoYXNUb1N0cmluZ1RhZykge1xuXHRcdHZhciBzdHIgPSB0b1N0ci5jYWxsKGZuKTtcblx0XHRyZXR1cm4gc3RyID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXHR9XG5cdHJldHVybiBnZXRQcm90byAmJiBnZXRQcm90byhmbikgPT09IEdlbmVyYXRvckZ1bmN0aW9uO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/is-generator-function/index.js\n")},"./node_modules/is-typed-array/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\nvar hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';\n\nvar typedArrays = availableTypedArrays();\n\nvar $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {\n\tfor (var i = 0; i < array.length; i += 1) {\n\t\tif (array[i] === value) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n};\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tvar arr = new __webpack_require__.g[typedArray]();\n\t\tif (!(Symbol.toStringTag in arr)) {\n\t\t\tthrow new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');\n\t\t}\n\t\tvar proto = getPrototypeOf(arr);\n\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\tif (!descriptor) {\n\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t}\n\t\ttoStrTags[typedArray] = descriptor.get;\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar anyTrue = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!anyTrue) {\n\t\t\ttry {\n\t\t\t\tanyTrue = getter.call(value) === typedArray;\n\t\t\t} catch (e) { /**/ }\n\t\t}\n\t});\n\treturn anyTrue;\n};\n\nmodule.exports = function isTypedArray(value) {\n\tif (!value || typeof value !== 'object') { return false; }\n\tif (!hasToStringTag) {\n\t\tvar tag = $slice($toString(value), 8, -1);\n\t\treturn $indexOf(typedArrays, tag) > -1;\n\t}\n\tif (!gOPD) { return false; }\n\treturn tryTypedArrays(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvaXMtdHlwZWQtYXJyYXkvaW5kZXguanM/ZjRlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsMkJBQTJCLG1CQUFPLENBQUMsOEVBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFxQjs7QUFFN0M7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxvSEFBOEM7QUFDakUsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxZQUFZO0FBQ2hCO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzLXR5cGVkLWFycmF5L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbnZhciBhdmFpbGFibGVUeXBlZEFycmF5cyA9IHJlcXVpcmUoJ2F2YWlsYWJsZS10eXBlZC1hcnJheXMnKTtcbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG5cbnZhciAkdG9TdHJpbmcgPSBjYWxsQm91bmQoJ09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcnKTtcbnZhciBoYXNTeW1ib2xzID0gcmVxdWlyZSgnaGFzLXN5bWJvbHMnKSgpO1xudmFyIGhhc1RvU3RyaW5nVGFnID0gaGFzU3ltYm9scyAmJiB0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJztcblxudmFyIHR5cGVkQXJyYXlzID0gYXZhaWxhYmxlVHlwZWRBcnJheXMoKTtcblxudmFyICRpbmRleE9mID0gY2FsbEJvdW5kKCdBcnJheS5wcm90b3R5cGUuaW5kZXhPZicsIHRydWUpIHx8IGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gaTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIC0xO1xufTtcbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0dmFyIGFyciA9IG5ldyBnbG9iYWxbdHlwZWRBcnJheV0oKTtcblx0XHRpZiAoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSkge1xuXHRcdFx0dGhyb3cgbmV3IEV2YWxFcnJvcigndGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0ICcgKyB0eXBlZEFycmF5ICsgJyBkb2VzIG5vdCBoYXZlIHRoZSBwcm9wZXJ0eSEgUGxlYXNlIHJlcG9ydCB0aGlzLicpO1xuXHRcdH1cblx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdHZhciBkZXNjcmlwdG9yID0gZ09QRChwcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHRpZiAoIWRlc2NyaXB0b3IpIHtcblx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0ZGVzY3JpcHRvciA9IGdPUEQoc3VwZXJQcm90bywgU3ltYm9sLnRvU3RyaW5nVGFnKTtcblx0XHR9XG5cdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdH0pO1xufVxuXG52YXIgdHJ5VHlwZWRBcnJheXMgPSBmdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyh2YWx1ZSkge1xuXHR2YXIgYW55VHJ1ZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghYW55VHJ1ZSkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0YW55VHJ1ZSA9IGdldHRlci5jYWxsKHZhbHVlKSA9PT0gdHlwZWRBcnJheTtcblx0XHRcdH0gY2F0Y2ggKGUpIHsgLyoqLyB9XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIGFueVRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzVHlwZWRBcnJheSh2YWx1ZSkge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICghaGFzVG9TdHJpbmdUYWcpIHtcblx0XHR2YXIgdGFnID0gJHNsaWNlKCR0b1N0cmluZyh2YWx1ZSksIDgsIC0xKTtcblx0XHRyZXR1cm4gJGluZGV4T2YodHlwZWRBcnJheXMsIHRhZykgPiAtMTtcblx0fVxuXHRpZiAoIWdPUEQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/is-typed-array/index.js\n")},"./node_modules/loglevel/lib/loglevel.js":function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    "use strict";\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === \'function\' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n    "use strict";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = "undefined";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        "trace",\n        "debug",\n        "info",\n        "warn",\n        "error"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === \'function\') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn\'t print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don\'t have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === \'debug\') {\n            methodName = \'log\';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === \'trace\' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, \'log\');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn\'t present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      var storageKey = "loglevel";\n      if (name) {\n        storageKey += ":" + name;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || \'silent\').toUpperCase();\n\n          if (typeof window === undefinedType) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + "=" + levelName + ";";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + "=");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,\n          "ERROR": 4, "SILENT": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return "No console available for logging";\n              }\n          } else {\n              throw "log.setLevel() called with invalid level: " + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if (typeof name !== "string" || name === "") {\n          throw new TypeError("You must supply a name when creating a logger.");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    return defaultLogger;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzPzVjN2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEM7QUFDbEQsUUFBUSxvQ0FBTyxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDMUIsS0FBSyxNQUFNLEVBSU47QUFDTCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckUsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/loglevel/lib/loglevel.js\n')},"./node_modules/precond/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nmodule.exports = __webpack_require__(/*! ./lib/checks */ "./node_modules/precond/lib/checks.js");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcHJlY29uZC9pbmRleC5qcz9jY2MxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdHQUF3QyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcmVjb25kL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoYykgMjAxMiBNYXRoaWV1IFR1cmNvdHRlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jaGVja3MnKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/precond/index.js\n')},"./node_modules/precond/lib/checks.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nvar errors = module.exports = __webpack_require__(/*! ./errors */ \"./node_modules/precond/lib/errors.js\");\n\nfunction failCheck(ExceptionConstructor, callee, messageFormat, formatArgs) {\n    messageFormat = messageFormat || '';\n    var message = util.format.apply(this, [messageFormat].concat(formatArgs));\n    var error = new ExceptionConstructor(message);\n    Error.captureStackTrace(error, callee);\n    throw error;\n}\n\nfunction failArgumentCheck(callee, message, formatArgs) {\n    failCheck(errors.IllegalArgumentError, callee, message, formatArgs);\n}\n\nfunction failStateCheck(callee, message, formatArgs) {\n    failCheck(errors.IllegalStateError, callee, message, formatArgs);\n}\n\nmodule.exports.checkArgument = function(value, message) {\n    if (!value) {\n        failArgumentCheck(arguments.callee, message,\n            Array.prototype.slice.call(arguments, 2));\n    }\n};\n\nmodule.exports.checkState = function(value, message) {\n    if (!value) {\n        failStateCheck(arguments.callee, message,\n            Array.prototype.slice.call(arguments, 2));\n    }\n};\n\nmodule.exports.checkIsDef = function(value, message) {\n    if (value !== undefined) {\n        return value;\n    }\n\n    failArgumentCheck(arguments.callee, message ||\n        'Expected value to be defined but was undefined.',\n        Array.prototype.slice.call(arguments, 2));\n};\n\nmodule.exports.checkIsDefAndNotNull = function(value, message) {\n    // Note that undefined == null.\n    if (value != null) {\n        return value;\n    }\n\n    failArgumentCheck(arguments.callee, message ||\n        'Expected value to be defined and not null but got \"' +\n        typeOf(value) + '\".', Array.prototype.slice.call(arguments, 2));\n};\n\n// Fixed version of the typeOf operator which returns 'null' for null values\n// and 'array' for arrays.\nfunction typeOf(value) {\n    var s = typeof value;\n    if (s == 'object') {\n        if (!value) {\n            return 'null';\n        } else if (value instanceof Array) {\n            return 'array';\n        }\n    }\n    return s;\n}\n\nfunction typeCheck(expect) {\n    return function(value, message) {\n        var type = typeOf(value);\n\n        if (type == expect) {\n            return value;\n        }\n\n        failArgumentCheck(arguments.callee, message ||\n            'Expected \"' + expect + '\" but got \"' + type + '\".',\n            Array.prototype.slice.call(arguments, 2));\n    };\n}\n\nmodule.exports.checkIsString = typeCheck('string');\nmodule.exports.checkIsArray = typeCheck('array');\nmodule.exports.checkIsNumber = typeCheck('number');\nmodule.exports.checkIsBoolean = typeCheck('boolean');\nmodule.exports.checkIsFunction = typeCheck('function');\nmodule.exports.checkIsObject = typeCheck('object');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcHJlY29uZC9saWIvY2hlY2tzLmpzPzFjZGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHlDQUFNOztBQUV6QixhQUFhLDRGQUFvQzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLDRCQUE0QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcmVjb25kL2xpYi9jaGVja3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGVycm9ycyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuZnVuY3Rpb24gZmFpbENoZWNrKEV4Y2VwdGlvbkNvbnN0cnVjdG9yLCBjYWxsZWUsIG1lc3NhZ2VGb3JtYXQsIGZvcm1hdEFyZ3MpIHtcbiAgICBtZXNzYWdlRm9ybWF0ID0gbWVzc2FnZUZvcm1hdCB8fCAnJztcbiAgICB2YXIgbWVzc2FnZSA9IHV0aWwuZm9ybWF0LmFwcGx5KHRoaXMsIFttZXNzYWdlRm9ybWF0XS5jb25jYXQoZm9ybWF0QXJncykpO1xuICAgIHZhciBlcnJvciA9IG5ldyBFeGNlcHRpb25Db25zdHJ1Y3RvcihtZXNzYWdlKTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnJvciwgY2FsbGVlKTtcbiAgICB0aHJvdyBlcnJvcjtcbn1cblxuZnVuY3Rpb24gZmFpbEFyZ3VtZW50Q2hlY2soY2FsbGVlLCBtZXNzYWdlLCBmb3JtYXRBcmdzKSB7XG4gICAgZmFpbENoZWNrKGVycm9ycy5JbGxlZ2FsQXJndW1lbnRFcnJvciwgY2FsbGVlLCBtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbn1cblxuZnVuY3Rpb24gZmFpbFN0YXRlQ2hlY2soY2FsbGVlLCBtZXNzYWdlLCBmb3JtYXRBcmdzKSB7XG4gICAgZmFpbENoZWNrKGVycm9ycy5JbGxlZ2FsU3RhdGVFcnJvciwgY2FsbGVlLCBtZXNzYWdlLCBmb3JtYXRBcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMuY2hlY2tBcmd1bWVudCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBmYWlsQXJndW1lbnRDaGVjayhhcmd1bWVudHMuY2FsbGVlLCBtZXNzYWdlLFxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuY2hlY2tTdGF0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBmYWlsU3RhdGVDaGVjayhhcmd1bWVudHMuY2FsbGVlLCBtZXNzYWdlLFxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuY2hlY2tJc0RlZiA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZhaWxBcmd1bWVudENoZWNrKGFyZ3VtZW50cy5jYWxsZWUsIG1lc3NhZ2UgfHxcbiAgICAgICAgJ0V4cGVjdGVkIHZhbHVlIHRvIGJlIGRlZmluZWQgYnV0IHdhcyB1bmRlZmluZWQuJyxcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzRGVmQW5kTm90TnVsbCA9IGZ1bmN0aW9uKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgLy8gTm90ZSB0aGF0IHVuZGVmaW5lZCA9PSBudWxsLlxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmYWlsQXJndW1lbnRDaGVjayhhcmd1bWVudHMuY2FsbGVlLCBtZXNzYWdlIHx8XG4gICAgICAgICdFeHBlY3RlZCB2YWx1ZSB0byBiZSBkZWZpbmVkIGFuZCBub3QgbnVsbCBidXQgZ290IFwiJyArXG4gICAgICAgIHR5cGVPZih2YWx1ZSkgKyAnXCIuJywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG59O1xuXG4vLyBGaXhlZCB2ZXJzaW9uIG9mIHRoZSB0eXBlT2Ygb3BlcmF0b3Igd2hpY2ggcmV0dXJucyAnbnVsbCcgZm9yIG51bGwgdmFsdWVzXG4vLyBhbmQgJ2FycmF5JyBmb3IgYXJyYXlzLlxuZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgdmFsdWU7XG4gICAgaWYgKHMgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gdHlwZUNoZWNrKGV4cGVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICB2YXIgdHlwZSA9IHR5cGVPZih2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT0gZXhwZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmYWlsQXJndW1lbnRDaGVjayhhcmd1bWVudHMuY2FsbGVlLCBtZXNzYWdlIHx8XG4gICAgICAgICAgICAnRXhwZWN0ZWQgXCInICsgZXhwZWN0ICsgJ1wiIGJ1dCBnb3QgXCInICsgdHlwZSArICdcIi4nLFxuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuY2hlY2tJc1N0cmluZyA9IHR5cGVDaGVjaygnc3RyaW5nJyk7XG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzQXJyYXkgPSB0eXBlQ2hlY2soJ2FycmF5Jyk7XG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzTnVtYmVyID0gdHlwZUNoZWNrKCdudW1iZXInKTtcbm1vZHVsZS5leHBvcnRzLmNoZWNrSXNCb29sZWFuID0gdHlwZUNoZWNrKCdib29sZWFuJyk7XG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzRnVuY3Rpb24gPSB0eXBlQ2hlY2soJ2Z1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cy5jaGVja0lzT2JqZWN0ID0gdHlwZUNoZWNrKCdvYmplY3QnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/precond/lib/checks.js\n")},"./node_modules/precond/lib/errors.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("/*\n * Copyright (c) 2012 Mathieu Turcotte\n * Licensed under the MIT license.\n */\n\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nfunction IllegalArgumentError(message) {\n    Error.call(this, message);\n    this.message = message;\n}\nutil.inherits(IllegalArgumentError, Error);\n\nIllegalArgumentError.prototype.name = 'IllegalArgumentError';\n\nfunction IllegalStateError(message) {\n    Error.call(this, message);\n    this.message = message;\n}\nutil.inherits(IllegalStateError, Error);\n\nIllegalStateError.prototype.name = 'IllegalStateError';\n\nmodule.exports.IllegalStateError = IllegalStateError;\nmodule.exports.IllegalArgumentError = IllegalArgumentError;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcHJlY29uZC9saWIvZXJyb3JzLmpzPzc3YmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHlDQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDLG1DQUFtQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcmVjb25kL2xpYi9lcnJvcnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE1hdGhpZXUgVHVyY290dGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gSWxsZWdhbEFyZ3VtZW50RXJyb3IobWVzc2FnZSkge1xuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cbnV0aWwuaW5oZXJpdHMoSWxsZWdhbEFyZ3VtZW50RXJyb3IsIEVycm9yKTtcblxuSWxsZWdhbEFyZ3VtZW50RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSWxsZWdhbEFyZ3VtZW50RXJyb3InO1xuXG5mdW5jdGlvbiBJbGxlZ2FsU3RhdGVFcnJvcihtZXNzYWdlKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxudXRpbC5pbmhlcml0cyhJbGxlZ2FsU3RhdGVFcnJvciwgRXJyb3IpO1xuXG5JbGxlZ2FsU3RhdGVFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbGxlZ2FsU3RhdGVFcnJvcic7XG5cbm1vZHVsZS5leHBvcnRzLklsbGVnYWxTdGF0ZUVycm9yID0gSWxsZWdhbFN0YXRlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsQXJndW1lbnRFcnJvciA9IElsbGVnYWxBcmd1bWVudEVycm9yOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/precond/lib/errors.js\n")},"./node_modules/process/browser.js":module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/process/browser.js\n")},"./node_modules/regenerator-runtime/runtime-module.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function("return this")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = __webpack_require__(/*! ./runtime */ "./node_modules/regenerator-runtime/runtime.js");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLW1vZHVsZS5qcz9iYmRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGNBQWM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzR0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS1tb2R1bGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbi8vIFRoaXMgbWV0aG9kIG9mIG9idGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdCBuZWVkcyB0byBiZVxuLy8ga2VwdCBpZGVudGljYWwgdG8gdGhlIHdheSBpdCBpcyBvYnRhaW5lZCBpbiBydW50aW1lLmpzXG52YXIgZyA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG5cbi8vIFVzZSBgZ2V0T3duUHJvcGVydHlOYW1lc2AgYmVjYXVzZSBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgY2FsbGluZ1xuLy8gYGhhc093blByb3BlcnR5YCBvbiB0aGUgZ2xvYmFsIGBzZWxmYCBvYmplY3QgaW4gYSB3b3JrZXIuIFNlZSAjMTgzLlxudmFyIGhhZFJ1bnRpbWUgPSBnLnJlZ2VuZXJhdG9yUnVudGltZSAmJlxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhnKS5pbmRleE9mKFwicmVnZW5lcmF0b3JSdW50aW1lXCIpID49IDA7XG5cbi8vIFNhdmUgdGhlIG9sZCByZWdlbmVyYXRvclJ1bnRpbWUgaW4gY2FzZSBpdCBuZWVkcyB0byBiZSByZXN0b3JlZCBsYXRlci5cbnZhciBvbGRSdW50aW1lID0gaGFkUnVudGltZSAmJiBnLnJlZ2VuZXJhdG9yUnVudGltZTtcblxuLy8gRm9yY2UgcmVldmFsdXRhdGlvbiBvZiBydW50aW1lLmpzLlxuZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSB1bmRlZmluZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcblxuaWYgKGhhZFJ1bnRpbWUpIHtcbiAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcnVudGltZS5cbiAgZy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBvbGRSdW50aW1lO1xufSBlbHNlIHtcbiAgLy8gUmVtb3ZlIHRoZSBnbG9iYWwgcHJvcGVydHkgYWRkZWQgYnkgcnVudGltZS5qcy5cbiAgdHJ5IHtcbiAgICBkZWxldGUgZy5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIGcucmVnZW5lcmF0b3JSdW50aW1lID0gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime-module.js\n')},"./node_modules/regenerator-runtime/runtime.js":module=>{eval('/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  "use strict";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === "function" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || "@@iterator";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";\n  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";\n\n  var inModule = "object" === "object";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we\'re in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don\'t bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we\'re in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there\'s no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don\'t have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: "normal", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: "throw", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = "suspendedStart";\n  var GenStateSuspendedYield = "suspendedYield";\n  var GenStateExecuting = "executing";\n  var GenStateCompleted = "completed";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don\'t natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = "GeneratorFunction";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    ["next", "throw", "return"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === "function" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === "GeneratorFunction"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = "GeneratorFunction";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, "__await")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === "throw") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === "object" &&\n            hasOwn.call(value, "__await")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke("next", value, resolve, reject);\n          }, function(err) {\n            invoke("throw", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error("Generator is already running");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === "throw") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === "next") {\n          // Setting context._sent for legacy support of Babel\'s\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === "throw") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === "return") {\n          context.abrupt("return", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === "normal") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === "throw") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = "throw";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === "throw") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = "return";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === "throw") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // "return" to "throw", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = "throw";\n        context.arg = new TypeError(\n          "The iterator does not provide a \'throw\' method");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === "throw") {\n      context.method = "throw";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = "throw";\n      context.arg = new TypeError("iterator result is not an object");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was "throw" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was "next", forget context.arg since it has been\n      // "consumed" by the delegate iterator. If context.method was\n      // "return", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== "return") {\n        context.method = "next";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = "Generator";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers\' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn\'t happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return "[object Generator]";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = "normal";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: "root" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === "function") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel\'s\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = "next";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === "t" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === "throw") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = "throw";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = "next";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === "root") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle("end");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, "catchLoc");\n          var hasFinally = hasOwn.call(entry, "finallyLoc");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error("try statement without catch or finally");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, "finallyLoc") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === "break" ||\n           type === "continue") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = "next";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === "throw") {\n        throw record.arg;\n      }\n\n      if (record.type === "break" ||\n          record.type === "continue") {\n        this.next = record.arg;\n      } else if (record.type === "return") {\n        this.rval = this.arg = record.arg;\n        this.method = "return";\n        this.next = "end";\n      } else if (record.type === "normal" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    "catch": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === "throw") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error("illegal catch attempt");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === "next") {\n        // Deliberately forget the last sent value so that we don\'t\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we\'re in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function("return this")()\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzPzk2Y2YiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsUUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuIShmdW5jdGlvbihnbG9iYWwpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICB2YXIgaW5Nb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiO1xuICB2YXIgcnVudGltZSA9IGdsb2JhbC5yZWdlbmVyYXRvclJ1bnRpbWU7XG4gIGlmIChydW50aW1lKSB7XG4gICAgaWYgKGluTW9kdWxlKSB7XG4gICAgICAvLyBJZiByZWdlbmVyYXRvclJ1bnRpbWUgaXMgZGVmaW5lZCBnbG9iYWxseSBhbmQgd2UncmUgaW4gYSBtb2R1bGUsXG4gICAgICAvLyBtYWtlIHRoZSBleHBvcnRzIG9iamVjdCBpZGVudGljYWwgdG8gcmVnZW5lcmF0b3JSdW50aW1lLlxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBydW50aW1lO1xuICAgIH1cbiAgICAvLyBEb24ndCBib3RoZXIgZXZhbHVhdGluZyB0aGUgcmVzdCBvZiB0aGlzIGZpbGUgaWYgdGhlIHJ1bnRpbWUgd2FzXG4gICAgLy8gYWxyZWFkeSBkZWZpbmVkIGdsb2JhbGx5LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIERlZmluZSB0aGUgcnVudGltZSBnbG9iYWxseSAoYXMgZXhwZWN0ZWQgYnkgZ2VuZXJhdGVkIGNvZGUpIGFzIGVpdGhlclxuICAvLyBtb2R1bGUuZXhwb3J0cyAoaWYgd2UncmUgaW4gYSBtb2R1bGUpIG9yIGEgbmV3LCBlbXB0eSBvYmplY3QuXG4gIHJ1bnRpbWUgPSBnbG9iYWwucmVnZW5lcmF0b3JSdW50aW1lID0gaW5Nb2R1bGUgPyBtb2R1bGUuZXhwb3J0cyA6IHt9O1xuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIHJ1bnRpbWUud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlW3RvU3RyaW5nVGFnU3ltYm9sXSA9XG4gICAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgcHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgcnVudGltZS5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgcnVudGltZS5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBpZiAoISh0b1N0cmluZ1RhZ1N5bWJvbCBpbiBnZW5GdW4pKSB7XG4gICAgICAgIGdlbkZ1blt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIHJ1bnRpbWUuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgaG93ZXZlciwgdGhlXG4gICAgICAgICAgLy8gcmVzdWx0IGZvciB0aGlzIGl0ZXJhdGlvbiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhlIHNhbWVcbiAgICAgICAgICAvLyByZWFzb24uIE5vdGUgdGhhdCByZWplY3Rpb25zIG9mIHlpZWxkZWQgUHJvbWlzZXMgYXJlIG5vdFxuICAgICAgICAgIC8vIHRocm93biBiYWNrIGludG8gdGhlIGdlbmVyYXRvciBmdW5jdGlvbiwgYXMgaXMgdGhlIGNhc2VcbiAgICAgICAgICAvLyB3aGVuIGFuIGF3YWl0ZWQgUHJvbWlzZSBpcyByZWplY3RlZC4gVGhpcyBkaWZmZXJlbmNlIGluXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYmV0d2VlbiB5aWVsZCBhbmQgYXdhaXQgaXMgaW1wb3J0YW50LCBiZWNhdXNlIGl0XG4gICAgICAgICAgLy8gYWxsb3dzIHRoZSBjb25zdW1lciB0byBkZWNpZGUgd2hhdCB0byBkbyB3aXRoIHRoZSB5aWVsZGVkXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIChzd2FsbG93IGl0IGFuZCBjb250aW51ZSwgbWFudWFsbHkgLnRocm93IGl0IGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBnZW5lcmF0b3IsIGFiYW5kb24gaXRlcmF0aW9uLCB3aGF0ZXZlcikuIFdpdGhcbiAgICAgICAgICAvLyBhd2FpdCwgYnkgY29udHJhc3QsIHRoZXJlIGlzIG5vIG9wcG9ydHVuaXR5IHRvIGV4YW1pbmUgdGhlXG4gICAgICAgICAgLy8gcmVqZWN0aW9uIHJlYXNvbiBvdXRzaWRlIHRoZSBnZW5lcmF0b3IgZnVuY3Rpb24sIHNvIHRoZVxuICAgICAgICAgIC8vIG9ubHkgb3B0aW9uIGlzIHRvIHRocm93IGl0IGZyb20gdGhlIGF3YWl0IGV4cHJlc3Npb24sIGFuZFxuICAgICAgICAgIC8vIGxldCB0aGUgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhbmRsZSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgcnVudGltZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgcnVudGltZS5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBydW50aW1lLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgLy8gSWYgbWF5YmVJbnZva2VEZWxlZ2F0ZShjb250ZXh0KSBjaGFuZ2VkIGNvbnRleHQubWV0aG9kIGZyb21cbiAgICAgICAgICAgIC8vIFwicmV0dXJuXCIgdG8gXCJ0aHJvd1wiLCBsZXQgdGhhdCBvdmVycmlkZSB0aGUgVHlwZUVycm9yIGJlbG93LlxuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghIGluZm8pIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIGlmIChpbmZvLmRvbmUpIHtcbiAgICAgIC8vIEFzc2lnbiB0aGUgcmVzdWx0IG9mIHRoZSBmaW5pc2hlZCBkZWxlZ2F0ZSB0byB0aGUgdGVtcG9yYXJ5XG4gICAgICAvLyB2YXJpYWJsZSBzcGVjaWZpZWQgYnkgZGVsZWdhdGUucmVzdWx0TmFtZSAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG5cbiAgICAgIC8vIFJlc3VtZSBleGVjdXRpb24gYXQgdGhlIGRlc2lyZWQgbG9jYXRpb24gKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIC8vIElmIGNvbnRleHQubWV0aG9kIHdhcyBcInRocm93XCIgYnV0IHRoZSBkZWxlZ2F0ZSBoYW5kbGVkIHRoZVxuICAgICAgLy8gZXhjZXB0aW9uLCBsZXQgdGhlIG91dGVyIGdlbmVyYXRvciBwcm9jZWVkIG5vcm1hbGx5LiBJZlxuICAgICAgLy8gY29udGV4dC5tZXRob2Qgd2FzIFwibmV4dFwiLCBmb3JnZXQgY29udGV4dC5hcmcgc2luY2UgaXQgaGFzIGJlZW5cbiAgICAgIC8vIFwiY29uc3VtZWRcIiBieSB0aGUgZGVsZWdhdGUgaXRlcmF0b3IuIElmIGNvbnRleHQubWV0aG9kIHdhc1xuICAgICAgLy8gXCJyZXR1cm5cIiwgYWxsb3cgdGhlIG9yaWdpbmFsIC5yZXR1cm4gY2FsbCB0byBjb250aW51ZSBpbiB0aGVcbiAgICAgIC8vIG91dGVyIGdlbmVyYXRvci5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZS15aWVsZCB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBkZWxlZ2F0ZSBtZXRob2QuXG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICAvLyBUaGUgZGVsZWdhdGUgaXRlcmF0b3IgaXMgZmluaXNoZWQsIHNvIGZvcmdldCBpdCBhbmQgY29udGludWUgd2l0aFxuICAgIC8vIHRoZSBvdXRlciBnZW5lcmF0b3IuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICAvLyBEZWZpbmUgR2VuZXJhdG9yLnByb3RvdHlwZS57bmV4dCx0aHJvdyxyZXR1cm59IGluIHRlcm1zIG9mIHRoZVxuICAvLyB1bmlmaWVkIC5faW52b2tlIGhlbHBlciBtZXRob2QuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCk7XG5cbiAgR3BbdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JcIjtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBydW50aW1lLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgcnVudGltZS52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcbn0pKFxuICAvLyBJbiBzbG9wcHkgbW9kZSwgdW5ib3VuZCBgdGhpc2AgcmVmZXJzIHRvIHRoZSBnbG9iYWwgb2JqZWN0LCBmYWxsYmFjayB0b1xuICAvLyBGdW5jdGlvbiBjb25zdHJ1Y3RvciBpZiB3ZSdyZSBpbiBnbG9iYWwgc3RyaWN0IG1vZGUuIFRoYXQgaXMgc2FkbHkgYSBmb3JtXG4gIC8vIG9mIGluZGlyZWN0IGV2YWwgd2hpY2ggdmlvbGF0ZXMgQ29udGVudCBTZWN1cml0eSBQb2xpY3kuXG4gIChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMgfSkoKSB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKClcbik7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n')},"./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */\n /* eslint-env node */\n\n\nvar SDPUtils = __webpack_require__(/*! sdp */ \"./node_modules/sdp/sdp.js\");\n\nfunction writeMediaSection(transceiver, caps, type, stream, dtlsRole) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n      transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n      transceiver.dtlsTransport.getLocalParameters(),\n      type === 'offer' ? 'actpass' : dtlsRole || 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    var trackId = transceiver.rtpSender._initialTrackId ||\n        transceiver.rtpSender.track.id;\n    transceiver.rtpSender._initialTrackId = trackId;\n    // spec.\n    var msid = 'msid:' + (stream ? stream.id : '-') + ' ' +\n        trackId + '\\r\\n';\n    sdp += 'a=' + msid;\n    // for Chrome. Legacy should no longer be required.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n\n    // RTX\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n}\n\n// Edge does not like\n// 1) stun: filtered after 14393 unless ?transport=udp is present\n// 2) turn: that does not have all of turn:host:port?transport=udp\n// 3) turn: with ipv6 addresses\n// 4) turn: occurring muliple times\nfunction filterIceServers(iceServers, edgeVersion) {\n  var hasTurn = false;\n  iceServers = JSON.parse(JSON.stringify(iceServers));\n  return iceServers.filter(function(server) {\n    if (server && (server.urls || server.url)) {\n      var urls = server.urls || server.url;\n      if (server.url && !server.urls) {\n        console.warn('RTCIceServer.url is deprecated! Use urls instead.');\n      }\n      var isString = typeof urls === 'string';\n      if (isString) {\n        urls = [urls];\n      }\n      urls = urls.filter(function(url) {\n        var validTurn = url.indexOf('turn:') === 0 &&\n            url.indexOf('transport=udp') !== -1 &&\n            url.indexOf('turn:[') === -1 &&\n            !hasTurn;\n\n        if (validTurn) {\n          hasTurn = true;\n          return true;\n        }\n        return url.indexOf('stun:') === 0 && edgeVersion >= 14393 &&\n            url.indexOf('?transport=udp') === -1;\n      });\n\n      delete server.url;\n      server.urls = isString ? urls[0] : urls;\n      return !!urls.length;\n    }\n  });\n}\n\n// Determines the intersection of local and remote capabilities.\nfunction getCommonCapabilities(localCapabilities, remoteCapabilities) {\n  var commonCapabilities = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: []\n  };\n\n  var findCodecByPayloadType = function(pt, codecs) {\n    pt = parseInt(pt, 10);\n    for (var i = 0; i < codecs.length; i++) {\n      if (codecs[i].payloadType === pt ||\n          codecs[i].preferredPayloadType === pt) {\n        return codecs[i];\n      }\n    }\n  };\n\n  var rtxCapabilityMatches = function(lRtx, rRtx, lCodecs, rCodecs) {\n    var lCodec = findCodecByPayloadType(lRtx.parameters.apt, lCodecs);\n    var rCodec = findCodecByPayloadType(rRtx.parameters.apt, rCodecs);\n    return lCodec && rCodec &&\n        lCodec.name.toLowerCase() === rCodec.name.toLowerCase();\n  };\n\n  localCapabilities.codecs.forEach(function(lCodec) {\n    for (var i = 0; i < remoteCapabilities.codecs.length; i++) {\n      var rCodec = remoteCapabilities.codecs[i];\n      if (lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&\n          lCodec.clockRate === rCodec.clockRate) {\n        if (lCodec.name.toLowerCase() === 'rtx' &&\n            lCodec.parameters && rCodec.parameters.apt) {\n          // for RTX we need to find the local rtx that has a apt\n          // which points to the same local codec as the remote one.\n          if (!rtxCapabilityMatches(lCodec, rCodec,\n              localCapabilities.codecs, remoteCapabilities.codecs)) {\n            continue;\n          }\n        }\n        rCodec = JSON.parse(JSON.stringify(rCodec)); // deepcopy\n        // number of channels is the highest common number of channels\n        rCodec.numChannels = Math.min(lCodec.numChannels,\n            rCodec.numChannels);\n        // push rCodec so we reply with offerer payload type\n        commonCapabilities.codecs.push(rCodec);\n\n        // determine common feedback mechanisms\n        rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function(fb) {\n          for (var j = 0; j < lCodec.rtcpFeedback.length; j++) {\n            if (lCodec.rtcpFeedback[j].type === fb.type &&\n                lCodec.rtcpFeedback[j].parameter === fb.parameter) {\n              return true;\n            }\n          }\n          return false;\n        });\n        // FIXME: also need to determine .parameters\n        //  see https://github.com/openpeer/ortc/issues/569\n        break;\n      }\n    }\n  });\n\n  localCapabilities.headerExtensions.forEach(function(lHeaderExtension) {\n    for (var i = 0; i < remoteCapabilities.headerExtensions.length;\n         i++) {\n      var rHeaderExtension = remoteCapabilities.headerExtensions[i];\n      if (lHeaderExtension.uri === rHeaderExtension.uri) {\n        commonCapabilities.headerExtensions.push(rHeaderExtension);\n        break;\n      }\n    }\n  });\n\n  // FIXME: fecMechanisms\n  return commonCapabilities;\n}\n\n// is action=setLocalDescription with type allowed in signalingState\nfunction isActionAllowedInSignalingState(action, type, signalingState) {\n  return {\n    offer: {\n      setLocalDescription: ['stable', 'have-local-offer'],\n      setRemoteDescription: ['stable', 'have-remote-offer']\n    },\n    answer: {\n      setLocalDescription: ['have-remote-offer', 'have-local-pranswer'],\n      setRemoteDescription: ['have-local-offer', 'have-remote-pranswer']\n    }\n  }[type][action].indexOf(signalingState) !== -1;\n}\n\nfunction maybeAddCandidate(iceTransport, candidate) {\n  // Edge's internal representation adds some fields therefore\n  // not all field are taken into account.\n  var alreadyAdded = iceTransport.getRemoteCandidates()\n      .find(function(remoteCandidate) {\n        return candidate.foundation === remoteCandidate.foundation &&\n            candidate.ip === remoteCandidate.ip &&\n            candidate.port === remoteCandidate.port &&\n            candidate.priority === remoteCandidate.priority &&\n            candidate.protocol === remoteCandidate.protocol &&\n            candidate.type === remoteCandidate.type;\n      });\n  if (!alreadyAdded) {\n    iceTransport.addRemoteCandidate(candidate);\n  }\n  return !alreadyAdded;\n}\n\n\nfunction makeError(name, description) {\n  var e = new Error(description);\n  e.name = name;\n  return e;\n}\n\nmodule.exports = function(window, edgeVersion) {\n  // https://w3c.github.io/mediacapture-main/#mediastream\n  // Helper function to add the track to the stream and\n  // dispatch the event ourselves.\n  function addTrackToStreamAndFireEvent(track, stream) {\n    stream.addTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('addtrack',\n        {track: track}));\n  }\n\n  function removeTrackFromStreamAndFireEvent(track, stream) {\n    stream.removeTrack(track);\n    stream.dispatchEvent(new window.MediaStreamTrackEvent('removetrack',\n        {track: track}));\n  }\n\n  function fireAddTrack(pc, track, receiver, streams) {\n    var trackEvent = new Event('track');\n    trackEvent.track = track;\n    trackEvent.receiver = receiver;\n    trackEvent.transceiver = {receiver: receiver};\n    trackEvent.streams = streams;\n    window.setTimeout(function() {\n      pc._dispatchEvent('track', trackEvent);\n    });\n  }\n\n  var RTCPeerConnection = function(config) {\n    var pc = this;\n\n    var _eventTarget = document.createDocumentFragment();\n    ['addEventListener', 'removeEventListener', 'dispatchEvent']\n        .forEach(function(method) {\n          pc[method] = _eventTarget[method].bind(_eventTarget);\n        });\n\n    this.canTrickleIceCandidates = null;\n\n    this.needNegotiation = false;\n\n    this.localStreams = [];\n    this.remoteStreams = [];\n\n    this.localDescription = null;\n    this.remoteDescription = null;\n\n    this.signalingState = 'stable';\n    this.iceConnectionState = 'new';\n    this.iceGatheringState = 'new';\n\n    config = JSON.parse(JSON.stringify(config || {}));\n\n    this.usingBundle = config.bundlePolicy === 'max-bundle';\n    if (config.rtcpMuxPolicy === 'negotiate') {\n      throw(makeError('NotSupportedError',\n          'rtcpMuxPolicy \\'negotiate\\' is not supported'));\n    } else if (!config.rtcpMuxPolicy) {\n      config.rtcpMuxPolicy = 'require';\n    }\n\n    switch (config.iceTransportPolicy) {\n      case 'all':\n      case 'relay':\n        break;\n      default:\n        config.iceTransportPolicy = 'all';\n        break;\n    }\n\n    switch (config.bundlePolicy) {\n      case 'balanced':\n      case 'max-compat':\n      case 'max-bundle':\n        break;\n      default:\n        config.bundlePolicy = 'balanced';\n        break;\n    }\n\n    config.iceServers = filterIceServers(config.iceServers || [], edgeVersion);\n\n    this._iceGatherers = [];\n    if (config.iceCandidatePoolSize) {\n      for (var i = config.iceCandidatePoolSize; i > 0; i--) {\n        this._iceGatherers.push(new window.RTCIceGatherer({\n          iceServers: config.iceServers,\n          gatherPolicy: config.iceTransportPolicy\n        }));\n      }\n    } else {\n      config.iceCandidatePoolSize = 0;\n    }\n\n    this._config = config;\n\n    // per-track iceGathers, iceTransports, dtlsTransports, rtpSenders, ...\n    // everything that is needed to describe a SDP m-line.\n    this.transceivers = [];\n\n    this._sdpSessionId = SDPUtils.generateSessionId();\n    this._sdpSessionVersion = 0;\n\n    this._dtlsRole = undefined; // role for a=setup to use in answers.\n\n    this._isClosed = false;\n  };\n\n  // set up event handlers on prototype\n  RTCPeerConnection.prototype.onicecandidate = null;\n  RTCPeerConnection.prototype.onaddstream = null;\n  RTCPeerConnection.prototype.ontrack = null;\n  RTCPeerConnection.prototype.onremovestream = null;\n  RTCPeerConnection.prototype.onsignalingstatechange = null;\n  RTCPeerConnection.prototype.oniceconnectionstatechange = null;\n  RTCPeerConnection.prototype.onicegatheringstatechange = null;\n  RTCPeerConnection.prototype.onnegotiationneeded = null;\n  RTCPeerConnection.prototype.ondatachannel = null;\n\n  RTCPeerConnection.prototype._dispatchEvent = function(name, event) {\n    if (this._isClosed) {\n      return;\n    }\n    this.dispatchEvent(event);\n    if (typeof this['on' + name] === 'function') {\n      this['on' + name](event);\n    }\n  };\n\n  RTCPeerConnection.prototype._emitGatheringStateChange = function() {\n    var event = new Event('icegatheringstatechange');\n    this._dispatchEvent('icegatheringstatechange', event);\n  };\n\n  RTCPeerConnection.prototype.getConfiguration = function() {\n    return this._config;\n  };\n\n  RTCPeerConnection.prototype.getLocalStreams = function() {\n    return this.localStreams;\n  };\n\n  RTCPeerConnection.prototype.getRemoteStreams = function() {\n    return this.remoteStreams;\n  };\n\n  // internal helper to create a transceiver object.\n  // (whih is not yet the same as the WebRTC 1.0 transceiver)\n  RTCPeerConnection.prototype._createTransceiver = function(kind) {\n    var hasBundleTransport = this.transceivers.length > 0;\n    var transceiver = {\n      track: null,\n      iceGatherer: null,\n      iceTransport: null,\n      dtlsTransport: null,\n      localCapabilities: null,\n      remoteCapabilities: null,\n      rtpSender: null,\n      rtpReceiver: null,\n      kind: kind,\n      mid: null,\n      sendEncodingParameters: null,\n      recvEncodingParameters: null,\n      stream: null,\n      associatedRemoteMediaStreams: [],\n      wantReceive: true\n    };\n    if (this.usingBundle && hasBundleTransport) {\n      transceiver.iceTransport = this.transceivers[0].iceTransport;\n      transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;\n    } else {\n      var transports = this._createIceAndDtlsTransports();\n      transceiver.iceTransport = transports.iceTransport;\n      transceiver.dtlsTransport = transports.dtlsTransport;\n    }\n    this.transceivers.push(transceiver);\n    return transceiver;\n  };\n\n  RTCPeerConnection.prototype.addTrack = function(track, stream) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call addTrack on a closed peerconnection.');\n    }\n\n    var alreadyExists = this.transceivers.find(function(s) {\n      return s.track === track;\n    });\n\n    if (alreadyExists) {\n      throw makeError('InvalidAccessError', 'Track already exists.');\n    }\n\n    var transceiver;\n    for (var i = 0; i < this.transceivers.length; i++) {\n      if (!this.transceivers[i].track &&\n          this.transceivers[i].kind === track.kind) {\n        transceiver = this.transceivers[i];\n      }\n    }\n    if (!transceiver) {\n      transceiver = this._createTransceiver(track.kind);\n    }\n\n    this._maybeFireNegotiationNeeded();\n\n    if (this.localStreams.indexOf(stream) === -1) {\n      this.localStreams.push(stream);\n    }\n\n    transceiver.track = track;\n    transceiver.stream = stream;\n    transceiver.rtpSender = new window.RTCRtpSender(track,\n        transceiver.dtlsTransport);\n    return transceiver.rtpSender;\n  };\n\n  RTCPeerConnection.prototype.addStream = function(stream) {\n    var pc = this;\n    if (edgeVersion >= 15025) {\n      stream.getTracks().forEach(function(track) {\n        pc.addTrack(track, stream);\n      });\n    } else {\n      // Clone is necessary for local demos mostly, attaching directly\n      // to two different senders does not work (build 10547).\n      // Fixed in 15025 (or earlier)\n      var clonedStream = stream.clone();\n      stream.getTracks().forEach(function(track, idx) {\n        var clonedTrack = clonedStream.getTracks()[idx];\n        track.addEventListener('enabled', function(event) {\n          clonedTrack.enabled = event.enabled;\n        });\n      });\n      clonedStream.getTracks().forEach(function(track) {\n        pc.addTrack(track, clonedStream);\n      });\n    }\n  };\n\n  RTCPeerConnection.prototype.removeTrack = function(sender) {\n    if (this._isClosed) {\n      throw makeError('InvalidStateError',\n          'Attempted to call removeTrack on a closed peerconnection.');\n    }\n\n    if (!(sender instanceof window.RTCRtpSender)) {\n      throw new TypeError('Argument 1 of RTCPeerConnection.removeTrack ' +\n          'does not implement interface RTCRtpSender.');\n    }\n\n    var transceiver = this.transceivers.find(function(t) {\n      return t.rtpSender === sender;\n    });\n\n    if (!transceiver) {\n      throw makeError('InvalidAccessError',\n          'Sender was not created by this connection.');\n    }\n    var stream = transceiver.stream;\n\n    transceiver.rtpSender.stop();\n    transceiver.rtpSender = null;\n    transceiver.track = null;\n    transceiver.stream = null;\n\n    // remove the stream from the set of local streams\n    var localStreams = this.transceivers.map(function(t) {\n      return t.stream;\n    });\n    if (localStreams.indexOf(stream) === -1 &&\n        this.localStreams.indexOf(stream) > -1) {\n      this.localStreams.splice(this.localStreams.indexOf(stream), 1);\n    }\n\n    this._maybeFireNegotiationNeeded();\n  };\n\n  RTCPeerConnection.prototype.removeStream = function(stream) {\n    var pc = this;\n    stream.getTracks().forEach(function(track) {\n      var sender = pc.getSenders().find(function(s) {\n        return s.track === track;\n      });\n      if (sender) {\n        pc.removeTrack(sender);\n      }\n    });\n  };\n\n  RTCPeerConnection.prototype.getSenders = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpSender;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpSender;\n    });\n  };\n\n  RTCPeerConnection.prototype.getReceivers = function() {\n    return this.transceivers.filter(function(transceiver) {\n      return !!transceiver.rtpReceiver;\n    })\n    .map(function(transceiver) {\n      return transceiver.rtpReceiver;\n    });\n  };\n\n\n  RTCPeerConnection.prototype._createIceGatherer = function(sdpMLineIndex,\n      usingBundle) {\n    var pc = this;\n    if (usingBundle && sdpMLineIndex > 0) {\n      return this.transceivers[0].iceGatherer;\n    } else if (this._iceGatherers.length) {\n      return this._iceGatherers.shift();\n    }\n    var iceGatherer = new window.RTCIceGatherer({\n      iceServers: this._config.iceServers,\n      gatherPolicy: this._config.iceTransportPolicy\n    });\n    Object.defineProperty(iceGatherer, 'state',\n        {value: 'new', writable: true}\n    );\n\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];\n    this.transceivers[sdpMLineIndex].bufferCandidates = function(event) {\n      var end = !event.candidate || Object.keys(event.candidate).length === 0;\n      // polyfill since RTCIceGatherer.state is not implemented in\n      // Edge 10547 yet.\n      iceGatherer.state = end ? 'completed' : 'gathering';\n      if (pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !== null) {\n        pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(event);\n      }\n    };\n    iceGatherer.addEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    return iceGatherer;\n  };\n\n  // start gathering from an RTCIceGatherer.\n  RTCPeerConnection.prototype._gather = function(mid, sdpMLineIndex) {\n    var pc = this;\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer.onlocalcandidate) {\n      return;\n    }\n    var bufferedCandidateEvents =\n      this.transceivers[sdpMLineIndex].bufferedCandidateEvents;\n    this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;\n    iceGatherer.removeEventListener('localcandidate',\n      this.transceivers[sdpMLineIndex].bufferCandidates);\n    iceGatherer.onlocalcandidate = function(evt) {\n      if (pc.usingBundle && sdpMLineIndex > 0) {\n        // if we know that we use bundle we can drop candidates with\n        // dpMLineIndex > 0. If we don't do this then our state gets\n        // confused since we dispose the extra ice gatherer.\n        return;\n      }\n      var event = new Event('icecandidate');\n      event.candidate = {sdpMid: mid, sdpMLineIndex: sdpMLineIndex};\n\n      var cand = evt.candidate;\n      // Edge emits an empty object for RTCIceCandidateComplete\n      var end = !cand || Object.keys(cand).length === 0;\n      if (end) {\n        // polyfill since RTCIceGatherer.state is not implemented in\n        // Edge 10547 yet.\n        if (iceGatherer.state === 'new' || iceGatherer.state === 'gathering') {\n          iceGatherer.state = 'completed';\n        }\n      } else {\n        if (iceGatherer.state === 'new') {\n          iceGatherer.state = 'gathering';\n        }\n        // RTCIceCandidate doesn't have a component, needs to be added\n        cand.component = 1;\n        var serializedCandidate = SDPUtils.writeCandidate(cand);\n        event.candidate = Object.assign(event.candidate,\n            SDPUtils.parseCandidate(serializedCandidate));\n        event.candidate.candidate = serializedCandidate;\n      }\n\n      // update local description.\n      var sections = SDPUtils.getMediaSections(pc.localDescription.sdp);\n      if (!end) {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=' + event.candidate.candidate + '\\r\\n';\n      } else {\n        sections[event.candidate.sdpMLineIndex] +=\n            'a=end-of-candidates\\r\\n';\n      }\n      pc.localDescription.sdp =\n          SDPUtils.getDescription(pc.localDescription.sdp) +\n          sections.join('');\n      var complete = pc.transceivers.every(function(transceiver) {\n        return transceiver.iceGatherer &&\n            transceiver.iceGatherer.state === 'completed';\n      });\n\n      if (pc.iceGatheringState !== 'gathering') {\n        pc.iceGatheringState = 'gathering';\n        pc._emitGatheringStateChange();\n      }\n\n      // Emit candidate. Also emit null candidate when all gatherers are\n      // complete.\n      if (!end) {\n        pc._dispatchEvent('icecandidate', event);\n      }\n      if (complete) {\n        pc._dispatchEvent('icecandidate', new Event('icecandidate'));\n        pc.iceGatheringState = 'complete';\n        pc._emitGatheringStateChange();\n      }\n    };\n\n    // emit already gathered candidates.\n    window.setTimeout(function() {\n      bufferedCandidateEvents.forEach(function(e) {\n        iceGatherer.onlocalcandidate(e);\n      });\n    }, 0);\n  };\n\n  // Create ICE transport and DTLS transport.\n  RTCPeerConnection.prototype._createIceAndDtlsTransports = function() {\n    var pc = this;\n    var iceTransport = new window.RTCIceTransport(null);\n    iceTransport.onicestatechange = function() {\n      pc._updateConnectionState();\n    };\n\n    var dtlsTransport = new window.RTCDtlsTransport(iceTransport);\n    dtlsTransport.ondtlsstatechange = function() {\n      pc._updateConnectionState();\n    };\n    dtlsTransport.onerror = function() {\n      // onerror does not set state to failed by itself.\n      Object.defineProperty(dtlsTransport, 'state',\n          {value: 'failed', writable: true});\n      pc._updateConnectionState();\n    };\n\n    return {\n      iceTransport: iceTransport,\n      dtlsTransport: dtlsTransport\n    };\n  };\n\n  // Destroy ICE gatherer, ICE transport and DTLS transport.\n  // Without triggering the callbacks.\n  RTCPeerConnection.prototype._disposeIceAndDtlsTransports = function(\n      sdpMLineIndex) {\n    var iceGatherer = this.transceivers[sdpMLineIndex].iceGatherer;\n    if (iceGatherer) {\n      delete iceGatherer.onlocalcandidate;\n      delete this.transceivers[sdpMLineIndex].iceGatherer;\n    }\n    var iceTransport = this.transceivers[sdpMLineIndex].iceTransport;\n    if (iceTransport) {\n      delete iceTransport.onicestatechange;\n      delete this.transceivers[sdpMLineIndex].iceTransport;\n    }\n    var dtlsTransport = this.transceivers[sdpMLineIndex].dtlsTransport;\n    if (dtlsTransport) {\n      delete dtlsTransport.ondtlsstatechange;\n      delete dtlsTransport.onerror;\n      delete this.transceivers[sdpMLineIndex].dtlsTransport;\n    }\n  };\n\n  // Start the RTP Sender and Receiver for a transceiver.\n  RTCPeerConnection.prototype._transceive = function(transceiver,\n      send, recv) {\n    var params = getCommonCapabilities(transceiver.localCapabilities,\n        transceiver.remoteCapabilities);\n    if (send && transceiver.rtpSender) {\n      params.encodings = transceiver.sendEncodingParameters;\n      params.rtcp = {\n        cname: SDPUtils.localCName,\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.recvEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpSender.send(params);\n    }\n    if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {\n      // remove RTX field in Edge 14942\n      if (transceiver.kind === 'video'\n          && transceiver.recvEncodingParameters\n          && edgeVersion < 15019) {\n        transceiver.recvEncodingParameters.forEach(function(p) {\n          delete p.rtx;\n        });\n      }\n      if (transceiver.recvEncodingParameters.length) {\n        params.encodings = transceiver.recvEncodingParameters;\n      } else {\n        params.encodings = [{}];\n      }\n      params.rtcp = {\n        compound: transceiver.rtcpParameters.compound\n      };\n      if (transceiver.rtcpParameters.cname) {\n        params.rtcp.cname = transceiver.rtcpParameters.cname;\n      }\n      if (transceiver.sendEncodingParameters.length) {\n        params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;\n      }\n      transceiver.rtpReceiver.receive(params);\n    }\n  };\n\n  RTCPeerConnection.prototype.setLocalDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setLocalDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set local ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var sections;\n    var sessionpart;\n    if (description.type === 'offer') {\n      // VERY limited support for SDP munging. Limited to:\n      // * changing the order of codecs\n      sections = SDPUtils.splitSections(description.sdp);\n      sessionpart = sections.shift();\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var caps = SDPUtils.parseRtpParameters(mediaSection);\n        pc.transceivers[sdpMLineIndex].localCapabilities = caps;\n      });\n\n      pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n        pc._gather(transceiver.mid, sdpMLineIndex);\n      });\n    } else if (description.type === 'answer') {\n      sections = SDPUtils.splitSections(pc.remoteDescription.sdp);\n      sessionpart = sections.shift();\n      var isIceLite = SDPUtils.matchPrefix(sessionpart,\n          'a=ice-lite').length > 0;\n      sections.forEach(function(mediaSection, sdpMLineIndex) {\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        var iceGatherer = transceiver.iceGatherer;\n        var iceTransport = transceiver.iceTransport;\n        var dtlsTransport = transceiver.dtlsTransport;\n        var localCapabilities = transceiver.localCapabilities;\n        var remoteCapabilities = transceiver.remoteCapabilities;\n\n        // treat bundle-only as not-rejected.\n        var rejected = SDPUtils.isRejected(mediaSection) &&\n            SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n\n        if (!rejected && !transceiver.isDatachannel) {\n          var remoteIceParameters = SDPUtils.getIceParameters(\n              mediaSection, sessionpart);\n          var remoteDtlsParameters = SDPUtils.getDtlsParameters(\n              mediaSection, sessionpart);\n          if (isIceLite) {\n            remoteDtlsParameters.role = 'server';\n          }\n\n          if (!pc.usingBundle || sdpMLineIndex === 0) {\n            pc._gather(transceiver.mid, sdpMLineIndex);\n            if (iceTransport.state === 'new') {\n              iceTransport.start(iceGatherer, remoteIceParameters,\n                  isIceLite ? 'controlling' : 'controlled');\n            }\n            if (dtlsTransport.state === 'new') {\n              dtlsTransport.start(remoteDtlsParameters);\n            }\n          }\n\n          // Calculate intersection of capabilities.\n          var params = getCommonCapabilities(localCapabilities,\n              remoteCapabilities);\n\n          // Start the RTCRtpSender. The RTCRtpReceiver for this\n          // transceiver has already been started in setRemoteDescription.\n          pc._transceive(transceiver,\n              params.codecs.length > 0,\n              false);\n        }\n      });\n    }\n\n    pc.localDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-local-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.setRemoteDescription = function(description) {\n    var pc = this;\n\n    // Note: pranswer is not supported.\n    if (['offer', 'answer'].indexOf(description.type) === -1) {\n      return Promise.reject(makeError('TypeError',\n          'Unsupported type \"' + description.type + '\"'));\n    }\n\n    if (!isActionAllowedInSignalingState('setRemoteDescription',\n        description.type, pc.signalingState) || pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not set remote ' + description.type +\n          ' in state ' + pc.signalingState));\n    }\n\n    var streams = {};\n    pc.remoteStreams.forEach(function(stream) {\n      streams[stream.id] = stream;\n    });\n    var receiverList = [];\n    var sections = SDPUtils.splitSections(description.sdp);\n    var sessionpart = sections.shift();\n    var isIceLite = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-lite').length > 0;\n    var usingBundle = SDPUtils.matchPrefix(sessionpart,\n        'a=group:BUNDLE ').length > 0;\n    pc.usingBundle = usingBundle;\n    var iceOptions = SDPUtils.matchPrefix(sessionpart,\n        'a=ice-options:')[0];\n    if (iceOptions) {\n      pc.canTrickleIceCandidates = iceOptions.substr(14).split(' ')\n          .indexOf('trickle') >= 0;\n    } else {\n      pc.canTrickleIceCandidates = false;\n    }\n\n    sections.forEach(function(mediaSection, sdpMLineIndex) {\n      var lines = SDPUtils.splitLines(mediaSection);\n      var kind = SDPUtils.getKind(mediaSection);\n      // treat bundle-only as not-rejected.\n      var rejected = SDPUtils.isRejected(mediaSection) &&\n          SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length === 0;\n      var protocol = lines[0].substr(2).split(' ')[2];\n\n      var direction = SDPUtils.getDirection(mediaSection, sessionpart);\n      var remoteMsid = SDPUtils.parseMsid(mediaSection);\n\n      var mid = SDPUtils.getMid(mediaSection) || SDPUtils.generateIdentifier();\n\n      // Reject datachannels which are not implemented yet.\n      if (kind === 'application' && protocol === 'DTLS/SCTP') {\n        pc.transceivers[sdpMLineIndex] = {\n          mid: mid,\n          isDatachannel: true\n        };\n        return;\n      }\n\n      var transceiver;\n      var iceGatherer;\n      var iceTransport;\n      var dtlsTransport;\n      var rtpReceiver;\n      var sendEncodingParameters;\n      var recvEncodingParameters;\n      var localCapabilities;\n\n      var track;\n      // FIXME: ensure the mediaSection has rtcp-mux set.\n      var remoteCapabilities = SDPUtils.parseRtpParameters(mediaSection);\n      var remoteIceParameters;\n      var remoteDtlsParameters;\n      if (!rejected) {\n        remoteIceParameters = SDPUtils.getIceParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters = SDPUtils.getDtlsParameters(mediaSection,\n            sessionpart);\n        remoteDtlsParameters.role = 'client';\n      }\n      recvEncodingParameters =\n          SDPUtils.parseRtpEncodingParameters(mediaSection);\n\n      var rtcpParameters = SDPUtils.parseRtcpParameters(mediaSection);\n\n      var isComplete = SDPUtils.matchPrefix(mediaSection,\n          'a=end-of-candidates', sessionpart).length > 0;\n      var cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')\n          .map(function(cand) {\n            return SDPUtils.parseCandidate(cand);\n          })\n          .filter(function(cand) {\n            return cand.component === 1;\n          });\n\n      // Check if we can use BUNDLE and dispose transports.\n      if ((description.type === 'offer' || description.type === 'answer') &&\n          !rejected && usingBundle && sdpMLineIndex > 0 &&\n          pc.transceivers[sdpMLineIndex]) {\n        pc._disposeIceAndDtlsTransports(sdpMLineIndex);\n        pc.transceivers[sdpMLineIndex].iceGatherer =\n            pc.transceivers[0].iceGatherer;\n        pc.transceivers[sdpMLineIndex].iceTransport =\n            pc.transceivers[0].iceTransport;\n        pc.transceivers[sdpMLineIndex].dtlsTransport =\n            pc.transceivers[0].dtlsTransport;\n        if (pc.transceivers[sdpMLineIndex].rtpSender) {\n          pc.transceivers[sdpMLineIndex].rtpSender.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n        if (pc.transceivers[sdpMLineIndex].rtpReceiver) {\n          pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(\n              pc.transceivers[0].dtlsTransport);\n        }\n      }\n      if (description.type === 'offer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex] ||\n            pc._createTransceiver(kind);\n        transceiver.mid = mid;\n\n        if (!transceiver.iceGatherer) {\n          transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n              usingBundle);\n        }\n\n        if (cands.length && transceiver.iceTransport.state === 'new') {\n          if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {\n            transceiver.iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        localCapabilities = window.RTCRtpReceiver.getCapabilities(kind);\n\n        // filter RTX until additional stuff needed for RTX is implemented\n        // in adapter.js\n        if (edgeVersion < 15019) {\n          localCapabilities.codecs = localCapabilities.codecs.filter(\n              function(codec) {\n                return codec.name !== 'rtx';\n              });\n        }\n\n        sendEncodingParameters = transceiver.sendEncodingParameters || [{\n          ssrc: (2 * sdpMLineIndex + 2) * 1001\n        }];\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        var isNewTrack = false;\n        if (direction === 'sendrecv' || direction === 'sendonly') {\n          isNewTrack = !transceiver.rtpReceiver;\n          rtpReceiver = transceiver.rtpReceiver ||\n              new window.RTCRtpReceiver(transceiver.dtlsTransport, kind);\n\n          if (isNewTrack) {\n            var stream;\n            track = rtpReceiver.track;\n            // FIXME: does not work with Plan B.\n            if (remoteMsid && remoteMsid.stream === '-') {\n              // no-op. a stream id of '-' means: no associated stream.\n            } else if (remoteMsid) {\n              if (!streams[remoteMsid.stream]) {\n                streams[remoteMsid.stream] = new window.MediaStream();\n                Object.defineProperty(streams[remoteMsid.stream], 'id', {\n                  get: function() {\n                    return remoteMsid.stream;\n                  }\n                });\n              }\n              Object.defineProperty(track, 'id', {\n                get: function() {\n                  return remoteMsid.track;\n                }\n              });\n              stream = streams[remoteMsid.stream];\n            } else {\n              if (!streams.default) {\n                streams.default = new window.MediaStream();\n              }\n              stream = streams.default;\n            }\n            if (stream) {\n              addTrackToStreamAndFireEvent(track, stream);\n              transceiver.associatedRemoteMediaStreams.push(stream);\n            }\n            receiverList.push([track, rtpReceiver, stream]);\n          }\n        } else if (transceiver.rtpReceiver && transceiver.rtpReceiver.track) {\n          transceiver.associatedRemoteMediaStreams.forEach(function(s) {\n            var nativeTrack = s.getTracks().find(function(t) {\n              return t.id === transceiver.rtpReceiver.track.id;\n            });\n            if (nativeTrack) {\n              removeTrackFromStreamAndFireEvent(nativeTrack, s);\n            }\n          });\n          transceiver.associatedRemoteMediaStreams = [];\n        }\n\n        transceiver.localCapabilities = localCapabilities;\n        transceiver.remoteCapabilities = remoteCapabilities;\n        transceiver.rtpReceiver = rtpReceiver;\n        transceiver.rtcpParameters = rtcpParameters;\n        transceiver.sendEncodingParameters = sendEncodingParameters;\n        transceiver.recvEncodingParameters = recvEncodingParameters;\n\n        // Start the RTCRtpReceiver now. The RTPSender is started in\n        // setLocalDescription.\n        pc._transceive(pc.transceivers[sdpMLineIndex],\n            false,\n            isNewTrack);\n      } else if (description.type === 'answer' && !rejected) {\n        transceiver = pc.transceivers[sdpMLineIndex];\n        iceGatherer = transceiver.iceGatherer;\n        iceTransport = transceiver.iceTransport;\n        dtlsTransport = transceiver.dtlsTransport;\n        rtpReceiver = transceiver.rtpReceiver;\n        sendEncodingParameters = transceiver.sendEncodingParameters;\n        localCapabilities = transceiver.localCapabilities;\n\n        pc.transceivers[sdpMLineIndex].recvEncodingParameters =\n            recvEncodingParameters;\n        pc.transceivers[sdpMLineIndex].remoteCapabilities =\n            remoteCapabilities;\n        pc.transceivers[sdpMLineIndex].rtcpParameters = rtcpParameters;\n\n        if (cands.length && iceTransport.state === 'new') {\n          if ((isIceLite || isComplete) &&\n              (!usingBundle || sdpMLineIndex === 0)) {\n            iceTransport.setRemoteCandidates(cands);\n          } else {\n            cands.forEach(function(candidate) {\n              maybeAddCandidate(transceiver.iceTransport, candidate);\n            });\n          }\n        }\n\n        if (!usingBundle || sdpMLineIndex === 0) {\n          if (iceTransport.state === 'new') {\n            iceTransport.start(iceGatherer, remoteIceParameters,\n                'controlling');\n          }\n          if (dtlsTransport.state === 'new') {\n            dtlsTransport.start(remoteDtlsParameters);\n          }\n        }\n\n        pc._transceive(transceiver,\n            direction === 'sendrecv' || direction === 'recvonly',\n            direction === 'sendrecv' || direction === 'sendonly');\n\n        // TODO: rewrite to use http://w3c.github.io/webrtc-pc/#set-associated-remote-streams\n        if (rtpReceiver &&\n            (direction === 'sendrecv' || direction === 'sendonly')) {\n          track = rtpReceiver.track;\n          if (remoteMsid) {\n            if (!streams[remoteMsid.stream]) {\n              streams[remoteMsid.stream] = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams[remoteMsid.stream]);\n            receiverList.push([track, rtpReceiver, streams[remoteMsid.stream]]);\n          } else {\n            if (!streams.default) {\n              streams.default = new window.MediaStream();\n            }\n            addTrackToStreamAndFireEvent(track, streams.default);\n            receiverList.push([track, rtpReceiver, streams.default]);\n          }\n        } else {\n          // FIXME: actually the receiver should be created later.\n          delete transceiver.rtpReceiver;\n        }\n      }\n    });\n\n    if (pc._dtlsRole === undefined) {\n      pc._dtlsRole = description.type === 'offer' ? 'active' : 'passive';\n    }\n\n    pc.remoteDescription = {\n      type: description.type,\n      sdp: description.sdp\n    };\n    if (description.type === 'offer') {\n      pc._updateSignalingState('have-remote-offer');\n    } else {\n      pc._updateSignalingState('stable');\n    }\n    Object.keys(streams).forEach(function(sid) {\n      var stream = streams[sid];\n      if (stream.getTracks().length) {\n        if (pc.remoteStreams.indexOf(stream) === -1) {\n          pc.remoteStreams.push(stream);\n          var event = new Event('addstream');\n          event.stream = stream;\n          window.setTimeout(function() {\n            pc._dispatchEvent('addstream', event);\n          });\n        }\n\n        receiverList.forEach(function(item) {\n          var track = item[0];\n          var receiver = item[1];\n          if (stream.id !== item[2].id) {\n            return;\n          }\n          fireAddTrack(pc, track, receiver, [stream]);\n        });\n      }\n    });\n    receiverList.forEach(function(item) {\n      if (item[2]) {\n        return;\n      }\n      fireAddTrack(pc, item[0], item[1], []);\n    });\n\n    // check whether addIceCandidate({}) was called within four seconds after\n    // setRemoteDescription.\n    window.setTimeout(function() {\n      if (!(pc && pc.transceivers)) {\n        return;\n      }\n      pc.transceivers.forEach(function(transceiver) {\n        if (transceiver.iceTransport &&\n            transceiver.iceTransport.state === 'new' &&\n            transceiver.iceTransport.getRemoteCandidates().length > 0) {\n          console.warn('Timeout for addRemoteCandidate. Consider sending ' +\n              'an end-of-candidates notification');\n          transceiver.iceTransport.addRemoteCandidate({});\n        }\n      });\n    }, 4000);\n\n    return Promise.resolve();\n  };\n\n  RTCPeerConnection.prototype.close = function() {\n    this.transceivers.forEach(function(transceiver) {\n      /* not yet\n      if (transceiver.iceGatherer) {\n        transceiver.iceGatherer.close();\n      }\n      */\n      if (transceiver.iceTransport) {\n        transceiver.iceTransport.stop();\n      }\n      if (transceiver.dtlsTransport) {\n        transceiver.dtlsTransport.stop();\n      }\n      if (transceiver.rtpSender) {\n        transceiver.rtpSender.stop();\n      }\n      if (transceiver.rtpReceiver) {\n        transceiver.rtpReceiver.stop();\n      }\n    });\n    // FIXME: clean up tracks, local streams, remote streams, etc\n    this._isClosed = true;\n    this._updateSignalingState('closed');\n  };\n\n  // Update the signaling state.\n  RTCPeerConnection.prototype._updateSignalingState = function(newState) {\n    this.signalingState = newState;\n    var event = new Event('signalingstatechange');\n    this._dispatchEvent('signalingstatechange', event);\n  };\n\n  // Determine whether to fire the negotiationneeded event.\n  RTCPeerConnection.prototype._maybeFireNegotiationNeeded = function() {\n    var pc = this;\n    if (this.signalingState !== 'stable' || this.needNegotiation === true) {\n      return;\n    }\n    this.needNegotiation = true;\n    window.setTimeout(function() {\n      if (pc.needNegotiation) {\n        pc.needNegotiation = false;\n        var event = new Event('negotiationneeded');\n        pc._dispatchEvent('negotiationneeded', event);\n      }\n    }, 0);\n  };\n\n  // Update the connection state.\n  RTCPeerConnection.prototype._updateConnectionState = function() {\n    var newState;\n    var states = {\n      'new': 0,\n      closed: 0,\n      connecting: 0,\n      checking: 0,\n      connected: 0,\n      completed: 0,\n      disconnected: 0,\n      failed: 0\n    };\n    this.transceivers.forEach(function(transceiver) {\n      states[transceiver.iceTransport.state]++;\n      states[transceiver.dtlsTransport.state]++;\n    });\n    // ICETransport.completed and connected are the same for this purpose.\n    states.connected += states.completed;\n\n    newState = 'new';\n    if (states.failed > 0) {\n      newState = 'failed';\n    } else if (states.connecting > 0 || states.checking > 0) {\n      newState = 'connecting';\n    } else if (states.disconnected > 0) {\n      newState = 'disconnected';\n    } else if (states.new > 0) {\n      newState = 'new';\n    } else if (states.connected > 0 || states.completed > 0) {\n      newState = 'connected';\n    }\n\n    if (newState !== this.iceConnectionState) {\n      this.iceConnectionState = newState;\n      var event = new Event('iceconnectionstatechange');\n      this._dispatchEvent('iceconnectionstatechange', event);\n    }\n  };\n\n  RTCPeerConnection.prototype.createOffer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createOffer after close'));\n    }\n\n    var numAudioTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'audio';\n    }).length;\n    var numVideoTracks = pc.transceivers.filter(function(t) {\n      return t.kind === 'video';\n    }).length;\n\n    // Determine number of audio and video tracks we need to send/recv.\n    var offerOptions = arguments[0];\n    if (offerOptions) {\n      // Reject Chrome legacy constraints.\n      if (offerOptions.mandatory || offerOptions.optional) {\n        throw new TypeError(\n            'Legacy mandatory/optional constraints not supported.');\n      }\n      if (offerOptions.offerToReceiveAudio !== undefined) {\n        if (offerOptions.offerToReceiveAudio === true) {\n          numAudioTracks = 1;\n        } else if (offerOptions.offerToReceiveAudio === false) {\n          numAudioTracks = 0;\n        } else {\n          numAudioTracks = offerOptions.offerToReceiveAudio;\n        }\n      }\n      if (offerOptions.offerToReceiveVideo !== undefined) {\n        if (offerOptions.offerToReceiveVideo === true) {\n          numVideoTracks = 1;\n        } else if (offerOptions.offerToReceiveVideo === false) {\n          numVideoTracks = 0;\n        } else {\n          numVideoTracks = offerOptions.offerToReceiveVideo;\n        }\n      }\n    }\n\n    pc.transceivers.forEach(function(transceiver) {\n      if (transceiver.kind === 'audio') {\n        numAudioTracks--;\n        if (numAudioTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      } else if (transceiver.kind === 'video') {\n        numVideoTracks--;\n        if (numVideoTracks < 0) {\n          transceiver.wantReceive = false;\n        }\n      }\n    });\n\n    // Create M-lines for recvonly streams.\n    while (numAudioTracks > 0 || numVideoTracks > 0) {\n      if (numAudioTracks > 0) {\n        pc._createTransceiver('audio');\n        numAudioTracks--;\n      }\n      if (numVideoTracks > 0) {\n        pc._createTransceiver('video');\n        numVideoTracks--;\n      }\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      // For each track, create an ice gatherer, ice transport,\n      // dtls transport, potentially rtpsender and rtpreceiver.\n      var track = transceiver.track;\n      var kind = transceiver.kind;\n      var mid = transceiver.mid || SDPUtils.generateIdentifier();\n      transceiver.mid = mid;\n\n      if (!transceiver.iceGatherer) {\n        transceiver.iceGatherer = pc._createIceGatherer(sdpMLineIndex,\n            pc.usingBundle);\n      }\n\n      var localCapabilities = window.RTCRtpSender.getCapabilities(kind);\n      // filter RTX until additional stuff needed for RTX is implemented\n      // in adapter.js\n      if (edgeVersion < 15019) {\n        localCapabilities.codecs = localCapabilities.codecs.filter(\n            function(codec) {\n              return codec.name !== 'rtx';\n            });\n      }\n      localCapabilities.codecs.forEach(function(codec) {\n        // work around https://bugs.chromium.org/p/webrtc/issues/detail?id=6552\n        // by adding level-asymmetry-allowed=1\n        if (codec.name === 'H264' &&\n            codec.parameters['level-asymmetry-allowed'] === undefined) {\n          codec.parameters['level-asymmetry-allowed'] = '1';\n        }\n\n        // for subsequent offers, we might have to re-use the payload\n        // type of the last offer.\n        if (transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.codecs) {\n          transceiver.remoteCapabilities.codecs.forEach(function(remoteCodec) {\n            if (codec.name.toLowerCase() === remoteCodec.name.toLowerCase() &&\n                codec.clockRate === remoteCodec.clockRate) {\n              codec.preferredPayloadType = remoteCodec.payloadType;\n            }\n          });\n        }\n      });\n      localCapabilities.headerExtensions.forEach(function(hdrExt) {\n        var remoteExtensions = transceiver.remoteCapabilities &&\n            transceiver.remoteCapabilities.headerExtensions || [];\n        remoteExtensions.forEach(function(rHdrExt) {\n          if (hdrExt.uri === rHdrExt.uri) {\n            hdrExt.id = rHdrExt.id;\n          }\n        });\n      });\n\n      // generate an ssrc now, to be used later in rtpSender.send\n      var sendEncodingParameters = transceiver.sendEncodingParameters || [{\n        ssrc: (2 * sdpMLineIndex + 1) * 1001\n      }];\n      if (track) {\n        // add RTX\n        if (edgeVersion >= 15019 && kind === 'video' &&\n            !sendEncodingParameters[0].rtx) {\n          sendEncodingParameters[0].rtx = {\n            ssrc: sendEncodingParameters[0].ssrc + 1\n          };\n        }\n      }\n\n      if (transceiver.wantReceive) {\n        transceiver.rtpReceiver = new window.RTCRtpReceiver(\n            transceiver.dtlsTransport, kind);\n      }\n\n      transceiver.localCapabilities = localCapabilities;\n      transceiver.sendEncodingParameters = sendEncodingParameters;\n    });\n\n    // always offer BUNDLE and dispose on return if not supported.\n    if (pc._config.bundlePolicy !== 'max-compat') {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    sdp += 'a=ice-options:trickle\\r\\n';\n\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      sdp += writeMediaSection(transceiver, transceiver.localCapabilities,\n          'offer', transceiver.stream, pc._dtlsRole);\n      sdp += 'a=rtcp-rsize\\r\\n';\n\n      if (transceiver.iceGatherer && pc.iceGatheringState !== 'new' &&\n          (sdpMLineIndex === 0 || !pc.usingBundle)) {\n        transceiver.iceGatherer.getLocalCandidates().forEach(function(cand) {\n          cand.component = 1;\n          sdp += 'a=' + SDPUtils.writeCandidate(cand) + '\\r\\n';\n        });\n\n        if (transceiver.iceGatherer.state === 'completed') {\n          sdp += 'a=end-of-candidates\\r\\n';\n        }\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'offer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.createAnswer = function() {\n    var pc = this;\n\n    if (pc._isClosed) {\n      return Promise.reject(makeError('InvalidStateError',\n          'Can not call createAnswer after close'));\n    }\n\n    var sdp = SDPUtils.writeSessionBoilerplate(pc._sdpSessionId,\n        pc._sdpSessionVersion++);\n    if (pc.usingBundle) {\n      sdp += 'a=group:BUNDLE ' + pc.transceivers.map(function(t) {\n        return t.mid;\n      }).join(' ') + '\\r\\n';\n    }\n    var mediaSectionsInOffer = SDPUtils.getMediaSections(\n        pc.remoteDescription.sdp).length;\n    pc.transceivers.forEach(function(transceiver, sdpMLineIndex) {\n      if (sdpMLineIndex + 1 > mediaSectionsInOffer) {\n        return;\n      }\n      if (transceiver.isDatachannel) {\n        sdp += 'm=application 0 DTLS/SCTP 5000\\r\\n' +\n            'c=IN IP4 0.0.0.0\\r\\n' +\n            'a=mid:' + transceiver.mid + '\\r\\n';\n        return;\n      }\n\n      // FIXME: look at direction.\n      if (transceiver.stream) {\n        var localTrack;\n        if (transceiver.kind === 'audio') {\n          localTrack = transceiver.stream.getAudioTracks()[0];\n        } else if (transceiver.kind === 'video') {\n          localTrack = transceiver.stream.getVideoTracks()[0];\n        }\n        if (localTrack) {\n          // add RTX\n          if (edgeVersion >= 15019 && transceiver.kind === 'video' &&\n              !transceiver.sendEncodingParameters[0].rtx) {\n            transceiver.sendEncodingParameters[0].rtx = {\n              ssrc: transceiver.sendEncodingParameters[0].ssrc + 1\n            };\n          }\n        }\n      }\n\n      // Calculate intersection of capabilities.\n      var commonCapabilities = getCommonCapabilities(\n          transceiver.localCapabilities,\n          transceiver.remoteCapabilities);\n\n      var hasRtx = commonCapabilities.codecs.filter(function(c) {\n        return c.name.toLowerCase() === 'rtx';\n      }).length;\n      if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {\n        delete transceiver.sendEncodingParameters[0].rtx;\n      }\n\n      sdp += writeMediaSection(transceiver, commonCapabilities,\n          'answer', transceiver.stream, pc._dtlsRole);\n      if (transceiver.rtcpParameters &&\n          transceiver.rtcpParameters.reducedSize) {\n        sdp += 'a=rtcp-rsize\\r\\n';\n      }\n    });\n\n    var desc = new window.RTCSessionDescription({\n      type: 'answer',\n      sdp: sdp\n    });\n    return Promise.resolve(desc);\n  };\n\n  RTCPeerConnection.prototype.addIceCandidate = function(candidate) {\n    var pc = this;\n    var sections;\n    if (candidate && !(candidate.sdpMLineIndex !== undefined ||\n        candidate.sdpMid)) {\n      return Promise.reject(new TypeError('sdpMLineIndex or sdpMid required'));\n    }\n\n    // TODO: needs to go into ops queue.\n    return new Promise(function(resolve, reject) {\n      if (!pc.remoteDescription) {\n        return reject(makeError('InvalidStateError',\n            'Can not add ICE candidate without a remote description'));\n      } else if (!candidate || candidate.candidate === '') {\n        for (var j = 0; j < pc.transceivers.length; j++) {\n          if (pc.transceivers[j].isDatachannel) {\n            continue;\n          }\n          pc.transceivers[j].iceTransport.addRemoteCandidate({});\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[j] += 'a=end-of-candidates\\r\\n';\n          pc.remoteDescription.sdp =\n              SDPUtils.getDescription(pc.remoteDescription.sdp) +\n              sections.join('');\n          if (pc.usingBundle) {\n            break;\n          }\n        }\n      } else {\n        var sdpMLineIndex = candidate.sdpMLineIndex;\n        if (candidate.sdpMid) {\n          for (var i = 0; i < pc.transceivers.length; i++) {\n            if (pc.transceivers[i].mid === candidate.sdpMid) {\n              sdpMLineIndex = i;\n              break;\n            }\n          }\n        }\n        var transceiver = pc.transceivers[sdpMLineIndex];\n        if (transceiver) {\n          if (transceiver.isDatachannel) {\n            return resolve();\n          }\n          var cand = Object.keys(candidate.candidate).length > 0 ?\n              SDPUtils.parseCandidate(candidate.candidate) : {};\n          // Ignore Chrome's invalid candidates since Edge does not like them.\n          if (cand.protocol === 'tcp' && (cand.port === 0 || cand.port === 9)) {\n            return resolve();\n          }\n          // Ignore RTCP candidates, we assume RTCP-MUX.\n          if (cand.component && cand.component !== 1) {\n            return resolve();\n          }\n          // when using bundle, avoid adding candidates to the wrong\n          // ice transport. And avoid adding candidates added in the SDP.\n          if (sdpMLineIndex === 0 || (sdpMLineIndex > 0 &&\n              transceiver.iceTransport !== pc.transceivers[0].iceTransport)) {\n            if (!maybeAddCandidate(transceiver.iceTransport, cand)) {\n              return reject(makeError('OperationError',\n                  'Can not add ICE candidate'));\n            }\n          }\n\n          // update the remoteDescription.\n          var candidateString = candidate.candidate.trim();\n          if (candidateString.indexOf('a=') === 0) {\n            candidateString = candidateString.substr(2);\n          }\n          sections = SDPUtils.getMediaSections(pc.remoteDescription.sdp);\n          sections[sdpMLineIndex] += 'a=' +\n              (cand.type ? candidateString : 'end-of-candidates')\n              + '\\r\\n';\n          pc.remoteDescription.sdp = sections.join('');\n        } else {\n          return reject(makeError('OperationError',\n              'Can not add ICE candidate'));\n        }\n      }\n      resolve();\n    });\n  };\n\n  RTCPeerConnection.prototype.getStats = function() {\n    var promises = [];\n    this.transceivers.forEach(function(transceiver) {\n      ['rtpSender', 'rtpReceiver', 'iceGatherer', 'iceTransport',\n          'dtlsTransport'].forEach(function(method) {\n            if (transceiver[method]) {\n              promises.push(transceiver[method].getStats());\n            }\n          });\n    });\n    var fixStatsType = function(stat) {\n      return {\n        inboundrtp: 'inbound-rtp',\n        outboundrtp: 'outbound-rtp',\n        candidatepair: 'candidate-pair',\n        localcandidate: 'local-candidate',\n        remotecandidate: 'remote-candidate'\n      }[stat.type] || stat.type;\n    };\n    return new Promise(function(resolve) {\n      // shim getStats with maplike support\n      var results = new Map();\n      Promise.all(promises).then(function(res) {\n        res.forEach(function(result) {\n          Object.keys(result).forEach(function(id) {\n            result[id].type = fixStatsType(result[id]);\n            results.set(id, result[id]);\n          });\n        });\n        resolve(results);\n      });\n    });\n  };\n\n  // legacy callback shims. Should be moved to adapter.js some days.\n  var methods = ['createOffer', 'createAnswer'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[0] === 'function' ||\n          typeof args[1] === 'function') { // legacy\n        return nativeMethod.apply(this, [arguments[2]])\n        .then(function(description) {\n          if (typeof args[0] === 'function') {\n            args[0].apply(null, [description]);\n          }\n        }, function(error) {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  methods = ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'];\n  methods.forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function' ||\n          typeof args[2] === 'function') { // legacy\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        }, function(error) {\n          if (typeof args[2] === 'function') {\n            args[2].apply(null, [error]);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  // getStats is special. It doesn't have a spec legacy method yet we support\n  // getStats(something, cb) without error callbacks.\n  ['getStats'].forEach(function(method) {\n    var nativeMethod = RTCPeerConnection.prototype[method];\n    RTCPeerConnection.prototype[method] = function() {\n      var args = arguments;\n      if (typeof args[1] === 'function') {\n        return nativeMethod.apply(this, arguments)\n        .then(function() {\n          if (typeof args[1] === 'function') {\n            args[1].apply(null);\n          }\n        });\n      }\n      return nativeMethod.apply(this, arguments);\n    };\n  });\n\n  return RTCPeerConnection;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvcnRjcGVlcmNvbm5lY3Rpb24tc2hpbS9ydGNwZWVyY29ubmVjdGlvbi5qcz9mMDNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsc0NBQUs7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLGdDQUFnQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsYUFBYTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDhCQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQWdDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcnRjcGVlcmNvbm5lY3Rpb24tc2hpbS9ydGNwZWVyY29ubmVjdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuIC8qIGVzbGludC1lbnYgbm9kZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU0RQVXRpbHMgPSByZXF1aXJlKCdzZHAnKTtcblxuZnVuY3Rpb24gd3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsIGNhcHMsIHR5cGUsIHN0cmVhbSwgZHRsc1JvbGUpIHtcbiAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlUnRwRGVzY3JpcHRpb24odHJhbnNjZWl2ZXIua2luZCwgY2Fwcyk7XG5cbiAgLy8gTWFwIElDRSBwYXJhbWV0ZXJzICh1ZnJhZywgcHdkKSB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMoXG4gICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5nZXRMb2NhbFBhcmFtZXRlcnMoKSk7XG5cbiAgLy8gTWFwIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzKFxuICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydC5nZXRMb2NhbFBhcmFtZXRlcnMoKSxcbiAgICAgIHR5cGUgPT09ICdvZmZlcicgPyAnYWN0cGFzcycgOiBkdGxzUm9sZSB8fCAnYWN0aXZlJyk7XG5cbiAgc2RwICs9ICdhPW1pZDonICsgdHJhbnNjZWl2ZXIubWlkICsgJ1xcclxcbic7XG5cbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1zZW5kcmVjdlxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgc2RwICs9ICdhPXNlbmRvbmx5XFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBSZWNlaXZlcikge1xuICAgIHNkcCArPSAnYT1yZWN2b25seVxcclxcbic7XG4gIH0gZWxzZSB7XG4gICAgc2RwICs9ICdhPWluYWN0aXZlXFxyXFxuJztcbiAgfVxuXG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIpIHtcbiAgICB2YXIgdHJhY2tJZCA9IHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5faW5pdGlhbFRyYWNrSWQgfHxcbiAgICAgICAgdHJhbnNjZWl2ZXIucnRwU2VuZGVyLnRyYWNrLmlkO1xuICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlci5faW5pdGlhbFRyYWNrSWQgPSB0cmFja0lkO1xuICAgIC8vIHNwZWMuXG4gICAgdmFyIG1zaWQgPSAnbXNpZDonICsgKHN0cmVhbSA/IHN0cmVhbS5pZCA6ICctJykgKyAnICcgK1xuICAgICAgICB0cmFja0lkICsgJ1xcclxcbic7XG4gICAgc2RwICs9ICdhPScgKyBtc2lkO1xuICAgIC8vIGZvciBDaHJvbWUuIExlZ2FjeSBzaG91bGQgbm8gbG9uZ2VyIGJlIHJlcXVpcmVkLlxuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgICAnICcgKyBtc2lkO1xuXG4gICAgLy8gUlRYXG4gICAgaWYgKHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4KSB7XG4gICAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICAgJyAnICsgbXNpZDtcbiAgICAgIHNkcCArPSAnYT1zc3JjLWdyb3VwOkZJRCAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgKyAnICcgK1xuICAgICAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICdcXHJcXG4nO1xuICAgIH1cbiAgfVxuICAvLyBGSVhNRTogdGhpcyBzaG91bGQgYmUgd3JpdHRlbiBieSB3cml0ZVJ0cERlc2NyaXB0aW9uLlxuICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICtcbiAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlciAmJiB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgJyBjbmFtZTonICsgU0RQVXRpbHMubG9jYWxDTmFtZSArICdcXHJcXG4nO1xuICB9XG4gIHJldHVybiBzZHA7XG59XG5cbi8vIEVkZ2UgZG9lcyBub3QgbGlrZVxuLy8gMSkgc3R1bjogZmlsdGVyZWQgYWZ0ZXIgMTQzOTMgdW5sZXNzID90cmFuc3BvcnQ9dWRwIGlzIHByZXNlbnRcbi8vIDIpIHR1cm46IHRoYXQgZG9lcyBub3QgaGF2ZSBhbGwgb2YgdHVybjpob3N0OnBvcnQ/dHJhbnNwb3J0PXVkcFxuLy8gMykgdHVybjogd2l0aCBpcHY2IGFkZHJlc3Nlc1xuLy8gNCkgdHVybjogb2NjdXJyaW5nIG11bGlwbGUgdGltZXNcbmZ1bmN0aW9uIGZpbHRlckljZVNlcnZlcnMoaWNlU2VydmVycywgZWRnZVZlcnNpb24pIHtcbiAgdmFyIGhhc1R1cm4gPSBmYWxzZTtcbiAgaWNlU2VydmVycyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaWNlU2VydmVycykpO1xuICByZXR1cm4gaWNlU2VydmVycy5maWx0ZXIoZnVuY3Rpb24oc2VydmVyKSB7XG4gICAgaWYgKHNlcnZlciAmJiAoc2VydmVyLnVybHMgfHwgc2VydmVyLnVybCkpIHtcbiAgICAgIHZhciB1cmxzID0gc2VydmVyLnVybHMgfHwgc2VydmVyLnVybDtcbiAgICAgIGlmIChzZXJ2ZXIudXJsICYmICFzZXJ2ZXIudXJscykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1JUQ0ljZVNlcnZlci51cmwgaXMgZGVwcmVjYXRlZCEgVXNlIHVybHMgaW5zdGVhZC4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiB1cmxzID09PSAnc3RyaW5nJztcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB1cmxzID0gW3VybHNdO1xuICAgICAgfVxuICAgICAgdXJscyA9IHVybHMuZmlsdGVyKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgdmFsaWRUdXJuID0gdXJsLmluZGV4T2YoJ3R1cm46JykgPT09IDAgJiZcbiAgICAgICAgICAgIHVybC5pbmRleE9mKCd0cmFuc3BvcnQ9dWRwJykgIT09IC0xICYmXG4gICAgICAgICAgICB1cmwuaW5kZXhPZigndHVybjpbJykgPT09IC0xICYmXG4gICAgICAgICAgICAhaGFzVHVybjtcblxuICAgICAgICBpZiAodmFsaWRUdXJuKSB7XG4gICAgICAgICAgaGFzVHVybiA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybC5pbmRleE9mKCdzdHVuOicpID09PSAwICYmIGVkZ2VWZXJzaW9uID49IDE0MzkzICYmXG4gICAgICAgICAgICB1cmwuaW5kZXhPZignP3RyYW5zcG9ydD11ZHAnKSA9PT0gLTE7XG4gICAgICB9KTtcblxuICAgICAgZGVsZXRlIHNlcnZlci51cmw7XG4gICAgICBzZXJ2ZXIudXJscyA9IGlzU3RyaW5nID8gdXJsc1swXSA6IHVybHM7XG4gICAgICByZXR1cm4gISF1cmxzLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBEZXRlcm1pbmVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgbG9jYWwgYW5kIHJlbW90ZSBjYXBhYmlsaXRpZXMuXG5mdW5jdGlvbiBnZXRDb21tb25DYXBhYmlsaXRpZXMobG9jYWxDYXBhYmlsaXRpZXMsIHJlbW90ZUNhcGFiaWxpdGllcykge1xuICB2YXIgY29tbW9uQ2FwYWJpbGl0aWVzID0ge1xuICAgIGNvZGVjczogW10sXG4gICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgZmVjTWVjaGFuaXNtczogW11cbiAgfTtcblxuICB2YXIgZmluZENvZGVjQnlQYXlsb2FkVHlwZSA9IGZ1bmN0aW9uKHB0LCBjb2RlY3MpIHtcbiAgICBwdCA9IHBhcnNlSW50KHB0LCAxMCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb2RlY3NbaV0ucGF5bG9hZFR5cGUgPT09IHB0IHx8XG4gICAgICAgICAgY29kZWNzW2ldLnByZWZlcnJlZFBheWxvYWRUeXBlID09PSBwdCkge1xuICAgICAgICByZXR1cm4gY29kZWNzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgcnR4Q2FwYWJpbGl0eU1hdGNoZXMgPSBmdW5jdGlvbihsUnR4LCByUnR4LCBsQ29kZWNzLCByQ29kZWNzKSB7XG4gICAgdmFyIGxDb2RlYyA9IGZpbmRDb2RlY0J5UGF5bG9hZFR5cGUobFJ0eC5wYXJhbWV0ZXJzLmFwdCwgbENvZGVjcyk7XG4gICAgdmFyIHJDb2RlYyA9IGZpbmRDb2RlY0J5UGF5bG9hZFR5cGUoclJ0eC5wYXJhbWV0ZXJzLmFwdCwgckNvZGVjcyk7XG4gICAgcmV0dXJuIGxDb2RlYyAmJiByQ29kZWMgJiZcbiAgICAgICAgbENvZGVjLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gckNvZGVjLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihsQ29kZWMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciByQ29kZWMgPSByZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzW2ldO1xuICAgICAgaWYgKGxDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHJDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICBsQ29kZWMuY2xvY2tSYXRlID09PSByQ29kZWMuY2xvY2tSYXRlKSB7XG4gICAgICAgIGlmIChsQ29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSAncnR4JyAmJlxuICAgICAgICAgICAgbENvZGVjLnBhcmFtZXRlcnMgJiYgckNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICAgICAgLy8gZm9yIFJUWCB3ZSBuZWVkIHRvIGZpbmQgdGhlIGxvY2FsIHJ0eCB0aGF0IGhhcyBhIGFwdFxuICAgICAgICAgIC8vIHdoaWNoIHBvaW50cyB0byB0aGUgc2FtZSBsb2NhbCBjb2RlYyBhcyB0aGUgcmVtb3RlIG9uZS5cbiAgICAgICAgICBpZiAoIXJ0eENhcGFiaWxpdHlNYXRjaGVzKGxDb2RlYywgckNvZGVjLFxuICAgICAgICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MsIHJlbW90ZUNhcGFiaWxpdGllcy5jb2RlY3MpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgckNvZGVjID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyQ29kZWMpKTsgLy8gZGVlcGNvcHlcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNoYW5uZWxzIGlzIHRoZSBoaWdoZXN0IGNvbW1vbiBudW1iZXIgb2YgY2hhbm5lbHNcbiAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzID0gTWF0aC5taW4obENvZGVjLm51bUNoYW5uZWxzLFxuICAgICAgICAgICAgckNvZGVjLm51bUNoYW5uZWxzKTtcbiAgICAgICAgLy8gcHVzaCByQ29kZWMgc28gd2UgcmVwbHkgd2l0aCBvZmZlcmVyIHBheWxvYWQgdHlwZVxuICAgICAgICBjb21tb25DYXBhYmlsaXRpZXMuY29kZWNzLnB1c2gockNvZGVjKTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgY29tbW9uIGZlZWRiYWNrIG1lY2hhbmlzbXNcbiAgICAgICAgckNvZGVjLnJ0Y3BGZWVkYmFjayA9IHJDb2RlYy5ydGNwRmVlZGJhY2suZmlsdGVyKGZ1bmN0aW9uKGZiKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsQ29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobENvZGVjLnJ0Y3BGZWVkYmFja1tqXS50eXBlID09PSBmYi50eXBlICYmXG4gICAgICAgICAgICAgICAgbENvZGVjLnJ0Y3BGZWVkYmFja1tqXS5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcikge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRklYTUU6IGFsc28gbmVlZCB0byBkZXRlcm1pbmUgLnBhcmFtZXRlcnNcbiAgICAgICAgLy8gIHNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnBlZXIvb3J0Yy9pc3N1ZXMvNTY5XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgbG9jYWxDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGxIZWFkZXJFeHRlbnNpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zLmxlbmd0aDtcbiAgICAgICAgIGkrKykge1xuICAgICAgdmFyIHJIZWFkZXJFeHRlbnNpb24gPSByZW1vdGVDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9uc1tpXTtcbiAgICAgIGlmIChsSGVhZGVyRXh0ZW5zaW9uLnVyaSA9PT0gckhlYWRlckV4dGVuc2lvbi51cmkpIHtcbiAgICAgICAgY29tbW9uQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChySGVhZGVyRXh0ZW5zaW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGSVhNRTogZmVjTWVjaGFuaXNtc1xuICByZXR1cm4gY29tbW9uQ2FwYWJpbGl0aWVzO1xufVxuXG4vLyBpcyBhY3Rpb249c2V0TG9jYWxEZXNjcmlwdGlvbiB3aXRoIHR5cGUgYWxsb3dlZCBpbiBzaWduYWxpbmdTdGF0ZVxuZnVuY3Rpb24gaXNBY3Rpb25BbGxvd2VkSW5TaWduYWxpbmdTdGF0ZShhY3Rpb24sIHR5cGUsIHNpZ25hbGluZ1N0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgb2ZmZXI6IHtcbiAgICAgIHNldExvY2FsRGVzY3JpcHRpb246IFsnc3RhYmxlJywgJ2hhdmUtbG9jYWwtb2ZmZXInXSxcbiAgICAgIHNldFJlbW90ZURlc2NyaXB0aW9uOiBbJ3N0YWJsZScsICdoYXZlLXJlbW90ZS1vZmZlciddXG4gICAgfSxcbiAgICBhbnN3ZXI6IHtcbiAgICAgIHNldExvY2FsRGVzY3JpcHRpb246IFsnaGF2ZS1yZW1vdGUtb2ZmZXInLCAnaGF2ZS1sb2NhbC1wcmFuc3dlciddLFxuICAgICAgc2V0UmVtb3RlRGVzY3JpcHRpb246IFsnaGF2ZS1sb2NhbC1vZmZlcicsICdoYXZlLXJlbW90ZS1wcmFuc3dlciddXG4gICAgfVxuICB9W3R5cGVdW2FjdGlvbl0uaW5kZXhPZihzaWduYWxpbmdTdGF0ZSkgIT09IC0xO1xufVxuXG5mdW5jdGlvbiBtYXliZUFkZENhbmRpZGF0ZShpY2VUcmFuc3BvcnQsIGNhbmRpZGF0ZSkge1xuICAvLyBFZGdlJ3MgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gYWRkcyBzb21lIGZpZWxkcyB0aGVyZWZvcmVcbiAgLy8gbm90IGFsbCBmaWVsZNGVIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gIHZhciBhbHJlYWR5QWRkZWQgPSBpY2VUcmFuc3BvcnQuZ2V0UmVtb3RlQ2FuZGlkYXRlcygpXG4gICAgICAuZmluZChmdW5jdGlvbihyZW1vdGVDYW5kaWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZS5mb3VuZGF0aW9uID09PSByZW1vdGVDYW5kaWRhdGUuZm91bmRhdGlvbiAmJlxuICAgICAgICAgICAgY2FuZGlkYXRlLmlwID09PSByZW1vdGVDYW5kaWRhdGUuaXAgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5wb3J0ID09PSByZW1vdGVDYW5kaWRhdGUucG9ydCAmJlxuICAgICAgICAgICAgY2FuZGlkYXRlLnByaW9yaXR5ID09PSByZW1vdGVDYW5kaWRhdGUucHJpb3JpdHkgJiZcbiAgICAgICAgICAgIGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gcmVtb3RlQ2FuZGlkYXRlLnByb3RvY29sICYmXG4gICAgICAgICAgICBjYW5kaWRhdGUudHlwZSA9PT0gcmVtb3RlQ2FuZGlkYXRlLnR5cGU7XG4gICAgICB9KTtcbiAgaWYgKCFhbHJlYWR5QWRkZWQpIHtcbiAgICBpY2VUcmFuc3BvcnQuYWRkUmVtb3RlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gIH1cbiAgcmV0dXJuICFhbHJlYWR5QWRkZWQ7XG59XG5cblxuZnVuY3Rpb24gbWFrZUVycm9yKG5hbWUsIGRlc2NyaXB0aW9uKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKGRlc2NyaXB0aW9uKTtcbiAgZS5uYW1lID0gbmFtZTtcbiAgcmV0dXJuIGU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24od2luZG93LCBlZGdlVmVyc2lvbikge1xuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vbWVkaWFjYXB0dXJlLW1haW4vI21lZGlhc3RyZWFtXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgdGhlIHRyYWNrIHRvIHRoZSBzdHJlYW0gYW5kXG4gIC8vIGRpc3BhdGNoIHRoZSBldmVudCBvdXJzZWx2ZXMuXG4gIGZ1bmN0aW9uIGFkZFRyYWNrVG9TdHJlYW1BbmRGaXJlRXZlbnQodHJhY2ssIHN0cmVhbSkge1xuICAgIHN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgc3RyZWFtLmRpc3BhdGNoRXZlbnQobmV3IHdpbmRvdy5NZWRpYVN0cmVhbVRyYWNrRXZlbnQoJ2FkZHRyYWNrJyxcbiAgICAgICAge3RyYWNrOiB0cmFja30pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVRyYWNrRnJvbVN0cmVhbUFuZEZpcmVFdmVudCh0cmFjaywgc3RyZWFtKSB7XG4gICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICBzdHJlYW0uZGlzcGF0Y2hFdmVudChuZXcgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2tFdmVudCgncmVtb3ZldHJhY2snLFxuICAgICAgICB7dHJhY2s6IHRyYWNrfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUFkZFRyYWNrKHBjLCB0cmFjaywgcmVjZWl2ZXIsIHN0cmVhbXMpIHtcbiAgICB2YXIgdHJhY2tFdmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICB0cmFja0V2ZW50LnRyYWNrID0gdHJhY2s7XG4gICAgdHJhY2tFdmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRyYWNrRXZlbnQudHJhbnNjZWl2ZXIgPSB7cmVjZWl2ZXI6IHJlY2VpdmVyfTtcbiAgICB0cmFja0V2ZW50LnN0cmVhbXMgPSBzdHJlYW1zO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgcGMuX2Rpc3BhdGNoRXZlbnQoJ3RyYWNrJywgdHJhY2tFdmVudCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgUlRDUGVlckNvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuXG4gICAgdmFyIF9ldmVudFRhcmdldCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBbJ2FkZEV2ZW50TGlzdGVuZXInLCAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsICdkaXNwYXRjaEV2ZW50J11cbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgICAgcGNbbWV0aG9kXSA9IF9ldmVudFRhcmdldFttZXRob2RdLmJpbmQoX2V2ZW50VGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICB0aGlzLmNhblRyaWNrbGVJY2VDYW5kaWRhdGVzID0gbnVsbDtcblxuICAgIHRoaXMubmVlZE5lZ290aWF0aW9uID0gZmFsc2U7XG5cbiAgICB0aGlzLmxvY2FsU3RyZWFtcyA9IFtdO1xuICAgIHRoaXMucmVtb3RlU3RyZWFtcyA9IFtdO1xuXG4gICAgdGhpcy5sb2NhbERlc2NyaXB0aW9uID0gbnVsbDtcbiAgICB0aGlzLnJlbW90ZURlc2NyaXB0aW9uID0gbnVsbDtcblxuICAgIHRoaXMuc2lnbmFsaW5nU3RhdGUgPSAnc3RhYmxlJztcbiAgICB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZSA9ICduZXcnO1xuICAgIHRoaXMuaWNlR2F0aGVyaW5nU3RhdGUgPSAnbmV3JztcblxuICAgIGNvbmZpZyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uZmlnIHx8IHt9KSk7XG5cbiAgICB0aGlzLnVzaW5nQnVuZGxlID0gY29uZmlnLmJ1bmRsZVBvbGljeSA9PT0gJ21heC1idW5kbGUnO1xuICAgIGlmIChjb25maWcucnRjcE11eFBvbGljeSA9PT0gJ25lZ290aWF0ZScpIHtcbiAgICAgIHRocm93KG1ha2VFcnJvcignTm90U3VwcG9ydGVkRXJyb3InLFxuICAgICAgICAgICdydGNwTXV4UG9saWN5IFxcJ25lZ290aWF0ZVxcJyBpcyBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH0gZWxzZSBpZiAoIWNvbmZpZy5ydGNwTXV4UG9saWN5KSB7XG4gICAgICBjb25maWcucnRjcE11eFBvbGljeSA9ICdyZXF1aXJlJztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ2FsbCc6XG4gICAgICBjYXNlICdyZWxheSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uZmlnLmljZVRyYW5zcG9ydFBvbGljeSA9ICdhbGwnO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbmZpZy5idW5kbGVQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ2JhbGFuY2VkJzpcbiAgICAgIGNhc2UgJ21heC1jb21wYXQnOlxuICAgICAgY2FzZSAnbWF4LWJ1bmRsZSc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uZmlnLmJ1bmRsZVBvbGljeSA9ICdiYWxhbmNlZCc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbmZpZy5pY2VTZXJ2ZXJzID0gZmlsdGVySWNlU2VydmVycyhjb25maWcuaWNlU2VydmVycyB8fCBbXSwgZWRnZVZlcnNpb24pO1xuXG4gICAgdGhpcy5faWNlR2F0aGVyZXJzID0gW107XG4gICAgaWYgKGNvbmZpZy5pY2VDYW5kaWRhdGVQb29sU2l6ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IGNvbmZpZy5pY2VDYW5kaWRhdGVQb29sU2l6ZTsgaSA+IDA7IGktLSkge1xuICAgICAgICB0aGlzLl9pY2VHYXRoZXJlcnMucHVzaChuZXcgd2luZG93LlJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgICAgICBpY2VTZXJ2ZXJzOiBjb25maWcuaWNlU2VydmVycyxcbiAgICAgICAgICBnYXRoZXJQb2xpY3k6IGNvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3lcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWcuaWNlQ2FuZGlkYXRlUG9vbFNpemUgPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcblxuICAgIC8vIHBlci10cmFjayBpY2VHYXRoZXJzLCBpY2VUcmFuc3BvcnRzLCBkdGxzVHJhbnNwb3J0cywgcnRwU2VuZGVycywgLi4uXG4gICAgLy8gZXZlcnl0aGluZyB0aGF0IGlzIG5lZWRlZCB0byBkZXNjcmliZSBhIFNEUCBtLWxpbmUuXG4gICAgdGhpcy50cmFuc2NlaXZlcnMgPSBbXTtcblxuICAgIHRoaXMuX3NkcFNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gICAgdGhpcy5fc2RwU2Vzc2lvblZlcnNpb24gPSAwO1xuXG4gICAgdGhpcy5fZHRsc1JvbGUgPSB1bmRlZmluZWQ7IC8vIHJvbGUgZm9yIGE9c2V0dXAgdG8gdXNlIGluIGFuc3dlcnMuXG5cbiAgICB0aGlzLl9pc0Nsb3NlZCA9IGZhbHNlO1xuICB9O1xuXG4gIC8vIHNldCB1cCBldmVudCBoYW5kbGVycyBvbiBwcm90b3R5cGVcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9uYWRkc3RyZWFtID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9udHJhY2sgPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25yZW1vdmVzdHJlYW0gPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG51bGw7XG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm9ubmVnb3RpYXRpb25uZWVkZWQgPSBudWxsO1xuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub25kYXRhY2hhbm5lbCA9IG51bGw7XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24obmFtZSwgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICBpZiAodHlwZW9mIHRoaXNbJ29uJyArIG5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzWydvbicgKyBuYW1lXShldmVudCk7XG4gICAgfVxuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZW1pdEdhdGhlcmluZ1N0YXRlQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdpY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZScpO1xuICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoJ2ljZWdhdGhlcmluZ3N0YXRlY2hhbmdlJywgZXZlbnQpO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRDb25maWd1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxTdHJlYW1zO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZW1vdGVTdHJlYW1zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlU3RyZWFtcztcbiAgfTtcblxuICAvLyBpbnRlcm5hbCBoZWxwZXIgdG8gY3JlYXRlIGEgdHJhbnNjZWl2ZXIgb2JqZWN0LlxuICAvLyAod2hpaCBpcyBub3QgeWV0IHRoZSBzYW1lIGFzIHRoZSBXZWJSVEMgMS4wIHRyYW5zY2VpdmVyKVxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZVRyYW5zY2VpdmVyID0gZnVuY3Rpb24oa2luZCkge1xuICAgIHZhciBoYXNCdW5kbGVUcmFuc3BvcnQgPSB0aGlzLnRyYW5zY2VpdmVycy5sZW5ndGggPiAwO1xuICAgIHZhciB0cmFuc2NlaXZlciA9IHtcbiAgICAgIHRyYWNrOiBudWxsLFxuICAgICAgaWNlR2F0aGVyZXI6IG51bGwsXG4gICAgICBpY2VUcmFuc3BvcnQ6IG51bGwsXG4gICAgICBkdGxzVHJhbnNwb3J0OiBudWxsLFxuICAgICAgbG9jYWxDYXBhYmlsaXRpZXM6IG51bGwsXG4gICAgICByZW1vdGVDYXBhYmlsaXRpZXM6IG51bGwsXG4gICAgICBydHBTZW5kZXI6IG51bGwsXG4gICAgICBydHBSZWNlaXZlcjogbnVsbCxcbiAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICBtaWQ6IG51bGwsXG4gICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzOiBudWxsLFxuICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVyczogbnVsbCxcbiAgICAgIHN0cmVhbTogbnVsbCxcbiAgICAgIGFzc29jaWF0ZWRSZW1vdGVNZWRpYVN0cmVhbXM6IFtdLFxuICAgICAgd2FudFJlY2VpdmU6IHRydWVcbiAgICB9O1xuICAgIGlmICh0aGlzLnVzaW5nQnVuZGxlICYmIGhhc0J1bmRsZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0ID0gdGhpcy50cmFuc2NlaXZlcnNbMF0uaWNlVHJhbnNwb3J0O1xuICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydCA9IHRoaXMudHJhbnNjZWl2ZXJzWzBdLmR0bHNUcmFuc3BvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0gdGhpcy5fY3JlYXRlSWNlQW5kRHRsc1RyYW5zcG9ydHMoKTtcbiAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydCA9IHRyYW5zcG9ydHMuaWNlVHJhbnNwb3J0O1xuICAgICAgdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydCA9IHRyYW5zcG9ydHMuZHRsc1RyYW5zcG9ydDtcbiAgICB9XG4gICAgdGhpcy50cmFuc2NlaXZlcnMucHVzaCh0cmFuc2NlaXZlcik7XG4gICAgcmV0dXJuIHRyYW5zY2VpdmVyO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG1ha2VFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLFxuICAgICAgICAgICdBdHRlbXB0ZWQgdG8gY2FsbCBhZGRUcmFjayBvbiBhIGNsb3NlZCBwZWVyY29ubmVjdGlvbi4nKTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUV4aXN0cyA9IHRoaXMudHJhbnNjZWl2ZXJzLmZpbmQoZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgIH0pO1xuXG4gICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgIHRocm93IG1ha2VFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yJywgJ1RyYWNrIGFscmVhZHkgZXhpc3RzLicpO1xuICAgIH1cblxuICAgIHZhciB0cmFuc2NlaXZlcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudHJhbnNjZWl2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMudHJhbnNjZWl2ZXJzW2ldLnRyYWNrICYmXG4gICAgICAgICAgdGhpcy50cmFuc2NlaXZlcnNbaV0ua2luZCA9PT0gdHJhY2sua2luZCkge1xuICAgICAgICB0cmFuc2NlaXZlciA9IHRoaXMudHJhbnNjZWl2ZXJzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRyYW5zY2VpdmVyKSB7XG4gICAgICB0cmFuc2NlaXZlciA9IHRoaXMuX2NyZWF0ZVRyYW5zY2VpdmVyKHRyYWNrLmtpbmQpO1xuICAgIH1cblxuICAgIHRoaXMuX21heWJlRmlyZU5lZ290aWF0aW9uTmVlZGVkKCk7XG5cbiAgICBpZiAodGhpcy5sb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID09PSAtMSkge1xuICAgICAgdGhpcy5sb2NhbFN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgIH1cblxuICAgIHRyYW5zY2VpdmVyLnRyYWNrID0gdHJhY2s7XG4gICAgdHJhbnNjZWl2ZXIuc3RyZWFtID0gc3RyZWFtO1xuICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlciA9IG5ldyB3aW5kb3cuUlRDUnRwU2VuZGVyKHRyYWNrLFxuICAgICAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0KTtcbiAgICByZXR1cm4gdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuICAgIGlmIChlZGdlVmVyc2lvbiA+PSAxNTAyNSkge1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xvbmUgaXMgbmVjZXNzYXJ5IGZvciBsb2NhbCBkZW1vcyBtb3N0bHksIGF0dGFjaGluZyBkaXJlY3RseVxuICAgICAgLy8gdG8gdHdvIGRpZmZlcmVudCBzZW5kZXJzIGRvZXMgbm90IHdvcmsgKGJ1aWxkIDEwNTQ3KS5cbiAgICAgIC8vIEZpeGVkIGluIDE1MDI1IChvciBlYXJsaWVyKVxuICAgICAgdmFyIGNsb25lZFN0cmVhbSA9IHN0cmVhbS5jbG9uZSgpO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2goZnVuY3Rpb24odHJhY2ssIGlkeCkge1xuICAgICAgICB2YXIgY2xvbmVkVHJhY2sgPSBjbG9uZWRTdHJlYW0uZ2V0VHJhY2tzKClbaWR4XTtcbiAgICAgICAgdHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlZCcsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgY2xvbmVkVHJhY2suZW5hYmxlZCA9IGV2ZW50LmVuYWJsZWQ7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjbG9uZWRTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgICBwYy5hZGRUcmFjayh0cmFjaywgY2xvbmVkU3RyZWFtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbihzZW5kZXIpIHtcbiAgICBpZiAodGhpcy5faXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG1ha2VFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLFxuICAgICAgICAgICdBdHRlbXB0ZWQgdG8gY2FsbCByZW1vdmVUcmFjayBvbiBhIGNsb3NlZCBwZWVyY29ubmVjdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShzZW5kZXIgaW5zdGFuY2VvZiB3aW5kb3cuUlRDUnRwU2VuZGVyKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICtcbiAgICAgICAgICAnZG9lcyBub3QgaW1wbGVtZW50IGludGVyZmFjZSBSVENSdHBTZW5kZXIuJyk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zY2VpdmVyID0gdGhpcy50cmFuc2NlaXZlcnMuZmluZChmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdC5ydHBTZW5kZXIgPT09IHNlbmRlcjtcbiAgICB9KTtcblxuICAgIGlmICghdHJhbnNjZWl2ZXIpIHtcbiAgICAgIHRocm93IG1ha2VFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yJyxcbiAgICAgICAgICAnU2VuZGVyIHdhcyBub3QgY3JlYXRlZCBieSB0aGlzIGNvbm5lY3Rpb24uJyk7XG4gICAgfVxuICAgIHZhciBzdHJlYW0gPSB0cmFuc2NlaXZlci5zdHJlYW07XG5cbiAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIuc3RvcCgpO1xuICAgIHRyYW5zY2VpdmVyLnJ0cFNlbmRlciA9IG51bGw7XG4gICAgdHJhbnNjZWl2ZXIudHJhY2sgPSBudWxsO1xuICAgIHRyYW5zY2VpdmVyLnN0cmVhbSA9IG51bGw7XG5cbiAgICAvLyByZW1vdmUgdGhlIHN0cmVhbSBmcm9tIHRoZSBzZXQgb2YgbG9jYWwgc3RyZWFtc1xuICAgIHZhciBsb2NhbFN0cmVhbXMgPSB0aGlzLnRyYW5zY2VpdmVycy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHQuc3RyZWFtO1xuICAgIH0pO1xuICAgIGlmIChsb2NhbFN0cmVhbXMuaW5kZXhPZihzdHJlYW0pID09PSAtMSAmJlxuICAgICAgICB0aGlzLmxvY2FsU3RyZWFtcy5pbmRleE9mKHN0cmVhbSkgPiAtMSkge1xuICAgICAgdGhpcy5sb2NhbFN0cmVhbXMuc3BsaWNlKHRoaXMubG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSwgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWF5YmVGaXJlTmVnb3RpYXRpb25OZWVkZWQoKTtcbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIHBjID0gdGhpcztcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgdmFyIHNlbmRlciA9IHBjLmdldFNlbmRlcnMoKS5maW5kKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudHJhY2sgPT09IHRyYWNrO1xuICAgICAgfSk7XG4gICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgIHBjLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICByZXR1cm4gISF0cmFuc2NlaXZlci5ydHBTZW5kZXI7XG4gICAgfSlcbiAgICAubWFwKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucnRwU2VuZGVyO1xuICAgIH0pO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICByZXR1cm4gISF0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICB9KVxuICAgIC5tYXAoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIHJldHVybiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICB9KTtcbiAgfTtcblxuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlSWNlR2F0aGVyZXIgPSBmdW5jdGlvbihzZHBNTGluZUluZGV4LFxuICAgICAgdXNpbmdCdW5kbGUpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuICAgIGlmICh1c2luZ0J1bmRsZSAmJiBzZHBNTGluZUluZGV4ID4gMCkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNjZWl2ZXJzWzBdLmljZUdhdGhlcmVyO1xuICAgIH0gZWxzZSBpZiAodGhpcy5faWNlR2F0aGVyZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ljZUdhdGhlcmVycy5zaGlmdCgpO1xuICAgIH1cbiAgICB2YXIgaWNlR2F0aGVyZXIgPSBuZXcgd2luZG93LlJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgIGljZVNlcnZlcnM6IHRoaXMuX2NvbmZpZy5pY2VTZXJ2ZXJzLFxuICAgICAgZ2F0aGVyUG9saWN5OiB0aGlzLl9jb25maWcuaWNlVHJhbnNwb3J0UG9saWN5XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGljZUdhdGhlcmVyLCAnc3RhdGUnLFxuICAgICAgICB7dmFsdWU6ICduZXcnLCB3cml0YWJsZTogdHJ1ZX1cbiAgICApO1xuXG4gICAgdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5idWZmZXJDYW5kaWRhdGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciBlbmQgPSAhZXZlbnQuY2FuZGlkYXRlIHx8IE9iamVjdC5rZXlzKGV2ZW50LmNhbmRpZGF0ZSkubGVuZ3RoID09PSAwO1xuICAgICAgLy8gcG9seWZpbGwgc2luY2UgUlRDSWNlR2F0aGVyZXIuc3RhdGUgaXMgbm90IGltcGxlbWVudGVkIGluXG4gICAgICAvLyBFZGdlIDEwNTQ3IHlldC5cbiAgICAgIGljZUdhdGhlcmVyLnN0YXRlID0gZW5kID8gJ2NvbXBsZXRlZCcgOiAnZ2F0aGVyaW5nJztcbiAgICAgIGlmIChwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmJ1ZmZlcmVkQ2FuZGlkYXRlRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWNlR2F0aGVyZXIuYWRkRXZlbnRMaXN0ZW5lcignbG9jYWxjYW5kaWRhdGUnLFxuICAgICAgdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uYnVmZmVyQ2FuZGlkYXRlcyk7XG4gICAgcmV0dXJuIGljZUdhdGhlcmVyO1xuICB9O1xuXG4gIC8vIHN0YXJ0IGdhdGhlcmluZyBmcm9tIGFuIFJUQ0ljZUdhdGhlcmVyLlxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2dhdGhlciA9IGZ1bmN0aW9uKG1pZCwgc2RwTUxpbmVJbmRleCkge1xuICAgIHZhciBwYyA9IHRoaXM7XG4gICAgdmFyIGljZUdhdGhlcmVyID0gdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlR2F0aGVyZXI7XG4gICAgaWYgKGljZUdhdGhlcmVyLm9ubG9jYWxjYW5kaWRhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlcmVkQ2FuZGlkYXRlRXZlbnRzID1cbiAgICAgIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmJ1ZmZlcmVkQ2FuZGlkYXRlRXZlbnRzO1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmJ1ZmZlcmVkQ2FuZGlkYXRlRXZlbnRzID0gbnVsbDtcbiAgICBpY2VHYXRoZXJlci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2NhbGNhbmRpZGF0ZScsXG4gICAgICB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5idWZmZXJDYW5kaWRhdGVzKTtcbiAgICBpY2VHYXRoZXJlci5vbmxvY2FsY2FuZGlkYXRlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICBpZiAocGMudXNpbmdCdW5kbGUgJiYgc2RwTUxpbmVJbmRleCA+IDApIHtcbiAgICAgICAgLy8gaWYgd2Uga25vdyB0aGF0IHdlIHVzZSBidW5kbGUgd2UgY2FuIGRyb3AgY2FuZGlkYXRlcyB3aXRoXG4gICAgICAgIC8vINGVZHBNTGluZUluZGV4ID4gMC4gSWYgd2UgZG9uJ3QgZG8gdGhpcyB0aGVuIG91ciBzdGF0ZSBnZXRzXG4gICAgICAgIC8vIGNvbmZ1c2VkIHNpbmNlIHdlIGRpc3Bvc2UgdGhlIGV4dHJhIGljZSBnYXRoZXJlci5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KCdpY2VjYW5kaWRhdGUnKTtcbiAgICAgIGV2ZW50LmNhbmRpZGF0ZSA9IHtzZHBNaWQ6IG1pZCwgc2RwTUxpbmVJbmRleDogc2RwTUxpbmVJbmRleH07XG5cbiAgICAgIHZhciBjYW5kID0gZXZ0LmNhbmRpZGF0ZTtcbiAgICAgIC8vIEVkZ2UgZW1pdHMgYW4gZW1wdHkgb2JqZWN0IGZvciBSVENJY2VDYW5kaWRhdGVDb21wbGV0ZeKApVxuICAgICAgdmFyIGVuZCA9ICFjYW5kIHx8IE9iamVjdC5rZXlzKGNhbmQpLmxlbmd0aCA9PT0gMDtcbiAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgLy8gcG9seWZpbGwgc2luY2UgUlRDSWNlR2F0aGVyZXIuc3RhdGUgaXMgbm90IGltcGxlbWVudGVkIGluXG4gICAgICAgIC8vIEVkZ2UgMTA1NDcgeWV0LlxuICAgICAgICBpZiAoaWNlR2F0aGVyZXIuc3RhdGUgPT09ICduZXcnIHx8IGljZUdhdGhlcmVyLnN0YXRlID09PSAnZ2F0aGVyaW5nJykge1xuICAgICAgICAgIGljZUdhdGhlcmVyLnN0YXRlID0gJ2NvbXBsZXRlZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICBpY2VHYXRoZXJlci5zdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJUQ0ljZUNhbmRpZGF0ZSBkb2Vzbid0IGhhdmUgYSBjb21wb25lbnQsIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICAgIGNhbmQuY29tcG9uZW50ID0gMTtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWRDYW5kaWRhdGUgPSBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZShjYW5kKTtcbiAgICAgICAgZXZlbnQuY2FuZGlkYXRlID0gT2JqZWN0LmFzc2lnbihldmVudC5jYW5kaWRhdGUsXG4gICAgICAgICAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShzZXJpYWxpemVkQ2FuZGlkYXRlKSk7XG4gICAgICAgIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgPSBzZXJpYWxpemVkQ2FuZGlkYXRlO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgbG9jYWwgZGVzY3JpcHRpb24uXG4gICAgICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5nZXRNZWRpYVNlY3Rpb25zKHBjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgIGlmICghZW5kKSB7XG4gICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4XSArPVxuICAgICAgICAgICAgJ2E9JyArIGV2ZW50LmNhbmRpZGF0ZS5jYW5kaWRhdGUgKyAnXFxyXFxuJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlY3Rpb25zW2V2ZW50LmNhbmRpZGF0ZS5zZHBNTGluZUluZGV4XSArPVxuICAgICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcGMubG9jYWxEZXNjcmlwdGlvbi5zZHAgPVxuICAgICAgICAgIFNEUFV0aWxzLmdldERlc2NyaXB0aW9uKHBjLmxvY2FsRGVzY3JpcHRpb24uc2RwKSArXG4gICAgICAgICAgc2VjdGlvbnMuam9pbignJyk7XG4gICAgICB2YXIgY29tcGxldGUgPSBwYy50cmFuc2NlaXZlcnMuZXZlcnkoZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCc7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBjLmljZUdhdGhlcmluZ1N0YXRlICE9PSAnZ2F0aGVyaW5nJykge1xuICAgICAgICBwYy5pY2VHYXRoZXJpbmdTdGF0ZSA9ICdnYXRoZXJpbmcnO1xuICAgICAgICBwYy5fZW1pdEdhdGhlcmluZ1N0YXRlQ2hhbmdlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVtaXQgY2FuZGlkYXRlLiBBbHNvIGVtaXQgbnVsbCBjYW5kaWRhdGUgd2hlbiBhbGwgZ2F0aGVyZXJzIGFyZVxuICAgICAgLy8gY29tcGxldGUuXG4gICAgICBpZiAoIWVuZCkge1xuICAgICAgICBwYy5fZGlzcGF0Y2hFdmVudCgnaWNlY2FuZGlkYXRlJywgZXZlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBsZXRlKSB7XG4gICAgICAgIHBjLl9kaXNwYXRjaEV2ZW50KCdpY2VjYW5kaWRhdGUnLCBuZXcgRXZlbnQoJ2ljZWNhbmRpZGF0ZScpKTtcbiAgICAgICAgcGMuaWNlR2F0aGVyaW5nU3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgICBwYy5fZW1pdEdhdGhlcmluZ1N0YXRlQ2hhbmdlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGVtaXQgYWxyZWFkeSBnYXRoZXJlZCBjYW5kaWRhdGVzLlxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgYnVmZmVyZWRDYW5kaWRhdGVFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIGljZUdhdGhlcmVyLm9ubG9jYWxjYW5kaWRhdGUoZSk7XG4gICAgICB9KTtcbiAgICB9LCAwKTtcbiAgfTtcblxuICAvLyBDcmVhdGUgSUNFIHRyYW5zcG9ydCBhbmQgRFRMUyB0cmFuc3BvcnQuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlSWNlQW5kRHRsc1RyYW5zcG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuICAgIHZhciBpY2VUcmFuc3BvcnQgPSBuZXcgd2luZG93LlJUQ0ljZVRyYW5zcG9ydChudWxsKTtcbiAgICBpY2VUcmFuc3BvcnQub25pY2VzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcGMuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgZHRsc1RyYW5zcG9ydCA9IG5ldyB3aW5kb3cuUlRDRHRsc1RyYW5zcG9ydChpY2VUcmFuc3BvcnQpO1xuICAgIGR0bHNUcmFuc3BvcnQub25kdGxzc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHBjLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoKTtcbiAgICB9O1xuICAgIGR0bHNUcmFuc3BvcnQub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gb25lcnJvciBkb2VzIG5vdCBzZXQgc3RhdGUgdG8gZmFpbGVkIGJ5IGl0c2VsZi5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkdGxzVHJhbnNwb3J0LCAnc3RhdGUnLFxuICAgICAgICAgIHt2YWx1ZTogJ2ZhaWxlZCcsIHdyaXRhYmxlOiB0cnVlfSk7XG4gICAgICBwYy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICBpY2VUcmFuc3BvcnQ6IGljZVRyYW5zcG9ydCxcbiAgICAgIGR0bHNUcmFuc3BvcnQ6IGR0bHNUcmFuc3BvcnRcbiAgICB9O1xuICB9O1xuXG4gIC8vIERlc3Ryb3kgSUNFIGdhdGhlcmVyLCBJQ0UgdHJhbnNwb3J0IGFuZCBEVExTIHRyYW5zcG9ydC5cbiAgLy8gV2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBjYWxsYmFja3MuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fZGlzcG9zZUljZUFuZER0bHNUcmFuc3BvcnRzID0gZnVuY3Rpb24oXG4gICAgICBzZHBNTGluZUluZGV4KSB7XG4gICAgdmFyIGljZUdhdGhlcmVyID0gdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlR2F0aGVyZXI7XG4gICAgaWYgKGljZUdhdGhlcmVyKSB7XG4gICAgICBkZWxldGUgaWNlR2F0aGVyZXIub25sb2NhbGNhbmRpZGF0ZTtcbiAgICAgIGRlbGV0ZSB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5pY2VHYXRoZXJlcjtcbiAgICB9XG4gICAgdmFyIGljZVRyYW5zcG9ydCA9IHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmljZVRyYW5zcG9ydDtcbiAgICBpZiAoaWNlVHJhbnNwb3J0KSB7XG4gICAgICBkZWxldGUgaWNlVHJhbnNwb3J0Lm9uaWNlc3RhdGVjaGFuZ2U7XG4gICAgICBkZWxldGUgdGhpcy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uaWNlVHJhbnNwb3J0O1xuICAgIH1cbiAgICB2YXIgZHRsc1RyYW5zcG9ydCA9IHRoaXMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmR0bHNUcmFuc3BvcnQ7XG4gICAgaWYgKGR0bHNUcmFuc3BvcnQpIHtcbiAgICAgIGRlbGV0ZSBkdGxzVHJhbnNwb3J0Lm9uZHRsc3N0YXRlY2hhbmdlO1xuICAgICAgZGVsZXRlIGR0bHNUcmFuc3BvcnQub25lcnJvcjtcbiAgICAgIGRlbGV0ZSB0aGlzLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5kdGxzVHJhbnNwb3J0O1xuICAgIH1cbiAgfTtcblxuICAvLyBTdGFydCB0aGUgUlRQIFNlbmRlciBhbmQgUmVjZWl2ZXIgZm9yIGEgdHJhbnNjZWl2ZXIuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdHJhbnNjZWl2ZSA9IGZ1bmN0aW9uKHRyYW5zY2VpdmVyLFxuICAgICAgc2VuZCwgcmVjdikge1xuICAgIHZhciBwYXJhbXMgPSBnZXRDb21tb25DYXBhYmlsaXRpZXModHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcyk7XG4gICAgaWYgKHNlbmQgJiYgdHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgICBwYXJhbXMuZW5jb2RpbmdzID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICBjbmFtZTogU0RQVXRpbHMubG9jYWxDTmFtZSxcbiAgICAgICAgY29tcG91bmQ6IHRyYW5zY2VpdmVyLnJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kXG4gICAgICB9O1xuICAgICAgaWYgKHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5ydGNwLnNzcmMgPSB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmM7XG4gICAgICB9XG4gICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIuc2VuZChwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAocmVjdiAmJiB0cmFuc2NlaXZlci5ydHBSZWNlaXZlciAmJiBwYXJhbXMuY29kZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHJlbW92ZSBSVFggZmllbGQgaW4gRWRnZSAxNDk0MlxuICAgICAgaWYgKHRyYW5zY2VpdmVyLmtpbmQgPT09ICd2aWRlbydcbiAgICAgICAgICAmJiB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzXG4gICAgICAgICAgJiYgZWRnZVZlcnNpb24gPCAxNTAxOSkge1xuICAgICAgICB0cmFuc2NlaXZlci5yZWN2RW5jb2RpbmdQYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlbGV0ZSBwLnJ0eDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLmVuY29kaW5ncyA9IHRyYW5zY2VpdmVyLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW3t9XTtcbiAgICAgIH1cbiAgICAgIHBhcmFtcy5ydGNwID0ge1xuICAgICAgICBjb21wb3VuZDogdHJhbnNjZWl2ZXIucnRjcFBhcmFtZXRlcnMuY29tcG91bmRcbiAgICAgIH07XG4gICAgICBpZiAodHJhbnNjZWl2ZXIucnRjcFBhcmFtZXRlcnMuY25hbWUpIHtcbiAgICAgICAgcGFyYW1zLnJ0Y3AuY25hbWUgPSB0cmFuc2NlaXZlci5ydGNwUGFyYW1ldGVycy5jbmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMucnRjcC5zc3JjID0gdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjO1xuICAgICAgfVxuICAgICAgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIucmVjZWl2ZShwYXJhbXMpO1xuICAgIH1cbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHBjID0gdGhpcztcblxuICAgIC8vIE5vdGU6IHByYW5zd2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgaWYgKFsnb2ZmZXInLCAnYW5zd2VyJ10uaW5kZXhPZihkZXNjcmlwdGlvbi50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoJ1R5cGVFcnJvcicsXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHR5cGUgXCInICsgZGVzY3JpcHRpb24udHlwZSArICdcIicpKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQWN0aW9uQWxsb3dlZEluU2lnbmFsaW5nU3RhdGUoJ3NldExvY2FsRGVzY3JpcHRpb24nLFxuICAgICAgICBkZXNjcmlwdGlvbi50eXBlLCBwYy5zaWduYWxpbmdTdGF0ZSkgfHwgcGMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0NhbiBub3Qgc2V0IGxvY2FsICcgKyBkZXNjcmlwdGlvbi50eXBlICtcbiAgICAgICAgICAnIGluIHN0YXRlICcgKyBwYy5zaWduYWxpbmdTdGF0ZSkpO1xuICAgIH1cblxuICAgIHZhciBzZWN0aW9ucztcbiAgICB2YXIgc2Vzc2lvbnBhcnQ7XG4gICAgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdvZmZlcicpIHtcbiAgICAgIC8vIFZFUlkgbGltaXRlZCBzdXBwb3J0IGZvciBTRFAgbXVuZ2luZy4gTGltaXRlZCB0bzpcbiAgICAgIC8vICogY2hhbmdpbmcgdGhlIG9yZGVyIG9mIGNvZGVjc1xuICAgICAgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGRlc2NyaXB0aW9uLnNkcCk7XG4gICAgICBzZXNzaW9ucGFydCA9IHNlY3Rpb25zLnNoaWZ0KCk7XG4gICAgICBzZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgICB2YXIgY2FwcyA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ubG9jYWxDYXBhYmlsaXRpZXMgPSBjYXBzO1xuICAgICAgfSk7XG5cbiAgICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIHBjLl9nYXRoZXIodHJhbnNjZWl2ZXIubWlkLCBzZHBNTGluZUluZGV4KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgICAgdmFyIGlzSWNlTGl0ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAgICdhPWljZS1saXRlJykubGVuZ3RoID4gMDtcbiAgICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAgIHZhciB0cmFuc2NlaXZlciA9IHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgdmFyIGljZUdhdGhlcmVyID0gdHJhbnNjZWl2ZXIuaWNlR2F0aGVyZXI7XG4gICAgICAgIHZhciBpY2VUcmFuc3BvcnQgPSB0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQ7XG4gICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgdmFyIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG4gICAgICAgIHZhciByZW1vdGVDYXBhYmlsaXRpZXMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgLy8gdHJlYXQgYnVuZGxlLW9ubHkgYXMgbm90LXJlamVjdGVkLlxuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBTRFBVdGlscy5pc1JlamVjdGVkKG1lZGlhU2VjdGlvbikgJiZcbiAgICAgICAgICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9YnVuZGxlLW9ubHknKS5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKCFyZWplY3RlZCAmJiAhdHJhbnNjZWl2ZXIuaXNEYXRhY2hhbm5lbCkge1xuICAgICAgICAgIHZhciByZW1vdGVJY2VQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0SWNlUGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgbWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCk7XG4gICAgICAgICAgdmFyIHJlbW90ZUR0bHNQYXJhbWV0ZXJzID0gU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMoXG4gICAgICAgICAgICAgIG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpO1xuICAgICAgICAgIGlmIChpc0ljZUxpdGUpIHtcbiAgICAgICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnc2VydmVyJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXBjLnVzaW5nQnVuZGxlIHx8IHNkcE1MaW5lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHBjLl9nYXRoZXIodHJhbnNjZWl2ZXIubWlkLCBzZHBNTGluZUluZGV4KTtcbiAgICAgICAgICAgIGlmIChpY2VUcmFuc3BvcnQuc3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zdGFydChpY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgIGlzSWNlTGl0ZSA/ICdjb250cm9sbGluZycgOiAnY29udHJvbGxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnQuc3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICAgIGR0bHNUcmFuc3BvcnQuc3RhcnQocmVtb3RlRHRsc1BhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgIHZhciBwYXJhbXMgPSBnZXRDb21tb25DYXBhYmlsaXRpZXMobG9jYWxDYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICAgIHJlbW90ZUNhcGFiaWxpdGllcyk7XG5cbiAgICAgICAgICAvLyBTdGFydCB0aGUgUlRDUnRwU2VuZGVyLiBUaGUgUlRDUnRwUmVjZWl2ZXIgZm9yIHRoaXNcbiAgICAgICAgICAvLyB0cmFuc2NlaXZlciBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWQgaW4gc2V0UmVtb3RlRGVzY3JpcHRpb24uXG4gICAgICAgICAgcGMuX3RyYW5zY2VpdmUodHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgIHBhcmFtcy5jb2RlY3MubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBwYy5sb2NhbERlc2NyaXB0aW9uID0ge1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgfTtcbiAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgcGMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdoYXZlLWxvY2FsLW9mZmVyJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBjLl91cGRhdGVTaWduYWxpbmdTdGF0ZSgnc3RhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHBjID0gdGhpcztcblxuICAgIC8vIE5vdGU6IHByYW5zd2VyIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgaWYgKFsnb2ZmZXInLCAnYW5zd2VyJ10uaW5kZXhPZihkZXNjcmlwdGlvbi50eXBlKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChtYWtlRXJyb3IoJ1R5cGVFcnJvcicsXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHR5cGUgXCInICsgZGVzY3JpcHRpb24udHlwZSArICdcIicpKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQWN0aW9uQWxsb3dlZEluU2lnbmFsaW5nU3RhdGUoJ3NldFJlbW90ZURlc2NyaXB0aW9uJyxcbiAgICAgICAgZGVzY3JpcHRpb24udHlwZSwgcGMuc2lnbmFsaW5nU3RhdGUpIHx8IHBjLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLFxuICAgICAgICAgICdDYW4gbm90IHNldCByZW1vdGUgJyArIGRlc2NyaXB0aW9uLnR5cGUgK1xuICAgICAgICAgICcgaW4gc3RhdGUgJyArIHBjLnNpZ25hbGluZ1N0YXRlKSk7XG4gICAgfVxuXG4gICAgdmFyIHN0cmVhbXMgPSB7fTtcbiAgICBwYy5yZW1vdGVTdHJlYW1zLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICBzdHJlYW1zW3N0cmVhbS5pZF0gPSBzdHJlYW07XG4gICAgfSk7XG4gICAgdmFyIHJlY2VpdmVyTGlzdCA9IFtdO1xuICAgIHZhciBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICB2YXIgc2Vzc2lvbnBhcnQgPSBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHZhciBpc0ljZUxpdGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChzZXNzaW9ucGFydCxcbiAgICAgICAgJ2E9aWNlLWxpdGUnKS5sZW5ndGggPiAwO1xuICAgIHZhciB1c2luZ0J1bmRsZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KHNlc3Npb25wYXJ0LFxuICAgICAgICAnYT1ncm91cDpCVU5ETEUgJykubGVuZ3RoID4gMDtcbiAgICBwYy51c2luZ0J1bmRsZSA9IHVzaW5nQnVuZGxlO1xuICAgIHZhciBpY2VPcHRpb25zID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoc2Vzc2lvbnBhcnQsXG4gICAgICAgICdhPWljZS1vcHRpb25zOicpWzBdO1xuICAgIGlmIChpY2VPcHRpb25zKSB7XG4gICAgICBwYy5jYW5Ucmlja2xlSWNlQ2FuZGlkYXRlcyA9IGljZU9wdGlvbnMuc3Vic3RyKDE0KS5zcGxpdCgnICcpXG4gICAgICAgICAgLmluZGV4T2YoJ3RyaWNrbGUnKSA+PSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYy5jYW5Ucmlja2xlSWNlQ2FuZGlkYXRlcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gICAgICB2YXIga2luZCA9IFNEUFV0aWxzLmdldEtpbmQobWVkaWFTZWN0aW9uKTtcbiAgICAgIC8vIHRyZWF0IGJ1bmRsZS1vbmx5IGFzIG5vdC1yZWplY3RlZC5cbiAgICAgIHZhciByZWplY3RlZCA9IFNEUFV0aWxzLmlzUmVqZWN0ZWQobWVkaWFTZWN0aW9uKSAmJlxuICAgICAgICAgIFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9YnVuZGxlLW9ubHknKS5sZW5ndGggPT09IDA7XG4gICAgICB2YXIgcHJvdG9jb2wgPSBsaW5lc1swXS5zdWJzdHIoMikuc3BsaXQoJyAnKVsyXTtcblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IFNEUFV0aWxzLmdldERpcmVjdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KTtcbiAgICAgIHZhciByZW1vdGVNc2lkID0gU0RQVXRpbHMucGFyc2VNc2lkKG1lZGlhU2VjdGlvbik7XG5cbiAgICAgIHZhciBtaWQgPSBTRFBVdGlscy5nZXRNaWQobWVkaWFTZWN0aW9uKSB8fCBTRFBVdGlscy5nZW5lcmF0ZUlkZW50aWZpZXIoKTtcblxuICAgICAgLy8gUmVqZWN0IGRhdGFjaGFubmVscyB3aGljaCBhcmUgbm90IGltcGxlbWVudGVkIHlldC5cbiAgICAgIGlmIChraW5kID09PSAnYXBwbGljYXRpb24nICYmIHByb3RvY29sID09PSAnRFRMUy9TQ1RQJykge1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0gPSB7XG4gICAgICAgICAgbWlkOiBtaWQsXG4gICAgICAgICAgaXNEYXRhY2hhbm5lbDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2NlaXZlcjtcbiAgICAgIHZhciBpY2VHYXRoZXJlcjtcbiAgICAgIHZhciBpY2VUcmFuc3BvcnQ7XG4gICAgICB2YXIgZHRsc1RyYW5zcG9ydDtcbiAgICAgIHZhciBydHBSZWNlaXZlcjtcbiAgICAgIHZhciBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgICAgdmFyIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICB2YXIgbG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgIHZhciB0cmFjaztcbiAgICAgIC8vIEZJWE1FOiBlbnN1cmUgdGhlIG1lZGlhU2VjdGlvbiBoYXMgcnRjcC1tdXggc2V0LlxuICAgICAgdmFyIHJlbW90ZUNhcGFiaWxpdGllcyA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICAgICAgdmFyIHJlbW90ZUljZVBhcmFtZXRlcnM7XG4gICAgICB2YXIgcmVtb3RlRHRsc1BhcmFtZXRlcnM7XG4gICAgICBpZiAoIXJlamVjdGVkKSB7XG4gICAgICAgIHJlbW90ZUljZVBhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbixcbiAgICAgICAgICAgIHNlc3Npb25wYXJ0KTtcbiAgICAgICAgcmVtb3RlRHRsc1BhcmFtZXRlcnMgPSBTRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgICBzZXNzaW9ucGFydCk7XG4gICAgICAgIHJlbW90ZUR0bHNQYXJhbWV0ZXJzLnJvbGUgPSAnY2xpZW50JztcbiAgICAgIH1cbiAgICAgIHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMgPVxuICAgICAgICAgIFNEUFV0aWxzLnBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKG1lZGlhU2VjdGlvbik7XG5cbiAgICAgIHZhciBydGNwUGFyYW1ldGVycyA9IFNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcblxuICAgICAgdmFyIGlzQ29tcGxldGUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sXG4gICAgICAgICAgJ2E9ZW5kLW9mLWNhbmRpZGF0ZXMnLCBzZXNzaW9ucGFydCkubGVuZ3RoID4gMDtcbiAgICAgIHZhciBjYW5kcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9Y2FuZGlkYXRlOicpXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihjYW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGNhbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW5kLmNvbXBvbmVudCA9PT0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHVzZSBCVU5ETEUgYW5kIGRpc3Bvc2UgdHJhbnNwb3J0cy5cbiAgICAgIGlmICgoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJyB8fCBkZXNjcmlwdGlvbi50eXBlID09PSAnYW5zd2VyJykgJiZcbiAgICAgICAgICAhcmVqZWN0ZWQgJiYgdXNpbmdCdW5kbGUgJiYgc2RwTUxpbmVJbmRleCA+IDAgJiZcbiAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0pIHtcbiAgICAgICAgcGMuX2Rpc3Bvc2VJY2VBbmREdGxzVHJhbnNwb3J0cyhzZHBNTGluZUluZGV4KTtcbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmljZUdhdGhlcmVyID1cbiAgICAgICAgICAgIHBjLnRyYW5zY2VpdmVyc1swXS5pY2VHYXRoZXJlcjtcbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLmljZVRyYW5zcG9ydCA9XG4gICAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbMF0uaWNlVHJhbnNwb3J0O1xuICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0uZHRsc1RyYW5zcG9ydCA9XG4gICAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbMF0uZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgaWYgKHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5ydHBTZW5kZXIpIHtcbiAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucnRwU2VuZGVyLnNldFRyYW5zcG9ydChcbiAgICAgICAgICAgICAgcGMudHJhbnNjZWl2ZXJzWzBdLmR0bHNUcmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucnRwUmVjZWl2ZXIpIHtcbiAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbc2RwTUxpbmVJbmRleF0ucnRwUmVjZWl2ZXIuc2V0VHJhbnNwb3J0KFxuICAgICAgICAgICAgICBwYy50cmFuc2NlaXZlcnNbMF0uZHRsc1RyYW5zcG9ydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnb2ZmZXInICYmICFyZWplY3RlZCkge1xuICAgICAgICB0cmFuc2NlaXZlciA9IHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSB8fFxuICAgICAgICAgICAgcGMuX2NyZWF0ZVRyYW5zY2VpdmVyKGtpbmQpO1xuICAgICAgICB0cmFuc2NlaXZlci5taWQgPSBtaWQ7XG5cbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlci5pY2VHYXRoZXJlcikge1xuICAgICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyID0gcGMuX2NyZWF0ZUljZUdhdGhlcmVyKHNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgICAgIHVzaW5nQnVuZGxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjYW5kcy5sZW5ndGggJiYgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgIGlmIChpc0NvbXBsZXRlICYmICghdXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FuZHMuZm9yRWFjaChmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgbWF5YmVBZGRDYW5kaWRhdGUodHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LCBjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMgPSB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuXG4gICAgICAgIC8vIGZpbHRlciBSVFggdW50aWwgYWRkaXRpb25hbCBzdHVmZiBuZWVkZWQgZm9yIFJUWCBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAvLyBpbiBhZGFwdGVyLmpzXG4gICAgICAgIGlmIChlZGdlVmVyc2lvbiA8IDE1MDE5KSB7XG4gICAgICAgICAgbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzID0gbG9jYWxDYXBhYmlsaXRpZXMuY29kZWNzLmZpbHRlcihcbiAgICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29kZWMubmFtZSAhPT0gJ3J0eCc7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgfHwgW3tcbiAgICAgICAgICBzc3JjOiAoMiAqIHNkcE1MaW5lSW5kZXggKyAyKSAqIDEwMDFcbiAgICAgICAgfV07XG5cbiAgICAgICAgLy8gVE9ETzogcmV3cml0ZSB0byB1c2UgaHR0cDovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNzZXQtYXNzb2NpYXRlZC1yZW1vdGUtc3RyZWFtc1xuICAgICAgICB2YXIgaXNOZXdUcmFjayA9IGZhbHNlO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAnc2VuZHJlY3YnIHx8IGRpcmVjdGlvbiA9PT0gJ3NlbmRvbmx5Jykge1xuICAgICAgICAgIGlzTmV3VHJhY2sgPSAhdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICAgICAgcnRwUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlciB8fFxuICAgICAgICAgICAgICBuZXcgd2luZG93LlJUQ1J0cFJlY2VpdmVyKHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQsIGtpbmQpO1xuXG4gICAgICAgICAgaWYgKGlzTmV3VHJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW07XG4gICAgICAgICAgICB0cmFjayA9IHJ0cFJlY2VpdmVyLnRyYWNrO1xuICAgICAgICAgICAgLy8gRklYTUU6IGRvZXMgbm90IHdvcmsgd2l0aCBQbGFuIEIuXG4gICAgICAgICAgICBpZiAocmVtb3RlTXNpZCAmJiByZW1vdGVNc2lkLnN0cmVhbSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIC8vIG5vLW9wLiBhIHN0cmVhbSBpZCBvZiAnLScgbWVhbnM6IG5vIGFzc29jaWF0ZWQgc3RyZWFtLlxuICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdGVNc2lkKSB7XG4gICAgICAgICAgICAgIGlmICghc3RyZWFtc1tyZW1vdGVNc2lkLnN0cmVhbV0pIHtcbiAgICAgICAgICAgICAgICBzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RyZWFtc1tyZW1vdGVNc2lkLnN0cmVhbV0sICdpZCcsIHtcbiAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZW1vdGVNc2lkLnN0cmVhbTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHJhY2ssICdpZCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW90ZU1zaWQudHJhY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgc3RyZWFtID0gc3RyZWFtc1tyZW1vdGVNc2lkLnN0cmVhbV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIXN0cmVhbXMuZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHN0cmVhbXMuZGVmYXVsdCA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJlYW0gPSBzdHJlYW1zLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgIGFkZFRyYWNrVG9TdHJlYW1BbmRGaXJlRXZlbnQodHJhY2ssIHN0cmVhbSk7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmFzc29jaWF0ZWRSZW1vdGVNZWRpYVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjZWl2ZXJMaXN0LnB1c2goW3RyYWNrLCBydHBSZWNlaXZlciwgc3RyZWFtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyICYmIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnRyYWNrKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuYXNzb2NpYXRlZFJlbW90ZU1lZGlhU3RyZWFtcy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICAgIHZhciBuYXRpdmVUcmFjayA9IHMuZ2V0VHJhY2tzKCkuZmluZChmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0LmlkID09PSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlci50cmFjay5pZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZVRyYWNrKSB7XG4gICAgICAgICAgICAgIHJlbW92ZVRyYWNrRnJvbVN0cmVhbUFuZEZpcmVFdmVudChuYXRpdmVUcmFjaywgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuYXNzb2NpYXRlZFJlbW90ZU1lZGlhU3RyZWFtcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMgPSBsb2NhbENhcGFiaWxpdGllcztcbiAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzID0gcmVtb3RlQ2FwYWJpbGl0aWVzO1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlciA9IHJ0cFJlY2VpdmVyO1xuICAgICAgICB0cmFuc2NlaXZlci5ydGNwUGFyYW1ldGVycyA9IHJ0Y3BQYXJhbWV0ZXJzO1xuICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzID0gc2VuZEVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgdHJhbnNjZWl2ZXIucmVjdkVuY29kaW5nUGFyYW1ldGVycyA9IHJlY3ZFbmNvZGluZ1BhcmFtZXRlcnM7XG5cbiAgICAgICAgLy8gU3RhcnQgdGhlIFJUQ1J0cFJlY2VpdmVyIG5vdy4gVGhlIFJUUFNlbmRlciBpcyBzdGFydGVkIGluXG4gICAgICAgIC8vIHNldExvY2FsRGVzY3JpcHRpb24uXG4gICAgICAgIHBjLl90cmFuc2NlaXZlKHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XSxcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgaXNOZXdUcmFjayk7XG4gICAgICB9IGVsc2UgaWYgKGRlc2NyaXB0aW9uLnR5cGUgPT09ICdhbnN3ZXInICYmICFyZWplY3RlZCkge1xuICAgICAgICB0cmFuc2NlaXZlciA9IHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XTtcbiAgICAgICAgaWNlR2F0aGVyZXIgPSB0cmFuc2NlaXZlci5pY2VHYXRoZXJlcjtcbiAgICAgICAgaWNlVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0O1xuICAgICAgICBkdGxzVHJhbnNwb3J0ID0gdHJhbnNjZWl2ZXIuZHRsc1RyYW5zcG9ydDtcbiAgICAgICAgcnRwUmVjZWl2ZXIgPSB0cmFuc2NlaXZlci5ydHBSZWNlaXZlcjtcbiAgICAgICAgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzID0gdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXM7XG5cbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJlY3ZFbmNvZGluZ1BhcmFtZXRlcnMgPVxuICAgICAgICAgICAgcmVjdkVuY29kaW5nUGFyYW1ldGVycztcbiAgICAgICAgcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdLnJlbW90ZUNhcGFiaWxpdGllcyA9XG4gICAgICAgICAgICByZW1vdGVDYXBhYmlsaXRpZXM7XG4gICAgICAgIHBjLnRyYW5zY2VpdmVyc1tzZHBNTGluZUluZGV4XS5ydGNwUGFyYW1ldGVycyA9IHJ0Y3BQYXJhbWV0ZXJzO1xuXG4gICAgICAgIGlmIChjYW5kcy5sZW5ndGggJiYgaWNlVHJhbnNwb3J0LnN0YXRlID09PSAnbmV3Jykge1xuICAgICAgICAgIGlmICgoaXNJY2VMaXRlIHx8IGlzQ29tcGxldGUpICYmXG4gICAgICAgICAgICAgICghdXNpbmdCdW5kbGUgfHwgc2RwTUxpbmVJbmRleCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zZXRSZW1vdGVDYW5kaWRhdGVzKGNhbmRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FuZHMuZm9yRWFjaChmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgICAgbWF5YmVBZGRDYW5kaWRhdGUodHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LCBjYW5kaWRhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1c2luZ0J1bmRsZSB8fCBzZHBNTGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgaWYgKGljZVRyYW5zcG9ydC5zdGF0ZSA9PT0gJ25ldycpIHtcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydC5zdGFydChpY2VHYXRoZXJlciwgcmVtb3RlSWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAnY29udHJvbGxpbmcnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnQuc3RhdGUgPT09ICduZXcnKSB7XG4gICAgICAgICAgICBkdGxzVHJhbnNwb3J0LnN0YXJ0KHJlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYy5fdHJhbnNjZWl2ZSh0cmFuc2NlaXZlcixcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdyZWN2b25seScsXG4gICAgICAgICAgICBkaXJlY3Rpb24gPT09ICdzZW5kcmVjdicgfHwgZGlyZWN0aW9uID09PSAnc2VuZG9ubHknKTtcblxuICAgICAgICAvLyBUT0RPOiByZXdyaXRlIHRvIHVzZSBodHRwOi8vdzNjLmdpdGh1Yi5pby93ZWJydGMtcGMvI3NldC1hc3NvY2lhdGVkLXJlbW90ZS1zdHJlYW1zXG4gICAgICAgIGlmIChydHBSZWNlaXZlciAmJlxuICAgICAgICAgICAgKGRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2JyB8fCBkaXJlY3Rpb24gPT09ICdzZW5kb25seScpKSB7XG4gICAgICAgICAgdHJhY2sgPSBydHBSZWNlaXZlci50cmFjaztcbiAgICAgICAgICBpZiAocmVtb3RlTXNpZCkge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSkge1xuICAgICAgICAgICAgICBzdHJlYW1zW3JlbW90ZU1zaWQuc3RyZWFtXSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRyYWNrVG9TdHJlYW1BbmRGaXJlRXZlbnQodHJhY2ssIHN0cmVhbXNbcmVtb3RlTXNpZC5zdHJlYW1dKTtcbiAgICAgICAgICAgIHJlY2VpdmVyTGlzdC5wdXNoKFt0cmFjaywgcnRwUmVjZWl2ZXIsIHN0cmVhbXNbcmVtb3RlTXNpZC5zdHJlYW1dXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RyZWFtcy5kZWZhdWx0KSB7XG4gICAgICAgICAgICAgIHN0cmVhbXMuZGVmYXVsdCA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFRyYWNrVG9TdHJlYW1BbmRGaXJlRXZlbnQodHJhY2ssIHN0cmVhbXMuZGVmYXVsdCk7XG4gICAgICAgICAgICByZWNlaXZlckxpc3QucHVzaChbdHJhY2ssIHJ0cFJlY2VpdmVyLCBzdHJlYW1zLmRlZmF1bHRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRklYTUU6IGFjdHVhbGx5IHRoZSByZWNlaXZlciBzaG91bGQgYmUgY3JlYXRlZCBsYXRlci5cbiAgICAgICAgICBkZWxldGUgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwYy5fZHRsc1JvbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGMuX2R0bHNSb2xlID0gZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJyA/ICdhY3RpdmUnIDogJ3Bhc3NpdmUnO1xuICAgIH1cblxuICAgIHBjLnJlbW90ZURlc2NyaXB0aW9uID0ge1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcDogZGVzY3JpcHRpb24uc2RwXG4gICAgfTtcbiAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgcGMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdoYXZlLXJlbW90ZS1vZmZlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYy5fdXBkYXRlU2lnbmFsaW5nU3RhdGUoJ3N0YWJsZScpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhzdHJlYW1zKS5mb3JFYWNoKGZ1bmN0aW9uKHNpZCkge1xuICAgICAgdmFyIHN0cmVhbSA9IHN0cmVhbXNbc2lkXTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYy5yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA9PT0gLTEpIHtcbiAgICAgICAgICBwYy5yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBjLl9kaXNwYXRjaEV2ZW50KCdhZGRzdHJlYW0nLCBldmVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWNlaXZlckxpc3QuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgdmFyIHRyYWNrID0gaXRlbVswXTtcbiAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSBpdGVtWzFdO1xuICAgICAgICAgIGlmIChzdHJlYW0uaWQgIT09IGl0ZW1bMl0uaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmlyZUFkZFRyYWNrKHBjLCB0cmFjaywgcmVjZWl2ZXIsIFtzdHJlYW1dKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVjZWl2ZXJMaXN0LmZvckVhY2goZnVuY3Rpb24oaXRlbSkge1xuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmlyZUFkZFRyYWNrKHBjLCBpdGVtWzBdLCBpdGVtWzFdLCBbXSk7XG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIGFkZEljZUNhbmRpZGF0ZSh7fSkgd2FzIGNhbGxlZCB3aXRoaW4gZm91ciBzZWNvbmRzIGFmdGVyXG4gICAgLy8gc2V0UmVtb3RlRGVzY3JpcHRpb24uXG4gICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIShwYyAmJiBwYy50cmFuc2NlaXZlcnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5zdGF0ZSA9PT0gJ25ldycgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLmljZVRyYW5zcG9ydC5nZXRSZW1vdGVDYW5kaWRhdGVzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVGltZW91dCBmb3IgYWRkUmVtb3RlQ2FuZGlkYXRlLiBDb25zaWRlciBzZW5kaW5nICcgK1xuICAgICAgICAgICAgICAnYW4gZW5kLW9mLWNhbmRpZGF0ZXMgbm90aWZpY2F0aW9uJyk7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZSh7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIDQwMDApO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIC8qIG5vdCB5ZXRcbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlcikge1xuICAgICAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5jbG9zZSgpO1xuICAgICAgfVxuICAgICAgKi9cbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0KSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIuc3RvcCgpO1xuICAgICAgfVxuICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLnJ0cFJlY2VpdmVyLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBGSVhNRTogY2xlYW4gdXAgdHJhY2tzLCBsb2NhbCBzdHJlYW1zLCByZW1vdGUgc3RyZWFtcywgZXRjXG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuX3VwZGF0ZVNpZ25hbGluZ1N0YXRlKCdjbG9zZWQnKTtcbiAgfTtcblxuICAvLyBVcGRhdGUgdGhlIHNpZ25hbGluZyBzdGF0ZS5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVTaWduYWxpbmdTdGF0ZSA9IGZ1bmN0aW9uKG5ld1N0YXRlKSB7XG4gICAgdGhpcy5zaWduYWxpbmdTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnc2lnbmFsaW5nc3RhdGVjaGFuZ2UnKTtcbiAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCdzaWduYWxpbmdzdGF0ZWNoYW5nZScsIGV2ZW50KTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgd2hldGhlciB0byBmaXJlIHRoZSBuZWdvdGlhdGlvbm5lZWRlZCBldmVudC5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9tYXliZUZpcmVOZWdvdGlhdGlvbk5lZWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnIHx8IHRoaXMubmVlZE5lZ290aWF0aW9uID09PSB0cnVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubmVlZE5lZ290aWF0aW9uID0gdHJ1ZTtcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGlmIChwYy5uZWVkTmVnb3RpYXRpb24pIHtcbiAgICAgICAgcGMubmVlZE5lZ290aWF0aW9uID0gZmFsc2U7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKTtcbiAgICAgICAgcGMuX2Rpc3BhdGNoRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9O1xuXG4gIC8vIFVwZGF0ZSB0aGUgY29ubmVjdGlvbiBzdGF0ZS5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl91cGRhdGVDb25uZWN0aW9uU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3U3RhdGU7XG4gICAgdmFyIHN0YXRlcyA9IHtcbiAgICAgICduZXcnOiAwLFxuICAgICAgY2xvc2VkOiAwLFxuICAgICAgY29ubmVjdGluZzogMCxcbiAgICAgIGNoZWNraW5nOiAwLFxuICAgICAgY29ubmVjdGVkOiAwLFxuICAgICAgY29tcGxldGVkOiAwLFxuICAgICAgZGlzY29ubmVjdGVkOiAwLFxuICAgICAgZmFpbGVkOiAwXG4gICAgfTtcbiAgICB0aGlzLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICBzdGF0ZXNbdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0LnN0YXRlXSsrO1xuICAgICAgc3RhdGVzW3RyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuc3RhdGVdKys7XG4gICAgfSk7XG4gICAgLy8gSUNFVHJhbnNwb3J0LmNvbXBsZXRlZCBhbmQgY29ubmVjdGVkIGFyZSB0aGUgc2FtZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIHN0YXRlcy5jb25uZWN0ZWQgKz0gc3RhdGVzLmNvbXBsZXRlZDtcblxuICAgIG5ld1N0YXRlID0gJ25ldyc7XG4gICAgaWYgKHN0YXRlcy5mYWlsZWQgPiAwKSB7XG4gICAgICBuZXdTdGF0ZSA9ICdmYWlsZWQnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVzLmNvbm5lY3RpbmcgPiAwIHx8IHN0YXRlcy5jaGVja2luZyA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2Nvbm5lY3RpbmcnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGVzLmRpc2Nvbm5lY3RlZCA+IDApIHtcbiAgICAgIG5ld1N0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZXMubmV3ID4gMCkge1xuICAgICAgbmV3U3RhdGUgPSAnbmV3JztcbiAgICB9IGVsc2UgaWYgKHN0YXRlcy5jb25uZWN0ZWQgPiAwIHx8IHN0YXRlcy5jb21wbGV0ZWQgPiAwKSB7XG4gICAgICBuZXdTdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgIH1cblxuICAgIGlmIChuZXdTdGF0ZSAhPT0gdGhpcy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgIHRoaXMuaWNlQ29ubmVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScpO1xuICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZXZlbnQpO1xuICAgIH1cbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGMgPSB0aGlzO1xuXG4gICAgaWYgKHBjLl9pc0Nsb3NlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG1ha2VFcnJvcignSW52YWxpZFN0YXRlRXJyb3InLFxuICAgICAgICAgICdDYW4gbm90IGNhbGwgY3JlYXRlT2ZmZXIgYWZ0ZXIgY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgdmFyIG51bUF1ZGlvVHJhY2tzID0gcGMudHJhbnNjZWl2ZXJzLmZpbHRlcihmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gdC5raW5kID09PSAnYXVkaW8nO1xuICAgIH0pLmxlbmd0aDtcbiAgICB2YXIgbnVtVmlkZW9UcmFja3MgPSBwYy50cmFuc2NlaXZlcnMuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiB0LmtpbmQgPT09ICd2aWRlbyc7XG4gICAgfSkubGVuZ3RoO1xuXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHdlIG5lZWQgdG8gc2VuZC9yZWN2LlxuICAgIHZhciBvZmZlck9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKG9mZmVyT3B0aW9ucykge1xuICAgICAgLy8gUmVqZWN0IENocm9tZSBsZWdhY3kgY29uc3RyYWludHMuXG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm1hbmRhdG9yeSB8fCBvZmZlck9wdGlvbnMub3B0aW9uYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdMZWdhY3kgbWFuZGF0b3J5L29wdGlvbmFsIGNvbnN0cmFpbnRzIG5vdCBzdXBwb3J0ZWQuJyk7XG4gICAgICB9XG4gICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IHRydWUpIHtcbiAgICAgICAgICBudW1BdWRpb1RyYWNrcyA9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAob2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gPT09IGZhbHNlKSB7XG4gICAgICAgICAgbnVtQXVkaW9UcmFja3MgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG51bUF1ZGlvVHJhY2tzID0gb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG51bVZpZGVvVHJhY2tzID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBudW1WaWRlb1RyYWNrcyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtVmlkZW9UcmFja3MgPSBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyKSB7XG4gICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBudW1BdWRpb1RyYWNrcy0tO1xuICAgICAgICBpZiAobnVtQXVkaW9UcmFja3MgPCAwKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIud2FudFJlY2VpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgIG51bVZpZGVvVHJhY2tzLS07XG4gICAgICAgIGlmIChudW1WaWRlb1RyYWNrcyA8IDApIHtcbiAgICAgICAgICB0cmFuc2NlaXZlci53YW50UmVjZWl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgTS1saW5lcyBmb3IgcmVjdm9ubHkgc3RyZWFtcy5cbiAgICB3aGlsZSAobnVtQXVkaW9UcmFja3MgPiAwIHx8IG51bVZpZGVvVHJhY2tzID4gMCkge1xuICAgICAgaWYgKG51bUF1ZGlvVHJhY2tzID4gMCkge1xuICAgICAgICBwYy5fY3JlYXRlVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgIG51bUF1ZGlvVHJhY2tzLS07XG4gICAgICB9XG4gICAgICBpZiAobnVtVmlkZW9UcmFja3MgPiAwKSB7XG4gICAgICAgIHBjLl9jcmVhdGVUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgbnVtVmlkZW9UcmFja3MtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUocGMuX3NkcFNlc3Npb25JZCxcbiAgICAgICAgcGMuX3NkcFNlc3Npb25WZXJzaW9uKyspO1xuICAgIHBjLnRyYW5zY2VpdmVycy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zY2VpdmVyLCBzZHBNTGluZUluZGV4KSB7XG4gICAgICAvLyBGb3IgZWFjaCB0cmFjaywgY3JlYXRlIGFuIGljZSBnYXRoZXJlciwgaWNlIHRyYW5zcG9ydCxcbiAgICAgIC8vIGR0bHMgdHJhbnNwb3J0LCBwb3RlbnRpYWxseSBydHBzZW5kZXIgYW5kIHJ0cHJlY2VpdmVyLlxuICAgICAgdmFyIHRyYWNrID0gdHJhbnNjZWl2ZXIudHJhY2s7XG4gICAgICB2YXIga2luZCA9IHRyYW5zY2VpdmVyLmtpbmQ7XG4gICAgICB2YXIgbWlkID0gdHJhbnNjZWl2ZXIubWlkIHx8IFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllcigpO1xuICAgICAgdHJhbnNjZWl2ZXIubWlkID0gbWlkO1xuXG4gICAgICBpZiAoIXRyYW5zY2VpdmVyLmljZUdhdGhlcmVyKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyID0gcGMuX2NyZWF0ZUljZUdhdGhlcmVyKHNkcE1MaW5lSW5kZXgsXG4gICAgICAgICAgICBwYy51c2luZ0J1bmRsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsb2NhbENhcGFiaWxpdGllcyA9IHdpbmRvdy5SVENSdHBTZW5kZXIuZ2V0Q2FwYWJpbGl0aWVzKGtpbmQpO1xuICAgICAgLy8gZmlsdGVyIFJUWCB1bnRpbCBhZGRpdGlvbmFsIHN0dWZmIG5lZWRlZCBmb3IgUlRYIGlzIGltcGxlbWVudGVkXG4gICAgICAvLyBpbiBhZGFwdGVyLmpzXG4gICAgICBpZiAoZWRnZVZlcnNpb24gPCAxNTAxOSkge1xuICAgICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MgPSBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZmlsdGVyKFxuICAgICAgICAgICAgZnVuY3Rpb24oY29kZWMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvZGVjLm5hbWUgIT09ICdydHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsb2NhbENhcGFiaWxpdGllcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgICAgICAvLyB3b3JrIGFyb3VuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjU1MlxuICAgICAgICAvLyBieSBhZGRpbmcgbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQ9MVxuICAgICAgICBpZiAoY29kZWMubmFtZSA9PT0gJ0gyNjQnICYmXG4gICAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzWydsZXZlbC1hc3ltbWV0cnktYWxsb3dlZCddID0gJzEnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZm9yIHN1YnNlcXVlbnQgb2ZmZXJzLCB3ZSBtaWdodCBoYXZlIHRvIHJlLXVzZSB0aGUgcGF5bG9hZFxuICAgICAgICAvLyB0eXBlIG9mIHRoZSBsYXN0IG9mZmVyLlxuICAgICAgICBpZiAodHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzICYmXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgICAgdHJhbnNjZWl2ZXIucmVtb3RlQ2FwYWJpbGl0aWVzLmNvZGVjcy5mb3JFYWNoKGZ1bmN0aW9uKHJlbW90ZUNvZGVjKSB7XG4gICAgICAgICAgICBpZiAoY29kZWMubmFtZS50b0xvd2VyQ2FzZSgpID09PSByZW1vdGVDb2RlYy5uYW1lLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICBjb2RlYy5jbG9ja1JhdGUgPT09IHJlbW90ZUNvZGVjLmNsb2NrUmF0ZSkge1xuICAgICAgICAgICAgICBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSA9IHJlbW90ZUNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxvY2FsQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbihoZHJFeHQpIHtcbiAgICAgICAgdmFyIHJlbW90ZUV4dGVuc2lvbnMgPSB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMgJiZcbiAgICAgICAgICAgIHRyYW5zY2VpdmVyLnJlbW90ZUNhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zIHx8IFtdO1xuICAgICAgICByZW1vdGVFeHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24ockhkckV4dCkge1xuICAgICAgICAgIGlmIChoZHJFeHQudXJpID09PSBySGRyRXh0LnVyaSkge1xuICAgICAgICAgICAgaGRyRXh0LmlkID0gckhkckV4dC5pZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGFuIHNzcmMgbm93LCB0byBiZSB1c2VkIGxhdGVyIGluIHJ0cFNlbmRlci5zZW5kXG4gICAgICB2YXIgc2VuZEVuY29kaW5nUGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgfHwgW3tcbiAgICAgICAgc3NyYzogKDIgKiBzZHBNTGluZUluZGV4ICsgMSkgKiAxMDAxXG4gICAgICB9XTtcbiAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAvLyBhZGQgUlRYXG4gICAgICAgIGlmIChlZGdlVmVyc2lvbiA+PSAxNTAxOSAmJiBraW5kID09PSAndmlkZW8nICYmXG4gICAgICAgICAgICAhc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICAgICAgICBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCA9IHtcbiAgICAgICAgICAgIHNzcmM6IHNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArIDFcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2NlaXZlci53YW50UmVjZWl2ZSkge1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBSZWNlaXZlciA9IG5ldyB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIoXG4gICAgICAgICAgICB0cmFuc2NlaXZlci5kdGxzVHJhbnNwb3J0LCBraW5kKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNjZWl2ZXIubG9jYWxDYXBhYmlsaXRpZXMgPSBsb2NhbENhcGFiaWxpdGllcztcbiAgICAgIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnMgPSBzZW5kRW5jb2RpbmdQYXJhbWV0ZXJzO1xuICAgIH0pO1xuXG4gICAgLy8gYWx3YXlzIG9mZmVyIEJVTkRMRSBhbmQgZGlzcG9zZSBvbiByZXR1cm4gaWYgbm90IHN1cHBvcnRlZC5cbiAgICBpZiAocGMuX2NvbmZpZy5idW5kbGVQb2xpY3kgIT09ICdtYXgtY29tcGF0Jykge1xuICAgICAgc2RwICs9ICdhPWdyb3VwOkJVTkRMRSAnICsgcGMudHJhbnNjZWl2ZXJzLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0Lm1pZDtcbiAgICAgIH0pLmpvaW4oJyAnKSArICdcXHJcXG4nO1xuICAgIH1cbiAgICBzZHAgKz0gJ2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcclxcbic7XG5cbiAgICBwYy50cmFuc2NlaXZlcnMuZm9yRWFjaChmdW5jdGlvbih0cmFuc2NlaXZlciwgc2RwTUxpbmVJbmRleCkge1xuICAgICAgc2RwICs9IHdyaXRlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLCB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICAnb2ZmZXInLCB0cmFuc2NlaXZlci5zdHJlYW0sIHBjLl9kdGxzUm9sZSk7XG4gICAgICBzZHAgKz0gJ2E9cnRjcC1yc2l6ZVxcclxcbic7XG5cbiAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlciAmJiBwYy5pY2VHYXRoZXJpbmdTdGF0ZSAhPT0gJ25ldycgJiZcbiAgICAgICAgICAoc2RwTUxpbmVJbmRleCA9PT0gMCB8fCAhcGMudXNpbmdCdW5kbGUpKSB7XG4gICAgICAgIHRyYW5zY2VpdmVyLmljZUdhdGhlcmVyLmdldExvY2FsQ2FuZGlkYXRlcygpLmZvckVhY2goZnVuY3Rpb24oY2FuZCkge1xuICAgICAgICAgIGNhbmQuY29tcG9uZW50ID0gMTtcbiAgICAgICAgICBzZHAgKz0gJ2E9JyArIFNEUFV0aWxzLndyaXRlQ2FuZGlkYXRlKGNhbmQpICsgJ1xcclxcbic7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICBzZHAgKz0gJ2E9ZW5kLW9mLWNhbmRpZGF0ZXNcXHJcXG4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZGVzYyA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICBzZHA6IHNkcFxuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGVzYyk7XG4gIH07XG5cbiAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYyA9IHRoaXM7XG5cbiAgICBpZiAocGMuX2lzQ2xvc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgJ0NhbiBub3QgY2FsbCBjcmVhdGVBbnN3ZXIgYWZ0ZXIgY2xvc2UnKSk7XG4gICAgfVxuXG4gICAgdmFyIHNkcCA9IFNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlKHBjLl9zZHBTZXNzaW9uSWQsXG4gICAgICAgIHBjLl9zZHBTZXNzaW9uVmVyc2lvbisrKTtcbiAgICBpZiAocGMudXNpbmdCdW5kbGUpIHtcbiAgICAgIHNkcCArPSAnYT1ncm91cDpCVU5ETEUgJyArIHBjLnRyYW5zY2VpdmVycy5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdC5taWQ7XG4gICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcbiAgICB9XG4gICAgdmFyIG1lZGlhU2VjdGlvbnNJbk9mZmVyID0gU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyhcbiAgICAgICAgcGMucmVtb3RlRGVzY3JpcHRpb24uc2RwKS5sZW5ndGg7XG4gICAgcGMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIsIHNkcE1MaW5lSW5kZXgpIHtcbiAgICAgIGlmIChzZHBNTGluZUluZGV4ICsgMSA+IG1lZGlhU2VjdGlvbnNJbk9mZmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0cmFuc2NlaXZlci5pc0RhdGFjaGFubmVsKSB7XG4gICAgICAgIHNkcCArPSAnbT1hcHBsaWNhdGlvbiAwIERUTFMvU0NUUCA1MDAwXFxyXFxuJyArXG4gICAgICAgICAgICAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicgK1xuICAgICAgICAgICAgJ2E9bWlkOicgKyB0cmFuc2NlaXZlci5taWQgKyAnXFxyXFxuJztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRTogbG9vayBhdCBkaXJlY3Rpb24uXG4gICAgICBpZiAodHJhbnNjZWl2ZXIuc3RyZWFtKSB7XG4gICAgICAgIHZhciBsb2NhbFRyYWNrO1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgIGxvY2FsVHJhY2sgPSB0cmFuc2NlaXZlci5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgbG9jYWxUcmFjayA9IHRyYW5zY2VpdmVyLnN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbFRyYWNrKSB7XG4gICAgICAgICAgLy8gYWRkIFJUWFxuICAgICAgICAgIGlmIChlZGdlVmVyc2lvbiA+PSAxNTAxOSAmJiB0cmFuc2NlaXZlci5raW5kID09PSAndmlkZW8nICYmXG4gICAgICAgICAgICAgICF0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHggPSB7XG4gICAgICAgICAgICAgIHNzcmM6IHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArIDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBpbnRlcnNlY3Rpb24gb2YgY2FwYWJpbGl0aWVzLlxuICAgICAgdmFyIGNvbW1vbkNhcGFiaWxpdGllcyA9IGdldENvbW1vbkNhcGFiaWxpdGllcyhcbiAgICAgICAgICB0cmFuc2NlaXZlci5sb2NhbENhcGFiaWxpdGllcyxcbiAgICAgICAgICB0cmFuc2NlaXZlci5yZW1vdGVDYXBhYmlsaXRpZXMpO1xuXG4gICAgICB2YXIgaGFzUnR4ID0gY29tbW9uQ2FwYWJpbGl0aWVzLmNvZGVjcy5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdydHgnO1xuICAgICAgfSkubGVuZ3RoO1xuICAgICAgaWYgKCFoYXNSdHggJiYgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICAgICAgZGVsZXRlIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4O1xuICAgICAgfVxuXG4gICAgICBzZHAgKz0gd3JpdGVNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIsIGNvbW1vbkNhcGFiaWxpdGllcyxcbiAgICAgICAgICAnYW5zd2VyJywgdHJhbnNjZWl2ZXIuc3RyZWFtLCBwYy5fZHRsc1JvbGUpO1xuICAgICAgaWYgKHRyYW5zY2VpdmVyLnJ0Y3BQYXJhbWV0ZXJzICYmXG4gICAgICAgICAgdHJhbnNjZWl2ZXIucnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGRlc2MgPSBuZXcgd2luZG93LlJUQ1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICB0eXBlOiAnYW5zd2VyJyxcbiAgICAgIHNkcDogc2RwXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShkZXNjKTtcbiAgfTtcblxuICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oY2FuZGlkYXRlKSB7XG4gICAgdmFyIHBjID0gdGhpcztcbiAgICB2YXIgc2VjdGlvbnM7XG4gICAgaWYgKGNhbmRpZGF0ZSAmJiAhKGNhbmRpZGF0ZS5zZHBNTGluZUluZGV4ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY2FuZGlkYXRlLnNkcE1pZCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdzZHBNTGluZUluZGV4IG9yIHNkcE1pZCByZXF1aXJlZCcpKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBuZWVkcyB0byBnbyBpbnRvIG9wcyBxdWV1ZS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoIXBjLnJlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobWFrZUVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicsXG4gICAgICAgICAgICAnQ2FuIG5vdCBhZGQgSUNFIGNhbmRpZGF0ZSB3aXRob3V0IGEgcmVtb3RlIGRlc2NyaXB0aW9uJykpO1xuICAgICAgfSBlbHNlIGlmICghY2FuZGlkYXRlIHx8IGNhbmRpZGF0ZS5jYW5kaWRhdGUgPT09ICcnKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGMudHJhbnNjZWl2ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHBjLnRyYW5zY2VpdmVyc1tqXS5pc0RhdGFjaGFubmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGMudHJhbnNjZWl2ZXJzW2pdLmljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgICAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyhwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHNlY3Rpb25zW2pdICs9ICdhPWVuZC1vZi1jYW5kaWRhdGVzXFxyXFxuJztcbiAgICAgICAgICBwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHAgPVxuICAgICAgICAgICAgICBTRFBVdGlscy5nZXREZXNjcmlwdGlvbihwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHApICtcbiAgICAgICAgICAgICAgc2VjdGlvbnMuam9pbignJyk7XG4gICAgICAgICAgaWYgKHBjLnVzaW5nQnVuZGxlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZHBNTGluZUluZGV4ID0gY2FuZGlkYXRlLnNkcE1MaW5lSW5kZXg7XG4gICAgICAgIGlmIChjYW5kaWRhdGUuc2RwTWlkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYy50cmFuc2NlaXZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYy50cmFuc2NlaXZlcnNbaV0ubWlkID09PSBjYW5kaWRhdGUuc2RwTWlkKSB7XG4gICAgICAgICAgICAgIHNkcE1MaW5lSW5kZXggPSBpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zY2VpdmVyID0gcGMudHJhbnNjZWl2ZXJzW3NkcE1MaW5lSW5kZXhdO1xuICAgICAgICBpZiAodHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICBpZiAodHJhbnNjZWl2ZXIuaXNEYXRhY2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNhbmQgPSBPYmplY3Qua2V5cyhjYW5kaWRhdGUuY2FuZGlkYXRlKS5sZW5ndGggPiAwID9cbiAgICAgICAgICAgICAgU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoY2FuZGlkYXRlLmNhbmRpZGF0ZSkgOiB7fTtcbiAgICAgICAgICAvLyBJZ25vcmUgQ2hyb21lJ3MgaW52YWxpZCBjYW5kaWRhdGVzIHNpbmNlIEVkZ2UgZG9lcyBub3QgbGlrZSB0aGVtLlxuICAgICAgICAgIGlmIChjYW5kLnByb3RvY29sID09PSAndGNwJyAmJiAoY2FuZC5wb3J0ID09PSAwIHx8IGNhbmQucG9ydCA9PT0gOSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIElnbm9yZSBSVENQIGNhbmRpZGF0ZXMsIHdlIGFzc3VtZSBSVENQLU1VWC5cbiAgICAgICAgICBpZiAoY2FuZC5jb21wb25lbnQgJiYgY2FuZC5jb21wb25lbnQgIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdoZW4gdXNpbmcgYnVuZGxlLCBhdm9pZCBhZGRpbmcgY2FuZGlkYXRlcyB0byB0aGUgd3JvbmdcbiAgICAgICAgICAvLyBpY2UgdHJhbnNwb3J0LiBBbmQgYXZvaWQgYWRkaW5nIGNhbmRpZGF0ZXMgYWRkZWQgaW4gdGhlIFNEUC5cbiAgICAgICAgICBpZiAoc2RwTUxpbmVJbmRleCA9PT0gMCB8fCAoc2RwTUxpbmVJbmRleCA+IDAgJiZcbiAgICAgICAgICAgICAgdHJhbnNjZWl2ZXIuaWNlVHJhbnNwb3J0ICE9PSBwYy50cmFuc2NlaXZlcnNbMF0uaWNlVHJhbnNwb3J0KSkge1xuICAgICAgICAgICAgaWYgKCFtYXliZUFkZENhbmRpZGF0ZSh0cmFuc2NlaXZlci5pY2VUcmFuc3BvcnQsIGNhbmQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QobWFrZUVycm9yKCdPcGVyYXRpb25FcnJvcicsXG4gICAgICAgICAgICAgICAgICAnQ2FuIG5vdCBhZGQgSUNFIGNhbmRpZGF0ZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1cGRhdGUgdGhlIHJlbW90ZURlc2NyaXB0aW9uLlxuICAgICAgICAgIHZhciBjYW5kaWRhdGVTdHJpbmcgPSBjYW5kaWRhdGUuY2FuZGlkYXRlLnRyaW0oKTtcbiAgICAgICAgICBpZiAoY2FuZGlkYXRlU3RyaW5nLmluZGV4T2YoJ2E9JykgPT09IDApIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZVN0cmluZyA9IGNhbmRpZGF0ZVN0cmluZy5zdWJzdHIoMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlY3Rpb25zID0gU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyhwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAgIHNlY3Rpb25zW3NkcE1MaW5lSW5kZXhdICs9ICdhPScgK1xuICAgICAgICAgICAgICAoY2FuZC50eXBlID8gY2FuZGlkYXRlU3RyaW5nIDogJ2VuZC1vZi1jYW5kaWRhdGVzJylcbiAgICAgICAgICAgICAgKyAnXFxyXFxuJztcbiAgICAgICAgICBwYy5yZW1vdGVEZXNjcmlwdGlvbi5zZHAgPSBzZWN0aW9ucy5qb2luKCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG1ha2VFcnJvcignT3BlcmF0aW9uRXJyb3InLFxuICAgICAgICAgICAgICAnQ2FuIG5vdCBhZGQgSUNFIGNhbmRpZGF0ZScpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgIHRoaXMudHJhbnNjZWl2ZXJzLmZvckVhY2goZnVuY3Rpb24odHJhbnNjZWl2ZXIpIHtcbiAgICAgIFsncnRwU2VuZGVyJywgJ3J0cFJlY2VpdmVyJywgJ2ljZUdhdGhlcmVyJywgJ2ljZVRyYW5zcG9ydCcsXG4gICAgICAgICAgJ2R0bHNUcmFuc3BvcnQnXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICAgICAgaWYgKHRyYW5zY2VpdmVyW21ldGhvZF0pIHtcbiAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmFuc2NlaXZlclttZXRob2RdLmdldFN0YXRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHZhciBmaXhTdGF0c1R5cGUgPSBmdW5jdGlvbihzdGF0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmJvdW5kcnRwOiAnaW5ib3VuZC1ydHAnLFxuICAgICAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgICAgIGNhbmRpZGF0ZXBhaXI6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgICAgIGxvY2FsY2FuZGlkYXRlOiAnbG9jYWwtY2FuZGlkYXRlJyxcbiAgICAgICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgICAgIH1bc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgLy8gc2hpbSBnZXRTdGF0cyB3aXRoIG1hcGxpa2Ugc3VwcG9ydFxuICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgTWFwKCk7XG4gICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmVzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICByZXN1bHRbaWRdLnR5cGUgPSBmaXhTdGF0c1R5cGUocmVzdWx0W2lkXSk7XG4gICAgICAgICAgICByZXN1bHRzLnNldChpZCwgcmVzdWx0W2lkXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gbGVnYWN5IGNhbGxiYWNrIHNoaW1zLiBTaG91bGQgYmUgbW92ZWQgdG8gYWRhcHRlci5qcyBzb21lIGRheXMuXG4gIHZhciBtZXRob2RzID0gWydjcmVhdGVPZmZlcicsICdjcmVhdGVBbnN3ZXInXTtcbiAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIHZhciBuYXRpdmVNZXRob2QgPSBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICBSVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICB0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBsZWdhY3lcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBbYXJndW1lbnRzWzJdXSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3NbMF0uYXBwbHkobnVsbCwgW2Rlc2NyaXB0aW9uXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJnc1sxXS5hcHBseShudWxsLCBbZXJyb3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuXG4gIG1ldGhvZHMgPSBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ107XG4gIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgdHlwZW9mIGFyZ3NbMl0gPT09ICdmdW5jdGlvbicpIHsgLy8gbGVnYWN5XG4gICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGFyZ3NbMV0uYXBwbHkobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJnc1syXS5hcHBseShudWxsLCBbZXJyb3JdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGdldFN0YXRzIGlzIHNwZWNpYWwuIEl0IGRvZXNuJ3QgaGF2ZSBhIHNwZWMgbGVnYWN5IG1ldGhvZCB5ZXQgd2Ugc3VwcG9ydFxuICAvLyBnZXRTdGF0cyhzb21ldGhpbmcsIGNiKSB3aXRob3V0IGVycm9yIGNhbGxiYWNrcy5cbiAgWydnZXRTdGF0cyddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgdmFyIG5hdGl2ZU1ldGhvZCA9IFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIFJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIFJUQ1BlZXJDb25uZWN0aW9uO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\n")},"./node_modules/sdp/sdp.js":module=>{"use strict";eval("/* eslint-env node */\n\n\n// SDP helpers.\nvar SDPUtils = {};\n\n// Generate an alphanumeric identifier for cname or mids.\n// TODO: use UUIDs instead? https://gist.github.com/jed/982883\nSDPUtils.generateIdentifier = function() {\n  return Math.random().toString(36).substr(2, 10);\n};\n\n// The RTCP CNAME used by all peerconnections from the same JS.\nSDPUtils.localCName = SDPUtils.generateIdentifier();\n\n// Splits SDP into lines, dealing with both CRLF and LF.\nSDPUtils.splitLines = function(blob) {\n  return blob.trim().split('\\n').map(function(line) {\n    return line.trim();\n  });\n};\n// Splits SDP into sessionpart and mediasections. Ensures CRLF.\nSDPUtils.splitSections = function(blob) {\n  var parts = blob.split('\\nm=');\n  return parts.map(function(part, index) {\n    return (index > 0 ? 'm=' + part : part).trim() + '\\r\\n';\n  });\n};\n\n// returns the session description.\nSDPUtils.getDescription = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  return sections && sections[0];\n};\n\n// returns the individual media sections.\nSDPUtils.getMediaSections = function(blob) {\n  var sections = SDPUtils.splitSections(blob);\n  sections.shift();\n  return sections;\n};\n\n// Returns lines that start with a certain prefix.\nSDPUtils.matchPrefix = function(blob, prefix) {\n  return SDPUtils.splitLines(blob).filter(function(line) {\n    return line.indexOf(prefix) === 0;\n  });\n};\n\n// Parses an ICE candidate line. Sample input:\n// candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n// rport 55996\"\nSDPUtils.parseCandidate = function(line) {\n  var parts;\n  // Parse both variants.\n  if (line.indexOf('a=candidate:') === 0) {\n    parts = line.substring(12).split(' ');\n  } else {\n    parts = line.substring(10).split(' ');\n  }\n\n  var candidate = {\n    foundation: parts[0],\n    component: parseInt(parts[1], 10),\n    protocol: parts[2].toLowerCase(),\n    priority: parseInt(parts[3], 10),\n    ip: parts[4],\n    address: parts[4], // address is an alias for ip.\n    port: parseInt(parts[5], 10),\n    // skip parts[6] == 'typ'\n    type: parts[7]\n  };\n\n  for (var i = 8; i < parts.length; i += 2) {\n    switch (parts[i]) {\n      case 'raddr':\n        candidate.relatedAddress = parts[i + 1];\n        break;\n      case 'rport':\n        candidate.relatedPort = parseInt(parts[i + 1], 10);\n        break;\n      case 'tcptype':\n        candidate.tcpType = parts[i + 1];\n        break;\n      case 'ufrag':\n        candidate.ufrag = parts[i + 1]; // for backward compability.\n        candidate.usernameFragment = parts[i + 1];\n        break;\n      default: // extension handling, in particular ufrag\n        candidate[parts[i]] = parts[i + 1];\n        break;\n    }\n  }\n  return candidate;\n};\n\n// Translates a candidate object into SDP candidate attribute.\nSDPUtils.writeCandidate = function(candidate) {\n  var sdp = [];\n  sdp.push(candidate.foundation);\n  sdp.push(candidate.component);\n  sdp.push(candidate.protocol.toUpperCase());\n  sdp.push(candidate.priority);\n  sdp.push(candidate.address || candidate.ip);\n  sdp.push(candidate.port);\n\n  var type = candidate.type;\n  sdp.push('typ');\n  sdp.push(type);\n  if (type !== 'host' && candidate.relatedAddress &&\n      candidate.relatedPort) {\n    sdp.push('raddr');\n    sdp.push(candidate.relatedAddress);\n    sdp.push('rport');\n    sdp.push(candidate.relatedPort);\n  }\n  if (candidate.tcpType && candidate.protocol.toLowerCase() === 'tcp') {\n    sdp.push('tcptype');\n    sdp.push(candidate.tcpType);\n  }\n  if (candidate.usernameFragment || candidate.ufrag) {\n    sdp.push('ufrag');\n    sdp.push(candidate.usernameFragment || candidate.ufrag);\n  }\n  return 'candidate:' + sdp.join(' ');\n};\n\n// Parses an ice-options line, returns an array of option tags.\n// a=ice-options:foo bar\nSDPUtils.parseIceOptions = function(line) {\n  return line.substr(14).split(' ');\n};\n\n// Parses an rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n// a=rtpmap:111 opus/48000/2\nSDPUtils.parseRtpMap = function(line) {\n  var parts = line.substr(9).split(' ');\n  var parsed = {\n    payloadType: parseInt(parts.shift(), 10) // was: id\n  };\n\n  parts = parts[0].split('/');\n\n  parsed.name = parts[0];\n  parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n  parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n  // legacy alias, got renamed back to channels in ORTC.\n  parsed.numChannels = parsed.channels;\n  return parsed;\n};\n\n// Generate an a=rtpmap line from RTCRtpCodecCapability or\n// RTCRtpCodecParameters.\nSDPUtils.writeRtpMap = function(codec) {\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  var channels = codec.channels || codec.numChannels || 1;\n  return 'a=rtpmap:' + pt + ' ' + codec.name + '/' + codec.clockRate +\n      (channels !== 1 ? '/' + channels : '') + '\\r\\n';\n};\n\n// Parses an a=extmap line (headerextension from RFC 5285). Sample input:\n// a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n// a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\nSDPUtils.parseExtmap = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    id: parseInt(parts[0], 10),\n    direction: parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',\n    uri: parts[1]\n  };\n};\n\n// Generates a=extmap line from RTCRtpHeaderExtensionParameters or\n// RTCRtpHeaderExtension.\nSDPUtils.writeExtmap = function(headerExtension) {\n  return 'a=extmap:' + (headerExtension.id || headerExtension.preferredId) +\n      (headerExtension.direction && headerExtension.direction !== 'sendrecv'\n        ? '/' + headerExtension.direction\n        : '') +\n      ' ' + headerExtension.uri + '\\r\\n';\n};\n\n// Parses an ftmp line, returns dictionary. Sample input:\n// a=fmtp:96 vbr=on;cng=on\n// Also deals with vbr=on; cng=on\nSDPUtils.parseFmtp = function(line) {\n  var parsed = {};\n  var kv;\n  var parts = line.substr(line.indexOf(' ') + 1).split(';');\n  for (var j = 0; j < parts.length; j++) {\n    kv = parts[j].trim().split('=');\n    parsed[kv[0].trim()] = kv[1];\n  }\n  return parsed;\n};\n\n// Generates an a=ftmp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeFmtp = function(codec) {\n  var line = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.parameters && Object.keys(codec.parameters).length) {\n    var params = [];\n    Object.keys(codec.parameters).forEach(function(param) {\n      if (codec.parameters[param]) {\n        params.push(param + '=' + codec.parameters[param]);\n      } else {\n        params.push(param);\n      }\n    });\n    line += 'a=fmtp:' + pt + ' ' + params.join(';') + '\\r\\n';\n  }\n  return line;\n};\n\n// Parses an rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n// a=rtcp-fb:98 nack rpsi\nSDPUtils.parseRtcpFb = function(line) {\n  var parts = line.substr(line.indexOf(' ') + 1).split(' ');\n  return {\n    type: parts.shift(),\n    parameter: parts.join(' ')\n  };\n};\n// Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\nSDPUtils.writeRtcpFb = function(codec) {\n  var lines = '';\n  var pt = codec.payloadType;\n  if (codec.preferredPayloadType !== undefined) {\n    pt = codec.preferredPayloadType;\n  }\n  if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n    // FIXME: special handling for trr-int?\n    codec.rtcpFeedback.forEach(function(fb) {\n      lines += 'a=rtcp-fb:' + pt + ' ' + fb.type +\n      (fb.parameter && fb.parameter.length ? ' ' + fb.parameter : '') +\n          '\\r\\n';\n    });\n  }\n  return lines;\n};\n\n// Parses an RFC 5576 ssrc media attribute. Sample input:\n// a=ssrc:3735928559 cname:something\nSDPUtils.parseSsrcMedia = function(line) {\n  var sp = line.indexOf(' ');\n  var parts = {\n    ssrc: parseInt(line.substr(7, sp - 7), 10)\n  };\n  var colon = line.indexOf(':', sp);\n  if (colon > -1) {\n    parts.attribute = line.substr(sp + 1, colon - sp - 1);\n    parts.value = line.substr(colon + 1);\n  } else {\n    parts.attribute = line.substr(sp + 1);\n  }\n  return parts;\n};\n\nSDPUtils.parseSsrcGroup = function(line) {\n  var parts = line.substr(13).split(' ');\n  return {\n    semantics: parts.shift(),\n    ssrcs: parts.map(function(ssrc) {\n      return parseInt(ssrc, 10);\n    })\n  };\n};\n\n// Extracts the MID (RFC 5888) from a media section.\n// returns the MID or undefined if no mid line was found.\nSDPUtils.getMid = function(mediaSection) {\n  var mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];\n  if (mid) {\n    return mid.substr(6);\n  }\n};\n\nSDPUtils.parseFingerprint = function(line) {\n  var parts = line.substr(14).split(' ');\n  return {\n    algorithm: parts[0].toLowerCase(), // algorithm is case-sensitive in Edge.\n    value: parts[1]\n  };\n};\n\n// Extracts DTLS parameters from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the fingerprint line as input. See also getIceParameters.\nSDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=fingerprint:');\n  // Note: a=setup line is ignored since we use the 'auto' role.\n  // Note2: 'algorithm' is not case sensitive except in Edge.\n  return {\n    role: 'auto',\n    fingerprints: lines.map(SDPUtils.parseFingerprint)\n  };\n};\n\n// Serializes DTLS parameters to SDP.\nSDPUtils.writeDtlsParameters = function(params, setupType) {\n  var sdp = 'a=setup:' + setupType + '\\r\\n';\n  params.fingerprints.forEach(function(fp) {\n    sdp += 'a=fingerprint:' + fp.algorithm + ' ' + fp.value + '\\r\\n';\n  });\n  return sdp;\n};\n\n// Parses a=crypto lines into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\nSDPUtils.parseCryptoLine = function(line) {\n  var parts = line.substr(9).split(' ');\n  return {\n    tag: parseInt(parts[0], 10),\n    cryptoSuite: parts[1],\n    keyParams: parts[2],\n    sessionParams: parts.slice(3),\n  };\n};\n\nSDPUtils.writeCryptoLine = function(parameters) {\n  return 'a=crypto:' + parameters.tag + ' ' +\n    parameters.cryptoSuite + ' ' +\n    (typeof parameters.keyParams === 'object'\n      ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)\n      : parameters.keyParams) +\n    (parameters.sessionParams ? ' ' + parameters.sessionParams.join(' ') : '') +\n    '\\r\\n';\n};\n\n// Parses the crypto key parameters into\n//   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\nSDPUtils.parseCryptoKeyParams = function(keyParams) {\n  if (keyParams.indexOf('inline:') !== 0) {\n    return null;\n  }\n  var parts = keyParams.substr(7).split('|');\n  return {\n    keyMethod: 'inline',\n    keySalt: parts[0],\n    lifeTime: parts[1],\n    mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,\n    mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,\n  };\n};\n\nSDPUtils.writeCryptoKeyParams = function(keyParams) {\n  return keyParams.keyMethod + ':'\n    + keyParams.keySalt +\n    (keyParams.lifeTime ? '|' + keyParams.lifeTime : '') +\n    (keyParams.mkiValue && keyParams.mkiLength\n      ? '|' + keyParams.mkiValue + ':' + keyParams.mkiLength\n      : '');\n};\n\n// Extracts all SDES paramters.\nSDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n  var lines = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=crypto:');\n  return lines.map(SDPUtils.parseCryptoLine);\n};\n\n// Parses ICE information from SDP media section or sessionpart.\n// FIXME: for consistency with other functions this should only\n//   get the ice-ufrag and ice-pwd lines as input.\nSDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n  var ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-ufrag:')[0];\n  var pwd = SDPUtils.matchPrefix(mediaSection + sessionpart,\n    'a=ice-pwd:')[0];\n  if (!(ufrag && pwd)) {\n    return null;\n  }\n  return {\n    usernameFragment: ufrag.substr(12),\n    password: pwd.substr(10),\n  };\n};\n\n// Serializes ICE parameters to SDP.\nSDPUtils.writeIceParameters = function(params) {\n  return 'a=ice-ufrag:' + params.usernameFragment + '\\r\\n' +\n      'a=ice-pwd:' + params.password + '\\r\\n';\n};\n\n// Parses the SDP media section and returns RTCRtpParameters.\nSDPUtils.parseRtpParameters = function(mediaSection) {\n  var description = {\n    codecs: [],\n    headerExtensions: [],\n    fecMechanisms: [],\n    rtcp: []\n  };\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  for (var i = 3; i < mline.length; i++) { // find all codecs from mline[3..]\n    var pt = mline[i];\n    var rtpmapline = SDPUtils.matchPrefix(\n      mediaSection, 'a=rtpmap:' + pt + ' ')[0];\n    if (rtpmapline) {\n      var codec = SDPUtils.parseRtpMap(rtpmapline);\n      var fmtps = SDPUtils.matchPrefix(\n        mediaSection, 'a=fmtp:' + pt + ' ');\n      // Only the first a=fmtp:<pt> is considered.\n      codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n      codec.rtcpFeedback = SDPUtils.matchPrefix(\n        mediaSection, 'a=rtcp-fb:' + pt + ' ')\n        .map(SDPUtils.parseRtcpFb);\n      description.codecs.push(codec);\n      // parse FEC mechanisms from rtpmap lines.\n      switch (codec.name.toUpperCase()) {\n        case 'RED':\n        case 'ULPFEC':\n          description.fecMechanisms.push(codec.name.toUpperCase());\n          break;\n        default: // only RED and ULPFEC are recognized as FEC mechanisms.\n          break;\n      }\n    }\n  }\n  SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function(line) {\n    description.headerExtensions.push(SDPUtils.parseExtmap(line));\n  });\n  // FIXME: parse rtcp.\n  return description;\n};\n\n// Generates parts of the SDP media section describing the capabilities /\n// parameters.\nSDPUtils.writeRtpDescription = function(kind, caps) {\n  var sdp = '';\n\n  // Build the mline.\n  sdp += 'm=' + kind + ' ';\n  sdp += caps.codecs.length > 0 ? '9' : '0'; // reject if no codecs.\n  sdp += ' UDP/TLS/RTP/SAVPF ';\n  sdp += caps.codecs.map(function(codec) {\n    if (codec.preferredPayloadType !== undefined) {\n      return codec.preferredPayloadType;\n    }\n    return codec.payloadType;\n  }).join(' ') + '\\r\\n';\n\n  sdp += 'c=IN IP4 0.0.0.0\\r\\n';\n  sdp += 'a=rtcp:9 IN IP4 0.0.0.0\\r\\n';\n\n  // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n  caps.codecs.forEach(function(codec) {\n    sdp += SDPUtils.writeRtpMap(codec);\n    sdp += SDPUtils.writeFmtp(codec);\n    sdp += SDPUtils.writeRtcpFb(codec);\n  });\n  var maxptime = 0;\n  caps.codecs.forEach(function(codec) {\n    if (codec.maxptime > maxptime) {\n      maxptime = codec.maxptime;\n    }\n  });\n  if (maxptime > 0) {\n    sdp += 'a=maxptime:' + maxptime + '\\r\\n';\n  }\n  sdp += 'a=rtcp-mux\\r\\n';\n\n  if (caps.headerExtensions) {\n    caps.headerExtensions.forEach(function(extension) {\n      sdp += SDPUtils.writeExtmap(extension);\n    });\n  }\n  // FIXME: write fecMechanisms.\n  return sdp;\n};\n\n// Parses the SDP media section and returns an array of\n// RTCRtpEncodingParameters.\nSDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n  var encodingParameters = [];\n  var description = SDPUtils.parseRtpParameters(mediaSection);\n  var hasRed = description.fecMechanisms.indexOf('RED') !== -1;\n  var hasUlpfec = description.fecMechanisms.indexOf('ULPFEC') !== -1;\n\n  // filter a=ssrc:... cname:, ignore PlanB-msid\n  var ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(parts) {\n      return parts.attribute === 'cname';\n    });\n  var primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n  var secondarySsrc;\n\n  var flows = SDPUtils.matchPrefix(mediaSection, 'a=ssrc-group:FID')\n    .map(function(line) {\n      var parts = line.substr(17).split(' ');\n      return parts.map(function(part) {\n        return parseInt(part, 10);\n      });\n    });\n  if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n    secondarySsrc = flows[0][1];\n  }\n\n  description.codecs.forEach(function(codec) {\n    if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {\n      var encParam = {\n        ssrc: primarySsrc,\n        codecPayloadType: parseInt(codec.parameters.apt, 10)\n      };\n      if (primarySsrc && secondarySsrc) {\n        encParam.rtx = {ssrc: secondarySsrc};\n      }\n      encodingParameters.push(encParam);\n      if (hasRed) {\n        encParam = JSON.parse(JSON.stringify(encParam));\n        encParam.fec = {\n          ssrc: primarySsrc,\n          mechanism: hasUlpfec ? 'red+ulpfec' : 'red'\n        };\n        encodingParameters.push(encParam);\n      }\n    }\n  });\n  if (encodingParameters.length === 0 && primarySsrc) {\n    encodingParameters.push({\n      ssrc: primarySsrc\n    });\n  }\n\n  // we support both b=AS and b=TIAS but interpret AS as TIAS.\n  var bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');\n  if (bandwidth.length) {\n    if (bandwidth[0].indexOf('b=TIAS:') === 0) {\n      bandwidth = parseInt(bandwidth[0].substr(7), 10);\n    } else if (bandwidth[0].indexOf('b=AS:') === 0) {\n      // use formula from JSEP to convert b=AS to TIAS value.\n      bandwidth = parseInt(bandwidth[0].substr(5), 10) * 1000 * 0.95\n          - (50 * 40 * 8);\n    } else {\n      bandwidth = undefined;\n    }\n    encodingParameters.forEach(function(params) {\n      params.maxBitrate = bandwidth;\n    });\n  }\n  return encodingParameters;\n};\n\n// parses http://draft.ortc.org/#rtcrtcpparameters*\nSDPUtils.parseRtcpParameters = function(mediaSection) {\n  var rtcpParameters = {};\n\n  // Gets the first SSRC. Note tha with RTX there might be multiple\n  // SSRCs.\n  var remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(obj) {\n      return obj.attribute === 'cname';\n    })[0];\n  if (remoteSsrc) {\n    rtcpParameters.cname = remoteSsrc.value;\n    rtcpParameters.ssrc = remoteSsrc.ssrc;\n  }\n\n  // Edge uses the compound attribute instead of reducedSize\n  // compound is !reducedSize\n  var rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');\n  rtcpParameters.reducedSize = rsize.length > 0;\n  rtcpParameters.compound = rsize.length === 0;\n\n  // parses the rtcp-mux attrbute.\n  // Note that Edge does not support unmuxed RTCP.\n  var mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');\n  rtcpParameters.mux = mux.length > 0;\n\n  return rtcpParameters;\n};\n\n// parses either a=msid: or a=ssrc:... msid lines and returns\n// the id of the MediaStream and MediaStreamTrack.\nSDPUtils.parseMsid = function(mediaSection) {\n  var parts;\n  var spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');\n  if (spec.length === 1) {\n    parts = spec[0].substr(7).split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n  var planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')\n    .map(function(line) {\n      return SDPUtils.parseSsrcMedia(line);\n    })\n    .filter(function(msidParts) {\n      return msidParts.attribute === 'msid';\n    });\n  if (planB.length > 0) {\n    parts = planB[0].value.split(' ');\n    return {stream: parts[0], track: parts[1]};\n  }\n};\n\n// SCTP\n// parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n// to draft-ietf-mmusic-sctp-sdp-05\nSDPUtils.parseSctpDescription = function(mediaSection) {\n  var mline = SDPUtils.parseMLine(mediaSection);\n  var maxSizeLine = SDPUtils.matchPrefix(mediaSection, 'a=max-message-size:');\n  var maxMessageSize;\n  if (maxSizeLine.length > 0) {\n    maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);\n  }\n  if (isNaN(maxMessageSize)) {\n    maxMessageSize = 65536;\n  }\n  var sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');\n  if (sctpPort.length > 0) {\n    return {\n      port: parseInt(sctpPort[0].substr(12), 10),\n      protocol: mline.fmt,\n      maxMessageSize: maxMessageSize\n    };\n  }\n  var sctpMapLines = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:');\n  if (sctpMapLines.length > 0) {\n    var parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]\n      .substr(10)\n      .split(' ');\n    return {\n      port: parseInt(parts[0], 10),\n      protocol: parts[1],\n      maxMessageSize: maxMessageSize\n    };\n  }\n};\n\n// SCTP\n// outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n// support by now receiving in this format, unless we originally parsed\n// as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n// protocol of DTLS/SCTP -- without UDP/ or TCP/)\nSDPUtils.writeSctpDescription = function(media, sctp) {\n  var output = [];\n  if (media.protocol !== 'DTLS/SCTP') {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.protocol + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctp-port:' + sctp.port + '\\r\\n'\n    ];\n  } else {\n    output = [\n      'm=' + media.kind + ' 9 ' + media.protocol + ' ' + sctp.port + '\\r\\n',\n      'c=IN IP4 0.0.0.0\\r\\n',\n      'a=sctpmap:' + sctp.port + ' ' + sctp.protocol + ' 65535\\r\\n'\n    ];\n  }\n  if (sctp.maxMessageSize !== undefined) {\n    output.push('a=max-message-size:' + sctp.maxMessageSize + '\\r\\n');\n  }\n  return output.join('');\n};\n\n// Generate a session ID for SDP.\n// https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n// recommends using a cryptographically random +ve 64-bit value\n// but right now this should be acceptable and within the right range\nSDPUtils.generateSessionId = function() {\n  return Math.random().toString().substr(2, 21);\n};\n\n// Write boilder plate for start of SDP\n// sessId argument is optional - if not supplied it will\n// be generated randomly\n// sessVersion is optional and defaults to 2\n// sessUser is optional and defaults to 'thisisadapterortc'\nSDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n  var sessionId;\n  var version = sessVer !== undefined ? sessVer : 2;\n  if (sessId) {\n    sessionId = sessId;\n  } else {\n    sessionId = SDPUtils.generateSessionId();\n  }\n  var user = sessUser || 'thisisadapterortc';\n  // FIXME: sess-id should be an NTP timestamp.\n  return 'v=0\\r\\n' +\n      'o=' + user + ' ' + sessionId + ' ' + version +\n        ' IN IP4 127.0.0.1\\r\\n' +\n      's=-\\r\\n' +\n      't=0 0\\r\\n';\n};\n\nSDPUtils.writeMediaSection = function(transceiver, caps, type, stream) {\n  var sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);\n\n  // Map ICE parameters (ufrag, pwd) to SDP.\n  sdp += SDPUtils.writeIceParameters(\n    transceiver.iceGatherer.getLocalParameters());\n\n  // Map DTLS parameters to SDP.\n  sdp += SDPUtils.writeDtlsParameters(\n    transceiver.dtlsTransport.getLocalParameters(),\n    type === 'offer' ? 'actpass' : 'active');\n\n  sdp += 'a=mid:' + transceiver.mid + '\\r\\n';\n\n  if (transceiver.direction) {\n    sdp += 'a=' + transceiver.direction + '\\r\\n';\n  } else if (transceiver.rtpSender && transceiver.rtpReceiver) {\n    sdp += 'a=sendrecv\\r\\n';\n  } else if (transceiver.rtpSender) {\n    sdp += 'a=sendonly\\r\\n';\n  } else if (transceiver.rtpReceiver) {\n    sdp += 'a=recvonly\\r\\n';\n  } else {\n    sdp += 'a=inactive\\r\\n';\n  }\n\n  if (transceiver.rtpSender) {\n    // spec.\n    var msid = 'msid:' + stream.id + ' ' +\n        transceiver.rtpSender.track.id + '\\r\\n';\n    sdp += 'a=' + msid;\n\n    // for Chrome.\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n        ' ' + msid;\n    if (transceiver.sendEncodingParameters[0].rtx) {\n      sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n          ' ' + msid;\n      sdp += 'a=ssrc-group:FID ' +\n          transceiver.sendEncodingParameters[0].ssrc + ' ' +\n          transceiver.sendEncodingParameters[0].rtx.ssrc +\n          '\\r\\n';\n    }\n  }\n  // FIXME: this should be written by writeRtpDescription.\n  sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].ssrc +\n      ' cname:' + SDPUtils.localCName + '\\r\\n';\n  if (transceiver.rtpSender && transceiver.sendEncodingParameters[0].rtx) {\n    sdp += 'a=ssrc:' + transceiver.sendEncodingParameters[0].rtx.ssrc +\n        ' cname:' + SDPUtils.localCName + '\\r\\n';\n  }\n  return sdp;\n};\n\n// Gets the direction from the mediaSection or the sessionpart.\nSDPUtils.getDirection = function(mediaSection, sessionpart) {\n  // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n  var lines = SDPUtils.splitLines(mediaSection);\n  for (var i = 0; i < lines.length; i++) {\n    switch (lines[i]) {\n      case 'a=sendrecv':\n      case 'a=sendonly':\n      case 'a=recvonly':\n      case 'a=inactive':\n        return lines[i].substr(2);\n      default:\n        // FIXME: What should happen here?\n    }\n  }\n  if (sessionpart) {\n    return SDPUtils.getDirection(sessionpart);\n  }\n  return 'sendrecv';\n};\n\nSDPUtils.getKind = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var mline = lines[0].split(' ');\n  return mline[0].substr(2);\n};\n\nSDPUtils.isRejected = function(mediaSection) {\n  return mediaSection.split(' ', 2)[1] === '0';\n};\n\nSDPUtils.parseMLine = function(mediaSection) {\n  var lines = SDPUtils.splitLines(mediaSection);\n  var parts = lines[0].substr(2).split(' ');\n  return {\n    kind: parts[0],\n    port: parseInt(parts[1], 10),\n    protocol: parts[2],\n    fmt: parts.slice(3).join(' ')\n  };\n};\n\nSDPUtils.parseOLine = function(mediaSection) {\n  var line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];\n  var parts = line.substr(2).split(' ');\n  return {\n    username: parts[0],\n    sessionId: parts[1],\n    sessionVersion: parseInt(parts[2], 10),\n    netType: parts[3],\n    addressType: parts[4],\n    address: parts[5]\n  };\n};\n\n// a very naive interpretation of a valid SDP.\nSDPUtils.isValidSDP = function(blob) {\n  if (typeof blob !== 'string' || blob.length === 0) {\n    return false;\n  }\n  var lines = SDPUtils.splitLines(blob);\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {\n      return false;\n    }\n    // TODO: check the modifier a bit more.\n  }\n  return true;\n};\n\n// Expose public methods.\nif (true) {\n  module.exports = SDPUtils;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvc2RwL3NkcC5qcz8yODJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0IsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUEwQjtBQUM5QjtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NkcC9zZHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IG5vZGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gU0RQIGhlbHBlcnMuXG52YXIgU0RQVXRpbHMgPSB7fTtcblxuLy8gR2VuZXJhdGUgYW4gYWxwaGFudW1lcmljIGlkZW50aWZpZXIgZm9yIGNuYW1lIG9yIG1pZHMuXG4vLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgMTApO1xufTtcblxuLy8gVGhlIFJUQ1AgQ05BTUUgdXNlZCBieSBhbGwgcGVlcmNvbm5lY3Rpb25zIGZyb20gdGhlIHNhbWUgSlMuXG5TRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbi8vIFNwbGl0cyBTRFAgaW50byBsaW5lcywgZGVhbGluZyB3aXRoIGJvdGggQ1JMRiBhbmQgTEYuXG5TRFBVdGlscy5zcGxpdExpbmVzID0gZnVuY3Rpb24oYmxvYikge1xuICByZXR1cm4gYmxvYi50cmltKCkuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICB9KTtcbn07XG4vLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cblNEUFV0aWxzLnNwbGl0U2VjdGlvbnMgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBwYXJ0cyA9IGJsb2Iuc3BsaXQoJ1xcbm09Jyk7XG4gIHJldHVybiBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCwgaW5kZXgpIHtcbiAgICByZXR1cm4gKGluZGV4ID4gMCA/ICdtPScgKyBwYXJ0IDogcGFydCkudHJpbSgpICsgJ1xcclxcbic7XG4gIH0pO1xufTtcblxuLy8gcmV0dXJucyB0aGUgc2Vzc2lvbiBkZXNjcmlwdGlvbi5cblNEUFV0aWxzLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24oYmxvYikge1xuICB2YXIgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICByZXR1cm4gc2VjdGlvbnMgJiYgc2VjdGlvbnNbMF07XG59O1xuXG4vLyByZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuU0RQVXRpbHMuZ2V0TWVkaWFTZWN0aW9ucyA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdmFyIHNlY3Rpb25zID0gU0RQVXRpbHMuc3BsaXRTZWN0aW9ucyhibG9iKTtcbiAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgcmV0dXJuIHNlY3Rpb25zO1xufTtcblxuLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cblNEUFV0aWxzLm1hdGNoUHJlZml4ID0gZnVuY3Rpb24oYmxvYiwgcHJlZml4KSB7XG4gIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwO1xuICB9KTtcbn07XG5cbi8vIFBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGxpbmUuIFNhbXBsZSBpbnB1dDpcbi8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuLy8gcnBvcnQgNTU5OTZcIlxuU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cztcbiAgLy8gUGFyc2UgYm90aCB2YXJpYW50cy5cbiAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDEyKS5zcGxpdCgnICcpO1xuICB9IGVsc2Uge1xuICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlID0ge1xuICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgIGNvbXBvbmVudDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICBpcDogcGFydHNbNF0sXG4gICAgYWRkcmVzczogcGFydHNbNF0sIC8vIGFkZHJlc3MgaXMgYW4gYWxpYXMgZm9yIGlwLlxuICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgLy8gc2tpcCBwYXJ0c1s2XSA9PSAndHlwJ1xuICAgIHR5cGU6IHBhcnRzWzddXG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDg7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgIGNhc2UgJ3JhZGRyJzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3Jwb3J0JzpcbiAgICAgICAgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0ID0gcGFyc2VJbnQocGFydHNbaSArIDFdLCAxMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGNwdHlwZSc6XG4gICAgICAgIGNhbmRpZGF0ZS50Y3BUeXBlID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VmcmFnJzpcbiAgICAgICAgY2FuZGlkYXRlLnVmcmFnID0gcGFydHNbaSArIDFdOyAvLyBmb3IgYmFja3dhcmQgY29tcGFiaWxpdHkuXG4gICAgICAgIGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50ID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIGV4dGVuc2lvbiBoYW5kbGluZywgaW4gcGFydGljdWxhciB1ZnJhZ1xuICAgICAgICBjYW5kaWRhdGVbcGFydHNbaV1dID0gcGFydHNbaSArIDFdO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZTtcbn07XG5cbi8vIFRyYW5zbGF0ZXMgYSBjYW5kaWRhdGUgb2JqZWN0IGludG8gU0RQIGNhbmRpZGF0ZSBhdHRyaWJ1dGUuXG5TRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICB2YXIgc2RwID0gW107XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5mb3VuZGF0aW9uKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmNvbXBvbmVudCk7XG4gIHNkcC5wdXNoKGNhbmRpZGF0ZS5wcm90b2NvbC50b1VwcGVyQ2FzZSgpKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnByaW9yaXR5KTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgc2RwLnB1c2goY2FuZGlkYXRlLnBvcnQpO1xuXG4gIHZhciB0eXBlID0gY2FuZGlkYXRlLnR5cGU7XG4gIHNkcC5wdXNoKCd0eXAnKTtcbiAgc2RwLnB1c2godHlwZSk7XG4gIGlmICh0eXBlICE9PSAnaG9zdCcgJiYgY2FuZGlkYXRlLnJlbGF0ZWRBZGRyZXNzICYmXG4gICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQpIHtcbiAgICBzZHAucHVzaCgncmFkZHInKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpO1xuICAgIHNkcC5wdXNoKCdycG9ydCcpO1xuICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5yZWxhdGVkUG9ydCk7XG4gIH1cbiAgaWYgKGNhbmRpZGF0ZS50Y3BUeXBlICYmIGNhbmRpZGF0ZS5wcm90b2NvbC50b0xvd2VyQ2FzZSgpID09PSAndGNwJykge1xuICAgIHNkcC5wdXNoKCd0Y3B0eXBlJyk7XG4gICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICB9XG4gIGlmIChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpIHtcbiAgICBzZHAucHVzaCgndWZyYWcnKTtcbiAgICBzZHAucHVzaChjYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudCB8fCBjYW5kaWRhdGUudWZyYWcpO1xuICB9XG4gIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIGljZS1vcHRpb25zIGxpbmUsIHJldHVybnMgYW4gYXJyYXkgb2Ygb3B0aW9uIHRhZ3MuXG4vLyBhPWljZS1vcHRpb25zOmZvbyBiYXJcblNEUFV0aWxzLnBhcnNlSWNlT3B0aW9ucyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgcmV0dXJuIGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xufTtcblxuLy8gUGFyc2VzIGFuIHJ0cG1hcCBsaW5lLCByZXR1cm5zIFJUQ1J0cENvZGRlY1BhcmFtZXRlcnMuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcblNEUFV0aWxzLnBhcnNlUnRwTWFwID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICB2YXIgcGFyc2VkID0ge1xuICAgIHBheWxvYWRUeXBlOiBwYXJzZUludChwYXJ0cy5zaGlmdCgpLCAxMCkgLy8gd2FzOiBpZFxuICB9O1xuXG4gIHBhcnRzID0gcGFydHNbMF0uc3BsaXQoJy8nKTtcblxuICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICBwYXJzZWQuY2xvY2tSYXRlID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTsgLy8gd2FzOiBjbG9ja3JhdGVcbiAgcGFyc2VkLmNoYW5uZWxzID0gcGFydHMubGVuZ3RoID09PSAzID8gcGFyc2VJbnQocGFydHNbMl0sIDEwKSA6IDE7XG4gIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICBwYXJzZWQubnVtQ2hhbm5lbHMgPSBwYXJzZWQuY2hhbm5lbHM7XG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG4vLyBHZW5lcmF0ZSBhbiBhPXJ0cG1hcCBsaW5lIGZyb20gUlRDUnRwQ29kZWNDYXBhYmlsaXR5IG9yXG4vLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cE1hcCA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHB0ID0gY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGU7XG4gIH1cbiAgdmFyIGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgcmV0dXJuICdhPXJ0cG1hcDonICsgcHQgKyAnICcgKyBjb2RlYy5uYW1lICsgJy8nICsgY29kZWMuY2xvY2tSYXRlICtcbiAgICAgIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG59O1xuXG4vLyBQYXJzZXMgYW4gYT1leHRtYXAgbGluZSAoaGVhZGVyZXh0ZW5zaW9uIGZyb20gUkZDIDUyODUpLiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbi8vIGE9ZXh0bWFwOjIvc2VuZG9ubHkgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuU0RQVXRpbHMucGFyc2VFeHRtYXAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDkpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgaWQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgdXJpOiBwYXJ0c1sxXVxuICB9O1xufTtcblxuLy8gR2VuZXJhdGVzIGE9ZXh0bWFwIGxpbmUgZnJvbSBSVENSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzIG9yXG4vLyBSVENSdHBIZWFkZXJFeHRlbnNpb24uXG5TRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uKGhlYWRlckV4dGVuc2lvbikge1xuICByZXR1cm4gJ2E9ZXh0bWFwOicgKyAoaGVhZGVyRXh0ZW5zaW9uLmlkIHx8IGhlYWRlckV4dGVuc2lvbi5wcmVmZXJyZWRJZCkgK1xuICAgICAgKGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gJiYgaGVhZGVyRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2J1xuICAgICAgICA/ICcvJyArIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgOiAnJykgK1xuICAgICAgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArICdcXHJcXG4nO1xufTtcblxuLy8gUGFyc2VzIGFuIGZ0bXAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4vLyBhPWZtdHA6OTYgdmJyPW9uO2NuZz1vblxuLy8gQWxzbyBkZWFscyB3aXRoIHZicj1vbjsgY25nPW9uXG5TRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGt2O1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCc7Jyk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICBrdiA9IHBhcnRzW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgIHBhcnNlZFtrdlswXS50cmltKCldID0ga3ZbMV07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG5cbi8vIEdlbmVyYXRlcyBhbiBhPWZ0bXAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZUZtdHAgPSBmdW5jdGlvbihjb2RlYykge1xuICB2YXIgbGluZSA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5wYXJhbWV0ZXJzICYmIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpLmxlbmd0aCkge1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0pIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGluZSArPSAnYT1mbXRwOicgKyBwdCArICcgJyArIHBhcmFtcy5qb2luKCc7JykgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gbGluZTtcbn07XG5cbi8vIFBhcnNlcyBhbiBydGNwLWZiIGxpbmUsIHJldHVybnMgUlRDUFJ0Y3BGZWVkYmFjayBvYmplY3QuIFNhbXBsZSBpbnB1dDpcbi8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcblNEUFV0aWxzLnBhcnNlUnRjcEZiID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cihsaW5lLmluZGV4T2YoJyAnKSArIDEpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogcGFydHMuc2hpZnQoKSxcbiAgICBwYXJhbWV0ZXI6IHBhcnRzLmpvaW4oJyAnKVxuICB9O1xufTtcbi8vIEdlbmVyYXRlIGE9cnRjcC1mYiBsaW5lcyBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0Y3BGYiA9IGZ1bmN0aW9uKGNvZGVjKSB7XG4gIHZhciBsaW5lcyA9ICcnO1xuICB2YXIgcHQgPSBjb2RlYy5wYXlsb2FkVHlwZTtcbiAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICB9XG4gIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgIC8vIEZJWE1FOiBzcGVjaWFsIGhhbmRsaW5nIGZvciB0cnItaW50P1xuICAgIGNvZGVjLnJ0Y3BGZWVkYmFjay5mb3JFYWNoKGZ1bmN0aW9uKGZiKSB7XG4gICAgICBsaW5lcyArPSAnYT1ydGNwLWZiOicgKyBwdCArICcgJyArIGZiLnR5cGUgK1xuICAgICAgKGZiLnBhcmFtZXRlciAmJiBmYi5wYXJhbWV0ZXIubGVuZ3RoID8gJyAnICsgZmIucGFyYW1ldGVyIDogJycpICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGluZXM7XG59O1xuXG4vLyBQYXJzZXMgYW4gUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbi8vIGE9c3NyYzozNzM1OTI4NTU5IGNuYW1lOnNvbWV0aGluZ1xuU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICB2YXIgcGFydHMgPSB7XG4gICAgc3NyYzogcGFyc2VJbnQobGluZS5zdWJzdHIoNywgc3AgLSA3KSwgMTApXG4gIH07XG4gIHZhciBjb2xvbiA9IGxpbmUuaW5kZXhPZignOicsIHNwKTtcbiAgaWYgKGNvbG9uID4gLTEpIHtcbiAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cihzcCArIDEsIGNvbG9uIC0gc3AgLSAxKTtcbiAgICBwYXJ0cy52YWx1ZSA9IGxpbmUuc3Vic3RyKGNvbG9uICsgMSk7XG4gIH0gZWxzZSB7XG4gICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHIoc3AgKyAxKTtcbiAgfVxuICByZXR1cm4gcGFydHM7XG59O1xuXG5TRFBVdGlscy5wYXJzZVNzcmNHcm91cCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgdmFyIHBhcnRzID0gbGluZS5zdWJzdHIoMTMpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAgc2VtYW50aWNzOiBwYXJ0cy5zaGlmdCgpLFxuICAgIHNzcmNzOiBwYXJ0cy5tYXAoZnVuY3Rpb24oc3NyYykge1xuICAgICAgcmV0dXJuIHBhcnNlSW50KHNzcmMsIDEwKTtcbiAgICB9KVxuICB9O1xufTtcblxuLy8gRXh0cmFjdHMgdGhlIE1JRCAoUkZDIDU4ODgpIGZyb20gYSBtZWRpYSBzZWN0aW9uLlxuLy8gcmV0dXJucyB0aGUgTUlEIG9yIHVuZGVmaW5lZCBpZiBubyBtaWQgbGluZSB3YXMgZm91bmQuXG5TRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIG1pZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bWlkOicpWzBdO1xuICBpZiAobWlkKSB7XG4gICAgcmV0dXJuIG1pZC5zdWJzdHIoNik7XG4gIH1cbn07XG5cblNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQgPSBmdW5jdGlvbihsaW5lKSB7XG4gIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE0KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIGFsZ29yaXRobTogcGFydHNbMF0udG9Mb3dlckNhc2UoKSwgLy8gYWxnb3JpdGhtIGlzIGNhc2Utc2Vuc2l0aXZlIGluIEVkZ2UuXG4gICAgdmFsdWU6IHBhcnRzWzFdXG4gIH07XG59O1xuXG4vLyBFeHRyYWN0cyBEVExTIHBhcmFtZXRlcnMgZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG5TRFBVdGlscy5nZXREdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgdmFyIGxpbmVzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsXG4gICAgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gIC8vIE5vdGU6IGE9c2V0dXAgbGluZSBpcyBpZ25vcmVkIHNpbmNlIHdlIHVzZSB0aGUgJ2F1dG8nIHJvbGUuXG4gIC8vIE5vdGUyOiAnYWxnb3JpdGhtJyBpcyBub3QgY2FzZSBzZW5zaXRpdmUgZXhjZXB0IGluIEVkZ2UuXG4gIHJldHVybiB7XG4gICAgcm9sZTogJ2F1dG8nLFxuICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gIH07XG59O1xuXG4vLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocGFyYW1zLCBzZXR1cFR5cGUpIHtcbiAgdmFyIHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgcGFyYW1zLmZpbmdlcnByaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGZwKSB7XG4gICAgc2RwICs9ICdhPWZpbmdlcnByaW50OicgKyBmcC5hbGdvcml0aG0gKyAnICcgKyBmcC52YWx1ZSArICdcXHJcXG4nO1xuICB9KTtcbiAgcmV0dXJuIHNkcDtcbn07XG5cbi8vIFBhcnNlcyBhPWNyeXB0byBsaW5lcyBpbnRvXG4vLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lID0gZnVuY3Rpb24obGluZSkge1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cig5KS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHRhZzogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICBjcnlwdG9TdWl0ZTogcGFydHNbMV0sXG4gICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICBzZXNzaW9uUGFyYW1zOiBwYXJ0cy5zbGljZSgzKSxcbiAgfTtcbn07XG5cblNEUFV0aWxzLndyaXRlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uKHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgK1xuICAgIHBhcmFtZXRlcnMuY3J5cHRvU3VpdGUgKyAnICcgK1xuICAgICh0eXBlb2YgcGFyYW1ldGVycy5rZXlQYXJhbXMgPT09ICdvYmplY3QnXG4gICAgICA/IFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zKHBhcmFtZXRlcnMua2V5UGFyYW1zKVxuICAgICAgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgK1xuICAgIChwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMgPyAnICcgKyBwYXJhbWV0ZXJzLnNlc3Npb25QYXJhbXMuam9pbignICcpIDogJycpICtcbiAgICAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgY3J5cHRvIGtleSBwYXJhbWV0ZXJzIGludG9cbi8vICAgaHR0cHM6Ly9yYXdnaXQuY29tL2Fib2JhL2VkZ2VydGMvbWFzdGVyL21zb3J0Yy1yczQuaHRtbCNydGNzcnRwa2V5cGFyYW0qXG5TRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uKGtleVBhcmFtcykge1xuICBpZiAoa2V5UGFyYW1zLmluZGV4T2YoJ2lubGluZTonKSAhPT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwYXJ0cyA9IGtleVBhcmFtcy5zdWJzdHIoNykuc3BsaXQoJ3wnKTtcbiAgcmV0dXJuIHtcbiAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgIGtleVNhbHQ6IHBhcnRzWzBdLFxuICAgIGxpZmVUaW1lOiBwYXJ0c1sxXSxcbiAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgIG1raUxlbmd0aDogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzFdIDogdW5kZWZpbmVkLFxuICB9O1xufTtcblxuU0RQVXRpbHMud3JpdGVDcnlwdG9LZXlQYXJhbXMgPSBmdW5jdGlvbihrZXlQYXJhbXMpIHtcbiAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOidcbiAgICArIGtleVBhcmFtcy5rZXlTYWx0ICtcbiAgICAoa2V5UGFyYW1zLmxpZmVUaW1lID8gJ3wnICsga2V5UGFyYW1zLmxpZmVUaW1lIDogJycpICtcbiAgICAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGhcbiAgICAgID8gJ3wnICsga2V5UGFyYW1zLm1raVZhbHVlICsgJzonICsga2V5UGFyYW1zLm1raUxlbmd0aFxuICAgICAgOiAnJyk7XG59O1xuXG4vLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbXRlcnMuXG5TRFBVdGlscy5nZXRDcnlwdG9QYXJhbWV0ZXJzID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCxcbiAgICAnYT1jcnlwdG86Jyk7XG4gIHJldHVybiBsaW5lcy5tYXAoU0RQVXRpbHMucGFyc2VDcnlwdG9MaW5lKTtcbn07XG5cbi8vIFBhcnNlcyBJQ0UgaW5mb3JtYXRpb24gZnJvbSBTRFAgbWVkaWEgc2VjdGlvbiBvciBzZXNzaW9ucGFydC5cbi8vIEZJWE1FOiBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBmdW5jdGlvbnMgdGhpcyBzaG91bGQgb25seVxuLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cblNEUFV0aWxzLmdldEljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIHZhciB1ZnJhZyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS11ZnJhZzonKVswXTtcbiAgdmFyIHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LFxuICAgICdhPWljZS1wd2Q6JylbMF07XG4gIGlmICghKHVmcmFnICYmIHB3ZCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cigxMiksXG4gICAgcGFzc3dvcmQ6IHB3ZC5zdWJzdHIoMTApLFxuICB9O1xufTtcblxuLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG5TRFBVdGlscy53cml0ZUljZVBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgcmV0dXJuICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArXG4gICAgICAnYT1pY2UtcHdkOicgKyBwYXJhbXMucGFzc3dvcmQgKyAnXFxyXFxuJztcbn07XG5cbi8vIFBhcnNlcyB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gYW5kIHJldHVybnMgUlRDUnRwUGFyYW1ldGVycy5cblNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZGVzY3JpcHRpb24gPSB7XG4gICAgY29kZWNzOiBbXSxcbiAgICBoZWFkZXJFeHRlbnNpb25zOiBbXSxcbiAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICBydGNwOiBbXVxuICB9O1xuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIHZhciBtbGluZSA9IGxpbmVzWzBdLnNwbGl0KCcgJyk7XG4gIGZvciAodmFyIGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHsgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgIHZhciBwdCA9IG1saW5lW2ldO1xuICAgIHZhciBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICBtZWRpYVNlY3Rpb24sICdhPXJ0cG1hcDonICsgcHQgKyAnICcpWzBdO1xuICAgIGlmIChydHBtYXBsaW5lKSB7XG4gICAgICB2YXIgY29kZWMgPSBTRFBVdGlscy5wYXJzZVJ0cE1hcChydHBtYXBsaW5lKTtcbiAgICAgIHZhciBmbXRwcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KFxuICAgICAgICBtZWRpYVNlY3Rpb24sICdhPWZtdHA6JyArIHB0ICsgJyAnKTtcbiAgICAgIC8vIE9ubHkgdGhlIGZpcnN0IGE9Zm10cDo8cHQ+IGlzIGNvbnNpZGVyZWQuXG4gICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgoXG4gICAgICAgIG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpXG4gICAgICAgIC5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgLy8gcGFyc2UgRkVDIG1lY2hhbmlzbXMgZnJvbSBydHBtYXAgbGluZXMuXG4gICAgICBzd2l0Y2ggKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICBjYXNlICdVTFBGRUMnOlxuICAgICAgICAgIGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMucHVzaChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBvbmx5IFJFRCBhbmQgVUxQRkVDIGFyZSByZWNvZ25pemVkIGFzIEZFQyBtZWNoYW5pc21zLlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPWV4dG1hcDonKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICBkZXNjcmlwdGlvbi5oZWFkZXJFeHRlbnNpb25zLnB1c2goU0RQVXRpbHMucGFyc2VFeHRtYXAobGluZSkpO1xuICB9KTtcbiAgLy8gRklYTUU6IHBhcnNlIHJ0Y3AuXG4gIHJldHVybiBkZXNjcmlwdGlvbjtcbn07XG5cbi8vIEdlbmVyYXRlcyBwYXJ0cyBvZiB0aGUgU0RQIG1lZGlhIHNlY3Rpb24gZGVzY3JpYmluZyB0aGUgY2FwYWJpbGl0aWVzIC9cbi8vIHBhcmFtZXRlcnMuXG5TRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24oa2luZCwgY2Fwcykge1xuICB2YXIgc2RwID0gJyc7XG5cbiAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICBzZHAgKz0gJ209JyArIGtpbmQgKyAnICc7XG4gIHNkcCArPSBjYXBzLmNvZGVjcy5sZW5ndGggPiAwID8gJzknIDogJzAnOyAvLyByZWplY3QgaWYgbm8gY29kZWNzLlxuICBzZHAgKz0gJyBVRFAvVExTL1JUUC9TQVZQRiAnO1xuICBzZHAgKz0gY2Fwcy5jb2RlY3MubWFwKGZ1bmN0aW9uKGNvZGVjKSB7XG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVjLnBheWxvYWRUeXBlO1xuICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcblxuICBzZHAgKz0gJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nO1xuICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAvLyBBZGQgYT1ydHBtYXAgbGluZXMgZm9yIGVhY2ggY29kZWMuIEFsc28gZm10cCBhbmQgcnRjcC1mYi5cbiAgY2Fwcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0cE1hcChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRjcEZiKGNvZGVjKTtcbiAgfSk7XG4gIHZhciBtYXhwdGltZSA9IDA7XG4gIGNhcHMuY29kZWNzLmZvckVhY2goZnVuY3Rpb24oY29kZWMpIHtcbiAgICBpZiAoY29kZWMubWF4cHRpbWUgPiBtYXhwdGltZSkge1xuICAgICAgbWF4cHRpbWUgPSBjb2RlYy5tYXhwdGltZTtcbiAgICB9XG4gIH0pO1xuICBpZiAobWF4cHRpbWUgPiAwKSB7XG4gICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICB9XG4gIHNkcCArPSAnYT1ydGNwLW11eFxcclxcbic7XG5cbiAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgIGNhcHMuaGVhZGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRXh0bWFwKGV4dGVuc2lvbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gRklYTUU6IHdyaXRlIGZlY01lY2hhbmlzbXMuXG4gIHJldHVybiBzZHA7XG59O1xuXG4vLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mXG4vLyBSVENSdHBFbmNvZGluZ1BhcmFtZXRlcnMuXG5TRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgZW5jb2RpbmdQYXJhbWV0ZXJzID0gW107XG4gIHZhciBkZXNjcmlwdGlvbiA9IFNEUFV0aWxzLnBhcnNlUnRwUGFyYW1ldGVycyhtZWRpYVNlY3Rpb24pO1xuICB2YXIgaGFzUmVkID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdSRUQnKSAhPT0gLTE7XG4gIHZhciBoYXNVbHBmZWMgPSBkZXNjcmlwdGlvbi5mZWNNZWNoYW5pc21zLmluZGV4T2YoJ1VMUEZFQycpICE9PSAtMTtcblxuICAvLyBmaWx0ZXIgYT1zc3JjOi4uLiBjbmFtZTosIGlnbm9yZSBQbGFuQi1tc2lkXG4gIHZhciBzc3JjcyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKVxuICAgIC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgcmV0dXJuIFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpO1xuICAgIH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbihwYXJ0cykge1xuICAgICAgcmV0dXJuIHBhcnRzLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICB9KTtcbiAgdmFyIHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICB2YXIgc2Vjb25kYXJ5U3NyYztcblxuICB2YXIgZmxvd3MgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmMtZ3JvdXA6RklEJylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3Vic3RyKDE3KS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgaWYgKGZsb3dzLmxlbmd0aCA+IDAgJiYgZmxvd3NbMF0ubGVuZ3RoID4gMSAmJiBmbG93c1swXVswXSA9PT0gcHJpbWFyeVNzcmMpIHtcbiAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gIH1cblxuICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjb2RlYykge1xuICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICB2YXIgZW5jUGFyYW0gPSB7XG4gICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApXG4gICAgICB9O1xuICAgICAgaWYgKHByaW1hcnlTc3JjICYmIHNlY29uZGFyeVNzcmMpIHtcbiAgICAgICAgZW5jUGFyYW0ucnR4ID0ge3NzcmM6IHNlY29uZGFyeVNzcmN9O1xuICAgICAgfVxuICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICBlbmNQYXJhbSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jUGFyYW0pKTtcbiAgICAgICAgZW5jUGFyYW0uZmVjID0ge1xuICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgIG1lY2hhbmlzbTogaGFzVWxwZmVjID8gJ3JlZCt1bHBmZWMnIDogJ3JlZCdcbiAgICAgICAgfTtcbiAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChlbmNvZGluZ1BhcmFtZXRlcnMubGVuZ3RoID09PSAwICYmIHByaW1hcnlTc3JjKSB7XG4gICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goe1xuICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICB2YXIgYmFuZHdpZHRoID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYj0nKTtcbiAgaWYgKGJhbmR3aWR0aC5sZW5ndGgpIHtcbiAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgYmFuZHdpZHRoID0gcGFyc2VJbnQoYmFuZHdpZHRoWzBdLnN1YnN0cig3KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9QVM6JykgPT09IDApIHtcbiAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHIoNSksIDEwKSAqIDEwMDAgKiAwLjk1XG4gICAgICAgICAgLSAoNTAgKiA0MCAqIDgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYW5kd2lkdGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVuY29kaW5nUGFyYW1ldGVycy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgcGFyYW1zLm1heEJpdHJhdGUgPSBiYW5kd2lkdGg7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuU0RQVXRpbHMucGFyc2VSdGNwUGFyYW1ldGVycyA9IGZ1bmN0aW9uKG1lZGlhU2VjdGlvbikge1xuICB2YXIgcnRjcFBhcmFtZXRlcnMgPSB7fTtcblxuICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYSB3aXRoIFJUWCB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZVxuICAvLyBTU1JDcy5cbiAgdmFyIHJlbW90ZVNzcmMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJztcbiAgICB9KVswXTtcbiAgaWYgKHJlbW90ZVNzcmMpIHtcbiAgICBydGNwUGFyYW1ldGVycy5jbmFtZSA9IHJlbW90ZVNzcmMudmFsdWU7XG4gICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgfVxuXG4gIC8vIEVkZ2UgdXNlcyB0aGUgY29tcG91bmQgYXR0cmlidXRlIGluc3RlYWQgb2YgcmVkdWNlZFNpemVcbiAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gIHZhciByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICBydGNwUGFyYW1ldGVycy5yZWR1Y2VkU2l6ZSA9IHJzaXplLmxlbmd0aCA+IDA7XG4gIHJ0Y3BQYXJhbWV0ZXJzLmNvbXBvdW5kID0gcnNpemUubGVuZ3RoID09PSAwO1xuXG4gIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgLy8gTm90ZSB0aGF0IEVkZ2UgZG9lcyBub3Qgc3VwcG9ydCB1bm11eGVkIFJUQ1AuXG4gIHZhciBtdXggPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtbXV4Jyk7XG4gIHJ0Y3BQYXJhbWV0ZXJzLm11eCA9IG11eC5sZW5ndGggPiAwO1xuXG4gIHJldHVybiBydGNwUGFyYW1ldGVycztcbn07XG5cbi8vIHBhcnNlcyBlaXRoZXIgYT1tc2lkOiBvciBhPXNzcmM6Li4uIG1zaWQgbGluZXMgYW5kIHJldHVybnNcbi8vIHRoZSBpZCBvZiB0aGUgTWVkaWFTdHJlYW0gYW5kIE1lZGlhU3RyZWFtVHJhY2suXG5TRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIHBhcnRzO1xuICB2YXIgc3BlYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9bXNpZDonKTtcbiAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgcGFydHMgPSBzcGVjWzBdLnN1YnN0cig3KS5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7c3RyZWFtOiBwYXJ0c1swXSwgdHJhY2s6IHBhcnRzWzFdfTtcbiAgfVxuICB2YXIgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JylcbiAgICAubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKTtcbiAgICB9KVxuICAgIC5maWx0ZXIoZnVuY3Rpb24obXNpZFBhcnRzKSB7XG4gICAgICByZXR1cm4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnO1xuICAgIH0pO1xuICBpZiAocGxhbkIubGVuZ3RoID4gMCkge1xuICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICByZXR1cm4ge3N0cmVhbTogcGFydHNbMF0sIHRyYWNrOiBwYXJ0c1sxXX07XG4gIH1cbn07XG5cbi8vIFNDVFBcbi8vIHBhcnNlcyBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiBmaXJzdCBhbmQgZmFsbHMgYmFja1xuLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcblNEUFV0aWxzLnBhcnNlU2N0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBtbGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1heFNpemVMaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tYXgtbWVzc2FnZS1zaXplOicpO1xuICB2YXIgbWF4TWVzc2FnZVNpemU7XG4gIGlmIChtYXhTaXplTGluZS5sZW5ndGggPiAwKSB7XG4gICAgbWF4TWVzc2FnZVNpemUgPSBwYXJzZUludChtYXhTaXplTGluZVswXS5zdWJzdHIoMTkpLCAxMCk7XG4gIH1cbiAgaWYgKGlzTmFOKG1heE1lc3NhZ2VTaXplKSkge1xuICAgIG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG4gIH1cbiAgdmFyIHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gIGlmIChzY3RwUG9ydC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cigxMiksIDEwKSxcbiAgICAgIHByb3RvY29sOiBtbGluZS5mbXQsXG4gICAgICBtYXhNZXNzYWdlU2l6ZTogbWF4TWVzc2FnZVNpemVcbiAgICB9O1xuICB9XG4gIHZhciBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gIGlmIChzY3RwTWFwTGluZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXJ0cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c2N0cG1hcDonKVswXVxuICAgICAgLnN1YnN0cigxMClcbiAgICAgIC5zcGxpdCgnICcpO1xuICAgIHJldHVybiB7XG4gICAgICBwb3J0OiBwYXJzZUludChwYXJ0c1swXSwgMTApLFxuICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgbWF4TWVzc2FnZVNpemU6IG1heE1lc3NhZ2VTaXplXG4gICAgfTtcbiAgfVxufTtcblxuLy8gU0NUUFxuLy8gb3V0cHV0cyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMjYgdmVyc2lvbiB0aGF0IGFsbCBicm93c2Vyc1xuLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbi8vIGFzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0wNSBmb3JtYXQgKGluZGljYXRlZCBieSB0aGUgbS1saW5lXG4vLyBwcm90b2NvbCBvZiBEVExTL1NDVFAgLS0gd2l0aG91dCBVRFAvIG9yIFRDUC8pXG5TRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uKG1lZGlhLCBzY3RwKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnXFxyXFxuJyxcbiAgICAgICdjPUlOIElQNCAwLjAuMC4wXFxyXFxuJyxcbiAgICAgICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbidcbiAgICBdO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IFtcbiAgICAgICdtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLFxuICAgICAgJ2M9SU4gSVA0IDAuMC4wLjBcXHJcXG4nLFxuICAgICAgJ2E9c2N0cG1hcDonICsgc2N0cC5wb3J0ICsgJyAnICsgc2N0cC5wcm90b2NvbCArICcgNjU1MzVcXHJcXG4nXG4gICAgXTtcbiAgfVxuICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgb3V0cHV0LnB1c2goJ2E9bWF4LW1lc3NhZ2Utc2l6ZTonICsgc2N0cC5tYXhNZXNzYWdlU2l6ZSArICdcXHJcXG4nKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcblxuLy8gR2VuZXJhdGUgYSBzZXNzaW9uIElEIGZvciBTRFAuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4vLyByZWNvbW1lbmRzIHVzaW5nIGEgY3J5cHRvZ3JhcGhpY2FsbHkgcmFuZG9tICt2ZSA2NC1iaXQgdmFsdWVcbi8vIGJ1dCByaWdodCBub3cgdGhpcyBzaG91bGQgYmUgYWNjZXB0YWJsZSBhbmQgd2l0aGluIHRoZSByaWdodCByYW5nZVxuU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHIoMiwgMjEpO1xufTtcblxuLy8gV3JpdGUgYm9pbGRlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4vLyBzZXNzSWQgYXJndW1lbnQgaXMgb3B0aW9uYWwgLSBpZiBub3Qgc3VwcGxpZWQgaXQgd2lsbFxuLy8gYmUgZ2VuZXJhdGVkIHJhbmRvbWx5XG4vLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuLy8gc2Vzc1VzZXIgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvICd0aGlzaXNhZGFwdGVyb3J0YydcblNEUFV0aWxzLndyaXRlU2Vzc2lvbkJvaWxlcnBsYXRlID0gZnVuY3Rpb24oc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICB2YXIgc2Vzc2lvbklkO1xuICB2YXIgdmVyc2lvbiA9IHNlc3NWZXIgIT09IHVuZGVmaW5lZCA/IHNlc3NWZXIgOiAyO1xuICBpZiAoc2Vzc0lkKSB7XG4gICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICB9IGVsc2Uge1xuICAgIHNlc3Npb25JZCA9IFNEUFV0aWxzLmdlbmVyYXRlU2Vzc2lvbklkKCk7XG4gIH1cbiAgdmFyIHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAvLyBGSVhNRTogc2Vzcy1pZCBzaG91bGQgYmUgYW4gTlRQIHRpbWVzdGFtcC5cbiAgcmV0dXJuICd2PTBcXHJcXG4nICtcbiAgICAgICdvPScgKyB1c2VyICsgJyAnICsgc2Vzc2lvbklkICsgJyAnICsgdmVyc2lvbiArXG4gICAgICAgICcgSU4gSVA0IDEyNy4wLjAuMVxcclxcbicgK1xuICAgICAgJ3M9LVxcclxcbicgK1xuICAgICAgJ3Q9MCAwXFxyXFxuJztcbn07XG5cblNEUFV0aWxzLndyaXRlTWVkaWFTZWN0aW9uID0gZnVuY3Rpb24odHJhbnNjZWl2ZXIsIGNhcHMsIHR5cGUsIHN0cmVhbSkge1xuICB2YXIgc2RwID0gU0RQVXRpbHMud3JpdGVSdHBEZXNjcmlwdGlvbih0cmFuc2NlaXZlci5raW5kLCBjYXBzKTtcblxuICAvLyBNYXAgSUNFIHBhcmFtZXRlcnMgKHVmcmFnLCBwd2QpIHRvIFNEUC5cbiAgc2RwICs9IFNEUFV0aWxzLndyaXRlSWNlUGFyYW1ldGVycyhcbiAgICB0cmFuc2NlaXZlci5pY2VHYXRoZXJlci5nZXRMb2NhbFBhcmFtZXRlcnMoKSk7XG5cbiAgLy8gTWFwIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gIHNkcCArPSBTRFBVdGlscy53cml0ZUR0bHNQYXJhbWV0ZXJzKFxuICAgIHRyYW5zY2VpdmVyLmR0bHNUcmFuc3BvcnQuZ2V0TG9jYWxQYXJhbWV0ZXJzKCksXG4gICAgdHlwZSA9PT0gJ29mZmVyJyA/ICdhY3RwYXNzJyA6ICdhY3RpdmUnKTtcblxuICBzZHAgKz0gJ2E9bWlkOicgKyB0cmFuc2NlaXZlci5taWQgKyAnXFxyXFxuJztcblxuICBpZiAodHJhbnNjZWl2ZXIuZGlyZWN0aW9uKSB7XG4gICAgc2RwICs9ICdhPScgKyB0cmFuc2NlaXZlci5kaXJlY3Rpb24gKyAnXFxyXFxuJztcbiAgfSBlbHNlIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9c2VuZHJlY3ZcXHJcXG4nO1xuICB9IGVsc2UgaWYgKHRyYW5zY2VpdmVyLnJ0cFNlbmRlcikge1xuICAgIHNkcCArPSAnYT1zZW5kb25seVxcclxcbic7XG4gIH0gZWxzZSBpZiAodHJhbnNjZWl2ZXIucnRwUmVjZWl2ZXIpIHtcbiAgICBzZHAgKz0gJ2E9cmVjdm9ubHlcXHJcXG4nO1xuICB9IGVsc2Uge1xuICAgIHNkcCArPSAnYT1pbmFjdGl2ZVxcclxcbic7XG4gIH1cblxuICBpZiAodHJhbnNjZWl2ZXIucnRwU2VuZGVyKSB7XG4gICAgLy8gc3BlYy5cbiAgICB2YXIgbXNpZCA9ICdtc2lkOicgKyBzdHJlYW0uaWQgKyAnICcgK1xuICAgICAgICB0cmFuc2NlaXZlci5ydHBTZW5kZXIudHJhY2suaWQgKyAnXFxyXFxuJztcbiAgICBzZHAgKz0gJ2E9JyArIG1zaWQ7XG5cbiAgICAvLyBmb3IgQ2hyb21lLlxuICAgIHNkcCArPSAnYT1zc3JjOicgKyB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnNzcmMgK1xuICAgICAgICAnICcgKyBtc2lkO1xuICAgIGlmICh0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eCkge1xuICAgICAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0ucnR4LnNzcmMgK1xuICAgICAgICAgICcgJyArIG1zaWQ7XG4gICAgICBzZHAgKz0gJ2E9c3NyYy1ncm91cDpGSUQgJyArXG4gICAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5zc3JjICsgJyAnICtcbiAgICAgICAgICB0cmFuc2NlaXZlci5zZW5kRW5jb2RpbmdQYXJhbWV0ZXJzWzBdLnJ0eC5zc3JjICtcbiAgICAgICAgICAnXFxyXFxuJztcbiAgICB9XG4gIH1cbiAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIGJlIHdyaXR0ZW4gYnkgd3JpdGVSdHBEZXNjcmlwdGlvbi5cbiAgc2RwICs9ICdhPXNzcmM6JyArIHRyYW5zY2VpdmVyLnNlbmRFbmNvZGluZ1BhcmFtZXRlcnNbMF0uc3NyYyArXG4gICAgICAnIGNuYW1lOicgKyBTRFBVdGlscy5sb2NhbENOYW1lICsgJ1xcclxcbic7XG4gIGlmICh0cmFuc2NlaXZlci5ydHBTZW5kZXIgJiYgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHgpIHtcbiAgICBzZHAgKz0gJ2E9c3NyYzonICsgdHJhbnNjZWl2ZXIuc2VuZEVuY29kaW5nUGFyYW1ldGVyc1swXS5ydHguc3NyYyArXG4gICAgICAgICcgY25hbWU6JyArIFNEUFV0aWxzLmxvY2FsQ05hbWUgKyAnXFxyXFxuJztcbiAgfVxuICByZXR1cm4gc2RwO1xufTtcblxuLy8gR2V0cyB0aGUgZGlyZWN0aW9uIGZyb20gdGhlIG1lZGlhU2VjdGlvbiBvciB0aGUgc2Vzc2lvbnBhcnQuXG5TRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24sIHNlc3Npb25wYXJ0KSB7XG4gIC8vIExvb2sgZm9yIHNlbmRyZWN2LCBzZW5kb25seSwgcmVjdm9ubHksIGluYWN0aXZlLCBkZWZhdWx0IHRvIHNlbmRyZWN2LlxuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKG1lZGlhU2VjdGlvbik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2ggKGxpbmVzW2ldKSB7XG4gICAgICBjYXNlICdhPXNlbmRyZWN2JzpcbiAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgY2FzZSAnYT1yZWN2b25seSc6XG4gICAgICBjYXNlICdhPWluYWN0aXZlJzpcbiAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cigyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZJWE1FOiBXaGF0IHNob3VsZCBoYXBwZW4gaGVyZT9cbiAgICB9XG4gIH1cbiAgaWYgKHNlc3Npb25wYXJ0KSB7XG4gICAgcmV0dXJuIFNEUFV0aWxzLmdldERpcmVjdGlvbihzZXNzaW9ucGFydCk7XG4gIH1cbiAgcmV0dXJuICdzZW5kcmVjdic7XG59O1xuXG5TRFBVdGlscy5nZXRLaW5kID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cigyKTtcbn07XG5cblNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIG1lZGlhU2VjdGlvbi5zcGxpdCgnICcsIDIpWzFdID09PSAnMCc7XG59O1xuXG5TRFBVdGlscy5wYXJzZU1MaW5lID0gZnVuY3Rpb24obWVkaWFTZWN0aW9uKSB7XG4gIHZhciBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgdmFyIHBhcnRzID0gbGluZXNbMF0uc3Vic3RyKDIpLnNwbGl0KCcgJyk7XG4gIHJldHVybiB7XG4gICAga2luZDogcGFydHNbMF0sXG4gICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICBwcm90b2NvbDogcGFydHNbMl0sXG4gICAgZm10OiBwYXJ0cy5zbGljZSgzKS5qb2luKCcgJylcbiAgfTtcbn07XG5cblNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbihtZWRpYVNlY3Rpb24pIHtcbiAgdmFyIGxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdvPScpWzBdO1xuICB2YXIgcGFydHMgPSBsaW5lLnN1YnN0cigyKS5zcGxpdCgnICcpO1xuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICBzZXNzaW9uSWQ6IHBhcnRzWzFdLFxuICAgIHNlc3Npb25WZXJzaW9uOiBwYXJzZUludChwYXJ0c1syXSwgMTApLFxuICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgIGFkZHJlc3NUeXBlOiBwYXJ0c1s0XSxcbiAgICBhZGRyZXNzOiBwYXJ0c1s1XVxuICB9O1xufTtcblxuLy8gYSB2ZXJ5IG5haXZlIGludGVycHJldGF0aW9uIG9mIGEgdmFsaWQgU0RQLlxuU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgaWYgKHR5cGVvZiBibG9iICE9PSAnc3RyaW5nJyB8fCBibG9iLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGluZXMgPSBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTRFBVdGlscztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/sdp/sdp.js\n")},"./node_modules/twilio-client/browser/ws.js":module=>{"use strict";eval("\nmodule.exports = WebSocket;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9icm93c2VyL3dzLmpzPzAzODAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2Jyb3dzZXIvd3MuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/browser/ws.js\n")},"./node_modules/twilio-client/browser/xmlhttprequest.js":module=>{"use strict";eval("\nmodule.exports = { XMLHttpRequest: XMLHttpRequest };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9icm93c2VyL3htbGh0dHByZXF1ZXN0LmpzPzM5OWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixrQkFBa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9icm93c2VyL3htbGh0dHByZXF1ZXN0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSB7IFhNTEh0dHBSZXF1ZXN0OiBYTUxIdHRwUmVxdWVzdCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/browser/xmlhttprequest.js\n")},"./node_modules/twilio-client/es5/twilio.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * @packageDocumentation\n * @internalapi\n */\nvar events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");\nvar connection_1 = __webpack_require__(/*! ./twilio/connection */ "./node_modules/twilio-client/es5/twilio/connection.js");\nexports.Connection = connection_1.default;\nvar device_1 = __webpack_require__(/*! ./twilio/device */ "./node_modules/twilio-client/es5/twilio/device.js");\nexports.Device = device_1.default;\nvar preflight_1 = __webpack_require__(/*! ./twilio/preflight/preflight */ "./node_modules/twilio-client/es5/twilio/preflight/preflight.js");\nexports.PreflightTest = preflight_1.PreflightTest;\nvar PStream = __webpack_require__(/*! ./twilio/pstream */ "./node_modules/twilio-client/es5/twilio/pstream.js");\nexports.PStream = PStream;\nvar instance;\nObject.defineProperty(device_1.default, \'instance\', {\n    get: function () { return instance; },\n    set: function (_instance) {\n        if (_instance === null) {\n            instance = null;\n        }\n    },\n});\ndevice_1.default.destroy = function destroySingleton() {\n    if (instance) {\n        instance.destroy();\n    }\n    bindSingleton();\n};\n/**\n * Create a new Device instance and bind its functions to the Device static. This maintains\n * backwards compatibility for the Device singleton behavior and will be removed in the next\n * breaking release.\n */\nfunction bindSingleton() {\n    instance = new device_1.default();\n    Object.getOwnPropertyNames(device_1.default.prototype)\n        .concat(Object.getOwnPropertyNames(events_1.EventEmitter.prototype))\n        .filter(function (prop) {\n        return typeof device_1.default.prototype[prop] === \'function\';\n    })\n        .filter(function (prop) { return prop !== \'destroy\'; })\n        .forEach(function (prop) {\n        device_1.default[prop] = device_1.default.prototype[prop].bind(instance);\n    });\n}\nbindSingleton();\nObject.getOwnPropertyNames(instance)\n    .filter(function (prop) { return typeof device_1.default.prototype[prop] !== \'function\'; })\n    .forEach(function (prop) {\n    Object.defineProperty(device_1.default, prop, {\n        get: function () {\n            if (instance) {\n                return instance[prop];\n            }\n        },\n        set: function (_prop) {\n            if (instance) {\n                instance[prop] = _prop;\n            }\n        },\n    });\n});\n//# sourceMappingURL=twilio.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvLmpzP2U3MzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0NBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQXFCO0FBQ2hELGtCQUFrQjtBQUNsQixlQUFlLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3hDLGNBQWM7QUFDZCxrQkFBa0IsbUJBQU8sQ0FBQyxvR0FBOEI7QUFDeEQscUJBQXFCO0FBQ3JCLGNBQWMsbUJBQU8sQ0FBQyw0RUFBa0I7QUFDeEMsZUFBZTtBQUNmO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCLEVBQUU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDLDJCQUEyQixFQUFFO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtEQUErRCxFQUFFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3R3aWxpby9jb25uZWN0aW9uXCIpO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gY29ubmVjdGlvbl8xLmRlZmF1bHQ7XG52YXIgZGV2aWNlXzEgPSByZXF1aXJlKFwiLi90d2lsaW8vZGV2aWNlXCIpO1xuZXhwb3J0cy5EZXZpY2UgPSBkZXZpY2VfMS5kZWZhdWx0O1xudmFyIHByZWZsaWdodF8xID0gcmVxdWlyZShcIi4vdHdpbGlvL3ByZWZsaWdodC9wcmVmbGlnaHRcIik7XG5leHBvcnRzLlByZWZsaWdodFRlc3QgPSBwcmVmbGlnaHRfMS5QcmVmbGlnaHRUZXN0O1xudmFyIFBTdHJlYW0gPSByZXF1aXJlKCcuL3R3aWxpby9wc3RyZWFtJyk7XG5leHBvcnRzLlBTdHJlYW0gPSBQU3RyZWFtO1xudmFyIGluc3RhbmNlO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGRldmljZV8xLmRlZmF1bHQsICdpbnN0YW5jZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGluc3RhbmNlOyB9LFxuICAgIHNldDogZnVuY3Rpb24gKF9pbnN0YW5jZSkge1xuICAgICAgICBpZiAoX2luc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG5kZXZpY2VfMS5kZWZhdWx0LmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95U2luZ2xldG9uKCkge1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIGJpbmRTaW5nbGV0b24oKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBEZXZpY2UgaW5zdGFuY2UgYW5kIGJpbmQgaXRzIGZ1bmN0aW9ucyB0byB0aGUgRGV2aWNlIHN0YXRpYy4gVGhpcyBtYWludGFpbnNcbiAqIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciB0aGUgRGV2aWNlIHNpbmdsZXRvbiBiZWhhdmlvciBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0XG4gKiBicmVha2luZyByZWxlYXNlLlxuICovXG5mdW5jdGlvbiBiaW5kU2luZ2xldG9uKCkge1xuICAgIGluc3RhbmNlID0gbmV3IGRldmljZV8xLmRlZmF1bHQoKTtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXZpY2VfMS5kZWZhdWx0LnByb3RvdHlwZSlcbiAgICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhldmVudHNfMS5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRldmljZV8xLmRlZmF1bHQucHJvdG90eXBlW3Byb3BdID09PSAnZnVuY3Rpb24nO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgIT09ICdkZXN0cm95JzsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgZGV2aWNlXzEuZGVmYXVsdFtwcm9wXSA9IGRldmljZV8xLmRlZmF1bHQucHJvdG90eXBlW3Byb3BdLmJpbmQoaW5zdGFuY2UpO1xuICAgIH0pO1xufVxuYmluZFNpbmdsZXRvbigpO1xuT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5zdGFuY2UpXG4gICAgLmZpbHRlcihmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gdHlwZW9mIGRldmljZV8xLmRlZmF1bHQucHJvdG90eXBlW3Byb3BdICE9PSAnZnVuY3Rpb24nOyB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRldmljZV8xLmRlZmF1bHQsIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9wcm9wKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtwcm9wXSA9IF9wcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10d2lsaW8uanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio.js\n')},"./node_modules/twilio-client/es5/twilio/asyncQueue.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nvar deferred_1 = __webpack_require__(/*! ./deferred */ "./node_modules/twilio-client/es5/twilio/deferred.js");\n/**\n * Queue async operations and executes them synchronously.\n */\nvar AsyncQueue = /** @class */ (function () {\n    function AsyncQueue() {\n        /**\n         * The list of async operations in this queue\n         */\n        this._operations = [];\n    }\n    /**\n     * Adds the async operation to the queue\n     * @param callback An async callback that returns a promise\n     * @returns A promise that will get resolved or rejected after executing the callback\n     */\n    AsyncQueue.prototype.enqueue = function (callback) {\n        var hasPending = !!this._operations.length;\n        var deferred = new deferred_1.default();\n        this._operations.push({ deferred: deferred, callback: callback });\n        if (!hasPending) {\n            this._processQueue();\n        }\n        return deferred.promise;\n    };\n    /**\n     * Start processing the queue. This executes the first item and removes it after.\n     * Then do the same for next items until the queue is emptied.\n     */\n    AsyncQueue.prototype._processQueue = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, deferred, callback, result, error, hasResolved, e_1;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this._operations.length) return [3 /*break*/, 5];\n                        _a = this._operations[0], deferred = _a.deferred, callback = _a.callback;\n                        result = void 0;\n                        error = void 0;\n                        hasResolved = void 0;\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, callback()];\n                    case 2:\n                        result = _b.sent();\n                        hasResolved = true;\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_1 = _b.sent();\n                        error = e_1;\n                        return [3 /*break*/, 4];\n                    case 4:\n                        // Remove the item\n                        this._operations.shift();\n                        if (hasResolved) {\n                            deferred.resolve(result);\n                        }\n                        else {\n                            deferred.reject(error);\n                        }\n                        return [3 /*break*/, 0];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return AsyncQueue;\n}());\nexports.AsyncQueue = AsyncQueue;\n//# sourceMappingURL=asyncQueue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2FzeW5jUXVldWUuanM/MzI0NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkIsMEJBQTBCLGFBQWEsRUFBRSxxQkFBcUI7QUFDeEcsZ0JBQWdCLHFEQUFxRCxvRUFBb0UsYUFBYSxFQUFFO0FBQ3hKLHNCQUFzQixzQkFBc0IscUJBQXFCLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGtDQUFrQyxTQUFTO0FBQzNDLGtDQUFrQyxXQUFXLFVBQVU7QUFDdkQseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQSw2R0FBNkcsT0FBTyxVQUFVO0FBQzlILGdGQUFnRixpQkFBaUIsT0FBTztBQUN4Ryx3REFBd0QsZ0JBQWdCLFFBQVEsT0FBTztBQUN2Riw4Q0FBOEMsZ0JBQWdCLGdCQUFnQixPQUFPO0FBQ3JGO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTLFlBQVksYUFBYSxPQUFPLEVBQUUsVUFBVSxXQUFXO0FBQ2hFLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBeUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBa0I7QUFDbEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2FzeW5jUXVldWUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBWb2ljZVxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBkZWZlcnJlZF8xID0gcmVxdWlyZShcIi4vZGVmZXJyZWRcIik7XG4vKipcbiAqIFF1ZXVlIGFzeW5jIG9wZXJhdGlvbnMgYW5kIGV4ZWN1dGVzIHRoZW0gc3luY2hyb25vdXNseS5cbiAqL1xudmFyIEFzeW5jUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXN5bmNRdWV1ZSgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIGFzeW5jIG9wZXJhdGlvbnMgaW4gdGhpcyBxdWV1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb3BlcmF0aW9ucyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBhc3luYyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEFuIGFzeW5jIGNhbGxiYWNrIHRoYXQgcmV0dXJucyBhIHByb21pc2VcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCB3aWxsIGdldCByZXNvbHZlZCBvciByZWplY3RlZCBhZnRlciBleGVjdXRpbmcgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgQXN5bmNRdWV1ZS5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgaGFzUGVuZGluZyA9ICEhdGhpcy5fb3BlcmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIHZhciBkZWZlcnJlZCA9IG5ldyBkZWZlcnJlZF8xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9ucy5wdXNoKHsgZGVmZXJyZWQ6IGRlZmVycmVkLCBjYWxsYmFjazogY2FsbGJhY2sgfSk7XG4gICAgICAgIGlmICghaGFzUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZS4gVGhpcyBleGVjdXRlcyB0aGUgZmlyc3QgaXRlbSBhbmQgcmVtb3ZlcyBpdCBhZnRlci5cbiAgICAgKiBUaGVuIGRvIHRoZSBzYW1lIGZvciBuZXh0IGl0ZW1zIHVudGlsIHRoZSBxdWV1ZSBpcyBlbXB0aWVkLlxuICAgICAqL1xuICAgIEFzeW5jUXVldWUucHJvdG90eXBlLl9wcm9jZXNzUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZGVmZXJyZWQsIGNhbGxiYWNrLCByZXN1bHQsIGVycm9yLCBoYXNSZXNvbHZlZCwgZV8xO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcGVyYXRpb25zLmxlbmd0aCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuX29wZXJhdGlvbnNbMF0sIGRlZmVycmVkID0gX2EuZGVmZXJyZWQsIGNhbGxiYWNrID0gX2EuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Jlc29sdmVkID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgY2FsbGJhY2soKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYi5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVfMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZXJhdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAwXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jUXVldWU7XG59KCkpO1xuZXhwb3J0cy5Bc3luY1F1ZXVlID0gQXN5bmNRdWV1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jUXVldWUuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/asyncQueue.js\n')},"./node_modules/twilio-client/es5/twilio/audiohelper.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n */\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar log_1 = __webpack_require__(/*! ./log */ \"./node_modules/twilio-client/es5/twilio/log.js\");\nvar outputdevicecollection_1 = __webpack_require__(/*! ./outputdevicecollection */ \"./node_modules/twilio-client/es5/twilio/outputdevicecollection.js\");\nvar defaultMediaDevices = __webpack_require__(/*! ./shims/mediadevices */ \"./node_modules/twilio-client/es5/twilio/shims/mediadevices.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\nvar MediaDeviceInfoShim = __webpack_require__(/*! ./shims/mediadeviceinfo */ \"./node_modules/twilio-client/es5/twilio/shims/mediadeviceinfo.js\");\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\nvar kindAliases = {\n    audioinput: 'Audio Input',\n    audiooutput: 'Audio Output',\n};\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\nvar AudioHelper = /** @class */ (function (_super) {\n    __extends(AudioHelper, _super);\n    /**\n     * @constructor\n     * @private\n     * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n     * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n     * @param getUserMedia - The getUserMedia method to use.\n     * @param [options]\n     */\n    function AudioHelper(onActiveOutputsChanged, onActiveInputChanged, getUserMedia, options) {\n        var _this = _super.call(this) || this;\n        /**\n         * A Map of all audio input devices currently available to the browser by their device ID.\n         */\n        _this.availableInputDevices = new Map();\n        /**\n         * A Map of all audio output devices currently available to the browser by their device ID.\n         */\n        _this.availableOutputDevices = new Map();\n        /**\n         * The currently set audio constraints set by setAudioConstraints().\n         */\n        _this._audioConstraints = null;\n        /**\n         * The current input device.\n         */\n        _this._inputDevice = null;\n        /**\n         * The current input stream.\n         */\n        _this._inputStream = null;\n        /**\n         * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n         */\n        _this._isPollingInputVolume = false;\n        /**\n         * An instance of Logger to use.\n         */\n        _this._log = log_1.default.getInstance();\n        /**\n         * A record of unknown devices (Devices without labels)\n         */\n        _this._unknownDeviceIndexes = {\n            audioinput: {},\n            audiooutput: {},\n        };\n        /**\n         * Remove an input device from inputs\n         * @param lostDevice\n         * @returns Whether the device was active\n         */\n        _this._removeLostInput = function (lostDevice) {\n            if (!_this.inputDevice || _this.inputDevice.deviceId !== lostDevice.deviceId) {\n                return false;\n            }\n            _this._replaceStream(null);\n            _this._inputDevice = null;\n            _this._maybeStopPollingVolume();\n            var defaultDevice = _this.availableInputDevices.get('default')\n                || Array.from(_this.availableInputDevices.values())[0];\n            if (defaultDevice) {\n                _this.setInputDevice(defaultDevice.deviceId);\n            }\n            return true;\n        };\n        /**\n         * Remove an input device from outputs\n         * @param lostDevice\n         * @returns Whether the device was active\n         */\n        _this._removeLostOutput = function (lostDevice) {\n            var wasSpeakerLost = _this.speakerDevices.delete(lostDevice);\n            var wasRingtoneLost = _this.ringtoneDevices.delete(lostDevice);\n            return wasSpeakerLost || wasRingtoneLost;\n        };\n        /**\n         * Update the available input and output devices\n         */\n        _this._updateAvailableDevices = function () {\n            if (!_this._mediaDevices) {\n                return Promise.reject('Enumeration not supported');\n            }\n            return _this._mediaDevices.enumerateDevices().then(function (devices) {\n                _this._updateDevices(devices.filter(function (d) { return d.kind === 'audiooutput'; }), _this.availableOutputDevices, _this._removeLostOutput);\n                _this._updateDevices(devices.filter(function (d) { return d.kind === 'audioinput'; }), _this.availableInputDevices, _this._removeLostInput);\n                var defaultDevice = _this.availableOutputDevices.get('default')\n                    || Array.from(_this.availableOutputDevices.values())[0];\n                [_this.speakerDevices, _this.ringtoneDevices].forEach(function (outputDevices) {\n                    if (!outputDevices.get().size && _this.availableOutputDevices.size && _this.isOutputSelectionSupported) {\n                        outputDevices.set(defaultDevice.deviceId)\n                            .catch(function (reason) {\n                            _this._log.warn(\"Unable to set audio output devices. \" + reason);\n                        });\n                    }\n                });\n            });\n        };\n        options = Object.assign({\n            AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n            setSinkId: typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId,\n        }, options);\n        _this._getUserMedia = getUserMedia;\n        _this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n        _this._onActiveInputChanged = onActiveInputChanged;\n        var isAudioContextSupported = !!(options.AudioContext || options.audioContext);\n        var isEnumerationSupported = !!(_this._mediaDevices && _this._mediaDevices.enumerateDevices);\n        var isSetSinkSupported = typeof options.setSinkId === 'function';\n        _this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n        _this.isVolumeSupported = isAudioContextSupported;\n        if (options.enabledSounds) {\n            _this._addEnabledSounds(options.enabledSounds);\n        }\n        if (_this.isVolumeSupported) {\n            _this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n            if (_this._audioContext) {\n                _this._inputVolumeAnalyser = _this._audioContext.createAnalyser();\n                _this._inputVolumeAnalyser.fftSize = 32;\n                _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n            }\n        }\n        _this.ringtoneDevices = new outputdevicecollection_1.default('ringtone', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n        _this.speakerDevices = new outputdevicecollection_1.default('speaker', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n        _this.addListener('newListener', function (eventName) {\n            if (eventName === 'inputVolume') {\n                _this._maybeStartPollingVolume();\n            }\n        });\n        _this.addListener('removeListener', function (eventName) {\n            if (eventName === 'inputVolume') {\n                _this._maybeStopPollingVolume();\n            }\n        });\n        _this.once('newListener', function () {\n            // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n            //   in at least one browser version (Tested in FF48) enumerateDevices actually\n            //   returns bad data for the listed devices. Instead, we check for\n            //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n            if (!_this.isOutputSelectionSupported) {\n                _this._log.warn('Warning: This browser does not support audio output selection.');\n            }\n            if (!_this.isVolumeSupported) {\n                _this._log.warn(\"Warning: This browser does not support Twilio's volume indicator feature.\");\n            }\n        });\n        if (isEnumerationSupported) {\n            _this._initializeEnumeration();\n        }\n        return _this;\n    }\n    Object.defineProperty(AudioHelper.prototype, \"audioConstraints\", {\n        /**\n         * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n         */\n        get: function () { return this._audioConstraints; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AudioHelper.prototype, \"inputDevice\", {\n        /**\n         * The active input device. Having no inputDevice specified by `setInputDevice()`\n         * will disable input selection related functionality.\n         */\n        get: function () { return this._inputDevice; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AudioHelper.prototype, \"inputStream\", {\n        /**\n         * The current input stream.\n         */\n        get: function () { return this._inputStream; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Start polling volume if it's supported and there's an input stream to poll.\n     * @private\n     */\n    AudioHelper.prototype._maybeStartPollingVolume = function () {\n        var _this = this;\n        if (!this.isVolumeSupported || !this._inputStream) {\n            return;\n        }\n        this._updateVolumeSource();\n        if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {\n            return;\n        }\n        var bufferLength = this._inputVolumeAnalyser.frequencyBinCount;\n        var buffer = new Uint8Array(bufferLength);\n        this._isPollingInputVolume = true;\n        var emitVolume = function () {\n            if (!_this._isPollingInputVolume) {\n                return;\n            }\n            if (_this._inputVolumeAnalyser) {\n                _this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n                var inputVolume = util_1.average(buffer);\n                _this.emit('inputVolume', inputVolume / 255);\n            }\n            requestAnimationFrame(emitVolume);\n        };\n        requestAnimationFrame(emitVolume);\n    };\n    /**\n     * Stop polling volume if it's currently polling and there are no listeners.\n     * @private\n     */\n    AudioHelper.prototype._maybeStopPollingVolume = function () {\n        if (!this.isVolumeSupported) {\n            return;\n        }\n        if (!this._isPollingInputVolume || (this._inputStream && this.listenerCount('inputVolume'))) {\n            return;\n        }\n        if (this._inputVolumeSource) {\n            this._inputVolumeSource.disconnect();\n            delete this._inputVolumeSource;\n        }\n        this._isPollingInputVolume = false;\n    };\n    /**\n     * Unbind the listeners from mediaDevices.\n     * @private\n     */\n    AudioHelper.prototype._unbind = function () {\n        if (!this._mediaDevices) {\n            throw new errors_1.NotSupportedError('Enumeration is not supported');\n        }\n        if (this._mediaDevices.removeEventListener) {\n            this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n            this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n        }\n    };\n    /**\n     * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n     * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n     * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n     * when the media is successfully reacquired, or immediately if no input device is set.\n     * @param audioConstraints - The MediaTrackConstraints to apply.\n     */\n    AudioHelper.prototype.setAudioConstraints = function (audioConstraints) {\n        this._audioConstraints = Object.assign({}, audioConstraints);\n        delete this._audioConstraints.deviceId;\n        return this.inputDevice\n            ? this._setInputDevice(this.inputDevice.deviceId, true)\n            : Promise.resolve();\n    };\n    /**\n     * Replace the current input device with a new device by ID.\n     * @param deviceId - An ID of a device to replace the existing\n     *   input device with.\n     */\n    AudioHelper.prototype.setInputDevice = function (deviceId) {\n        return !util_1.isFirefox()\n            ? this._setInputDevice(deviceId, false)\n            : Promise.reject(new errors_1.NotSupportedError('Firefox does not currently support opening multiple ' +\n                'audio input tracks simultaneously, even across different tabs. As a result, ' +\n                'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' +\n                'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n    };\n    /**\n     * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n     * device audio. The returned Promise resolves when the media is successfully reacquired,\n     * or immediately if no input device is set.\n     */\n    AudioHelper.prototype.unsetAudioConstraints = function () {\n        this._audioConstraints = null;\n        return this.inputDevice\n            ? this._setInputDevice(this.inputDevice.deviceId, true)\n            : Promise.resolve();\n    };\n    /**\n     * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n     *   will not allow removal of the input device during a live call.\n     */\n    AudioHelper.prototype.unsetInputDevice = function () {\n        var _this = this;\n        if (!this.inputDevice) {\n            return Promise.resolve();\n        }\n        return this._onActiveInputChanged(null).then(function () {\n            _this._replaceStream(null);\n            _this._inputDevice = null;\n            _this._maybeStopPollingVolume();\n        });\n    };\n    /**\n     * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n     *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n     *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n     * @param enabledSounds - The initial sound settings to merge.\n     * @private\n     */\n    AudioHelper.prototype._addEnabledSounds = function (enabledSounds) {\n        var _this = this;\n        function setValue(key, value) {\n            if (typeof value !== 'undefined') {\n                enabledSounds[key] = value;\n            }\n            return enabledSounds[key];\n        }\n        Object.keys(enabledSounds).forEach(function (key) {\n            _this[key] = setValue.bind(null, key);\n        });\n    };\n    /**\n     * Get the index of an un-labeled Device.\n     * @param mediaDeviceInfo\n     * @returns The index of the passed MediaDeviceInfo\n     */\n    AudioHelper.prototype._getUnknownDeviceIndex = function (mediaDeviceInfo) {\n        var id = mediaDeviceInfo.deviceId;\n        var kind = mediaDeviceInfo.kind;\n        var index = this._unknownDeviceIndexes[kind][id];\n        if (!index) {\n            index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n            this._unknownDeviceIndexes[kind][id] = index;\n        }\n        return index;\n    };\n    /**\n     * Initialize output device enumeration.\n     */\n    AudioHelper.prototype._initializeEnumeration = function () {\n        var _this = this;\n        if (!this._mediaDevices) {\n            throw new errors_1.NotSupportedError('Enumeration is not supported');\n        }\n        if (this._mediaDevices.addEventListener) {\n            this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n            this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n        }\n        this._updateAvailableDevices().then(function () {\n            if (!_this.isOutputSelectionSupported) {\n                return;\n            }\n            Promise.all([\n                _this.speakerDevices.set('default'),\n                _this.ringtoneDevices.set('default'),\n            ]).catch(function (reason) {\n                _this._log.warn(\"Warning: Unable to set audio output devices. \" + reason);\n            });\n        });\n    };\n    /**\n     * Stop the tracks on the current input stream before replacing it with the passed stream.\n     * @param stream - The new stream\n     */\n    AudioHelper.prototype._replaceStream = function (stream) {\n        if (this._inputStream) {\n            this._inputStream.getTracks().forEach(function (track) {\n                track.stop();\n            });\n        }\n        this._inputStream = stream;\n    };\n    /**\n     * Replace the current input device with a new device by ID.\n     * @param deviceId - An ID of a device to replace the existing\n     *   input device with.\n     * @param forceGetUserMedia - If true, getUserMedia will be called even if\n     *   the specified device is already active.\n     */\n    AudioHelper.prototype._setInputDevice = function (deviceId, forceGetUserMedia) {\n        var _this = this;\n        if (typeof deviceId !== 'string') {\n            return Promise.reject(new errors_1.InvalidArgumentError('Must specify the device to set'));\n        }\n        var device = this.availableInputDevices.get(deviceId);\n        if (!device) {\n            return Promise.reject(new errors_1.InvalidArgumentError(\"Device not found: \" + deviceId));\n        }\n        if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n            if (!forceGetUserMedia) {\n                return Promise.resolve();\n            }\n            // If the currently active track is still in readyState `live`, gUM may return the same track\n            // rather than returning a fresh track.\n            this._inputStream.getTracks().forEach(function (track) {\n                track.stop();\n            });\n        }\n        var constraints = { audio: Object.assign({ deviceId: { exact: deviceId } }, this.audioConstraints) };\n        return this._getUserMedia(constraints).then(function (stream) {\n            return _this._onActiveInputChanged(stream).then(function () {\n                _this._replaceStream(stream);\n                _this._inputDevice = device;\n                _this._maybeStartPollingVolume();\n            });\n        });\n    };\n    /**\n     * Update a set of devices.\n     * @param updatedDevices - An updated list of available Devices\n     * @param availableDevices - The previous list of available Devices\n     * @param removeLostDevice - The method to call if a previously available Device is\n     *   no longer available.\n     */\n    AudioHelper.prototype._updateDevices = function (updatedDevices, availableDevices, removeLostDevice) {\n        var _this = this;\n        var updatedDeviceIds = updatedDevices.map(function (d) { return d.deviceId; });\n        var knownDeviceIds = Array.from(availableDevices.values()).map(function (d) { return d.deviceId; });\n        var lostActiveDevices = [];\n        // Remove lost devices\n        var lostDeviceIds = util_1.difference(knownDeviceIds, updatedDeviceIds);\n        lostDeviceIds.forEach(function (lostDeviceId) {\n            var lostDevice = availableDevices.get(lostDeviceId);\n            if (lostDevice) {\n                availableDevices.delete(lostDeviceId);\n                if (removeLostDevice(lostDevice)) {\n                    lostActiveDevices.push(lostDevice);\n                }\n            }\n        });\n        // Add any new devices, or devices with updated labels\n        var deviceChanged = false;\n        updatedDevices.forEach(function (newDevice) {\n            var existingDevice = availableDevices.get(newDevice.deviceId);\n            var newMediaDeviceInfo = _this._wrapMediaDeviceInfo(newDevice);\n            if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n                availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n                deviceChanged = true;\n            }\n        });\n        if (deviceChanged || lostDeviceIds.length) {\n            // Force a new gUM in case the underlying tracks of the active stream have changed. One\n            //   reason this might happen is when `default` is selected and set to a USB device,\n            //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n            //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n            //   in my testing. (rrowland)\n            if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n                this._log.warn(\"Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.\");\n                this._setInputDevice(this.inputDevice.deviceId, true);\n            }\n            this.emit('deviceChange', lostActiveDevices);\n        }\n    };\n    /**\n     * Disconnect the old input volume source, and create and connect a new one with the current\n     * input stream.\n     */\n    AudioHelper.prototype._updateVolumeSource = function () {\n        if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n            return;\n        }\n        if (this._inputVolumeSource) {\n            this._inputVolumeSource.disconnect();\n        }\n        this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n        this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n    };\n    /**\n     * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n     * @param mediaDeviceInfo - The info to convert\n     * @returns The converted shim\n     */\n    AudioHelper.prototype._wrapMediaDeviceInfo = function (mediaDeviceInfo) {\n        var options = {\n            deviceId: mediaDeviceInfo.deviceId,\n            groupId: mediaDeviceInfo.groupId,\n            kind: mediaDeviceInfo.kind,\n            label: mediaDeviceInfo.label,\n        };\n        if (!options.label) {\n            if (options.deviceId === 'default') {\n                options.label = 'Default';\n            }\n            else {\n                var index = this._getUnknownDeviceIndex(mediaDeviceInfo);\n                options.label = \"Unknown \" + kindAliases[options.kind] + \" Device \" + index;\n            }\n        }\n        return new MediaDeviceInfoShim(options);\n    };\n    return AudioHelper;\n}(events_1.EventEmitter));\n(function (AudioHelper) {\n})(AudioHelper || (AudioHelper = {}));\nexports.default = AudioHelper;\n//# sourceMappingURL=audiohelper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2F1ZGlvaGVscGVyLmpzPzEyYWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0NBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHlFQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw2REFBTztBQUMzQiwrQkFBK0IsbUJBQU8sQ0FBQyxtR0FBMEI7QUFDakUsMEJBQTBCLG1CQUFPLENBQUMsMkZBQXNCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQywrREFBUTtBQUM3QiwwQkFBMEIsbUJBQU8sQ0FBQyxpR0FBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQ0FBaUMsRUFBRTtBQUNyRyxrRUFBa0UsZ0NBQWdDLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtCQUErQixFQUFFO0FBQzNEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEIsRUFBRTtBQUN0RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQixFQUFFO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEMsa0JBQWtCO0FBQzlELDRDQUE0QyxrQkFBa0I7QUFDOUQsOENBQThDLGFBQWEsTUFBTSxrQkFBa0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwyQkFBMkIsdUJBQXVCLFlBQVksa0JBQWtCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsbUJBQW1CLEVBQUU7QUFDckYscUZBQXFGLG1CQUFtQixFQUFFO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsa0NBQWtDO0FBQ25DLGVBQWU7QUFDZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vYXVkaW9oZWxwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgVm9pY2VcbiAqL1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciBvdXRwdXRkZXZpY2Vjb2xsZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9vdXRwdXRkZXZpY2Vjb2xsZWN0aW9uXCIpO1xudmFyIGRlZmF1bHRNZWRpYURldmljZXMgPSByZXF1aXJlKFwiLi9zaGltcy9tZWRpYWRldmljZXNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBNZWRpYURldmljZUluZm9TaGltID0gcmVxdWlyZSgnLi9zaGltcy9tZWRpYWRldmljZWluZm8nKTtcbi8qKlxuICogQWxpYXNlcyBmb3IgYXVkaW8ga2luZHMsIHVzZWQgZm9yIGxhYmVsbGluZy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBraW5kQWxpYXNlcyA9IHtcbiAgICBhdWRpb2lucHV0OiAnQXVkaW8gSW5wdXQnLFxuICAgIGF1ZGlvb3V0cHV0OiAnQXVkaW8gT3V0cHV0Jyxcbn07XG4vKipcbiAqIFByb3ZpZGVzIGlucHV0IGFuZCBvdXRwdXQgYXVkaW8tYmFzZWQgZnVuY3Rpb25hbGl0eSBpbiBvbmUgY29udmVuaWVudCBjbGFzcy5cbiAqIEBwdWJsaWNhcGlcbiAqL1xudmFyIEF1ZGlvSGVscGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBdWRpb0hlbHBlciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBvbkFjdGl2ZU91dHB1dHNDaGFuZ2VkIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBhY3RpdmUgb3V0cHV0IGRldmljZXMuXG4gICAgICogQHBhcmFtIG9uQWN0aXZlSW5wdXRDaGFuZ2VkIC0gQSBjYWxsYmFjayB0byBiZSBjYWxsZWQgd2hlbiB0aGUgdXNlciBjaGFuZ2VzIHRoZSBhY3RpdmUgaW5wdXQgZGV2aWNlLlxuICAgICAqIEBwYXJhbSBnZXRVc2VyTWVkaWEgLSBUaGUgZ2V0VXNlck1lZGlhIG1ldGhvZCB0byB1c2UuXG4gICAgICogQHBhcmFtIFtvcHRpb25zXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1ZGlvSGVscGVyKG9uQWN0aXZlT3V0cHV0c0NoYW5nZWQsIG9uQWN0aXZlSW5wdXRDaGFuZ2VkLCBnZXRVc2VyTWVkaWEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTWFwIG9mIGFsbCBhdWRpbyBpbnB1dCBkZXZpY2VzIGN1cnJlbnRseSBhdmFpbGFibGUgdG8gdGhlIGJyb3dzZXIgYnkgdGhlaXIgZGV2aWNlIElELlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXZhaWxhYmxlSW5wdXREZXZpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBNYXAgb2YgYWxsIGF1ZGlvIG91dHB1dCBkZXZpY2VzIGN1cnJlbnRseSBhdmFpbGFibGUgdG8gdGhlIGJyb3dzZXIgYnkgdGhlaXIgZGV2aWNlIElELlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXZhaWxhYmxlT3V0cHV0RGV2aWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgc2V0IGF1ZGlvIGNvbnN0cmFpbnRzIHNldCBieSBzZXRBdWRpb0NvbnN0cmFpbnRzKCkuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fYXVkaW9Db25zdHJhaW50cyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBpbnB1dCBkZXZpY2UuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faW5wdXREZXZpY2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2lucHV0U3RyZWFtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHtAbGluayBBdWRpb0hlbHBlcn0gaXMgY3VycmVudGx5IHBvbGxpbmcgdGhlIGlucHV0IHN0cmVhbSdzIHZvbHVtZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9pc1BvbGxpbmdJbnB1dFZvbHVtZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5zdGFuY2Ugb2YgTG9nZ2VyIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sb2cgPSBsb2dfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlY29yZCBvZiB1bmtub3duIGRldmljZXMgKERldmljZXMgd2l0aG91dCBsYWJlbHMpXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdW5rbm93bkRldmljZUluZGV4ZXMgPSB7XG4gICAgICAgICAgICBhdWRpb2lucHV0OiB7fSxcbiAgICAgICAgICAgIGF1ZGlvb3V0cHV0OiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBpbnB1dCBkZXZpY2UgZnJvbSBpbnB1dHNcbiAgICAgICAgICogQHBhcmFtIGxvc3REZXZpY2VcbiAgICAgICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZGV2aWNlIHdhcyBhY3RpdmVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9yZW1vdmVMb3N0SW5wdXQgPSBmdW5jdGlvbiAobG9zdERldmljZSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pbnB1dERldmljZSB8fCBfdGhpcy5pbnB1dERldmljZS5kZXZpY2VJZCAhPT0gbG9zdERldmljZS5kZXZpY2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9yZXBsYWNlU3RyZWFtKG51bGwpO1xuICAgICAgICAgICAgX3RoaXMuX2lucHV0RGV2aWNlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLl9tYXliZVN0b3BQb2xsaW5nVm9sdW1lKCk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdERldmljZSA9IF90aGlzLmF2YWlsYWJsZUlucHV0RGV2aWNlcy5nZXQoJ2RlZmF1bHQnKVxuICAgICAgICAgICAgICAgIHx8IEFycmF5LmZyb20oX3RoaXMuYXZhaWxhYmxlSW5wdXREZXZpY2VzLnZhbHVlcygpKVswXTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RGV2aWNlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5wdXREZXZpY2UoZGVmYXVsdERldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSBhbiBpbnB1dCBkZXZpY2UgZnJvbSBvdXRwdXRzXG4gICAgICAgICAqIEBwYXJhbSBsb3N0RGV2aWNlXG4gICAgICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGRldmljZSB3YXMgYWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcmVtb3ZlTG9zdE91dHB1dCA9IGZ1bmN0aW9uIChsb3N0RGV2aWNlKSB7XG4gICAgICAgICAgICB2YXIgd2FzU3BlYWtlckxvc3QgPSBfdGhpcy5zcGVha2VyRGV2aWNlcy5kZWxldGUobG9zdERldmljZSk7XG4gICAgICAgICAgICB2YXIgd2FzUmluZ3RvbmVMb3N0ID0gX3RoaXMucmluZ3RvbmVEZXZpY2VzLmRlbGV0ZShsb3N0RGV2aWNlKTtcbiAgICAgICAgICAgIHJldHVybiB3YXNTcGVha2VyTG9zdCB8fCB3YXNSaW5ndG9uZUxvc3Q7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0IGRldmljZXNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl91cGRhdGVBdmFpbGFibGVEZXZpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fbWVkaWFEZXZpY2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCdFbnVtZXJhdGlvbiBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX21lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoZGV2aWNlcykge1xuICAgICAgICAgICAgICAgIF90aGlzLl91cGRhdGVEZXZpY2VzKGRldmljZXMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmtpbmQgPT09ICdhdWRpb291dHB1dCc7IH0pLCBfdGhpcy5hdmFpbGFibGVPdXRwdXREZXZpY2VzLCBfdGhpcy5fcmVtb3ZlTG9zdE91dHB1dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZURldmljZXMoZGV2aWNlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQua2luZCA9PT0gJ2F1ZGlvaW5wdXQnOyB9KSwgX3RoaXMuYXZhaWxhYmxlSW5wdXREZXZpY2VzLCBfdGhpcy5fcmVtb3ZlTG9zdElucHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdERldmljZSA9IF90aGlzLmF2YWlsYWJsZU91dHB1dERldmljZXMuZ2V0KCdkZWZhdWx0JylcbiAgICAgICAgICAgICAgICAgICAgfHwgQXJyYXkuZnJvbShfdGhpcy5hdmFpbGFibGVPdXRwdXREZXZpY2VzLnZhbHVlcygpKVswXTtcbiAgICAgICAgICAgICAgICBbX3RoaXMuc3BlYWtlckRldmljZXMsIF90aGlzLnJpbmd0b25lRGV2aWNlc10uZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0RGV2aWNlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW91dHB1dERldmljZXMuZ2V0KCkuc2l6ZSAmJiBfdGhpcy5hdmFpbGFibGVPdXRwdXREZXZpY2VzLnNpemUgJiYgX3RoaXMuaXNPdXRwdXRTZWxlY3Rpb25TdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dERldmljZXMuc2V0KGRlZmF1bHREZXZpY2UuZGV2aWNlSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oXCJVbmFibGUgdG8gc2V0IGF1ZGlvIG91dHB1dCBkZXZpY2VzLiBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEF1ZGlvQ29udGV4dDogdHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcgJiYgQXVkaW9Db250ZXh0LFxuICAgICAgICAgICAgc2V0U2lua0lkOiB0eXBlb2YgSFRNTEF1ZGlvRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgSFRNTEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2V0U2lua0lkLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuX2dldFVzZXJNZWRpYSA9IGdldFVzZXJNZWRpYTtcbiAgICAgICAgX3RoaXMuX21lZGlhRGV2aWNlcyA9IG9wdGlvbnMubWVkaWFEZXZpY2VzIHx8IGRlZmF1bHRNZWRpYURldmljZXM7XG4gICAgICAgIF90aGlzLl9vbkFjdGl2ZUlucHV0Q2hhbmdlZCA9IG9uQWN0aXZlSW5wdXRDaGFuZ2VkO1xuICAgICAgICB2YXIgaXNBdWRpb0NvbnRleHRTdXBwb3J0ZWQgPSAhIShvcHRpb25zLkF1ZGlvQ29udGV4dCB8fCBvcHRpb25zLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgIHZhciBpc0VudW1lcmF0aW9uU3VwcG9ydGVkID0gISEoX3RoaXMuX21lZGlhRGV2aWNlcyAmJiBfdGhpcy5fbWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xuICAgICAgICB2YXIgaXNTZXRTaW5rU3VwcG9ydGVkID0gdHlwZW9mIG9wdGlvbnMuc2V0U2lua0lkID09PSAnZnVuY3Rpb24nO1xuICAgICAgICBfdGhpcy5pc091dHB1dFNlbGVjdGlvblN1cHBvcnRlZCA9IGlzRW51bWVyYXRpb25TdXBwb3J0ZWQgJiYgaXNTZXRTaW5rU3VwcG9ydGVkO1xuICAgICAgICBfdGhpcy5pc1ZvbHVtZVN1cHBvcnRlZCA9IGlzQXVkaW9Db250ZXh0U3VwcG9ydGVkO1xuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVkU291bmRzKSB7XG4gICAgICAgICAgICBfdGhpcy5fYWRkRW5hYmxlZFNvdW5kcyhvcHRpb25zLmVuYWJsZWRTb3VuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5pc1ZvbHVtZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgX3RoaXMuX2F1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IG9wdGlvbnMuQXVkaW9Db250ZXh0ICYmIG5ldyBvcHRpb25zLkF1ZGlvQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9hdWRpb0NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5wdXRWb2x1bWVBbmFseXNlciA9IF90aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5wdXRWb2x1bWVBbmFseXNlci5mZnRTaXplID0gMzI7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0Vm9sdW1lQW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gMC4zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLnJpbmd0b25lRGV2aWNlcyA9IG5ldyBvdXRwdXRkZXZpY2Vjb2xsZWN0aW9uXzEuZGVmYXVsdCgncmluZ3RvbmUnLCBfdGhpcy5hdmFpbGFibGVPdXRwdXREZXZpY2VzLCBvbkFjdGl2ZU91dHB1dHNDaGFuZ2VkLCBfdGhpcy5pc091dHB1dFNlbGVjdGlvblN1cHBvcnRlZCk7XG4gICAgICAgIF90aGlzLnNwZWFrZXJEZXZpY2VzID0gbmV3IG91dHB1dGRldmljZWNvbGxlY3Rpb25fMS5kZWZhdWx0KCdzcGVha2VyJywgX3RoaXMuYXZhaWxhYmxlT3V0cHV0RGV2aWNlcywgb25BY3RpdmVPdXRwdXRzQ2hhbmdlZCwgX3RoaXMuaXNPdXRwdXRTZWxlY3Rpb25TdXBwb3J0ZWQpO1xuICAgICAgICBfdGhpcy5hZGRMaXN0ZW5lcignbmV3TGlzdGVuZXInLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnaW5wdXRWb2x1bWUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21heWJlU3RhcnRQb2xsaW5nVm9sdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5hZGRMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnaW5wdXRWb2x1bWUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21heWJlU3RvcFBvbGxpbmdWb2x1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uY2UoJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTk9URSAocnJvd2xhbmQpOiBJZGVhbGx5IHdlIHdvdWxkIG9ubHkgY2hlY2sgaXNFbnVtZXJhdGlvblN1cHBvcnRlZCBoZXJlLCBidXRcbiAgICAgICAgICAgIC8vICAgaW4gYXQgbGVhc3Qgb25lIGJyb3dzZXIgdmVyc2lvbiAoVGVzdGVkIGluIEZGNDgpIGVudW1lcmF0ZURldmljZXMgYWN0dWFsbHlcbiAgICAgICAgICAgIC8vICAgcmV0dXJucyBiYWQgZGF0YSBmb3IgdGhlIGxpc3RlZCBkZXZpY2VzLiBJbnN0ZWFkLCB3ZSBjaGVjayBmb3JcbiAgICAgICAgICAgIC8vICAgaXNPdXRwdXRTZWxlY3Rpb25TdXBwb3J0ZWQgdG8gYXZvaWQgdGhlc2UgcXVpcmtzIHRoYXQgbWF5IG5lZ2F0aXZlbHkgYWZmZWN0IGN1c3RvbWVycy5cbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNPdXRwdXRTZWxlY3Rpb25TdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ1dhcm5pbmc6IFRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGF1ZGlvIG91dHB1dCBzZWxlY3Rpb24uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzVm9sdW1lU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKFwiV2FybmluZzogVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgVHdpbGlvJ3Mgdm9sdW1lIGluZGljYXRvciBmZWF0dXJlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0VudW1lcmF0aW9uU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBfdGhpcy5faW5pdGlhbGl6ZUVudW1lcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQXVkaW9IZWxwZXIucHJvdG90eXBlLCBcImF1ZGlvQ29uc3RyYWludHNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBzZXQgYXVkaW8gY29uc3RyYWludHMgc2V0IGJ5IHNldEF1ZGlvQ29uc3RyYWludHMoKS4gU3RhcnRzIGFzIG51bGwuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2F1ZGlvQ29uc3RyYWludHM7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBdWRpb0hlbHBlci5wcm90b3R5cGUsIFwiaW5wdXREZXZpY2VcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFjdGl2ZSBpbnB1dCBkZXZpY2UuIEhhdmluZyBubyBpbnB1dERldmljZSBzcGVjaWZpZWQgYnkgYHNldElucHV0RGV2aWNlKClgXG4gICAgICAgICAqIHdpbGwgZGlzYWJsZSBpbnB1dCBzZWxlY3Rpb24gcmVsYXRlZCBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pbnB1dERldmljZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEF1ZGlvSGVscGVyLnByb3RvdHlwZSwgXCJpbnB1dFN0cmVhbVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBpbnB1dCBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2lucHV0U3RyZWFtOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIHZvbHVtZSBpZiBpdCdzIHN1cHBvcnRlZCBhbmQgdGhlcmUncyBhbiBpbnB1dCBzdHJlYW0gdG8gcG9sbC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fbWF5YmVTdGFydFBvbGxpbmdWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pc1ZvbHVtZVN1cHBvcnRlZCB8fCAhdGhpcy5faW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVWb2x1bWVTb3VyY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzUG9sbGluZ0lucHV0Vm9sdW1lIHx8ICF0aGlzLl9pbnB1dFZvbHVtZUFuYWx5c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlckxlbmd0aCA9IHRoaXMuX2lucHV0Vm9sdW1lQW5hbHlzZXIuZnJlcXVlbmN5QmluQ291bnQ7XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgICB0aGlzLl9pc1BvbGxpbmdJbnB1dFZvbHVtZSA9IHRydWU7XG4gICAgICAgIHZhciBlbWl0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNQb2xsaW5nSW5wdXRWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2lucHV0Vm9sdW1lQW5hbHlzZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5wdXRWb2x1bWVBbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YShidWZmZXIpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dFZvbHVtZSA9IHV0aWxfMS5hdmVyYWdlKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnaW5wdXRWb2x1bWUnLCBpbnB1dFZvbHVtZSAvIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZW1pdFZvbHVtZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShlbWl0Vm9sdW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZyB2b2x1bWUgaWYgaXQncyBjdXJyZW50bHkgcG9sbGluZyBhbmQgdGhlcmUgYXJlIG5vIGxpc3RlbmVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fbWF5YmVTdG9wUG9sbGluZ1ZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVm9sdW1lU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1BvbGxpbmdJbnB1dFZvbHVtZSB8fCAodGhpcy5faW5wdXRTdHJlYW0gJiYgdGhpcy5saXN0ZW5lckNvdW50KCdpbnB1dFZvbHVtZScpKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFZvbHVtZVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRWb2x1bWVTb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2lucHV0Vm9sdW1lU291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzUG9sbGluZ0lucHV0Vm9sdW1lID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbmJpbmQgdGhlIGxpc3RlbmVycyBmcm9tIG1lZGlhRGV2aWNlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fdW5iaW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuX21lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdFN1cHBvcnRlZEVycm9yKCdFbnVtZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX21lZGlhRGV2aWNlcy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5fdXBkYXRlQXZhaWxhYmxlRGV2aWNlcyk7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYURldmljZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlaW5mb2NoYW5nZScsIHRoaXMuX3VwZGF0ZUF2YWlsYWJsZURldmljZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0byBiZSBhcHBsaWVkIG9uIGV2ZXJ5IGdldFVzZXJNZWRpYSBjYWxsIGZvciBuZXcgaW5wdXRcbiAgICAgKiBkZXZpY2UgYXVkaW8uIEFueSBkZXZpY2VJZCBzcGVjaWZpZWQgaGVyZSB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRldmljZSBJRHMgc2hvdWxkXG4gICAgICogYmUgc3BlY2lmaWVkIHVzaW5nIHtAbGluayBBdWRpb0hlbHBlciNzZXRJbnB1dERldmljZX0uIFRoZSByZXR1cm5lZCBQcm9taXNlIHJlc29sdmVzXG4gICAgICogd2hlbiB0aGUgbWVkaWEgaXMgc3VjY2Vzc2Z1bGx5IHJlYWNxdWlyZWQsIG9yIGltbWVkaWF0ZWx5IGlmIG5vIGlucHV0IGRldmljZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIGF1ZGlvQ29uc3RyYWludHMgLSBUaGUgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5zZXRBdWRpb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGF1ZGlvQ29uc3RyYWludHMpIHtcbiAgICAgICAgdGhpcy5fYXVkaW9Db25zdHJhaW50cyA9IE9iamVjdC5hc3NpZ24oe30sIGF1ZGlvQ29uc3RyYWludHMpO1xuICAgICAgICBkZWxldGUgdGhpcy5fYXVkaW9Db25zdHJhaW50cy5kZXZpY2VJZDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXREZXZpY2VcbiAgICAgICAgICAgID8gdGhpcy5fc2V0SW5wdXREZXZpY2UodGhpcy5pbnB1dERldmljZS5kZXZpY2VJZCwgdHJ1ZSlcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBjdXJyZW50IGlucHV0IGRldmljZSB3aXRoIGEgbmV3IGRldmljZSBieSBJRC5cbiAgICAgKiBAcGFyYW0gZGV2aWNlSWQgLSBBbiBJRCBvZiBhIGRldmljZSB0byByZXBsYWNlIHRoZSBleGlzdGluZ1xuICAgICAqICAgaW5wdXQgZGV2aWNlIHdpdGguXG4gICAgICovXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLnNldElucHV0RGV2aWNlID0gZnVuY3Rpb24gKGRldmljZUlkKSB7XG4gICAgICAgIHJldHVybiAhdXRpbF8xLmlzRmlyZWZveCgpXG4gICAgICAgICAgICA/IHRoaXMuX3NldElucHV0RGV2aWNlKGRldmljZUlkLCBmYWxzZSlcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLk5vdFN1cHBvcnRlZEVycm9yKCdGaXJlZm94IGRvZXMgbm90IGN1cnJlbnRseSBzdXBwb3J0IG9wZW5pbmcgbXVsdGlwbGUgJyArXG4gICAgICAgICAgICAgICAgJ2F1ZGlvIGlucHV0IHRyYWNrcyBzaW11bHRhbmVvdXNseSwgZXZlbiBhY3Jvc3MgZGlmZmVyZW50IHRhYnMuIEFzIGEgcmVzdWx0LCAnICtcbiAgICAgICAgICAgICAgICAnRGV2aWNlLmF1ZGlvLnNldElucHV0RGV2aWNlIGlzIGRpc2FibGVkIG9uIEZpcmVmb3ggdW50aWwgc3VwcG9ydCBpcyBhZGRlZC5cXG4nICtcbiAgICAgICAgICAgICAgICAnUmVsYXRlZCBCdWdaaWxsYSB0aHJlYWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyOTkzMjQnKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnNldCB0aGUgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRvIGJlIGFwcGxpZWQgb24gZXZlcnkgZ2V0VXNlck1lZGlhIGNhbGwgZm9yIG5ldyBpbnB1dFxuICAgICAqIGRldmljZSBhdWRpby4gVGhlIHJldHVybmVkIFByb21pc2UgcmVzb2x2ZXMgd2hlbiB0aGUgbWVkaWEgaXMgc3VjY2Vzc2Z1bGx5IHJlYWNxdWlyZWQsXG4gICAgICogb3IgaW1tZWRpYXRlbHkgaWYgbm8gaW5wdXQgZGV2aWNlIGlzIHNldC5cbiAgICAgKi9cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUudW5zZXRBdWRpb0NvbnN0cmFpbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9hdWRpb0NvbnN0cmFpbnRzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXREZXZpY2VcbiAgICAgICAgICAgID8gdGhpcy5fc2V0SW5wdXREZXZpY2UodGhpcy5pbnB1dERldmljZS5kZXZpY2VJZCwgdHJ1ZSlcbiAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnNldCB0aGUgaW5wdXQgZGV2aWNlLCBzdG9wcGluZyB0aGUgdHJhY2tzLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuIG5vdCBpbiBhIGNvbm5lY3Rpb24sIGFuZFxuICAgICAqICAgd2lsbCBub3QgYWxsb3cgcmVtb3ZhbCBvZiB0aGUgaW5wdXQgZGV2aWNlIGR1cmluZyBhIGxpdmUgY2FsbC5cbiAgICAgKi9cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUudW5zZXRJbnB1dERldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RGV2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uQWN0aXZlSW5wdXRDaGFuZ2VkKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3JlcGxhY2VTdHJlYW0obnVsbCk7XG4gICAgICAgICAgICBfdGhpcy5faW5wdXREZXZpY2UgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX21heWJlU3RvcFBvbGxpbmdWb2x1bWUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBNZXJnZSB0aGUgcGFzc2VkIGVuYWJsZWRTb3VuZHMgaW50byB7QGxpbmsgQXVkaW9IZWxwZXJ9LiBDdXJyZW50bHkgdXNlZCB0byBtZXJnZSB0aGUgZGVwcmVjYXRlZFxuICAgICAqICAgRGV2aWNlLnNvdW5kcyBvYmplY3Qgb250byB0aGUgbmV3IHtAbGluayBBdWRpb0hlbHBlcn0gaW50ZXJmYWNlLiBNdXRhdGVzXG4gICAgICogICBieSByZWZlcmVuY2UsIHNoYXJpbmcgc3RhdGUgYmV0d2VlbiB7QGxpbmsgRGV2aWNlfSBhbmQge0BsaW5rIEF1ZGlvSGVscGVyfS5cbiAgICAgKiBAcGFyYW0gZW5hYmxlZFNvdW5kcyAtIFRoZSBpbml0aWFsIHNvdW5kIHNldHRpbmdzIHRvIG1lcmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9hZGRFbmFibGVkU291bmRzID0gZnVuY3Rpb24gKGVuYWJsZWRTb3VuZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVkU291bmRzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbmFibGVkU291bmRzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXMoZW5hYmxlZFNvdW5kcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBfdGhpc1trZXldID0gc2V0VmFsdWUuYmluZChudWxsLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgYW4gdW4tbGFiZWxlZCBEZXZpY2UuXG4gICAgICogQHBhcmFtIG1lZGlhRGV2aWNlSW5mb1xuICAgICAqIEByZXR1cm5zIFRoZSBpbmRleCBvZiB0aGUgcGFzc2VkIE1lZGlhRGV2aWNlSW5mb1xuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fZ2V0VW5rbm93bkRldmljZUluZGV4ID0gZnVuY3Rpb24gKG1lZGlhRGV2aWNlSW5mbykge1xuICAgICAgICB2YXIgaWQgPSBtZWRpYURldmljZUluZm8uZGV2aWNlSWQ7XG4gICAgICAgIHZhciBraW5kID0gbWVkaWFEZXZpY2VJbmZvLmtpbmQ7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3Vua25vd25EZXZpY2VJbmRleGVzW2tpbmRdW2lkXTtcbiAgICAgICAgaWYgKCFpbmRleCkge1xuICAgICAgICAgICAgaW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLl91bmtub3duRGV2aWNlSW5kZXhlc1traW5kXSkubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHRoaXMuX3Vua25vd25EZXZpY2VJbmRleGVzW2tpbmRdW2lkXSA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgb3V0cHV0IGRldmljZSBlbnVtZXJhdGlvbi5cbiAgICAgKi9cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUuX2luaXRpYWxpemVFbnVtZXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9tZWRpYURldmljZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RTdXBwb3J0ZWRFcnJvcignRW51bWVyYXRpb24gaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9tZWRpYURldmljZXMuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWNoYW5nZScsIHRoaXMuX3VwZGF0ZUF2YWlsYWJsZURldmljZXMpO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZWluZm9jaGFuZ2UnLCB0aGlzLl91cGRhdGVBdmFpbGFibGVEZXZpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVBdmFpbGFibGVEZXZpY2VzKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzT3V0cHV0U2VsZWN0aW9uU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIF90aGlzLnNwZWFrZXJEZXZpY2VzLnNldCgnZGVmYXVsdCcpLFxuICAgICAgICAgICAgICAgIF90aGlzLnJpbmd0b25lRGV2aWNlcy5zZXQoJ2RlZmF1bHQnKSxcbiAgICAgICAgICAgIF0pLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oXCJXYXJuaW5nOiBVbmFibGUgdG8gc2V0IGF1ZGlvIG91dHB1dCBkZXZpY2VzLiBcIiArIHJlYXNvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0cmFja3Mgb24gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtIGJlZm9yZSByZXBsYWNpbmcgaXQgd2l0aCB0aGUgcGFzc2VkIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gc3RyZWFtIC0gVGhlIG5ldyBzdHJlYW1cbiAgICAgKi9cbiAgICBBdWRpb0hlbHBlci5wcm90b3R5cGUuX3JlcGxhY2VTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbnB1dFN0cmVhbSA9IHN0cmVhbTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIGN1cnJlbnQgaW5wdXQgZGV2aWNlIHdpdGggYSBuZXcgZGV2aWNlIGJ5IElELlxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCAtIEFuIElEIG9mIGEgZGV2aWNlIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nXG4gICAgICogICBpbnB1dCBkZXZpY2Ugd2l0aC5cbiAgICAgKiBAcGFyYW0gZm9yY2VHZXRVc2VyTWVkaWEgLSBJZiB0cnVlLCBnZXRVc2VyTWVkaWEgd2lsbCBiZSBjYWxsZWQgZXZlbiBpZlxuICAgICAqICAgdGhlIHNwZWNpZmllZCBkZXZpY2UgaXMgYWxyZWFkeSBhY3RpdmUuXG4gICAgICovXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl9zZXRJbnB1dERldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VJZCwgZm9yY2VHZXRVc2VyTWVkaWEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ011c3Qgc3BlY2lmeSB0aGUgZGV2aWNlIHRvIHNldCcpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV2aWNlID0gdGhpcy5hdmFpbGFibGVJbnB1dERldmljZXMuZ2V0KGRldmljZUlkKTtcbiAgICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJEZXZpY2Ugbm90IGZvdW5kOiBcIiArIGRldmljZUlkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0RGV2aWNlICYmIHRoaXMuX2lucHV0RGV2aWNlLmRldmljZUlkID09PSBkZXZpY2VJZCAmJiB0aGlzLl9pbnB1dFN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZUdldFVzZXJNZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50bHkgYWN0aXZlIHRyYWNrIGlzIHN0aWxsIGluIHJlYWR5U3RhdGUgYGxpdmVgLCBnVU0gbWF5IHJldHVybiB0aGUgc2FtZSB0cmFja1xuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gcmV0dXJuaW5nIGEgZnJlc2ggdHJhY2suXG4gICAgICAgICAgICB0aGlzLl9pbnB1dFN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHsgYXVkaW86IE9iamVjdC5hc3NpZ24oeyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9LCB0aGlzLmF1ZGlvQ29uc3RyYWludHMpIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9vbkFjdGl2ZUlucHV0Q2hhbmdlZChzdHJlYW0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZXBsYWNlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lucHV0RGV2aWNlID0gZGV2aWNlO1xuICAgICAgICAgICAgICAgIF90aGlzLl9tYXliZVN0YXJ0UG9sbGluZ1ZvbHVtZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgc2V0IG9mIGRldmljZXMuXG4gICAgICogQHBhcmFtIHVwZGF0ZWREZXZpY2VzIC0gQW4gdXBkYXRlZCBsaXN0IG9mIGF2YWlsYWJsZSBEZXZpY2VzXG4gICAgICogQHBhcmFtIGF2YWlsYWJsZURldmljZXMgLSBUaGUgcHJldmlvdXMgbGlzdCBvZiBhdmFpbGFibGUgRGV2aWNlc1xuICAgICAqIEBwYXJhbSByZW1vdmVMb3N0RGV2aWNlIC0gVGhlIG1ldGhvZCB0byBjYWxsIGlmIGEgcHJldmlvdXNseSBhdmFpbGFibGUgRGV2aWNlIGlzXG4gICAgICogICBubyBsb25nZXIgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fdXBkYXRlRGV2aWNlcyA9IGZ1bmN0aW9uICh1cGRhdGVkRGV2aWNlcywgYXZhaWxhYmxlRGV2aWNlcywgcmVtb3ZlTG9zdERldmljZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBkYXRlZERldmljZUlkcyA9IHVwZGF0ZWREZXZpY2VzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5kZXZpY2VJZDsgfSk7XG4gICAgICAgIHZhciBrbm93bkRldmljZUlkcyA9IEFycmF5LmZyb20oYXZhaWxhYmxlRGV2aWNlcy52YWx1ZXMoKSkubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmRldmljZUlkOyB9KTtcbiAgICAgICAgdmFyIGxvc3RBY3RpdmVEZXZpY2VzID0gW107XG4gICAgICAgIC8vIFJlbW92ZSBsb3N0IGRldmljZXNcbiAgICAgICAgdmFyIGxvc3REZXZpY2VJZHMgPSB1dGlsXzEuZGlmZmVyZW5jZShrbm93bkRldmljZUlkcywgdXBkYXRlZERldmljZUlkcyk7XG4gICAgICAgIGxvc3REZXZpY2VJZHMuZm9yRWFjaChmdW5jdGlvbiAobG9zdERldmljZUlkKSB7XG4gICAgICAgICAgICB2YXIgbG9zdERldmljZSA9IGF2YWlsYWJsZURldmljZXMuZ2V0KGxvc3REZXZpY2VJZCk7XG4gICAgICAgICAgICBpZiAobG9zdERldmljZSkge1xuICAgICAgICAgICAgICAgIGF2YWlsYWJsZURldmljZXMuZGVsZXRlKGxvc3REZXZpY2VJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZUxvc3REZXZpY2UobG9zdERldmljZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9zdEFjdGl2ZURldmljZXMucHVzaChsb3N0RGV2aWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgYW55IG5ldyBkZXZpY2VzLCBvciBkZXZpY2VzIHdpdGggdXBkYXRlZCBsYWJlbHNcbiAgICAgICAgdmFyIGRldmljZUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdXBkYXRlZERldmljZXMuZm9yRWFjaChmdW5jdGlvbiAobmV3RGV2aWNlKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdEZXZpY2UgPSBhdmFpbGFibGVEZXZpY2VzLmdldChuZXdEZXZpY2UuZGV2aWNlSWQpO1xuICAgICAgICAgICAgdmFyIG5ld01lZGlhRGV2aWNlSW5mbyA9IF90aGlzLl93cmFwTWVkaWFEZXZpY2VJbmZvKG5ld0RldmljZSk7XG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nRGV2aWNlIHx8IGV4aXN0aW5nRGV2aWNlLmxhYmVsICE9PSBuZXdNZWRpYURldmljZUluZm8ubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVEZXZpY2VzLnNldChuZXdEZXZpY2UuZGV2aWNlSWQsIG5ld01lZGlhRGV2aWNlSW5mbyk7XG4gICAgICAgICAgICAgICAgZGV2aWNlQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGV2aWNlQ2hhbmdlZCB8fCBsb3N0RGV2aWNlSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRm9yY2UgYSBuZXcgZ1VNIGluIGNhc2UgdGhlIHVuZGVybHlpbmcgdHJhY2tzIG9mIHRoZSBhY3RpdmUgc3RyZWFtIGhhdmUgY2hhbmdlZC4gT25lXG4gICAgICAgICAgICAvLyAgIHJlYXNvbiB0aGlzIG1pZ2h0IGhhcHBlbiBpcyB3aGVuIGBkZWZhdWx0YCBpcyBzZWxlY3RlZCBhbmQgc2V0IHRvIGEgVVNCIGRldmljZSxcbiAgICAgICAgICAgIC8vICAgdGhlbiB0aGF0IGRldmljZSBpcyB1bnBsdWdnZWQgb3IgcGx1Z2dlZCBiYWNrIGluLiBXZSBjYW4ndCBjaGVjayBmb3IgdGhlICdlbmRlZCdcbiAgICAgICAgICAgIC8vICAgZXZlbnQgb3IgcmVhZHlTdGF0ZSBiZWNhdXNlIGl0IGlzIGFzeW5jaHJvbm91cyBhbmQgbWF5IHRha2UgdXB3YXJkcyBvZiA1IHNlY29uZHMsXG4gICAgICAgICAgICAvLyAgIGluIG15IHRlc3RpbmcuIChycm93bGFuZClcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0RGV2aWNlICE9PSBudWxsICYmIHRoaXMuaW5wdXREZXZpY2UuZGV2aWNlSWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiQ2FsbGluZyBnZXRVc2VyTWVkaWEgYWZ0ZXIgZGV2aWNlIGNoYW5nZSB0byBlbnN1cmUgdGhhdCB0aGUgICAgICAgICAgIHRyYWNrcyBvZiB0aGUgYWN0aXZlIGRldmljZSAoZGVmYXVsdCkgaGF2ZSBub3QgZ29uZSBzdGFsZS5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0SW5wdXREZXZpY2UodGhpcy5pbnB1dERldmljZS5kZXZpY2VJZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RldmljZUNoYW5nZScsIGxvc3RBY3RpdmVEZXZpY2VzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGUgb2xkIGlucHV0IHZvbHVtZSBzb3VyY2UsIGFuZCBjcmVhdGUgYW5kIGNvbm5lY3QgYSBuZXcgb25lIHdpdGggdGhlIGN1cnJlbnRcbiAgICAgKiBpbnB1dCBzdHJlYW0uXG4gICAgICovXG4gICAgQXVkaW9IZWxwZXIucHJvdG90eXBlLl91cGRhdGVWb2x1bWVTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5wdXRTdHJlYW0gfHwgIXRoaXMuX2F1ZGlvQ29udGV4dCB8fCAhdGhpcy5faW5wdXRWb2x1bWVBbmFseXNlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9pbnB1dFZvbHVtZVNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5faW5wdXRWb2x1bWVTb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0Vm9sdW1lU291cmNlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKHRoaXMuX2lucHV0U3RyZWFtKTtcbiAgICAgICAgdGhpcy5faW5wdXRWb2x1bWVTb3VyY2UuY29ubmVjdCh0aGlzLl9pbnB1dFZvbHVtZUFuYWx5c2VyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBNZWRpYURldmljZUluZm8gdG8gYSBJTWVkaWFEZXZpY2VJbmZvU2hpbS5cbiAgICAgKiBAcGFyYW0gbWVkaWFEZXZpY2VJbmZvIC0gVGhlIGluZm8gdG8gY29udmVydFxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgc2hpbVxuICAgICAqL1xuICAgIEF1ZGlvSGVscGVyLnByb3RvdHlwZS5fd3JhcE1lZGlhRGV2aWNlSW5mbyA9IGZ1bmN0aW9uIChtZWRpYURldmljZUluZm8pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZXZpY2VJZDogbWVkaWFEZXZpY2VJbmZvLmRldmljZUlkLFxuICAgICAgICAgICAgZ3JvdXBJZDogbWVkaWFEZXZpY2VJbmZvLmdyb3VwSWQsXG4gICAgICAgICAgICBraW5kOiBtZWRpYURldmljZUluZm8ua2luZCxcbiAgICAgICAgICAgIGxhYmVsOiBtZWRpYURldmljZUluZm8ubGFiZWwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghb3B0aW9ucy5sYWJlbCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGV2aWNlSWQgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubGFiZWwgPSAnRGVmYXVsdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9nZXRVbmtub3duRGV2aWNlSW5kZXgobWVkaWFEZXZpY2VJbmZvKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmxhYmVsID0gXCJVbmtub3duIFwiICsga2luZEFsaWFzZXNbb3B0aW9ucy5raW5kXSArIFwiIERldmljZSBcIiArIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTWVkaWFEZXZpY2VJbmZvU2hpbShvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBBdWRpb0hlbHBlcjtcbn0oZXZlbnRzXzEuRXZlbnRFbWl0dGVyKSk7XG4oZnVuY3Rpb24gKEF1ZGlvSGVscGVyKSB7XG59KShBdWRpb0hlbHBlciB8fCAoQXVkaW9IZWxwZXIgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXVkaW9IZWxwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdWRpb2hlbHBlci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/audiohelper.js\n")},"./node_modules/twilio-client/es5/twilio/connection.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar device_1 = __webpack_require__(/*! ./device */ \"./node_modules/twilio-client/es5/twilio/device.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar log_1 = __webpack_require__(/*! ./log */ \"./node_modules/twilio-client/es5/twilio/log.js\");\nvar icecandidate_1 = __webpack_require__(/*! ./rtc/icecandidate */ \"./node_modules/twilio-client/es5/twilio/rtc/icecandidate.js\");\nvar statsMonitor_1 = __webpack_require__(/*! ./statsMonitor */ \"./node_modules/twilio-client/es5/twilio/statsMonitor.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\nvar Backoff = __webpack_require__(/*! backoff */ \"./node_modules/backoff/index.js\");\nvar C = __webpack_require__(/*! ./constants */ \"./node_modules/twilio-client/es5/twilio/constants.js\");\nvar PeerConnection = __webpack_require__(/*! ./rtc */ \"./node_modules/twilio-client/es5/twilio/rtc/index.js\").PeerConnection;\nvar getPreferredCodecInfo = __webpack_require__(/*! ./rtc/sdp */ \"./node_modules/twilio-client/es5/twilio/rtc/sdp.js\").getPreferredCodecInfo;\nvar BACKOFF_CONFIG = {\n    factor: 1.1,\n    initialDelay: 1,\n    maxDelay: 30000,\n    randomisationFactor: 0.5,\n};\nvar DTMF_INTER_TONE_GAP = 70;\nvar DTMF_PAUSE_DURATION = 500;\nvar DTMF_TONE_DURATION = 160;\nvar METRICS_BATCH_SIZE = 10;\nvar METRICS_DELAY = 5000;\nvar MEDIA_DISCONNECT_ERROR = {\n    disconnect: true,\n    info: {\n        code: 31003,\n        message: 'Connection with Twilio was interrupted.',\n        twilioError: new errors_1.MediaErrors.ConnectionError(),\n    },\n};\nvar MULTIPLE_THRESHOLD_WARNING_NAMES = {\n    // The stat `packetsLostFraction` is monitored by two separate thresholds,\n    // `maxAverage` and `max`. Each threshold emits a different warning name.\n    packetsLostFraction: {\n        max: 'packet-loss',\n        maxAverage: 'packets-lost-fraction',\n    },\n};\nvar WARNING_NAMES = {\n    audioInputLevel: 'audio-input-level',\n    audioOutputLevel: 'audio-output-level',\n    bytesReceived: 'bytes-received',\n    bytesSent: 'bytes-sent',\n    jitter: 'jitter',\n    mos: 'mos',\n    rtt: 'rtt',\n};\nvar WARNING_PREFIXES = {\n    max: 'high-',\n    maxAverage: 'high-',\n    maxDuration: 'constant-',\n    min: 'low-',\n    minStandardDeviation: 'constant-',\n};\nvar hasBeenWarnedHandlers = false;\n/**\n * A {@link Connection} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nvar Connection = /** @class */ (function (_super) {\n    __extends(Connection, _super);\n    /**\n     * @constructor\n     * @private\n     * @param config - Mandatory configuration options\n     * @param [options] - Optional settings\n     */\n    function Connection(config, options) {\n        var _this = _super.call(this) || this;\n        /**\n         * Call parameters received from Twilio for an incoming call.\n         */\n        _this.parameters = {};\n        /**\n         * The number of times input volume has been the same consecutively.\n         */\n        _this._inputVolumeStreak = 0;\n        /**\n         * Whether the call has been answered.\n         */\n        _this._isAnswered = false;\n        /**\n         * Whether the call has been cancelled.\n         */\n        _this._isCancelled = false;\n        /**\n         * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n         */\n        _this._latestInputVolume = 0;\n        /**\n         * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n         */\n        _this._latestOutputVolume = 0;\n        /**\n         * An instance of Logger to use.\n         */\n        _this._log = log_1.default.getInstance();\n        /**\n         * A batch of metrics samples to send to Insights. Gets cleared after\n         * each send and appended to on each new sample.\n         */\n        _this._metricsSamples = [];\n        /**\n         * The number of times output volume has been the same consecutively.\n         */\n        _this._outputVolumeStreak = 0;\n        /**\n         * A Map of Sounds to play.\n         */\n        _this._soundcache = new Map();\n        /**\n         * State of the {@link Connection}.\n         */\n        _this._status = Connection.State.Pending;\n        /**\n         * Options passed to this {@link Connection}.\n         */\n        _this.options = {\n            enableRingingState: false,\n            mediaStreamFactory: PeerConnection,\n            offerSdp: null,\n            shouldPlayDisconnect: function () { return true; },\n        };\n        /**\n         * Whether the {@link Connection} should send a hangup on disconnect.\n         */\n        _this.sendHangup = true;\n        /**\n         * String representation of {@link Connection} instance.\n         * @private\n         */\n        _this.toString = function () { return '[Twilio.Connection instance]'; };\n        _this._emitWarning = function (groupPrefix, warningName, threshold, value, wasCleared, warningData) {\n            var groupSuffix = wasCleared ? '-cleared' : '-raised';\n            var groupName = groupPrefix + \"warning\" + groupSuffix;\n            // Ignore constant input if the Connection is muted (Expected)\n            if (warningName === 'constant-audio-input-level' && _this.isMuted()) {\n                return;\n            }\n            var level = wasCleared ? 'info' : 'warning';\n            // Avoid throwing false positives as warnings until we refactor volume metrics\n            if (warningName === 'constant-audio-output-level') {\n                level = 'info';\n            }\n            var payloadData = { threshold: threshold };\n            if (value) {\n                if (value instanceof Array) {\n                    payloadData.values = value.map(function (val) {\n                        if (typeof val === 'number') {\n                            return Math.round(val * 100) / 100;\n                        }\n                        return value;\n                    });\n                }\n                else {\n                    payloadData.value = value;\n                }\n            }\n            _this._publisher.post(level, groupName, warningName, { data: payloadData }, _this);\n            if (warningName !== 'constant-audio-output-level') {\n                var emitName = wasCleared ? 'warning-cleared' : 'warning';\n                _this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n            }\n        };\n        /**\n         * Called when the {@link Connection} is answered.\n         * @param payload\n         */\n        _this._onAnswer = function (payload) {\n            // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n            // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n            // the callee accepts the call firing a second `accept` event if we don't\n            // short circuit here.\n            if (_this._isAnswered) {\n                return;\n            }\n            _this._setCallSid(payload);\n            _this._isAnswered = true;\n            _this._maybeTransitionToOpen();\n        };\n        /**\n         * Called when the {@link Connection} is cancelled.\n         * @param payload\n         */\n        _this._onCancel = function (payload) {\n            // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n            var callsid = payload.callsid;\n            if (_this.parameters.CallSid === callsid) {\n                _this._isCancelled = true;\n                _this._publisher.info('connection', 'cancel', null, _this);\n                _this._cleanupEventListeners();\n                _this.mediaStream.close();\n                _this._status = Connection.State.Closed;\n                _this.emit('cancel');\n                _this.pstream.removeListener('cancel', _this._onCancel);\n            }\n        };\n        /**\n         * Called when the {@link Connection} is hung up.\n         * @param payload\n         */\n        _this._onHangup = function (payload) {\n            /**\n             *  see if callsid passed in message matches either callsid or outbound id\n             *  connection should always have either callsid or outbound id\n             *  if no callsid passed hangup anyways\n             */\n            if (payload.callsid && (_this.parameters.CallSid || _this.outboundConnectionId)) {\n                if (payload.callsid !== _this.parameters.CallSid\n                    && payload.callsid !== _this.outboundConnectionId) {\n                    return;\n                }\n            }\n            else if (payload.callsid) {\n                // hangup is for another connection\n                return;\n            }\n            _this._log.info('Received HANGUP from gateway');\n            if (payload.error) {\n                var error = {\n                    code: payload.error.code || 31000,\n                    connection: _this,\n                    message: payload.error.message || 'Error sent from gateway in HANGUP',\n                    twilioError: new errors_1.GeneralErrors.ConnectionError(),\n                };\n                _this._log.error('Received an error from the gateway:', error);\n                _this.emit('error', error);\n            }\n            _this.sendHangup = false;\n            _this._publisher.info('connection', 'disconnected-by-remote', null, _this);\n            _this._disconnect(null, true);\n            _this._cleanupEventListeners();\n        };\n        /**\n         * Called when there is a media failure.\n         * Manages all media-related states and takes action base on the states\n         * @param type - Type of media failure\n         */\n        _this._onMediaFailure = function (type) {\n            var _a = Connection.MediaFailure, ConnectionDisconnected = _a.ConnectionDisconnected, ConnectionFailed = _a.ConnectionFailed, IceGatheringFailed = _a.IceGatheringFailed, LowBytes = _a.LowBytes;\n            // These types signifies the end of a single ICE cycle\n            var isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n            // Default behavior on ice failures with disabled ice restart.\n            if ((!_this.options.enableIceRestart && isEndOfIceCycle)\n                // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n                // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n                // Since we cannot detect if ICE Restart is complete, we will not retry.\n                || (!util_1.isChrome(window, window.navigator) && type === ConnectionFailed)) {\n                return _this.mediaStream.onerror(MEDIA_DISCONNECT_ERROR);\n            }\n            // Ignore any other type of media failure if ice restart is disabled\n            if (!_this.options.enableIceRestart) {\n                return;\n            }\n            // Ignore subsequent requests if ice restart is in progress\n            if (_this._status === Connection.State.Reconnecting) {\n                // This is a retry. Previous ICE Restart failed\n                if (isEndOfIceCycle) {\n                    // We already exceeded max retry time.\n                    if (Date.now() - _this._mediaReconnectStartTime > BACKOFF_CONFIG.maxDelay) {\n                        _this._log.info('Exceeded max ICE retries');\n                        return _this.mediaStream.onerror(MEDIA_DISCONNECT_ERROR);\n                    }\n                    // Issue ICE restart with backoff\n                    _this._mediaReconnectBackoff.backoff();\n                }\n                return;\n            }\n            var pc = _this.mediaStream.version.pc;\n            var isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n            var hasLowBytesWarning = _this._monitor.hasActiveWarning('bytesSent', 'min')\n                || _this._monitor.hasActiveWarning('bytesReceived', 'min');\n            // Only certain conditions can trigger media reconnection\n            if ((type === LowBytes && isIceDisconnected)\n                || (type === ConnectionDisconnected && hasLowBytesWarning)\n                || isEndOfIceCycle) {\n                var mediaReconnectionError = {\n                    code: 53405,\n                    message: 'Media connection failed.',\n                    twilioError: new errors_1.MediaErrors.ConnectionError(),\n                };\n                _this._log.warn('ICE Connection disconnected.');\n                _this._publisher.warn('connection', 'error', mediaReconnectionError, _this);\n                _this._publisher.info('connection', 'reconnecting', null, _this);\n                _this._mediaReconnectStartTime = Date.now();\n                _this._status = Connection.State.Reconnecting;\n                _this._mediaReconnectBackoff.reset();\n                _this._mediaReconnectBackoff.backoff();\n                _this.emit('reconnecting', mediaReconnectionError);\n            }\n        };\n        /**\n         * Called when media connection is restored\n         */\n        _this._onMediaReconnected = function () {\n            // Only trigger once.\n            // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n            if (_this._status !== Connection.State.Reconnecting) {\n                return;\n            }\n            _this._log.info('ICE Connection reestablished.');\n            _this._publisher.info('connection', 'reconnected', null, _this);\n            _this._status = Connection.State.Open;\n            _this.emit('reconnected');\n        };\n        /**\n         * When we get a RINGING signal from PStream, update the {@link Connection} status.\n         * @param payload\n         */\n        _this._onRinging = function (payload) {\n            _this._setCallSid(payload);\n            // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n            if (_this._status !== Connection.State.Connecting && _this._status !== Connection.State.Ringing) {\n                return;\n            }\n            var hasEarlyMedia = !!payload.sdp;\n            if (_this.options.enableRingingState) {\n                _this._status = Connection.State.Ringing;\n                _this._publisher.info('connection', 'outgoing-ringing', { hasEarlyMedia: hasEarlyMedia }, _this);\n                _this.emit('ringing', hasEarlyMedia);\n                // answerOnBridge=false will send a 183, which we need to interpret as `answer` when\n                // the enableRingingState flag is disabled in order to maintain a non-breaking API from 1.4.24\n            }\n            else if (hasEarlyMedia) {\n                _this._onAnswer(payload);\n            }\n        };\n        /**\n         * Called each time StatsMonitor emits a sample.\n         * Emits stats event and batches the call stats metrics and sends them to Insights.\n         * @param sample\n         */\n        _this._onRTCSample = function (sample) {\n            var callMetrics = __assign(__assign({}, sample), { inputVolume: _this._latestInputVolume, outputVolume: _this._latestOutputVolume });\n            _this._codec = callMetrics.codecName;\n            _this._metricsSamples.push(callMetrics);\n            if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n                _this._publishMetrics();\n            }\n            _this.emit('sample', sample);\n        };\n        /**\n         * Called when we receive a transportClose event from pstream.\n         * Re-emits the event.\n         */\n        _this._onTransportClose = function () {\n            _this._log.error('Received transportClose from pstream');\n            _this.emit('transportClose');\n        };\n        /**\n         * Re-emit an StatsMonitor warning as a {@link Connection}.warning or .warning-cleared event.\n         * @param warningData\n         * @param wasCleared - Whether this is a -cleared or -raised event.\n         */\n        _this._reemitWarning = function (warningData, wasCleared) {\n            var groupPrefix = /^audio/.test(warningData.name) ?\n                'audio-level-' : 'network-quality-';\n            var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n            /**\n             * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n             * `high-packets-lost-fraction`, so in this case we need to use a different\n             * `WARNING_NAME` mapping.\n             */\n            var warningName;\n            if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n                warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n            }\n            else if (warningData.name in WARNING_NAMES) {\n                warningName = WARNING_NAMES[warningData.name];\n            }\n            var warning = warningPrefix + warningName;\n            _this._emitWarning(groupPrefix, warning, warningData.threshold.value, warningData.values || warningData.value, wasCleared, warningData);\n        };\n        /**\n         * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n         * @param warningData\n         */\n        _this._reemitWarningCleared = function (warningData) {\n            _this._reemitWarning(warningData, true);\n        };\n        _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n        _this._soundcache = config.soundcache;\n        _this.message = options && options.twimlParams || {};\n        _this.customParameters = new Map(Object.entries(_this.message).map(function (_a) {\n            var key = _a[0], val = _a[1];\n            return [key, String(val)];\n        }));\n        Object.assign(_this.options, options);\n        if (_this.options.callParameters) {\n            _this.parameters = _this.options.callParameters;\n        }\n        _this._direction = _this.parameters.CallSid ? Connection.CallDirection.Incoming : Connection.CallDirection.Outgoing;\n        if (_this._direction === Connection.CallDirection.Incoming && _this.parameters) {\n            _this.callerInfo = _this.parameters.StirStatus\n                ? { isVerified: _this.parameters.StirStatus === 'TN-Validation-Passed-A' }\n                : null;\n        }\n        else {\n            _this.callerInfo = null;\n        }\n        _this._mediaReconnectBackoff = Backoff.exponential(BACKOFF_CONFIG);\n        _this._mediaReconnectBackoff.on('ready', function () { return _this.mediaStream.iceRestart(); });\n        // temporary call sid to be used for outgoing calls\n        _this.outboundConnectionId = generateTempCallSid();\n        var publisher = _this._publisher = config.publisher;\n        if (_this._direction === Connection.CallDirection.Incoming) {\n            publisher.info('connection', 'incoming', null, _this);\n        }\n        else {\n            publisher.info('connection', 'outgoing', { preflight: _this.options.preflight }, _this);\n        }\n        var monitor = _this._monitor = new (_this.options.StatsMonitor || statsMonitor_1.default)();\n        monitor.on('sample', _this._onRTCSample);\n        // First 20 seconds or so are choppy, so let's not bother with these warnings.\n        monitor.disableWarnings();\n        setTimeout(function () { return monitor.enableWarnings(); }, METRICS_DELAY);\n        monitor.on('warning', function (data, wasCleared) {\n            if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n                _this._onMediaFailure(Connection.MediaFailure.LowBytes);\n            }\n            _this._reemitWarning(data, wasCleared);\n        });\n        monitor.on('warning-cleared', function (data) {\n            _this._reemitWarningCleared(data);\n        });\n        _this.mediaStream = new (_this.options.MediaStream || _this.options.mediaStreamFactory)(config.audioHelper, config.pstream, config.getUserMedia, {\n            codecPreferences: _this.options.codecPreferences,\n            dscp: _this.options.dscp,\n            enableIceRestart: _this.options.enableIceRestart,\n            forceAggressiveIceNomination: _this.options.forceAggressiveIceNomination,\n            isUnifiedPlan: _this._isUnifiedPlanDefault,\n            maxAverageBitrate: _this.options.maxAverageBitrate,\n            preflight: _this.options.preflight,\n        });\n        _this.on('volume', function (inputVolume, outputVolume) {\n            _this._inputVolumeStreak = _this._checkVolume(inputVolume, _this._inputVolumeStreak, _this._latestInputVolume, 'input');\n            _this._outputVolumeStreak = _this._checkVolume(outputVolume, _this._outputVolumeStreak, _this._latestOutputVolume, 'output');\n            _this._latestInputVolume = inputVolume;\n            _this._latestOutputVolume = outputVolume;\n        });\n        _this.mediaStream.onvolume = function (inputVolume, outputVolume, internalInputVolume, internalOutputVolume) {\n            // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n            // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n            // chosen below.\n            monitor.addVolumes((internalInputVolume / 255) * 32767, (internalOutputVolume / 255) * 32767);\n            // (rrowland) 0.0 -> 1.0 linear\n            _this.emit('volume', inputVolume, outputVolume);\n        };\n        _this.mediaStream.ondtlstransportstatechange = function (state) {\n            var level = state === 'failed' ? 'error' : 'debug';\n            _this._publisher.post(level, 'dtls-transport-state', state, null, _this);\n        };\n        _this.mediaStream.onpcconnectionstatechange = function (state) {\n            var level = 'debug';\n            var dtlsTransport = _this.mediaStream.getRTCDtlsTransport();\n            if (state === 'failed') {\n                level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n            }\n            _this._publisher.post(level, 'pc-connection-state', state, null, _this);\n        };\n        _this.mediaStream.onicecandidate = function (candidate) {\n            var payload = new icecandidate_1.IceCandidate(candidate).toPayload();\n            _this._publisher.debug('ice-candidate', 'ice-candidate', payload, _this);\n        };\n        _this.mediaStream.onselectedcandidatepairchange = function (pair) {\n            var localCandidatePayload = new icecandidate_1.IceCandidate(pair.local).toPayload();\n            var remoteCandidatePayload = new icecandidate_1.IceCandidate(pair.remote, true).toPayload();\n            _this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n                local_candidate: localCandidatePayload,\n                remote_candidate: remoteCandidatePayload,\n            }, _this);\n        };\n        _this.mediaStream.oniceconnectionstatechange = function (state) {\n            var level = state === 'failed' ? 'error' : 'debug';\n            _this._publisher.post(level, 'ice-connection-state', state, null, _this);\n        };\n        _this.mediaStream.onicegatheringfailure = function (type) {\n            _this._publisher.warn('ice-gathering-state', type, null, _this);\n            _this._onMediaFailure(Connection.MediaFailure.IceGatheringFailed);\n        };\n        _this.mediaStream.onicegatheringstatechange = function (state) {\n            _this._publisher.debug('ice-gathering-state', state, null, _this);\n        };\n        _this.mediaStream.onsignalingstatechange = function (state) {\n            _this._publisher.debug('signaling-state', state, null, _this);\n        };\n        _this.mediaStream.ondisconnected = function (msg) {\n            _this._log.info(msg);\n            _this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n                message: msg,\n            }, _this);\n            _this.emit('warning', 'ice-connectivity-lost');\n            _this._onMediaFailure(Connection.MediaFailure.ConnectionDisconnected);\n        };\n        _this.mediaStream.onfailed = function (msg) {\n            _this._onMediaFailure(Connection.MediaFailure.ConnectionFailed);\n        };\n        _this.mediaStream.onconnected = function () {\n            // First time mediaStream is connected, but ICE Gathering issued an ICE restart and succeeded.\n            if (_this._status === Connection.State.Reconnecting) {\n                _this._onMediaReconnected();\n            }\n        };\n        _this.mediaStream.onreconnected = function (msg) {\n            _this._log.info(msg);\n            _this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n                message: msg,\n            }, _this);\n            _this.emit('warning-cleared', 'ice-connectivity-lost');\n            _this._onMediaReconnected();\n        };\n        _this.mediaStream.onerror = function (e) {\n            if (e.disconnect === true) {\n                _this._disconnect(e.info && e.info.message);\n            }\n            var error = {\n                code: e.info.code,\n                connection: _this,\n                info: e.info,\n                message: e.info.message || 'Error with mediastream',\n                twilioError: e.info.twilioError,\n            };\n            _this._log.error('Received an error from MediaStream:', e);\n            _this.emit('error', error);\n        };\n        _this.mediaStream.onopen = function () {\n            // NOTE(mroberts): While this may have been happening in previous\n            // versions of Chrome, since Chrome 45 we have seen the\n            // PeerConnection's onsignalingstatechange handler invoked multiple\n            // times in the same signalingState 'stable'. When this happens, we\n            // invoke this onopen function. If we invoke it twice without checking\n            // for _status 'open', we'd accidentally close the PeerConnection.\n            //\n            // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n            if (_this._status === Connection.State.Open || _this._status === Connection.State.Reconnecting) {\n                return;\n            }\n            else if (_this._status === Connection.State.Ringing || _this._status === Connection.State.Connecting) {\n                _this.mute(false);\n                _this._maybeTransitionToOpen();\n            }\n            else {\n                // call was probably canceled sometime before this\n                _this.mediaStream.close();\n            }\n        };\n        _this.mediaStream.onclose = function () {\n            _this._status = Connection.State.Closed;\n            if (_this.options.shouldPlayDisconnect && _this.options.shouldPlayDisconnect()\n                // Don't play disconnect sound if this was from a cancel event. i.e. the call\n                // was ignored or hung up even before it was answered.\n                && !_this._isCancelled) {\n                _this._soundcache.get(device_1.default.SoundName.Disconnect).play();\n            }\n            monitor.disable();\n            _this._publishMetrics();\n            if (!_this._isCancelled) {\n                _this.emit('disconnect', _this);\n            }\n        };\n        _this.pstream = config.pstream;\n        _this.pstream.on('cancel', _this._onCancel);\n        _this.pstream.on('ringing', _this._onRinging);\n        _this.pstream.on('transportClose', _this._onTransportClose);\n        _this.on('error', function (error) {\n            _this._publisher.error('connection', 'error', {\n                code: error.code, message: error.message,\n            }, _this);\n            if (_this.pstream && _this.pstream.status === 'disconnected') {\n                _this._cleanupEventListeners();\n            }\n        });\n        _this.on('disconnect', function () {\n            _this._cleanupEventListeners();\n        });\n        return _this;\n    }\n    Object.defineProperty(Connection.prototype, \"direction\", {\n        /**\n         * Whether this {@link Connection} is incoming or outgoing.\n         */\n        get: function () {\n            return this._direction;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Connection.prototype, \"codec\", {\n        /**\n         * Audio codec used for this {@link Connection}. Expecting {@link Connection.Codec} but\n         * will copy whatever we get from RTC stats.\n         */\n        get: function () {\n            return this._codec;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Get the real CallSid. Returns null if not present or is a temporary call sid.\n     * @deprecated\n     * @private\n     */\n    Connection.prototype._getRealCallSid = function () {\n        this._log.warn('_getRealCallSid is deprecated and will be removed in 2.0.');\n        return /^TJ/.test(this.parameters.CallSid) ? null : this.parameters.CallSid;\n    };\n    /**\n     * Get the temporary CallSid.\n     * @deprecated\n     * @private\n     */\n    Connection.prototype._getTempCallSid = function () {\n        this._log.warn('_getTempCallSid is deprecated and will be removed in 2.0. \\\n                    Please use outboundConnectionId instead.');\n        return this.outboundConnectionId;\n    };\n    /**\n     * Set the audio input tracks from a given stream.\n     * @param stream\n     * @private\n     */\n    Connection.prototype._setInputTracksFromStream = function (stream) {\n        return this.mediaStream.setInputTracksFromStream(stream);\n    };\n    /**\n     * Set the audio output sink IDs.\n     * @param sinkIds\n     * @private\n     */\n    Connection.prototype._setSinkIds = function (sinkIds) {\n        return this.mediaStream._setSinkIds(sinkIds);\n    };\n    Connection.prototype.accept = function (handlerOrConstraints, rtcConfiguration) {\n        var _this = this;\n        if (typeof handlerOrConstraints === 'function') {\n            this._addHandler('accept', handlerOrConstraints);\n            return;\n        }\n        if (this._status !== Connection.State.Pending) {\n            return;\n        }\n        var audioConstraints = handlerOrConstraints || this.options.audioConstraints;\n        this._status = Connection.State.Connecting;\n        var connect = function () {\n            if (_this._status !== Connection.State.Connecting) {\n                // call must have been canceled\n                _this._cleanupEventListeners();\n                _this.mediaStream.close();\n                return;\n            }\n            var onAnswer = function (pc) {\n                // Report that the call was answered, and directionality\n                var eventName = _this._direction === Connection.CallDirection.Incoming\n                    ? 'accepted-by-local'\n                    : 'accepted-by-remote';\n                _this._publisher.info('connection', eventName, null, _this);\n                // Report the preferred codec and params as they appear in the SDP\n                var _a = getPreferredCodecInfo(_this.mediaStream.version.getSDP()), codecName = _a.codecName, codecParams = _a.codecParams;\n                _this._publisher.info('settings', 'codec', {\n                    codec_params: codecParams,\n                    selected_codec: codecName,\n                }, _this);\n                // Enable RTC monitoring\n                _this._monitor.enable(pc);\n            };\n            var sinkIds = typeof _this.options.getSinkIds === 'function' && _this.options.getSinkIds();\n            if (Array.isArray(sinkIds)) {\n                _this.mediaStream._setSinkIds(sinkIds).catch(function () {\n                    // (rrowland) We don't want this to throw to console since the customer\n                    // can't control this. This will most commonly be rejected on browsers\n                    // that don't support setting sink IDs.\n                });\n            }\n            _this.pstream.addListener('hangup', _this._onHangup);\n            rtcConfiguration = rtcConfiguration || _this.options.rtcConfiguration;\n            if (_this._direction === Connection.CallDirection.Incoming) {\n                _this._isAnswered = true;\n                _this.mediaStream.answerIncomingCall(_this.parameters.CallSid, _this.options.offerSdp, _this.options.rtcConstraints, rtcConfiguration, onAnswer);\n            }\n            else {\n                var params = Array.from(_this.customParameters.entries()).map(function (pair) {\n                    return encodeURIComponent(pair[0]) + \"=\" + encodeURIComponent(pair[1]);\n                }).join('&');\n                _this.pstream.once('answer', _this._onAnswer.bind(_this));\n                _this.mediaStream.makeOutgoingCall(_this.pstream.token, params, _this.outboundConnectionId, _this.options.rtcConstraints, rtcConfiguration, onAnswer);\n            }\n        };\n        if (this.options.beforeAccept) {\n            this.options.beforeAccept(this);\n        }\n        var inputStream = typeof this.options.getInputStream === 'function' && this.options.getInputStream();\n        var promise = inputStream\n            ? this.mediaStream.setInputTracksFromStream(inputStream)\n            : this.mediaStream.openWithConstraints(audioConstraints);\n        promise.then(function () {\n            _this._publisher.info('get-user-media', 'succeeded', {\n                data: { audioConstraints: audioConstraints },\n            }, _this);\n            connect();\n        }, function (error) {\n            var message;\n            var code;\n            if (error.code === 31208\n                || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n                code = 31208;\n                message = 'User denied access to microphone, or the web browser did not allow microphone '\n                    + 'access at this address.';\n                _this._publisher.error('get-user-media', 'denied', {\n                    data: {\n                        audioConstraints: audioConstraints,\n                        error: error,\n                    },\n                }, _this);\n            }\n            else {\n                code = 31201;\n                message = \"Error occurred while accessing microphone: \" + error.name + (error.message\n                    ? \" (\" + error.message + \")\"\n                    : '');\n                _this._publisher.error('get-user-media', 'failed', {\n                    data: {\n                        audioConstraints: audioConstraints,\n                        error: error,\n                    },\n                }, _this);\n            }\n            _this._disconnect();\n            _this.emit('error', { message: message, code: code });\n        });\n    };\n    Connection.prototype.cancel = function (handler) {\n        this._log.warn('.cancel() is deprecated. Please use .ignore() instead.');\n        if (handler) {\n            this.ignore(handler);\n        }\n        else {\n            this.ignore();\n        }\n    };\n    Connection.prototype.disconnect = function (handler) {\n        if (typeof handler === 'function') {\n            this._addHandler('disconnect', handler);\n            return;\n        }\n        this._disconnect();\n    };\n    /**\n     * @deprecated - Set a handler for the {@link errorEvent}\n     */\n    Connection.prototype.error = function (handler) {\n        if (typeof handler === 'function') {\n            this._addHandler('error', handler);\n        }\n    };\n    /**\n     * Get the local MediaStream, if set.\n     */\n    Connection.prototype.getLocalStream = function () {\n        return this.mediaStream && this.mediaStream.stream;\n    };\n    /**\n     * Get the remote MediaStream, if set.\n     */\n    Connection.prototype.getRemoteStream = function () {\n        return this.mediaStream && this.mediaStream._remoteStream;\n    };\n    Connection.prototype.ignore = function (handler) {\n        if (typeof handler === 'function') {\n            this._addHandler('cancel', handler);\n            return;\n        }\n        if (this._status !== Connection.State.Pending) {\n            return;\n        }\n        this._status = Connection.State.Closed;\n        this.emit('cancel');\n        this.mediaStream.ignore(this.parameters.CallSid);\n        this._publisher.info('connection', 'ignored-by-local', null, this);\n    };\n    /**\n     * Check if connection is muted\n     */\n    Connection.prototype.isMuted = function () {\n        return this.mediaStream.isMuted;\n    };\n    Connection.prototype.mute = function (shouldMute) {\n        if (shouldMute === void 0) { shouldMute = true; }\n        if (typeof shouldMute === 'function') {\n            this._addHandler('mute', shouldMute);\n            return;\n        }\n        var wasMuted = this.mediaStream.isMuted;\n        this.mediaStream.mute(shouldMute);\n        var isMuted = this.mediaStream.isMuted;\n        if (wasMuted !== isMuted) {\n            this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n            this.emit('mute', isMuted, this);\n        }\n    };\n    /**\n     * Post an event to Endpoint Analytics indicating that the end user\n     *   has given call quality feedback. Called without a score, this\n     *   will report that the customer declined to give feedback.\n     * @param score - The end-user's rating of the call; an\n     *   integer 1 through 5. Or undefined if the user declined to give\n     *   feedback.\n     * @param issue - The primary issue the end user\n     *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n     *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n     */\n    Connection.prototype.postFeedback = function (score, issue) {\n        if (typeof score === 'undefined' || score === null) {\n            return this._postFeedbackDeclined();\n        }\n        if (!Object.values(Connection.FeedbackScore).includes(score)) {\n            throw new errors_1.InvalidArgumentError(\"Feedback score must be one of: \" + Object.values(Connection.FeedbackScore));\n        }\n        if (typeof issue !== 'undefined' && issue !== null && !Object.values(Connection.FeedbackIssue).includes(issue)) {\n            throw new errors_1.InvalidArgumentError(\"Feedback issue must be one of: \" + Object.values(Connection.FeedbackIssue));\n        }\n        return this._publisher.info('feedback', 'received', {\n            issue_name: issue,\n            quality_score: score,\n        }, this, true);\n    };\n    Connection.prototype.reject = function (handler) {\n        if (typeof handler === 'function') {\n            this._addHandler('reject', handler);\n            return;\n        }\n        if (this._status !== Connection.State.Pending) {\n            return;\n        }\n        this.pstream.reject(this.parameters.CallSid);\n        this._status = Connection.State.Closed;\n        this.emit('reject');\n        this.mediaStream.reject(this.parameters.CallSid);\n        this._publisher.info('connection', 'rejected-by-local', null, this);\n    };\n    /**\n     * Send a string of digits.\n     * @param digits\n     */\n    Connection.prototype.sendDigits = function (digits) {\n        if (digits.match(/[^0-9*#w]/)) {\n            throw new errors_1.InvalidArgumentError('Illegal character passed into sendDigits');\n        }\n        var sequence = [];\n        digits.split('').forEach(function (digit) {\n            var dtmf = (digit !== 'w') ? \"dtmf\" + digit : '';\n            if (dtmf === 'dtmf*') {\n                dtmf = 'dtmfs';\n            }\n            if (dtmf === 'dtmf#') {\n                dtmf = 'dtmfh';\n            }\n            sequence.push(dtmf);\n        });\n        // Binds soundCache to be used in recursion until all digits have been played.\n        (function playNextDigit(soundCache, dialtonePlayer) {\n            var digit = sequence.shift();\n            if (digit) {\n                if (dialtonePlayer) {\n                    dialtonePlayer.play(digit);\n                }\n                else {\n                    soundCache.get(digit).play();\n                }\n            }\n            if (sequence.length) {\n                setTimeout(playNextDigit.bind(null, soundCache), 200);\n            }\n        })(this._soundcache, this.options.dialtonePlayer);\n        var dtmfSender = this.mediaStream.getOrCreateDTMFSender();\n        function insertDTMF(dtmfs) {\n            if (!dtmfs.length) {\n                return;\n            }\n            var dtmf = dtmfs.shift();\n            if (dtmf && dtmf.length) {\n                dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n            }\n            setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n        }\n        if (dtmfSender) {\n            if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n                this._log.info('Sending digits using RTCDTMFSender');\n                // NOTE(mroberts): We can't just map 'w' to ',' since\n                // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n                // like 500 ms. Instead, we will fudge it with setTimeout.\n                insertDTMF(digits.split('w'));\n                return;\n            }\n            this._log.info('RTCDTMFSender cannot insert DTMF');\n        }\n        // send pstream message to send DTMF\n        this._log.info('Sending digits over PStream');\n        if (this.pstream !== null && this.pstream.status !== 'disconnected') {\n            this.pstream.dtmf(this.parameters.CallSid, digits);\n        }\n        else {\n            var error = {\n                code: 31000,\n                connection: this,\n                message: 'Could not send DTMF: Signaling channel is disconnected',\n            };\n            this.emit('error', error);\n        }\n    };\n    /**\n     * Get the current {@link Connection} status.\n     */\n    Connection.prototype.status = function () {\n        return this._status;\n    };\n    /**\n     * @deprecated - Unmute the {@link Connection}.\n     */\n    Connection.prototype.unmute = function () {\n        this._log.warn('.unmute() is deprecated. Please use .mute(false) to unmute a call instead.');\n        this.mute(false);\n    };\n    /**\n     * @deprecated - Set a handler for the {@link volumeEvent}\n     * @param handler\n     */\n    Connection.prototype.volume = function (handler) {\n        if (!window || (!window.AudioContext && !window.webkitAudioContext)) {\n            this._log.warn('This browser does not support Connection.volume');\n        }\n        this._addHandler('volume', handler);\n    };\n    /**\n     * Add a handler for an EventEmitter and emit a deprecation warning on first call.\n     * @param eventName - Name of the event\n     * @param handler - A handler to call when the event is emitted\n     */\n    Connection.prototype._addHandler = function (eventName, handler) {\n        if (!hasBeenWarnedHandlers) {\n            this._log.warn(\"Connection callback handlers (accept, cancel, disconnect, error, ignore, mute, reject,\\n        volume) have been deprecated and will be removed in the next breaking release. Instead, the EventEmitter         interface can be used to set event listeners. Example: connection.on('\" + eventName + \"', handler)\");\n            hasBeenWarnedHandlers = true;\n        }\n        this.addListener(eventName, handler);\n        return this;\n    };\n    /**\n     * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n     * @param currentVolume - The current volume for this direction\n     * @param streakFieldName - The name of the field on the {@link Connection} object that tracks how many times the\n     *   current value has been repeated consecutively.\n     * @param lastValueFieldName - The name of the field on the {@link Connection} object that tracks the most recent\n     *   volume for this direction\n     * @param direction - The directionality of this audio track, either 'input' or 'output'\n     * @returns The current streak; how many times in a row the same value has been polled.\n     */\n    Connection.prototype._checkVolume = function (currentVolume, currentStreak, lastValue, direction) {\n        var wasWarningRaised = currentStreak >= 10;\n        var newStreak = 0;\n        if (lastValue === currentVolume) {\n            newStreak = currentStreak;\n        }\n        if (newStreak >= 10) {\n            this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, false);\n        }\n        else if (wasWarningRaised) {\n            this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, true);\n        }\n        return newStreak;\n    };\n    /**\n     * Clean up event listeners.\n     */\n    Connection.prototype._cleanupEventListeners = function () {\n        var _this = this;\n        var cleanup = function () {\n            if (!_this.pstream) {\n                return;\n            }\n            _this.pstream.removeListener('answer', _this._onAnswer);\n            _this.pstream.removeListener('cancel', _this._onCancel);\n            _this.pstream.removeListener('hangup', _this._onHangup);\n            _this.pstream.removeListener('ringing', _this._onRinging);\n            _this.pstream.removeListener('transportClose', _this._onTransportClose);\n        };\n        // This is kind of a hack, but it lets us avoid rewriting more code.\n        // Basically, there's a sequencing problem with the way PeerConnection raises\n        // the\n        //\n        //   Cannot establish connection. Client is disconnected\n        //\n        // error in Connection#accept. It calls PeerConnection#onerror, which emits\n        // the error event on Connection. An error handler on Connection then calls\n        // cleanupEventListeners, but then control returns to Connection#accept. It's\n        // at this point that we add a listener for the answer event that never gets\n        // removed. setTimeout will allow us to rerun cleanup again, _after_\n        // Connection#accept returns.\n        cleanup();\n        setTimeout(cleanup, 0);\n    };\n    /**\n     * Create the payload wrapper for a batch of metrics to be sent to Insights.\n     */\n    Connection.prototype._createMetricPayload = function () {\n        var payload = {\n            call_sid: this.parameters.CallSid,\n            dscp: !!this.options.dscp,\n            sdk_version: C.RELEASE_VERSION,\n            selected_region: this.options.selectedRegion,\n        };\n        if (this.options.gateway) {\n            payload.gateway = this.options.gateway;\n        }\n        if (this.options.region) {\n            payload.region = this.options.region;\n        }\n        payload.direction = this._direction;\n        return payload;\n    };\n    /**\n     * Disconnect the {@link Connection}.\n     * @param message - A message explaining why the {@link Connection} is being disconnected.\n     * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n     */\n    Connection.prototype._disconnect = function (message, wasRemote) {\n        message = typeof message === 'string' ? message : null;\n        if (this._status !== Connection.State.Open\n            && this._status !== Connection.State.Connecting\n            && this._status !== Connection.State.Reconnecting\n            && this._status !== Connection.State.Ringing) {\n            return;\n        }\n        this._log.info('Disconnecting...');\n        // send pstream hangup message\n        if (this.pstream !== null && this.pstream.status !== 'disconnected' && this.sendHangup) {\n            var callsid = this.parameters.CallSid || this.outboundConnectionId;\n            if (callsid) {\n                this.pstream.hangup(callsid, message);\n            }\n        }\n        this._cleanupEventListeners();\n        this.mediaStream.close();\n        if (!wasRemote) {\n            this._publisher.info('connection', 'disconnected-by-local', null, this);\n        }\n    };\n    /**\n     * Transition to {@link ConnectionStatus.Open} if criteria is met.\n     */\n    Connection.prototype._maybeTransitionToOpen = function () {\n        if (this.mediaStream && this.mediaStream.status === 'open' && this._isAnswered) {\n            this._status = Connection.State.Open;\n            this.emit('accept', this);\n        }\n    };\n    /**\n     * Post an event to Endpoint Analytics indicating that the end user\n     *   has ignored a request for feedback.\n     */\n    Connection.prototype._postFeedbackDeclined = function () {\n        return this._publisher.info('feedback', 'received-none', null, this, true);\n    };\n    /**\n     * Publish the current set of queued metrics samples to Insights.\n     */\n    Connection.prototype._publishMetrics = function () {\n        var _this = this;\n        if (this._metricsSamples.length === 0) {\n            return;\n        }\n        this._publisher.postMetrics('quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this).catch(function (e) {\n            _this._log.warn('Unable to post metrics to Insights. Received error:', e);\n        });\n    };\n    /**\n     * Set the CallSid\n     * @param payload\n     */\n    Connection.prototype._setCallSid = function (payload) {\n        var callSid = payload.callsid;\n        if (!callSid) {\n            return;\n        }\n        this.parameters.CallSid = callSid;\n        this.mediaStream.callSid = callSid;\n    };\n    /**\n     * String representation of the {@link Connection} class.\n     * @private\n     */\n    Connection.toString = function () { return '[Twilio.Connection class]'; };\n    return Connection;\n}(events_1.EventEmitter));\n(function (Connection) {\n    /**\n     * Possible states of the {@link Connection}.\n     */\n    var State;\n    (function (State) {\n        State[\"Closed\"] = \"closed\";\n        State[\"Connecting\"] = \"connecting\";\n        State[\"Open\"] = \"open\";\n        State[\"Pending\"] = \"pending\";\n        State[\"Reconnecting\"] = \"reconnecting\";\n        State[\"Ringing\"] = \"ringing\";\n    })(State = Connection.State || (Connection.State = {}));\n    /**\n     * Different issues that may have been experienced during a call, that can be\n     * reported to Twilio Insights via {@link Connection}.postFeedback().\n     */\n    var FeedbackIssue;\n    (function (FeedbackIssue) {\n        FeedbackIssue[\"AudioLatency\"] = \"audio-latency\";\n        FeedbackIssue[\"ChoppyAudio\"] = \"choppy-audio\";\n        FeedbackIssue[\"DroppedCall\"] = \"dropped-call\";\n        FeedbackIssue[\"Echo\"] = \"echo\";\n        FeedbackIssue[\"NoisyCall\"] = \"noisy-call\";\n        FeedbackIssue[\"OneWayAudio\"] = \"one-way-audio\";\n    })(FeedbackIssue = Connection.FeedbackIssue || (Connection.FeedbackIssue = {}));\n    /**\n     * A rating of call quality experienced during a call, to be reported to Twilio Insights\n     * via {@link Connection}.postFeedback().\n     */\n    var FeedbackScore;\n    (function (FeedbackScore) {\n        FeedbackScore[FeedbackScore[\"One\"] = 1] = \"One\";\n        FeedbackScore[FeedbackScore[\"Two\"] = 2] = \"Two\";\n        FeedbackScore[FeedbackScore[\"Three\"] = 3] = \"Three\";\n        FeedbackScore[FeedbackScore[\"Four\"] = 4] = \"Four\";\n        FeedbackScore[FeedbackScore[\"Five\"] = 5] = \"Five\";\n    })(FeedbackScore = Connection.FeedbackScore || (Connection.FeedbackScore = {}));\n    /**\n     * The directionality of the {@link Connection}, whether incoming or outgoing.\n     */\n    var CallDirection;\n    (function (CallDirection) {\n        CallDirection[\"Incoming\"] = \"INCOMING\";\n        CallDirection[\"Outgoing\"] = \"OUTGOING\";\n    })(CallDirection = Connection.CallDirection || (Connection.CallDirection = {}));\n    /**\n     * Valid audio codecs to use for the media connection.\n     */\n    var Codec;\n    (function (Codec) {\n        Codec[\"Opus\"] = \"opus\";\n        Codec[\"PCMU\"] = \"pcmu\";\n    })(Codec = Connection.Codec || (Connection.Codec = {}));\n    /**\n     * Possible ICE Gathering failures\n     */\n    var IceGatheringFailureReason;\n    (function (IceGatheringFailureReason) {\n        IceGatheringFailureReason[\"None\"] = \"none\";\n        IceGatheringFailureReason[\"Timeout\"] = \"timeout\";\n    })(IceGatheringFailureReason = Connection.IceGatheringFailureReason || (Connection.IceGatheringFailureReason = {}));\n    /**\n     * Possible media failures\n     */\n    var MediaFailure;\n    (function (MediaFailure) {\n        MediaFailure[\"ConnectionDisconnected\"] = \"ConnectionDisconnected\";\n        MediaFailure[\"ConnectionFailed\"] = \"ConnectionFailed\";\n        MediaFailure[\"IceGatheringFailed\"] = \"IceGatheringFailed\";\n        MediaFailure[\"LowBytes\"] = \"LowBytes\";\n    })(MediaFailure = Connection.MediaFailure || (Connection.MediaFailure = {}));\n})(Connection || (Connection = {}));\nfunction generateTempCallSid() {\n    return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        /* tslint:disable:no-bitwise */\n        var r = Math.random() * 16 | 0;\n        var v = c === 'x' ? r : (r & 0x3 | 0x8);\n        /* tslint:enable:no-bitwise */\n        return v.toString(16);\n    });\n}\nexports.default = Connection;\n//# sourceMappingURL=connection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2Nvbm5lY3Rpb24uanM/ZGI0ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQywrQ0FBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsbUVBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHlFQUFVO0FBQ2pDLFlBQVksbUJBQU8sQ0FBQyw2REFBTztBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQywrREFBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsUUFBUSxtQkFBTyxDQUFDLHlFQUFhO0FBQzdCLHFCQUFxQix1R0FBK0I7QUFDcEQsNEJBQTRCLGdIQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYSxFQUFFO0FBQzlEO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQ7QUFDQTtBQUNBLHNDQUFzQyx1Q0FBdUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0JBQW9CO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwrQkFBK0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxZQUFZLGlGQUFpRjtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdUNBQXVDLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUNBQXFDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUIsYUFBYSx1QkFBdUI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssb0RBQW9EO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnSEFBZ0g7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyx5RUFBeUU7QUFDOUUsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2Nvbm5lY3Rpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFZvaWNlXG4gKiBAcHVibGljYXBpXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBkZXZpY2VfMSA9IHJlcXVpcmUoXCIuL2RldmljZVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBsb2dfMSA9IHJlcXVpcmUoXCIuL2xvZ1wiKTtcbnZhciBpY2VjYW5kaWRhdGVfMSA9IHJlcXVpcmUoXCIuL3J0Yy9pY2VjYW5kaWRhdGVcIik7XG52YXIgc3RhdHNNb25pdG9yXzEgPSByZXF1aXJlKFwiLi9zdGF0c01vbml0b3JcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja29mZicpO1xudmFyIEMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xudmFyIFBlZXJDb25uZWN0aW9uID0gcmVxdWlyZSgnLi9ydGMnKS5QZWVyQ29ubmVjdGlvbjtcbnZhciBnZXRQcmVmZXJyZWRDb2RlY0luZm8gPSByZXF1aXJlKCcuL3J0Yy9zZHAnKS5nZXRQcmVmZXJyZWRDb2RlY0luZm87XG52YXIgQkFDS09GRl9DT05GSUcgPSB7XG4gICAgZmFjdG9yOiAxLjEsXG4gICAgaW5pdGlhbERlbGF5OiAxLFxuICAgIG1heERlbGF5OiAzMDAwMCxcbiAgICByYW5kb21pc2F0aW9uRmFjdG9yOiAwLjUsXG59O1xudmFyIERUTUZfSU5URVJfVE9ORV9HQVAgPSA3MDtcbnZhciBEVE1GX1BBVVNFX0RVUkFUSU9OID0gNTAwO1xudmFyIERUTUZfVE9ORV9EVVJBVElPTiA9IDE2MDtcbnZhciBNRVRSSUNTX0JBVENIX1NJWkUgPSAxMDtcbnZhciBNRVRSSUNTX0RFTEFZID0gNTAwMDtcbnZhciBNRURJQV9ESVNDT05ORUNUX0VSUk9SID0ge1xuICAgIGRpc2Nvbm5lY3Q6IHRydWUsXG4gICAgaW5mbzoge1xuICAgICAgICBjb2RlOiAzMTAwMyxcbiAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gd2l0aCBUd2lsaW8gd2FzIGludGVycnVwdGVkLicsXG4gICAgICAgIHR3aWxpb0Vycm9yOiBuZXcgZXJyb3JzXzEuTWVkaWFFcnJvcnMuQ29ubmVjdGlvbkVycm9yKCksXG4gICAgfSxcbn07XG52YXIgTVVMVElQTEVfVEhSRVNIT0xEX1dBUk5JTkdfTkFNRVMgPSB7XG4gICAgLy8gVGhlIHN0YXQgYHBhY2tldHNMb3N0RnJhY3Rpb25gIGlzIG1vbml0b3JlZCBieSB0d28gc2VwYXJhdGUgdGhyZXNob2xkcyxcbiAgICAvLyBgbWF4QXZlcmFnZWAgYW5kIGBtYXhgLiBFYWNoIHRocmVzaG9sZCBlbWl0cyBhIGRpZmZlcmVudCB3YXJuaW5nIG5hbWUuXG4gICAgcGFja2V0c0xvc3RGcmFjdGlvbjoge1xuICAgICAgICBtYXg6ICdwYWNrZXQtbG9zcycsXG4gICAgICAgIG1heEF2ZXJhZ2U6ICdwYWNrZXRzLWxvc3QtZnJhY3Rpb24nLFxuICAgIH0sXG59O1xudmFyIFdBUk5JTkdfTkFNRVMgPSB7XG4gICAgYXVkaW9JbnB1dExldmVsOiAnYXVkaW8taW5wdXQtbGV2ZWwnLFxuICAgIGF1ZGlvT3V0cHV0TGV2ZWw6ICdhdWRpby1vdXRwdXQtbGV2ZWwnLFxuICAgIGJ5dGVzUmVjZWl2ZWQ6ICdieXRlcy1yZWNlaXZlZCcsXG4gICAgYnl0ZXNTZW50OiAnYnl0ZXMtc2VudCcsXG4gICAgaml0dGVyOiAnaml0dGVyJyxcbiAgICBtb3M6ICdtb3MnLFxuICAgIHJ0dDogJ3J0dCcsXG59O1xudmFyIFdBUk5JTkdfUFJFRklYRVMgPSB7XG4gICAgbWF4OiAnaGlnaC0nLFxuICAgIG1heEF2ZXJhZ2U6ICdoaWdoLScsXG4gICAgbWF4RHVyYXRpb246ICdjb25zdGFudC0nLFxuICAgIG1pbjogJ2xvdy0nLFxuICAgIG1pblN0YW5kYXJkRGV2aWF0aW9uOiAnY29uc3RhbnQtJyxcbn07XG52YXIgaGFzQmVlbldhcm5lZEhhbmRsZXJzID0gZmFsc2U7XG4vKipcbiAqIEEge0BsaW5rIENvbm5lY3Rpb259IHJlcHJlc2VudHMgYSBtZWRpYSBhbmQgc2lnbmFsaW5nIGNvbm5lY3Rpb24gdG8gYSBUd2lNTCBhcHBsaWNhdGlvbi5cbiAqIEBwdWJsaWNhcGlcbiAqL1xudmFyIENvbm5lY3Rpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gTWFuZGF0b3J5IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gLSBPcHRpb25hbCBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb24oY29uZmlnLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsIHBhcmFtZXRlcnMgcmVjZWl2ZWQgZnJvbSBUd2lsaW8gZm9yIGFuIGluY29taW5nIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5wYXJhbWV0ZXJzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIGlucHV0IHZvbHVtZSBoYXMgYmVlbiB0aGUgc2FtZSBjb25zZWN1dGl2ZWx5LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2lucHV0Vm9sdW1lU3RyZWFrID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIGNhbGwgaGFzIGJlZW4gYW5zd2VyZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNBbnN3ZXJlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY2FsbCBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBwdWJsaWMgaW5wdXQgdm9sdW1lIHZhbHVlLiAwIC0+IDEgcmVwcmVzZW50aW5nIC0xMDAgdG8gLTMwIGRCLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2xhdGVzdElucHV0Vm9sdW1lID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBwdWJsaWMgb3V0cHV0IHZvbHVtZSB2YWx1ZS4gMCAtPiAxIHJlcHJlc2VudGluZyAtMTAwIHRvIC0zMCBkQi5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sYXRlc3RPdXRwdXRWb2x1bWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW5zdGFuY2Ugb2YgTG9nZ2VyIHRvIHVzZS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9sb2cgPSBsb2dfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJhdGNoIG9mIG1ldHJpY3Mgc2FtcGxlcyB0byBzZW5kIHRvIEluc2lnaHRzLiBHZXRzIGNsZWFyZWQgYWZ0ZXJcbiAgICAgICAgICogZWFjaCBzZW5kIGFuZCBhcHBlbmRlZCB0byBvbiBlYWNoIG5ldyBzYW1wbGUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbWV0cmljc1NhbXBsZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgb3V0cHV0IHZvbHVtZSBoYXMgYmVlbiB0aGUgc2FtZSBjb25zZWN1dGl2ZWx5LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX291dHB1dFZvbHVtZVN0cmVhayA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIE1hcCBvZiBTb3VuZHMgdG8gcGxheS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zb3VuZGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdGUgb2YgdGhlIHtAbGluayBDb25uZWN0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLlBlbmRpbmc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25zIHBhc3NlZCB0byB0aGlzIHtAbGluayBDb25uZWN0aW9ufS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbmFibGVSaW5naW5nU3RhdGU6IGZhbHNlLFxuICAgICAgICAgICAgbWVkaWFTdHJlYW1GYWN0b3J5OiBQZWVyQ29ubmVjdGlvbixcbiAgICAgICAgICAgIG9mZmVyU2RwOiBudWxsLFxuICAgICAgICAgICAgc2hvdWxkUGxheURpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0gc2hvdWxkIHNlbmQgYSBoYW5ndXAgb24gZGlzY29ubmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnNlbmRIYW5ndXAgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHtAbGluayBDb25uZWN0aW9ufSBpbnN0YW5jZS5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1tUd2lsaW8uQ29ubmVjdGlvbiBpbnN0YW5jZV0nOyB9O1xuICAgICAgICBfdGhpcy5fZW1pdFdhcm5pbmcgPSBmdW5jdGlvbiAoZ3JvdXBQcmVmaXgsIHdhcm5pbmdOYW1lLCB0aHJlc2hvbGQsIHZhbHVlLCB3YXNDbGVhcmVkLCB3YXJuaW5nRGF0YSkge1xuICAgICAgICAgICAgdmFyIGdyb3VwU3VmZml4ID0gd2FzQ2xlYXJlZCA/ICctY2xlYXJlZCcgOiAnLXJhaXNlZCc7XG4gICAgICAgICAgICB2YXIgZ3JvdXBOYW1lID0gZ3JvdXBQcmVmaXggKyBcIndhcm5pbmdcIiArIGdyb3VwU3VmZml4O1xuICAgICAgICAgICAgLy8gSWdub3JlIGNvbnN0YW50IGlucHV0IGlmIHRoZSBDb25uZWN0aW9uIGlzIG11dGVkIChFeHBlY3RlZClcbiAgICAgICAgICAgIGlmICh3YXJuaW5nTmFtZSA9PT0gJ2NvbnN0YW50LWF1ZGlvLWlucHV0LWxldmVsJyAmJiBfdGhpcy5pc011dGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSB3YXNDbGVhcmVkID8gJ2luZm8nIDogJ3dhcm5pbmcnO1xuICAgICAgICAgICAgLy8gQXZvaWQgdGhyb3dpbmcgZmFsc2UgcG9zaXRpdmVzIGFzIHdhcm5pbmdzIHVudGlsIHdlIHJlZmFjdG9yIHZvbHVtZSBtZXRyaWNzXG4gICAgICAgICAgICBpZiAod2FybmluZ05hbWUgPT09ICdjb25zdGFudC1hdWRpby1vdXRwdXQtbGV2ZWwnKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSAnaW5mbyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF5bG9hZERhdGEgPSB7IHRocmVzaG9sZDogdGhyZXNob2xkIH07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkRGF0YS52YWx1ZXMgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsICogMTAwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkRGF0YS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIucG9zdChsZXZlbCwgZ3JvdXBOYW1lLCB3YXJuaW5nTmFtZSwgeyBkYXRhOiBwYXlsb2FkRGF0YSB9LCBfdGhpcyk7XG4gICAgICAgICAgICBpZiAod2FybmluZ05hbWUgIT09ICdjb25zdGFudC1hdWRpby1vdXRwdXQtbGV2ZWwnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVtaXROYW1lID0gd2FzQ2xlYXJlZCA/ICd3YXJuaW5nLWNsZWFyZWQnIDogJ3dhcm5pbmcnO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoZW1pdE5hbWUsIHdhcm5pbmdOYW1lLCB3YXJuaW5nRGF0YSAmJiAhd2FzQ2xlYXJlZCA/IHdhcm5pbmdEYXRhIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUge0BsaW5rIENvbm5lY3Rpb259IGlzIGFuc3dlcmVkLlxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uQW5zd2VyID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8vIGFuc3dlck9uQnJpZGdlPWZhbHNlIHdpbGwgc2VuZCBhIDE4MyB3aGljaCB3ZSBuZWVkIHRvIGNhdGNoIGluIF9vblJpbmdpbmcgd2hlblxuICAgICAgICAgICAgLy8gdGhlIGVuYWJsZVJpbmdpbmdTdGF0ZSBmbGFnIGlzIGRpc2FibGVkLiBJbiB0aGF0IGNhc2UsIHdlIHdpbGwgcmVjZWl2ZSBhIDIwMCBhZnRlclxuICAgICAgICAgICAgLy8gdGhlIGNhbGxlZSBhY2NlcHRzIHRoZSBjYWxsIGZpcmluZyBhIHNlY29uZCBgYWNjZXB0YCBldmVudCBpZiB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gc2hvcnQgY2lyY3VpdCBoZXJlLlxuICAgICAgICAgICAgaWYgKF90aGlzLl9pc0Fuc3dlcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3NldENhbGxTaWQocGF5bG9hZCk7XG4gICAgICAgICAgICBfdGhpcy5faXNBbnN3ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5fbWF5YmVUcmFuc2l0aW9uVG9PcGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUge0BsaW5rIENvbm5lY3Rpb259IGlzIGNhbmNlbGxlZC5cbiAgICAgICAgICogQHBhcmFtIHBheWxvYWRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbkNhbmNlbCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAvLyAocnJvd2xhbmQpIElzIHRoaXMgY2hlY2sgbmVjZXNzYXJ5PyBWZXJpZnksIGFuZCBpZiBzbyBtb3ZlIHRvIHBzdHJlYW0gLyBWU1AgbW9kdWxlLlxuICAgICAgICAgICAgdmFyIGNhbGxzaWQgPSBwYXlsb2FkLmNhbGxzaWQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMucGFyYW1ldGVycy5DYWxsU2lkID09PSBjYWxsc2lkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmluZm8oJ2Nvbm5lY3Rpb24nLCAnY2FuY2VsJywgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jbGVhbnVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLkNsb3NlZDtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdjYW5jZWwnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjYW5jZWwnLCBfdGhpcy5fb25DYW5jZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIHtAbGluayBDb25uZWN0aW9ufSBpcyBodW5nIHVwLlxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uSGFuZ3VwID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogIHNlZSBpZiBjYWxsc2lkIHBhc3NlZCBpbiBtZXNzYWdlIG1hdGNoZXMgZWl0aGVyIGNhbGxzaWQgb3Igb3V0Ym91bmQgaWRcbiAgICAgICAgICAgICAqICBjb25uZWN0aW9uIHNob3VsZCBhbHdheXMgaGF2ZSBlaXRoZXIgY2FsbHNpZCBvciBvdXRib3VuZCBpZFxuICAgICAgICAgICAgICogIGlmIG5vIGNhbGxzaWQgcGFzc2VkIGhhbmd1cCBhbnl3YXlzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmNhbGxzaWQgJiYgKF90aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCB8fCBfdGhpcy5vdXRib3VuZENvbm5lY3Rpb25JZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5jYWxsc2lkICE9PSBfdGhpcy5wYXJhbWV0ZXJzLkNhbGxTaWRcbiAgICAgICAgICAgICAgICAgICAgJiYgcGF5bG9hZC5jYWxsc2lkICE9PSBfdGhpcy5vdXRib3VuZENvbm5lY3Rpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF5bG9hZC5jYWxsc2lkKSB7XG4gICAgICAgICAgICAgICAgLy8gaGFuZ3VwIGlzIGZvciBhbm90aGVyIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ1JlY2VpdmVkIEhBTkdVUCBmcm9tIGdhdGV3YXknKTtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBwYXlsb2FkLmVycm9yLmNvZGUgfHwgMzEwMDAsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb246IF90aGlzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXlsb2FkLmVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIHNlbnQgZnJvbSBnYXRld2F5IGluIEhBTkdVUCcsXG4gICAgICAgICAgICAgICAgICAgIHR3aWxpb0Vycm9yOiBuZXcgZXJyb3JzXzEuR2VuZXJhbEVycm9ycy5Db25uZWN0aW9uRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoJ1JlY2VpdmVkIGFuIGVycm9yIGZyb20gdGhlIGdhdGV3YXk6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2VuZEhhbmd1cCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgJ2Rpc2Nvbm5lY3RlZC1ieS1yZW1vdGUnLCBudWxsLCBfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5fZGlzY29ubmVjdChudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIF90aGlzLl9jbGVhbnVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgbWVkaWEgZmFpbHVyZS5cbiAgICAgICAgICogTWFuYWdlcyBhbGwgbWVkaWEtcmVsYXRlZCBzdGF0ZXMgYW5kIHRha2VzIGFjdGlvbiBiYXNlIG9uIHRoZSBzdGF0ZXNcbiAgICAgICAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIG1lZGlhIGZhaWx1cmVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vbk1lZGlhRmFpbHVyZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBDb25uZWN0aW9uLk1lZGlhRmFpbHVyZSwgQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCA9IF9hLkNvbm5lY3Rpb25EaXNjb25uZWN0ZWQsIENvbm5lY3Rpb25GYWlsZWQgPSBfYS5Db25uZWN0aW9uRmFpbGVkLCBJY2VHYXRoZXJpbmdGYWlsZWQgPSBfYS5JY2VHYXRoZXJpbmdGYWlsZWQsIExvd0J5dGVzID0gX2EuTG93Qnl0ZXM7XG4gICAgICAgICAgICAvLyBUaGVzZSB0eXBlcyBzaWduaWZpZXMgdGhlIGVuZCBvZiBhIHNpbmdsZSBJQ0UgY3ljbGVcbiAgICAgICAgICAgIHZhciBpc0VuZE9mSWNlQ3ljbGUgPSB0eXBlID09PSBDb25uZWN0aW9uRmFpbGVkIHx8IHR5cGUgPT09IEljZUdhdGhlcmluZ0ZhaWxlZDtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3Igb24gaWNlIGZhaWx1cmVzIHdpdGggZGlzYWJsZWQgaWNlIHJlc3RhcnQuXG4gICAgICAgICAgICBpZiAoKCFfdGhpcy5vcHRpb25zLmVuYWJsZUljZVJlc3RhcnQgJiYgaXNFbmRPZkljZUN5Y2xlKVxuICAgICAgICAgICAgICAgIC8vIEFsbCBicm93c2VycyBleGNlcHQgY2hyb21lIGRvZXNuJ3QgdXBkYXRlIHBjLmljZUNvbm5lY3Rpb25TdGF0ZSBhbmQgcGMuY29ubmVjdGlvblN0YXRlXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgaXNzdWluZyBhbiBJQ0UgUmVzdGFydCwgd2hpY2ggd2UgdXNlIHRvIGRldGVybWluZSBpZiBJQ0UgUmVzdGFydCBpcyBjb21wbGV0ZS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBjYW5ub3QgZGV0ZWN0IGlmIElDRSBSZXN0YXJ0IGlzIGNvbXBsZXRlLCB3ZSB3aWxsIG5vdCByZXRyeS5cbiAgICAgICAgICAgICAgICB8fCAoIXV0aWxfMS5pc0Nocm9tZSh3aW5kb3csIHdpbmRvdy5uYXZpZ2F0b3IpICYmIHR5cGUgPT09IENvbm5lY3Rpb25GYWlsZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1lZGlhU3RyZWFtLm9uZXJyb3IoTUVESUFfRElTQ09OTkVDVF9FUlJPUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IG90aGVyIHR5cGUgb2YgbWVkaWEgZmFpbHVyZSBpZiBpY2UgcmVzdGFydCBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmVuYWJsZUljZVJlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZ25vcmUgc3Vic2VxdWVudCByZXF1ZXN0cyBpZiBpY2UgcmVzdGFydCBpcyBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0dXMgPT09IENvbm5lY3Rpb24uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHJldHJ5LiBQcmV2aW91cyBJQ0UgUmVzdGFydCBmYWlsZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNFbmRPZkljZUN5Y2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFscmVhZHkgZXhjZWVkZWQgbWF4IHJldHJ5IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIC0gX3RoaXMuX21lZGlhUmVjb25uZWN0U3RhcnRUaW1lID4gQkFDS09GRl9DT05GSUcubWF4RGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbygnRXhjZWVkZWQgbWF4IElDRSByZXRyaWVzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWVkaWFTdHJlYW0ub25lcnJvcihNRURJQV9ESVNDT05ORUNUX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJc3N1ZSBJQ0UgcmVzdGFydCB3aXRoIGJhY2tvZmZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX21lZGlhUmVjb25uZWN0QmFja29mZi5iYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYyA9IF90aGlzLm1lZGlhU3RyZWFtLnZlcnNpb24ucGM7XG4gICAgICAgICAgICB2YXIgaXNJY2VEaXNjb25uZWN0ZWQgPSBwYyAmJiBwYy5pY2VDb25uZWN0aW9uU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICAgICAgdmFyIGhhc0xvd0J5dGVzV2FybmluZyA9IF90aGlzLl9tb25pdG9yLmhhc0FjdGl2ZVdhcm5pbmcoJ2J5dGVzU2VudCcsICdtaW4nKVxuICAgICAgICAgICAgICAgIHx8IF90aGlzLl9tb25pdG9yLmhhc0FjdGl2ZVdhcm5pbmcoJ2J5dGVzUmVjZWl2ZWQnLCAnbWluJyk7XG4gICAgICAgICAgICAvLyBPbmx5IGNlcnRhaW4gY29uZGl0aW9ucyBjYW4gdHJpZ2dlciBtZWRpYSByZWNvbm5lY3Rpb25cbiAgICAgICAgICAgIGlmICgodHlwZSA9PT0gTG93Qnl0ZXMgJiYgaXNJY2VEaXNjb25uZWN0ZWQpXG4gICAgICAgICAgICAgICAgfHwgKHR5cGUgPT09IENvbm5lY3Rpb25EaXNjb25uZWN0ZWQgJiYgaGFzTG93Qnl0ZXNXYXJuaW5nKVxuICAgICAgICAgICAgICAgIHx8IGlzRW5kT2ZJY2VDeWNsZSkge1xuICAgICAgICAgICAgICAgIHZhciBtZWRpYVJlY29ubmVjdGlvbkVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiA1MzQwNSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ01lZGlhIGNvbm5lY3Rpb24gZmFpbGVkLicsXG4gICAgICAgICAgICAgICAgICAgIHR3aWxpb0Vycm9yOiBuZXcgZXJyb3JzXzEuTWVkaWFFcnJvcnMuQ29ubmVjdGlvbkVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbG9nLndhcm4oJ0lDRSBDb25uZWN0aW9uIGRpc2Nvbm5lY3RlZC4nKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLndhcm4oJ2Nvbm5lY3Rpb24nLCAnZXJyb3InLCBtZWRpYVJlY29ubmVjdGlvbkVycm9yLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgJ3JlY29ubmVjdGluZycsIG51bGwsIF90aGlzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWVkaWFSZWNvbm5lY3RTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLlJlY29ubmVjdGluZztcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWVkaWFSZWNvbm5lY3RCYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21lZGlhUmVjb25uZWN0QmFja29mZi5iYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncmVjb25uZWN0aW5nJywgbWVkaWFSZWNvbm5lY3Rpb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBtZWRpYSBjb25uZWN0aW9uIGlzIHJlc3RvcmVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25NZWRpYVJlY29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT25seSB0cmlnZ2VyIG9uY2UuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiB0cmlnZ2VyIG9uIHBjLm9uSWNlQ29ubmVjdGlvbkNoYW5nZSBhbmQgcGMub25Db25uZWN0aW9uQ2hhbmdlLlxuICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0dXMgIT09IENvbm5lY3Rpb24uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX2xvZy5pbmZvKCdJQ0UgQ29ubmVjdGlvbiByZWVzdGFibGlzaGVkLicpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgJ3JlY29ubmVjdGVkJywgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuX3N0YXR1cyA9IENvbm5lY3Rpb24uU3RhdGUuT3BlbjtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3JlY29ubmVjdGVkJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHdlIGdldCBhIFJJTkdJTkcgc2lnbmFsIGZyb20gUFN0cmVhbSwgdXBkYXRlIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0gc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0gcGF5bG9hZFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uUmluZ2luZyA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgICAgICBfdGhpcy5fc2V0Q2FsbFNpZChwYXlsb2FkKTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBpbiAnY29ubmVjdGluZycgb3IgJ3JpbmdpbmcnIHN0YXRlLCB0aGlzIGV2ZW50IHdhcyByZWNlaXZlZCBvdXQgb2Ygb3JkZXIuXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXR1cyAhPT0gQ29ubmVjdGlvbi5TdGF0ZS5Db25uZWN0aW5nICYmIF90aGlzLl9zdGF0dXMgIT09IENvbm5lY3Rpb24uU3RhdGUuUmluZ2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoYXNFYXJseU1lZGlhID0gISFwYXlsb2FkLnNkcDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmVuYWJsZVJpbmdpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLlJpbmdpbmc7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgJ291dGdvaW5nLXJpbmdpbmcnLCB7IGhhc0Vhcmx5TWVkaWE6IGhhc0Vhcmx5TWVkaWEgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3JpbmdpbmcnLCBoYXNFYXJseU1lZGlhKTtcbiAgICAgICAgICAgICAgICAvLyBhbnN3ZXJPbkJyaWRnZT1mYWxzZSB3aWxsIHNlbmQgYSAxODMsIHdoaWNoIHdlIG5lZWQgdG8gaW50ZXJwcmV0IGFzIGBhbnN3ZXJgIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgZW5hYmxlUmluZ2luZ1N0YXRlIGZsYWcgaXMgZGlzYWJsZWQgaW4gb3JkZXIgdG8gbWFpbnRhaW4gYSBub24tYnJlYWtpbmcgQVBJIGZyb20gMS40LjI0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNFYXJseU1lZGlhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX29uQW5zd2VyKHBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGVhY2ggdGltZSBTdGF0c01vbml0b3IgZW1pdHMgYSBzYW1wbGUuXG4gICAgICAgICAqIEVtaXRzIHN0YXRzIGV2ZW50IGFuZCBiYXRjaGVzIHRoZSBjYWxsIHN0YXRzIG1ldHJpY3MgYW5kIHNlbmRzIHRoZW0gdG8gSW5zaWdodHMuXG4gICAgICAgICAqIEBwYXJhbSBzYW1wbGVcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblJUQ1NhbXBsZSA9IGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsTWV0cmljcyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBzYW1wbGUpLCB7IGlucHV0Vm9sdW1lOiBfdGhpcy5fbGF0ZXN0SW5wdXRWb2x1bWUsIG91dHB1dFZvbHVtZTogX3RoaXMuX2xhdGVzdE91dHB1dFZvbHVtZSB9KTtcbiAgICAgICAgICAgIF90aGlzLl9jb2RlYyA9IGNhbGxNZXRyaWNzLmNvZGVjTmFtZTtcbiAgICAgICAgICAgIF90aGlzLl9tZXRyaWNzU2FtcGxlcy5wdXNoKGNhbGxNZXRyaWNzKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fbWV0cmljc1NhbXBsZXMubGVuZ3RoID49IE1FVFJJQ1NfQkFUQ0hfU0laRSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoTWV0cmljcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnc2FtcGxlJywgc2FtcGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHdlIHJlY2VpdmUgYSB0cmFuc3BvcnRDbG9zZSBldmVudCBmcm9tIHBzdHJlYW0uXG4gICAgICAgICAqIFJlLWVtaXRzIHRoZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblRyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xvZy5lcnJvcignUmVjZWl2ZWQgdHJhbnNwb3J0Q2xvc2UgZnJvbSBwc3RyZWFtJyk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCd0cmFuc3BvcnRDbG9zZScpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmUtZW1pdCBhbiBTdGF0c01vbml0b3Igd2FybmluZyBhcyBhIHtAbGluayBDb25uZWN0aW9ufS53YXJuaW5nIG9yIC53YXJuaW5nLWNsZWFyZWQgZXZlbnQuXG4gICAgICAgICAqIEBwYXJhbSB3YXJuaW5nRGF0YVxuICAgICAgICAgKiBAcGFyYW0gd2FzQ2xlYXJlZCAtIFdoZXRoZXIgdGhpcyBpcyBhIC1jbGVhcmVkIG9yIC1yYWlzZWQgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcmVlbWl0V2FybmluZyA9IGZ1bmN0aW9uICh3YXJuaW5nRGF0YSwgd2FzQ2xlYXJlZCkge1xuICAgICAgICAgICAgdmFyIGdyb3VwUHJlZml4ID0gL15hdWRpby8udGVzdCh3YXJuaW5nRGF0YS5uYW1lKSA/XG4gICAgICAgICAgICAgICAgJ2F1ZGlvLWxldmVsLScgOiAnbmV0d29yay1xdWFsaXR5LSc7XG4gICAgICAgICAgICB2YXIgd2FybmluZ1ByZWZpeCA9IFdBUk5JTkdfUFJFRklYRVNbd2FybmluZ0RhdGEudGhyZXNob2xkLm5hbWVdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBhcmUgdHdvIFwicGFja2V0LWxvc3NcIiB3YXJuaW5nczogYGhpZ2gtcGFja2V0LWxvc3NgIGFuZFxuICAgICAgICAgICAgICogYGhpZ2gtcGFja2V0cy1sb3N0LWZyYWN0aW9uYCwgc28gaW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gdXNlIGEgZGlmZmVyZW50XG4gICAgICAgICAgICAgKiBgV0FSTklOR19OQU1FYCBtYXBwaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgd2FybmluZ05hbWU7XG4gICAgICAgICAgICBpZiAod2FybmluZ0RhdGEubmFtZSBpbiBNVUxUSVBMRV9USFJFU0hPTERfV0FSTklOR19OQU1FUykge1xuICAgICAgICAgICAgICAgIHdhcm5pbmdOYW1lID0gTVVMVElQTEVfVEhSRVNIT0xEX1dBUk5JTkdfTkFNRVNbd2FybmluZ0RhdGEubmFtZV1bd2FybmluZ0RhdGEudGhyZXNob2xkLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAod2FybmluZ0RhdGEubmFtZSBpbiBXQVJOSU5HX05BTUVTKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZ05hbWUgPSBXQVJOSU5HX05BTUVTW3dhcm5pbmdEYXRhLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdhcm5pbmcgPSB3YXJuaW5nUHJlZml4ICsgd2FybmluZ05hbWU7XG4gICAgICAgICAgICBfdGhpcy5fZW1pdFdhcm5pbmcoZ3JvdXBQcmVmaXgsIHdhcm5pbmcsIHdhcm5pbmdEYXRhLnRocmVzaG9sZC52YWx1ZSwgd2FybmluZ0RhdGEudmFsdWVzIHx8IHdhcm5pbmdEYXRhLnZhbHVlLCB3YXNDbGVhcmVkLCB3YXJuaW5nRGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1lbWl0IGFuIFN0YXRzTW9uaXRvciB3YXJuaW5nLWNsZWFyZWQgYXMgYSAud2FybmluZy1jbGVhcmVkIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0gd2FybmluZ0RhdGFcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9yZWVtaXRXYXJuaW5nQ2xlYXJlZCA9IGZ1bmN0aW9uICh3YXJuaW5nRGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuX3JlZW1pdFdhcm5pbmcod2FybmluZ0RhdGEsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5faXNVbmlmaWVkUGxhbkRlZmF1bHQgPSBjb25maWcuaXNVbmlmaWVkUGxhbkRlZmF1bHQ7XG4gICAgICAgIF90aGlzLl9zb3VuZGNhY2hlID0gY29uZmlnLnNvdW5kY2FjaGU7XG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBvcHRpb25zICYmIG9wdGlvbnMudHdpbWxQYXJhbXMgfHwge307XG4gICAgICAgIF90aGlzLmN1c3RvbVBhcmFtZXRlcnMgPSBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKF90aGlzLm1lc3NhZ2UpLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYVswXSwgdmFsID0gX2FbMV07XG4gICAgICAgICAgICByZXR1cm4gW2tleSwgU3RyaW5nKHZhbCldO1xuICAgICAgICB9KSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oX3RoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmNhbGxQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBfdGhpcy5wYXJhbWV0ZXJzID0gX3RoaXMub3B0aW9ucy5jYWxsUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5fZGlyZWN0aW9uID0gX3RoaXMucGFyYW1ldGVycy5DYWxsU2lkID8gQ29ubmVjdGlvbi5DYWxsRGlyZWN0aW9uLkluY29taW5nIDogQ29ubmVjdGlvbi5DYWxsRGlyZWN0aW9uLk91dGdvaW5nO1xuICAgICAgICBpZiAoX3RoaXMuX2RpcmVjdGlvbiA9PT0gQ29ubmVjdGlvbi5DYWxsRGlyZWN0aW9uLkluY29taW5nICYmIF90aGlzLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbGxlckluZm8gPSBfdGhpcy5wYXJhbWV0ZXJzLlN0aXJTdGF0dXNcbiAgICAgICAgICAgICAgICA/IHsgaXNWZXJpZmllZDogX3RoaXMucGFyYW1ldGVycy5TdGlyU3RhdHVzID09PSAnVE4tVmFsaWRhdGlvbi1QYXNzZWQtQScgfVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmNhbGxlckluZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9tZWRpYVJlY29ubmVjdEJhY2tvZmYgPSBCYWNrb2ZmLmV4cG9uZW50aWFsKEJBQ0tPRkZfQ09ORklHKTtcbiAgICAgICAgX3RoaXMuX21lZGlhUmVjb25uZWN0QmFja29mZi5vbigncmVhZHknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZWRpYVN0cmVhbS5pY2VSZXN0YXJ0KCk7IH0pO1xuICAgICAgICAvLyB0ZW1wb3JhcnkgY2FsbCBzaWQgdG8gYmUgdXNlZCBmb3Igb3V0Z29pbmcgY2FsbHNcbiAgICAgICAgX3RoaXMub3V0Ym91bmRDb25uZWN0aW9uSWQgPSBnZW5lcmF0ZVRlbXBDYWxsU2lkKCk7XG4gICAgICAgIHZhciBwdWJsaXNoZXIgPSBfdGhpcy5fcHVibGlzaGVyID0gY29uZmlnLnB1Ymxpc2hlcjtcbiAgICAgICAgaWYgKF90aGlzLl9kaXJlY3Rpb24gPT09IENvbm5lY3Rpb24uQ2FsbERpcmVjdGlvbi5JbmNvbWluZykge1xuICAgICAgICAgICAgcHVibGlzaGVyLmluZm8oJ2Nvbm5lY3Rpb24nLCAnaW5jb21pbmcnLCBudWxsLCBfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwdWJsaXNoZXIuaW5mbygnY29ubmVjdGlvbicsICdvdXRnb2luZycsIHsgcHJlZmxpZ2h0OiBfdGhpcy5vcHRpb25zLnByZWZsaWdodCB9LCBfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vbml0b3IgPSBfdGhpcy5fbW9uaXRvciA9IG5ldyAoX3RoaXMub3B0aW9ucy5TdGF0c01vbml0b3IgfHwgc3RhdHNNb25pdG9yXzEuZGVmYXVsdCkoKTtcbiAgICAgICAgbW9uaXRvci5vbignc2FtcGxlJywgX3RoaXMuX29uUlRDU2FtcGxlKTtcbiAgICAgICAgLy8gRmlyc3QgMjAgc2Vjb25kcyBvciBzbyBhcmUgY2hvcHB5LCBzbyBsZXQncyBub3QgYm90aGVyIHdpdGggdGhlc2Ugd2FybmluZ3MuXG4gICAgICAgIG1vbml0b3IuZGlzYWJsZVdhcm5pbmdzKCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbW9uaXRvci5lbmFibGVXYXJuaW5ncygpOyB9LCBNRVRSSUNTX0RFTEFZKTtcbiAgICAgICAgbW9uaXRvci5vbignd2FybmluZycsIGZ1bmN0aW9uIChkYXRhLCB3YXNDbGVhcmVkKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5uYW1lID09PSAnYnl0ZXNTZW50JyB8fCBkYXRhLm5hbWUgPT09ICdieXRlc1JlY2VpdmVkJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vbk1lZGlhRmFpbHVyZShDb25uZWN0aW9uLk1lZGlhRmFpbHVyZS5Mb3dCeXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmVlbWl0V2FybmluZyhkYXRhLCB3YXNDbGVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vbml0b3Iub24oJ3dhcm5pbmctY2xlYXJlZCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVlbWl0V2FybmluZ0NsZWFyZWQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyAoX3RoaXMub3B0aW9ucy5NZWRpYVN0cmVhbSB8fCBfdGhpcy5vcHRpb25zLm1lZGlhU3RyZWFtRmFjdG9yeSkoY29uZmlnLmF1ZGlvSGVscGVyLCBjb25maWcucHN0cmVhbSwgY29uZmlnLmdldFVzZXJNZWRpYSwge1xuICAgICAgICAgICAgY29kZWNQcmVmZXJlbmNlczogX3RoaXMub3B0aW9ucy5jb2RlY1ByZWZlcmVuY2VzLFxuICAgICAgICAgICAgZHNjcDogX3RoaXMub3B0aW9ucy5kc2NwLFxuICAgICAgICAgICAgZW5hYmxlSWNlUmVzdGFydDogX3RoaXMub3B0aW9ucy5lbmFibGVJY2VSZXN0YXJ0LFxuICAgICAgICAgICAgZm9yY2VBZ2dyZXNzaXZlSWNlTm9taW5hdGlvbjogX3RoaXMub3B0aW9ucy5mb3JjZUFnZ3Jlc3NpdmVJY2VOb21pbmF0aW9uLFxuICAgICAgICAgICAgaXNVbmlmaWVkUGxhbjogX3RoaXMuX2lzVW5pZmllZFBsYW5EZWZhdWx0LFxuICAgICAgICAgICAgbWF4QXZlcmFnZUJpdHJhdGU6IF90aGlzLm9wdGlvbnMubWF4QXZlcmFnZUJpdHJhdGUsXG4gICAgICAgICAgICBwcmVmbGlnaHQ6IF90aGlzLm9wdGlvbnMucHJlZmxpZ2h0LFxuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXMub24oJ3ZvbHVtZScsIGZ1bmN0aW9uIChpbnB1dFZvbHVtZSwgb3V0cHV0Vm9sdW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5faW5wdXRWb2x1bWVTdHJlYWsgPSBfdGhpcy5fY2hlY2tWb2x1bWUoaW5wdXRWb2x1bWUsIF90aGlzLl9pbnB1dFZvbHVtZVN0cmVhaywgX3RoaXMuX2xhdGVzdElucHV0Vm9sdW1lLCAnaW5wdXQnKTtcbiAgICAgICAgICAgIF90aGlzLl9vdXRwdXRWb2x1bWVTdHJlYWsgPSBfdGhpcy5fY2hlY2tWb2x1bWUob3V0cHV0Vm9sdW1lLCBfdGhpcy5fb3V0cHV0Vm9sdW1lU3RyZWFrLCBfdGhpcy5fbGF0ZXN0T3V0cHV0Vm9sdW1lLCAnb3V0cHV0Jyk7XG4gICAgICAgICAgICBfdGhpcy5fbGF0ZXN0SW5wdXRWb2x1bWUgPSBpbnB1dFZvbHVtZTtcbiAgICAgICAgICAgIF90aGlzLl9sYXRlc3RPdXRwdXRWb2x1bWUgPSBvdXRwdXRWb2x1bWU7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbnZvbHVtZSA9IGZ1bmN0aW9uIChpbnB1dFZvbHVtZSwgb3V0cHV0Vm9sdW1lLCBpbnRlcm5hbElucHV0Vm9sdW1lLCBpbnRlcm5hbE91dHB1dFZvbHVtZSkge1xuICAgICAgICAgICAgLy8gKHJyb3dsYW5kKSBUaGVzZSB2YWx1ZXMgbW9jayB0aGUgMCAtPiAzMjc2NyBmb3JtYXQgdXNlZCBieSBsZWdhY3kgZ2V0U3RhdHMuIFdlIHNob3VsZCBsb29rIGludG9cbiAgICAgICAgICAgIC8vIG1pZ3JhdGluZyB0byBhIG5ld2VyIHN0YW5kYXJkLCBlaXRoZXIgMC4wIC0+IGxpbmVhciBvciAtMTI3IHRvIDAgaW4gZEIsIG1hdGNoaW5nIHRoZSByYW5nZVxuICAgICAgICAgICAgLy8gY2hvc2VuIGJlbG93LlxuICAgICAgICAgICAgbW9uaXRvci5hZGRWb2x1bWVzKChpbnRlcm5hbElucHV0Vm9sdW1lIC8gMjU1KSAqIDMyNzY3LCAoaW50ZXJuYWxPdXRwdXRWb2x1bWUgLyAyNTUpICogMzI3NjcpO1xuICAgICAgICAgICAgLy8gKHJyb3dsYW5kKSAwLjAgLT4gMS4wIGxpbmVhclxuICAgICAgICAgICAgX3RoaXMuZW1pdCgndm9sdW1lJywgaW5wdXRWb2x1bWUsIG91dHB1dFZvbHVtZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLm9uZHRsc3RyYW5zcG9ydHN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbGV2ZWwgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyAnZXJyb3InIDogJ2RlYnVnJztcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIucG9zdChsZXZlbCwgJ2R0bHMtdHJhbnNwb3J0LXN0YXRlJywgc3RhdGUsIG51bGwsIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25wY2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIGxldmVsID0gJ2RlYnVnJztcbiAgICAgICAgICAgIHZhciBkdGxzVHJhbnNwb3J0ID0gX3RoaXMubWVkaWFTdHJlYW0uZ2V0UlRDRHRsc1RyYW5zcG9ydCgpO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgICAgIGxldmVsID0gZHRsc1RyYW5zcG9ydCAmJiBkdGxzVHJhbnNwb3J0LnN0YXRlID09PSAnZmFpbGVkJyA/ICdlcnJvcicgOiAnd2FybmluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLnBvc3QobGV2ZWwsICdwYy1jb25uZWN0aW9uLXN0YXRlJywgc3RhdGUsIG51bGwsIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25pY2VjYW5kaWRhdGUgPSBmdW5jdGlvbiAoY2FuZGlkYXRlKSB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ldyBpY2VjYW5kaWRhdGVfMS5JY2VDYW5kaWRhdGUoY2FuZGlkYXRlKS50b1BheWxvYWQoKTtcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIuZGVidWcoJ2ljZS1jYW5kaWRhdGUnLCAnaWNlLWNhbmRpZGF0ZScsIHBheWxvYWQsIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25zZWxlY3RlZGNhbmRpZGF0ZXBhaXJjaGFuZ2UgPSBmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2FuZGlkYXRlUGF5bG9hZCA9IG5ldyBpY2VjYW5kaWRhdGVfMS5JY2VDYW5kaWRhdGUocGFpci5sb2NhbCkudG9QYXlsb2FkKCk7XG4gICAgICAgICAgICB2YXIgcmVtb3RlQ2FuZGlkYXRlUGF5bG9hZCA9IG5ldyBpY2VjYW5kaWRhdGVfMS5JY2VDYW5kaWRhdGUocGFpci5yZW1vdGUsIHRydWUpLnRvUGF5bG9hZCgpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5kZWJ1ZygnaWNlLWNhbmRpZGF0ZScsICdzZWxlY3RlZC1pY2UtY2FuZGlkYXRlLXBhaXInLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxfY2FuZGlkYXRlOiBsb2NhbENhbmRpZGF0ZVBheWxvYWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NhbmRpZGF0ZTogcmVtb3RlQ2FuZGlkYXRlUGF5bG9hZCxcbiAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IHN0YXRlID09PSAnZmFpbGVkJyA/ICdlcnJvcicgOiAnZGVidWcnO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5wb3N0KGxldmVsLCAnaWNlLWNvbm5lY3Rpb24tc3RhdGUnLCBzdGF0ZSwgbnVsbCwgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbmljZWdhdGhlcmluZ2ZhaWx1cmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci53YXJuKCdpY2UtZ2F0aGVyaW5nLXN0YXRlJywgdHlwZSwgbnVsbCwgX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuX29uTWVkaWFGYWlsdXJlKENvbm5lY3Rpb24uTWVkaWFGYWlsdXJlLkljZUdhdGhlcmluZ0ZhaWxlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLm9uaWNlZ2F0aGVyaW5nc3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIuZGVidWcoJ2ljZS1nYXRoZXJpbmctc3RhdGUnLCBzdGF0ZSwgbnVsbCwgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmRlYnVnKCdzaWduYWxpbmctc3RhdGUnLCBzdGF0ZSwgbnVsbCwgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbmRpc2Nvbm5lY3RlZCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhtc2cpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci53YXJuKCduZXR3b3JrLXF1YWxpdHktd2FybmluZy1yYWlzZWQnLCAnaWNlLWNvbm5lY3Rpdml0eS1sb3N0Jywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3dhcm5pbmcnLCAnaWNlLWNvbm5lY3Rpdml0eS1sb3N0Jyk7XG4gICAgICAgICAgICBfdGhpcy5fb25NZWRpYUZhaWx1cmUoQ29ubmVjdGlvbi5NZWRpYUZhaWx1cmUuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLm9uZmFpbGVkID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgX3RoaXMuX29uTWVkaWFGYWlsdXJlKENvbm5lY3Rpb24uTWVkaWFGYWlsdXJlLkNvbm5lY3Rpb25GYWlsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbmNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRpbWUgbWVkaWFTdHJlYW0gaXMgY29ubmVjdGVkLCBidXQgSUNFIEdhdGhlcmluZyBpc3N1ZWQgYW4gSUNFIHJlc3RhcnQgYW5kIHN1Y2NlZWRlZC5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdHVzID09PSBDb25uZWN0aW9uLlN0YXRlLlJlY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vbk1lZGlhUmVjb25uZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25yZWNvbm5lY3RlZCA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhtc2cpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCduZXR3b3JrLXF1YWxpdHktd2FybmluZy1jbGVhcmVkJywgJ2ljZS1jb25uZWN0aXZpdHktbG9zdCcsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCd3YXJuaW5nLWNsZWFyZWQnLCAnaWNlLWNvbm5lY3Rpdml0eS1sb3N0Jyk7XG4gICAgICAgICAgICBfdGhpcy5fb25NZWRpYVJlY29ubmVjdGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLm9uZXJyb3IgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUuZGlzY29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kaXNjb25uZWN0KGUuaW5mbyAmJiBlLmluZm8ubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogZS5pbmZvLmNvZGUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbjogX3RoaXMsXG4gICAgICAgICAgICAgICAgaW5mbzogZS5pbmZvLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUuaW5mby5tZXNzYWdlIHx8ICdFcnJvciB3aXRoIG1lZGlhc3RyZWFtJyxcbiAgICAgICAgICAgICAgICB0d2lsaW9FcnJvcjogZS5pbmZvLnR3aWxpb0Vycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuZXJyb3IoJ1JlY2VpdmVkIGFuIGVycm9yIGZyb20gTWVkaWFTdHJlYW06JywgZSk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gTk9URShtcm9iZXJ0cyk6IFdoaWxlIHRoaXMgbWF5IGhhdmUgYmVlbiBoYXBwZW5pbmcgaW4gcHJldmlvdXNcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIENocm9tZSwgc2luY2UgQ2hyb21lIDQ1IHdlIGhhdmUgc2VlbiB0aGVcbiAgICAgICAgICAgIC8vIFBlZXJDb25uZWN0aW9uJ3Mgb25zaWduYWxpbmdzdGF0ZWNoYW5nZSBoYW5kbGVyIGludm9rZWQgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIHRpbWVzIGluIHRoZSBzYW1lIHNpZ25hbGluZ1N0YXRlICdzdGFibGUnLiBXaGVuIHRoaXMgaGFwcGVucywgd2VcbiAgICAgICAgICAgIC8vIGludm9rZSB0aGlzIG9ub3BlbiBmdW5jdGlvbi4gSWYgd2UgaW52b2tlIGl0IHR3aWNlIHdpdGhvdXQgY2hlY2tpbmdcbiAgICAgICAgICAgIC8vIGZvciBfc3RhdHVzICdvcGVuJywgd2UnZCBhY2NpZGVudGFsbHkgY2xvc2UgdGhlIFBlZXJDb25uZWN0aW9uLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFNlZSA8aHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJydGMvaXNzdWVzL2RldGFpbD9pZD00OTk2Pi5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fc3RhdHVzID09PSBDb25uZWN0aW9uLlN0YXRlLk9wZW4gfHwgX3RoaXMuX3N0YXR1cyA9PT0gQ29ubmVjdGlvbi5TdGF0ZS5SZWNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5fc3RhdHVzID09PSBDb25uZWN0aW9uLlN0YXRlLlJpbmdpbmcgfHwgX3RoaXMuX3N0YXR1cyA9PT0gQ29ubmVjdGlvbi5TdGF0ZS5Db25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubXV0ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21heWJlVHJhbnNpdGlvblRvT3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FsbCB3YXMgcHJvYmFibHkgY2FuY2VsZWQgc29tZXRpbWUgYmVmb3JlIHRoaXNcbiAgICAgICAgICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5tZWRpYVN0cmVhbS5vbmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3N0YXR1cyA9IENvbm5lY3Rpb24uU3RhdGUuQ2xvc2VkO1xuICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuc2hvdWxkUGxheURpc2Nvbm5lY3QgJiYgX3RoaXMub3B0aW9ucy5zaG91bGRQbGF5RGlzY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgcGxheSBkaXNjb25uZWN0IHNvdW5kIGlmIHRoaXMgd2FzIGZyb20gYSBjYW5jZWwgZXZlbnQuIGkuZS4gdGhlIGNhbGxcbiAgICAgICAgICAgICAgICAvLyB3YXMgaWdub3JlZCBvciBodW5nIHVwIGV2ZW4gYmVmb3JlIGl0IHdhcyBhbnN3ZXJlZC5cbiAgICAgICAgICAgICAgICAmJiAhX3RoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3NvdW5kY2FjaGUuZ2V0KGRldmljZV8xLmRlZmF1bHQuU291bmROYW1lLkRpc2Nvbm5lY3QpLnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vbml0b3IuZGlzYWJsZSgpO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hNZXRyaWNzKCk7XG4gICAgICAgICAgICBpZiAoIV90aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnBzdHJlYW0gPSBjb25maWcucHN0cmVhbTtcbiAgICAgICAgX3RoaXMucHN0cmVhbS5vbignY2FuY2VsJywgX3RoaXMuX29uQ2FuY2VsKTtcbiAgICAgICAgX3RoaXMucHN0cmVhbS5vbigncmluZ2luZycsIF90aGlzLl9vblJpbmdpbmcpO1xuICAgICAgICBfdGhpcy5wc3RyZWFtLm9uKCd0cmFuc3BvcnRDbG9zZScsIF90aGlzLl9vblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgX3RoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmVycm9yKCdjb25uZWN0aW9uJywgJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHN0cmVhbSAmJiBfdGhpcy5wc3RyZWFtLnN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW51cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbignZGlzY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jbGVhbnVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbm5lY3Rpb24ucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMge0BsaW5rIENvbm5lY3Rpb259IGlzIGluY29taW5nIG9yIG91dGdvaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGlyZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29ubmVjdGlvbi5wcm90b3R5cGUsIFwiY29kZWNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQXVkaW8gY29kZWMgdXNlZCBmb3IgdGhpcyB7QGxpbmsgQ29ubmVjdGlvbn0uIEV4cGVjdGluZyB7QGxpbmsgQ29ubmVjdGlvbi5Db2RlY30gYnV0XG4gICAgICAgICAqIHdpbGwgY29weSB3aGF0ZXZlciB3ZSBnZXQgZnJvbSBSVEMgc3RhdHMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2RlYztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZWFsIENhbGxTaWQuIFJldHVybnMgbnVsbCBpZiBub3QgcHJlc2VudCBvciBpcyBhIHRlbXBvcmFyeSBjYWxsIHNpZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuX2dldFJlYWxDYWxsU2lkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cud2FybignX2dldFJlYWxDYWxsU2lkIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAyLjAuJyk7XG4gICAgICAgIHJldHVybiAvXlRKLy50ZXN0KHRoaXMucGFyYW1ldGVycy5DYWxsU2lkKSA/IG51bGwgOiB0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdGVtcG9yYXJ5IENhbGxTaWQuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLl9nZXRUZW1wQ2FsbFNpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oJ19nZXRUZW1wQ2FsbFNpZCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gMi4wLiBcXFxuICAgICAgICAgICAgICAgICAgICBQbGVhc2UgdXNlIG91dGJvdW5kQ29ubmVjdGlvbklkIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGJvdW5kQ29ubmVjdGlvbklkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhdWRpbyBpbnB1dCB0cmFja3MgZnJvbSBhIGdpdmVuIHN0cmVhbS5cbiAgICAgKiBAcGFyYW0gc3RyZWFtXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0SW5wdXRUcmFja3NGcm9tU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVN0cmVhbS5zZXRJbnB1dFRyYWNrc0Zyb21TdHJlYW0oc3RyZWFtKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYXVkaW8gb3V0cHV0IHNpbmsgSURzLlxuICAgICAqIEBwYXJhbSBzaW5rSWRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0U2lua0lkcyA9IGZ1bmN0aW9uIChzaW5rSWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhU3RyZWFtLl9zZXRTaW5rSWRzKHNpbmtJZHMpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuYWNjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXJPckNvbnN0cmFpbnRzLCBydGNDb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlck9yQ29uc3RyYWludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEhhbmRsZXIoJ2FjY2VwdCcsIGhhbmRsZXJPckNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzICE9PSBDb25uZWN0aW9uLlN0YXRlLlBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXVkaW9Db25zdHJhaW50cyA9IGhhbmRsZXJPckNvbnN0cmFpbnRzIHx8IHRoaXMub3B0aW9ucy5hdWRpb0NvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLkNvbm5lY3Rpbmc7XG4gICAgICAgIHZhciBjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9zdGF0dXMgIT09IENvbm5lY3Rpb24uU3RhdGUuQ29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgbXVzdCBoYXZlIGJlZW4gY2FuY2VsZWRcbiAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYW51cEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb25BbnN3ZXIgPSBmdW5jdGlvbiAocGMpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBvcnQgdGhhdCB0aGUgY2FsbCB3YXMgYW5zd2VyZWQsIGFuZCBkaXJlY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgIHZhciBldmVudE5hbWUgPSBfdGhpcy5fZGlyZWN0aW9uID09PSBDb25uZWN0aW9uLkNhbGxEaXJlY3Rpb24uSW5jb21pbmdcbiAgICAgICAgICAgICAgICAgICAgPyAnYWNjZXB0ZWQtYnktbG9jYWwnXG4gICAgICAgICAgICAgICAgICAgIDogJ2FjY2VwdGVkLWJ5LXJlbW90ZSc7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgZXZlbnROYW1lLCBudWxsLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gUmVwb3J0IHRoZSBwcmVmZXJyZWQgY29kZWMgYW5kIHBhcmFtcyBhcyB0aGV5IGFwcGVhciBpbiB0aGUgU0RQXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZ2V0UHJlZmVycmVkQ29kZWNJbmZvKF90aGlzLm1lZGlhU3RyZWFtLnZlcnNpb24uZ2V0U0RQKCkpLCBjb2RlY05hbWUgPSBfYS5jb2RlY05hbWUsIGNvZGVjUGFyYW1zID0gX2EuY29kZWNQYXJhbXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdzZXR0aW5ncycsICdjb2RlYycsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZWNfcGFyYW1zOiBjb2RlY1BhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRfY29kZWM6IGNvZGVjTmFtZSxcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIFJUQyBtb25pdG9yaW5nXG4gICAgICAgICAgICAgICAgX3RoaXMuX21vbml0b3IuZW5hYmxlKHBjKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgc2lua0lkcyA9IHR5cGVvZiBfdGhpcy5vcHRpb25zLmdldFNpbmtJZHMgPT09ICdmdW5jdGlvbicgJiYgX3RoaXMub3B0aW9ucy5nZXRTaW5rSWRzKCk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzaW5rSWRzKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLl9zZXRTaW5rSWRzKHNpbmtJZHMpLmNhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gKHJyb3dsYW5kKSBXZSBkb24ndCB3YW50IHRoaXMgdG8gdGhyb3cgdG8gY29uc29sZSBzaW5jZSB0aGUgY3VzdG9tZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FuJ3QgY29udHJvbCB0aGlzLiBUaGlzIHdpbGwgbW9zdCBjb21tb25seSBiZSByZWplY3RlZCBvbiBicm93c2Vyc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IGRvbid0IHN1cHBvcnQgc2V0dGluZyBzaW5rIElEcy5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnBzdHJlYW0uYWRkTGlzdGVuZXIoJ2hhbmd1cCcsIF90aGlzLl9vbkhhbmd1cCk7XG4gICAgICAgICAgICBydGNDb25maWd1cmF0aW9uID0gcnRjQ29uZmlndXJhdGlvbiB8fCBfdGhpcy5vcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICBpZiAoX3RoaXMuX2RpcmVjdGlvbiA9PT0gQ29ubmVjdGlvbi5DYWxsRGlyZWN0aW9uLkluY29taW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2lzQW5zd2VyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLm1lZGlhU3RyZWFtLmFuc3dlckluY29taW5nQ2FsbChfdGhpcy5wYXJhbWV0ZXJzLkNhbGxTaWQsIF90aGlzLm9wdGlvbnMub2ZmZXJTZHAsIF90aGlzLm9wdGlvbnMucnRjQ29uc3RyYWludHMsIHJ0Y0NvbmZpZ3VyYXRpb24sIG9uQW5zd2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBBcnJheS5mcm9tKF90aGlzLmN1c3RvbVBhcmFtZXRlcnMuZW50cmllcygpKS5tYXAoZnVuY3Rpb24gKHBhaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5wc3RyZWFtLm9uY2UoJ2Fuc3dlcicsIF90aGlzLl9vbkFuc3dlci5iaW5kKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVkaWFTdHJlYW0ubWFrZU91dGdvaW5nQ2FsbChfdGhpcy5wc3RyZWFtLnRva2VuLCBwYXJhbXMsIF90aGlzLm91dGJvdW5kQ29ubmVjdGlvbklkLCBfdGhpcy5vcHRpb25zLnJ0Y0NvbnN0cmFpbnRzLCBydGNDb25maWd1cmF0aW9uLCBvbkFuc3dlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmVmb3JlQWNjZXB0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmVmb3JlQWNjZXB0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dFN0cmVhbSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuZ2V0SW5wdXRTdHJlYW0gPT09ICdmdW5jdGlvbicgJiYgdGhpcy5vcHRpb25zLmdldElucHV0U3RyZWFtKCk7XG4gICAgICAgIHZhciBwcm9taXNlID0gaW5wdXRTdHJlYW1cbiAgICAgICAgICAgID8gdGhpcy5tZWRpYVN0cmVhbS5zZXRJbnB1dFRyYWNrc0Zyb21TdHJlYW0oaW5wdXRTdHJlYW0pXG4gICAgICAgICAgICA6IHRoaXMubWVkaWFTdHJlYW0ub3BlbldpdGhDb25zdHJhaW50cyhhdWRpb0NvbnN0cmFpbnRzKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIuaW5mbygnZ2V0LXVzZXItbWVkaWEnLCAnc3VjY2VlZGVkJywge1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgYXVkaW9Db25zdHJhaW50czogYXVkaW9Db25zdHJhaW50cyB9LFxuICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgdmFyIGNvZGU7XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gMzEyMDhcbiAgICAgICAgICAgICAgICB8fCBbJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicsICdOb3RBbGxvd2VkRXJyb3InXS5pbmRleE9mKGVycm9yLm5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSAzMTIwODtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gJ1VzZXIgZGVuaWVkIGFjY2VzcyB0byBtaWNyb3Bob25lLCBvciB0aGUgd2ViIGJyb3dzZXIgZGlkIG5vdCBhbGxvdyBtaWNyb3Bob25lICdcbiAgICAgICAgICAgICAgICAgICAgKyAnYWNjZXNzIGF0IHRoaXMgYWRkcmVzcy4nO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIuZXJyb3IoJ2dldC11c2VyLW1lZGlhJywgJ2RlbmllZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50czogYXVkaW9Db25zdHJhaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gMzEyMDE7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiRXJyb3Igb2NjdXJyZWQgd2hpbGUgYWNjZXNzaW5nIG1pY3JvcGhvbmU6IFwiICsgZXJyb3IubmFtZSArIChlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgID8gXCIgKFwiICsgZXJyb3IubWVzc2FnZSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgIDogJycpO1xuICAgICAgICAgICAgICAgIF90aGlzLl9wdWJsaXNoZXIuZXJyb3IoJ2dldC11c2VyLW1lZGlhJywgJ2ZhaWxlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9Db25zdHJhaW50czogYXVkaW9Db25zdHJhaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCB7IG1lc3NhZ2U6IG1lc3NhZ2UsIGNvZGU6IGNvZGUgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fbG9nLndhcm4oJy5jYW5jZWwoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIC5pZ25vcmUoKSBpbnN0ZWFkLicpO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgdGhpcy5pZ25vcmUoaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlnbm9yZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRIYW5kbGVyKCdkaXNjb25uZWN0JywgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBTZXQgYSBoYW5kbGVyIGZvciB0aGUge0BsaW5rIGVycm9yRXZlbnR9XG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEhhbmRsZXIoJ2Vycm9yJywgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9jYWwgTWVkaWFTdHJlYW0sIGlmIHNldC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFTdHJlYW0gJiYgdGhpcy5tZWRpYVN0cmVhbS5zdHJlYW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJlbW90ZSBNZWRpYVN0cmVhbSwgaWYgc2V0LlxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlbW90ZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFTdHJlYW0gJiYgdGhpcy5tZWRpYVN0cmVhbS5fcmVtb3RlU3RyZWFtO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuaWdub3JlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRIYW5kbGVyKCdjYW5jZWwnLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzICE9PSBDb25uZWN0aW9uLlN0YXRlLlBlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLkNsb3NlZDtcbiAgICAgICAgdGhpcy5lbWl0KCdjYW5jZWwnKTtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbS5pZ25vcmUodGhpcy5wYXJhbWV0ZXJzLkNhbGxTaWQpO1xuICAgICAgICB0aGlzLl9wdWJsaXNoZXIuaW5mbygnY29ubmVjdGlvbicsICdpZ25vcmVkLWJ5LWxvY2FsJywgbnVsbCwgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIG11dGVkXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuaXNNdXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFTdHJlYW0uaXNNdXRlZDtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAoc2hvdWxkTXV0ZSkge1xuICAgICAgICBpZiAoc2hvdWxkTXV0ZSA9PT0gdm9pZCAwKSB7IHNob3VsZE11dGUgPSB0cnVlOyB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2hvdWxkTXV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fYWRkSGFuZGxlcignbXV0ZScsIHNob3VsZE11dGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3YXNNdXRlZCA9IHRoaXMubWVkaWFTdHJlYW0uaXNNdXRlZDtcbiAgICAgICAgdGhpcy5tZWRpYVN0cmVhbS5tdXRlKHNob3VsZE11dGUpO1xuICAgICAgICB2YXIgaXNNdXRlZCA9IHRoaXMubWVkaWFTdHJlYW0uaXNNdXRlZDtcbiAgICAgICAgaWYgKHdhc011dGVkICE9PSBpc011dGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaXNoZXIuaW5mbygnY29ubmVjdGlvbicsIGlzTXV0ZWQgPyAnbXV0ZWQnIDogJ3VubXV0ZWQnLCBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnbXV0ZScsIGlzTXV0ZWQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3N0IGFuIGV2ZW50IHRvIEVuZHBvaW50IEFuYWx5dGljcyBpbmRpY2F0aW5nIHRoYXQgdGhlIGVuZCB1c2VyXG4gICAgICogICBoYXMgZ2l2ZW4gY2FsbCBxdWFsaXR5IGZlZWRiYWNrLiBDYWxsZWQgd2l0aG91dCBhIHNjb3JlLCB0aGlzXG4gICAgICogICB3aWxsIHJlcG9ydCB0aGF0IHRoZSBjdXN0b21lciBkZWNsaW5lZCB0byBnaXZlIGZlZWRiYWNrLlxuICAgICAqIEBwYXJhbSBzY29yZSAtIFRoZSBlbmQtdXNlcidzIHJhdGluZyBvZiB0aGUgY2FsbDsgYW5cbiAgICAgKiAgIGludGVnZXIgMSB0aHJvdWdoIDUuIE9yIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBkZWNsaW5lZCB0byBnaXZlXG4gICAgICogICBmZWVkYmFjay5cbiAgICAgKiBAcGFyYW0gaXNzdWUgLSBUaGUgcHJpbWFyeSBpc3N1ZSB0aGUgZW5kIHVzZXJcbiAgICAgKiAgIGV4cGVyaWVuY2VkIG9uIHRoZSBjYWxsLiBDYW4gYmU6IFsnb25lLXdheS1hdWRpbycsICdjaG9wcHktYXVkaW8nLFxuICAgICAqICAgJ2Ryb3BwZWQtY2FsbCcsICdhdWRpby1sYXRlbmN5JywgJ25vaXN5LWNhbGwnLCAnZWNobyddXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUucG9zdEZlZWRiYWNrID0gZnVuY3Rpb24gKHNjb3JlLCBpc3N1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjb3JlID09PSAndW5kZWZpbmVkJyB8fCBzY29yZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc3RGZWVkYmFja0RlY2xpbmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKENvbm5lY3Rpb24uRmVlZGJhY2tTY29yZSkuaW5jbHVkZXMoc2NvcmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJGZWVkYmFjayBzY29yZSBtdXN0IGJlIG9uZSBvZjogXCIgKyBPYmplY3QudmFsdWVzKENvbm5lY3Rpb24uRmVlZGJhY2tTY29yZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaXNzdWUgIT09ICd1bmRlZmluZWQnICYmIGlzc3VlICE9PSBudWxsICYmICFPYmplY3QudmFsdWVzKENvbm5lY3Rpb24uRmVlZGJhY2tJc3N1ZSkuaW5jbHVkZXMoaXNzdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJGZWVkYmFjayBpc3N1ZSBtdXN0IGJlIG9uZSBvZjogXCIgKyBPYmplY3QudmFsdWVzKENvbm5lY3Rpb24uRmVlZGJhY2tJc3N1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaXNoZXIuaW5mbygnZmVlZGJhY2snLCAncmVjZWl2ZWQnLCB7XG4gICAgICAgICAgICBpc3N1ZV9uYW1lOiBpc3N1ZSxcbiAgICAgICAgICAgIHF1YWxpdHlfc2NvcmU6IHNjb3JlLFxuICAgICAgICB9LCB0aGlzLCB0cnVlKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fYWRkSGFuZGxlcigncmVqZWN0JywgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1cyAhPT0gQ29ubmVjdGlvbi5TdGF0ZS5QZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wc3RyZWFtLnJlamVjdCh0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCk7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IENvbm5lY3Rpb24uU3RhdGUuQ2xvc2VkO1xuICAgICAgICB0aGlzLmVtaXQoJ3JlamVjdCcpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLnJlamVjdCh0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCk7XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlci5pbmZvKCdjb25uZWN0aW9uJywgJ3JlamVjdGVkLWJ5LWxvY2FsJywgbnVsbCwgdGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZW5kIGEgc3RyaW5nIG9mIGRpZ2l0cy5cbiAgICAgKiBAcGFyYW0gZGlnaXRzXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZERpZ2l0cyA9IGZ1bmN0aW9uIChkaWdpdHMpIHtcbiAgICAgICAgaWYgKGRpZ2l0cy5tYXRjaCgvW14wLTkqI3ddLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQXJndW1lbnRFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXIgcGFzc2VkIGludG8gc2VuZERpZ2l0cycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXF1ZW5jZSA9IFtdO1xuICAgICAgICBkaWdpdHMuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGRpZ2l0KSB7XG4gICAgICAgICAgICB2YXIgZHRtZiA9IChkaWdpdCAhPT0gJ3cnKSA/IFwiZHRtZlwiICsgZGlnaXQgOiAnJztcbiAgICAgICAgICAgIGlmIChkdG1mID09PSAnZHRtZionKSB7XG4gICAgICAgICAgICAgICAgZHRtZiA9ICdkdG1mcyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHRtZiA9PT0gJ2R0bWYjJykge1xuICAgICAgICAgICAgICAgIGR0bWYgPSAnZHRtZmgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxdWVuY2UucHVzaChkdG1mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEJpbmRzIHNvdW5kQ2FjaGUgdG8gYmUgdXNlZCBpbiByZWN1cnNpb24gdW50aWwgYWxsIGRpZ2l0cyBoYXZlIGJlZW4gcGxheWVkLlxuICAgICAgICAoZnVuY3Rpb24gcGxheU5leHREaWdpdChzb3VuZENhY2hlLCBkaWFsdG9uZVBsYXllcikge1xuICAgICAgICAgICAgdmFyIGRpZ2l0ID0gc2VxdWVuY2Uuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChkaWdpdCkge1xuICAgICAgICAgICAgICAgIGlmIChkaWFsdG9uZVBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBkaWFsdG9uZVBsYXllci5wbGF5KGRpZ2l0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdW5kQ2FjaGUuZ2V0KGRpZ2l0KS5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocGxheU5leHREaWdpdC5iaW5kKG51bGwsIHNvdW5kQ2FjaGUpLCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSh0aGlzLl9zb3VuZGNhY2hlLCB0aGlzLm9wdGlvbnMuZGlhbHRvbmVQbGF5ZXIpO1xuICAgICAgICB2YXIgZHRtZlNlbmRlciA9IHRoaXMubWVkaWFTdHJlYW0uZ2V0T3JDcmVhdGVEVE1GU2VuZGVyKCk7XG4gICAgICAgIGZ1bmN0aW9uIGluc2VydERUTUYoZHRtZnMpIHtcbiAgICAgICAgICAgIGlmICghZHRtZnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGR0bWYgPSBkdG1mcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGR0bWYgJiYgZHRtZi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBkdG1mU2VuZGVyLmluc2VydERUTUYoZHRtZiwgRFRNRl9UT05FX0RVUkFUSU9OLCBEVE1GX0lOVEVSX1RPTkVfR0FQKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFRpbWVvdXQoaW5zZXJ0RFRNRi5iaW5kKG51bGwsIGR0bWZzKSwgRFRNRl9QQVVTRV9EVVJBVElPTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR0bWZTZW5kZXIpIHtcbiAgICAgICAgICAgIGlmICghKCdjYW5JbnNlcnREVE1GJyBpbiBkdG1mU2VuZGVyKSB8fCBkdG1mU2VuZGVyLmNhbkluc2VydERUTUYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnU2VuZGluZyBkaWdpdHMgdXNpbmcgUlRDRFRNRlNlbmRlcicpO1xuICAgICAgICAgICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBXZSBjYW4ndCBqdXN0IG1hcCAndycgdG8gJywnIHNpbmNlXG4gICAgICAgICAgICAgICAgLy8gUlRDRFRNRlNlbmRlcidzIHBhdXNlIGR1cmF0aW9uIGlzIDIgcyBhbmQgVHdpbGlvJ3MgaXMgbW9yZVxuICAgICAgICAgICAgICAgIC8vIGxpa2UgNTAwIG1zLiBJbnN0ZWFkLCB3ZSB3aWxsIGZ1ZGdlIGl0IHdpdGggc2V0VGltZW91dC5cbiAgICAgICAgICAgICAgICBpbnNlcnREVE1GKGRpZ2l0cy5zcGxpdCgndycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnUlRDRFRNRlNlbmRlciBjYW5ub3QgaW5zZXJ0IERUTUYnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIHBzdHJlYW0gbWVzc2FnZSB0byBzZW5kIERUTUZcbiAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1NlbmRpbmcgZGlnaXRzIG92ZXIgUFN0cmVhbScpO1xuICAgICAgICBpZiAodGhpcy5wc3RyZWFtICE9PSBudWxsICYmIHRoaXMucHN0cmVhbS5zdGF0dXMgIT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBzdHJlYW0uZHRtZih0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCwgZGlnaXRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiAzMTAwMCxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiB0aGlzLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3Qgc2VuZCBEVE1GOiBTaWduYWxpbmcgY2hhbm5lbCBpcyBkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB7QGxpbmsgQ29ubmVjdGlvbn0gc3RhdHVzLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVW5tdXRlIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0uXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cud2FybignLnVubXV0ZSgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgLm11dGUoZmFsc2UpIHRvIHVubXV0ZSBhIGNhbGwgaW5zdGVhZC4nKTtcbiAgICAgICAgdGhpcy5tdXRlKGZhbHNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gU2V0IGEgaGFuZGxlciBmb3IgdGhlIHtAbGluayB2b2x1bWVFdmVudH1cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIGlmICghd2luZG93IHx8ICghd2luZG93LkF1ZGlvQ29udGV4dCAmJiAhd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDb25uZWN0aW9uLnZvbHVtZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkZEhhbmRsZXIoJ3ZvbHVtZScsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkIGEgaGFuZGxlciBmb3IgYW4gRXZlbnRFbWl0dGVyIGFuZCBlbWl0IGEgZGVwcmVjYXRpb24gd2FybmluZyBvbiBmaXJzdCBjYWxsLlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gQSBoYW5kbGVyIHRvIGNhbGwgd2hlbiB0aGUgZXZlbnQgaXMgZW1pdHRlZFxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLl9hZGRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgICBpZiAoIWhhc0JlZW5XYXJuZWRIYW5kbGVycykge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4oXCJDb25uZWN0aW9uIGNhbGxiYWNrIGhhbmRsZXJzIChhY2NlcHQsIGNhbmNlbCwgZGlzY29ubmVjdCwgZXJyb3IsIGlnbm9yZSwgbXV0ZSwgcmVqZWN0LFxcbiAgICAgICAgdm9sdW1lKSBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IGJyZWFraW5nIHJlbGVhc2UuIEluc3RlYWQsIHRoZSBFdmVudEVtaXR0ZXIgICAgICAgICBpbnRlcmZhY2UgY2FuIGJlIHVzZWQgdG8gc2V0IGV2ZW50IGxpc3RlbmVycy4gRXhhbXBsZTogY29ubmVjdGlvbi5vbignXCIgKyBldmVudE5hbWUgKyBcIicsIGhhbmRsZXIpXCIpO1xuICAgICAgICAgICAgaGFzQmVlbldhcm5lZEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHZvbHVtZSBwYXNzZWQsIGVtaXR0aW5nIGEgd2FybmluZyBpZiBvbmUgd2F5IGF1ZGlvIGlzIGRldGVjdGVkIG9yIGNsZWFyZWQuXG4gICAgICogQHBhcmFtIGN1cnJlbnRWb2x1bWUgLSBUaGUgY3VycmVudCB2b2x1bWUgZm9yIHRoaXMgZGlyZWN0aW9uXG4gICAgICogQHBhcmFtIHN0cmVha0ZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCBvbiB0aGUge0BsaW5rIENvbm5lY3Rpb259IG9iamVjdCB0aGF0IHRyYWNrcyBob3cgbWFueSB0aW1lcyB0aGVcbiAgICAgKiAgIGN1cnJlbnQgdmFsdWUgaGFzIGJlZW4gcmVwZWF0ZWQgY29uc2VjdXRpdmVseS5cbiAgICAgKiBAcGFyYW0gbGFzdFZhbHVlRmllbGROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkIG9uIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0gb2JqZWN0IHRoYXQgdHJhY2tzIHRoZSBtb3N0IHJlY2VudFxuICAgICAqICAgdm9sdW1lIGZvciB0aGlzIGRpcmVjdGlvblxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhpcyBhdWRpbyB0cmFjaywgZWl0aGVyICdpbnB1dCcgb3IgJ291dHB1dCdcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzdHJlYWs7IGhvdyBtYW55IHRpbWVzIGluIGEgcm93IHRoZSBzYW1lIHZhbHVlIGhhcyBiZWVuIHBvbGxlZC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5fY2hlY2tWb2x1bWUgPSBmdW5jdGlvbiAoY3VycmVudFZvbHVtZSwgY3VycmVudFN0cmVhaywgbGFzdFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHdhc1dhcm5pbmdSYWlzZWQgPSBjdXJyZW50U3RyZWFrID49IDEwO1xuICAgICAgICB2YXIgbmV3U3RyZWFrID0gMDtcbiAgICAgICAgaWYgKGxhc3RWYWx1ZSA9PT0gY3VycmVudFZvbHVtZSkge1xuICAgICAgICAgICAgbmV3U3RyZWFrID0gY3VycmVudFN0cmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3U3RyZWFrID49IDEwKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0V2FybmluZygnYXVkaW8tbGV2ZWwtJywgXCJjb25zdGFudC1hdWRpby1cIiArIGRpcmVjdGlvbiArIFwiLWxldmVsXCIsIDEwLCBuZXdTdHJlYWssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXNXYXJuaW5nUmFpc2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0V2FybmluZygnYXVkaW8tbGV2ZWwtJywgXCJjb25zdGFudC1hdWRpby1cIiArIGRpcmVjdGlvbiArIFwiLWxldmVsXCIsIDEwLCBuZXdTdHJlYWssIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdHJlYWs7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NsZWFudXBFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnBzdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhbnN3ZXInLCBfdGhpcy5fb25BbnN3ZXIpO1xuICAgICAgICAgICAgX3RoaXMucHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2FuY2VsJywgX3RoaXMuX29uQ2FuY2VsKTtcbiAgICAgICAgICAgIF90aGlzLnBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2hhbmd1cCcsIF90aGlzLl9vbkhhbmd1cCk7XG4gICAgICAgICAgICBfdGhpcy5wc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyaW5naW5nJywgX3RoaXMuX29uUmluZ2luZyk7XG4gICAgICAgICAgICBfdGhpcy5wc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCd0cmFuc3BvcnRDbG9zZScsIF90aGlzLl9vblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhpcyBpcyBraW5kIG9mIGEgaGFjaywgYnV0IGl0IGxldHMgdXMgYXZvaWQgcmV3cml0aW5nIG1vcmUgY29kZS5cbiAgICAgICAgLy8gQmFzaWNhbGx5LCB0aGVyZSdzIGEgc2VxdWVuY2luZyBwcm9ibGVtIHdpdGggdGhlIHdheSBQZWVyQ29ubmVjdGlvbiByYWlzZXNcbiAgICAgICAgLy8gdGhlXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgQ2Fubm90IGVzdGFibGlzaCBjb25uZWN0aW9uLiBDbGllbnQgaXMgZGlzY29ubmVjdGVkXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGVycm9yIGluIENvbm5lY3Rpb24jYWNjZXB0LiBJdCBjYWxscyBQZWVyQ29ubmVjdGlvbiNvbmVycm9yLCB3aGljaCBlbWl0c1xuICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgb24gQ29ubmVjdGlvbi4gQW4gZXJyb3IgaGFuZGxlciBvbiBDb25uZWN0aW9uIHRoZW4gY2FsbHNcbiAgICAgICAgLy8gY2xlYW51cEV2ZW50TGlzdGVuZXJzLCBidXQgdGhlbiBjb250cm9sIHJldHVybnMgdG8gQ29ubmVjdGlvbiNhY2NlcHQuIEl0J3NcbiAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB0aGF0IHdlIGFkZCBhIGxpc3RlbmVyIGZvciB0aGUgYW5zd2VyIGV2ZW50IHRoYXQgbmV2ZXIgZ2V0c1xuICAgICAgICAvLyByZW1vdmVkLiBzZXRUaW1lb3V0IHdpbGwgYWxsb3cgdXMgdG8gcmVydW4gY2xlYW51cCBhZ2FpbiwgX2FmdGVyX1xuICAgICAgICAvLyBDb25uZWN0aW9uI2FjY2VwdCByZXR1cm5zLlxuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHNldFRpbWVvdXQoY2xlYW51cCwgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIHBheWxvYWQgd3JhcHBlciBmb3IgYSBiYXRjaCBvZiBtZXRyaWNzIHRvIGJlIHNlbnQgdG8gSW5zaWdodHMuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZU1ldHJpY1BheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgY2FsbF9zaWQ6IHRoaXMucGFyYW1ldGVycy5DYWxsU2lkLFxuICAgICAgICAgICAgZHNjcDogISF0aGlzLm9wdGlvbnMuZHNjcCxcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBDLlJFTEVBU0VfVkVSU0lPTixcbiAgICAgICAgICAgIHNlbGVjdGVkX3JlZ2lvbjogdGhpcy5vcHRpb25zLnNlbGVjdGVkUmVnaW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdhdGV3YXkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuZ2F0ZXdheSA9IHRoaXMub3B0aW9ucy5nYXRld2F5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVnaW9uKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnJlZ2lvbiA9IHRoaXMub3B0aW9ucy5yZWdpb247XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5kaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCB0aGUge0BsaW5rIENvbm5lY3Rpb259LlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gQSBtZXNzYWdlIGV4cGxhaW5pbmcgd2h5IHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0gaXMgYmVpbmcgZGlzY29ubmVjdGVkLlxuICAgICAqIEBwYXJhbSB3YXNSZW1vdGUgLSBXaGV0aGVyIHRoZSBkaXNjb25uZWN0IHdhcyB0cmlnZ2VyZWQgbG9jYWxseSBvciByZW1vdGVseS5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5fZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChtZXNzYWdlLCB3YXNSZW1vdGUpIHtcbiAgICAgICAgbWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5fc3RhdHVzICE9PSBDb25uZWN0aW9uLlN0YXRlLk9wZW5cbiAgICAgICAgICAgICYmIHRoaXMuX3N0YXR1cyAhPT0gQ29ubmVjdGlvbi5TdGF0ZS5Db25uZWN0aW5nXG4gICAgICAgICAgICAmJiB0aGlzLl9zdGF0dXMgIT09IENvbm5lY3Rpb24uU3RhdGUuUmVjb25uZWN0aW5nXG4gICAgICAgICAgICAmJiB0aGlzLl9zdGF0dXMgIT09IENvbm5lY3Rpb24uU3RhdGUuUmluZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvZy5pbmZvKCdEaXNjb25uZWN0aW5nLi4uJyk7XG4gICAgICAgIC8vIHNlbmQgcHN0cmVhbSBoYW5ndXAgbWVzc2FnZVxuICAgICAgICBpZiAodGhpcy5wc3RyZWFtICE9PSBudWxsICYmIHRoaXMucHN0cmVhbS5zdGF0dXMgIT09ICdkaXNjb25uZWN0ZWQnICYmIHRoaXMuc2VuZEhhbmd1cCkge1xuICAgICAgICAgICAgdmFyIGNhbGxzaWQgPSB0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCB8fCB0aGlzLm91dGJvdW5kQ29ubmVjdGlvbklkO1xuICAgICAgICAgICAgaWYgKGNhbGxzaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBzdHJlYW0uaGFuZ3VwKGNhbGxzaWQsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFudXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLm1lZGlhU3RyZWFtLmNsb3NlKCk7XG4gICAgICAgIGlmICghd2FzUmVtb3RlKSB7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaXNoZXIuaW5mbygnY29ubmVjdGlvbicsICdkaXNjb25uZWN0ZWQtYnktbG9jYWwnLCBudWxsLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbiB0byB7QGxpbmsgQ29ubmVjdGlvblN0YXR1cy5PcGVufSBpZiBjcml0ZXJpYSBpcyBtZXQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbi5wcm90b3R5cGUuX21heWJlVHJhbnNpdGlvblRvT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFTdHJlYW0gJiYgdGhpcy5tZWRpYVN0cmVhbS5zdGF0dXMgPT09ICdvcGVuJyAmJiB0aGlzLl9pc0Fuc3dlcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSBDb25uZWN0aW9uLlN0YXRlLk9wZW47XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2FjY2VwdCcsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQb3N0IGFuIGV2ZW50IHRvIEVuZHBvaW50IEFuYWx5dGljcyBpbmRpY2F0aW5nIHRoYXQgdGhlIGVuZCB1c2VyXG4gICAgICogICBoYXMgaWdub3JlZCBhIHJlcXVlc3QgZm9yIGZlZWRiYWNrLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLl9wb3N0RmVlZGJhY2tEZWNsaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1Ymxpc2hlci5pbmZvKCdmZWVkYmFjaycsICdyZWNlaXZlZC1ub25lJywgbnVsbCwgdGhpcywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQdWJsaXNoIHRoZSBjdXJyZW50IHNldCBvZiBxdWV1ZWQgbWV0cmljcyBzYW1wbGVzIHRvIEluc2lnaHRzLlxuICAgICAqL1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLl9wdWJsaXNoTWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX21ldHJpY3NTYW1wbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3B1Ymxpc2hlci5wb3N0TWV0cmljcygncXVhbGl0eS1tZXRyaWNzLXNhbXBsZXMnLCAnbWV0cmljcy1zYW1wbGUnLCB0aGlzLl9tZXRyaWNzU2FtcGxlcy5zcGxpY2UoMCksIHRoaXMuX2NyZWF0ZU1ldHJpY1BheWxvYWQoKSwgdGhpcykuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignVW5hYmxlIHRvIHBvc3QgbWV0cmljcyB0byBJbnNpZ2h0cy4gUmVjZWl2ZWQgZXJyb3I6JywgZSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBDYWxsU2lkXG4gICAgICogQHBhcmFtIHBheWxvYWRcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0Q2FsbFNpZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBjYWxsU2lkID0gcGF5bG9hZC5jYWxsc2lkO1xuICAgICAgICBpZiAoIWNhbGxTaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMuQ2FsbFNpZCA9IGNhbGxTaWQ7XG4gICAgICAgIHRoaXMubWVkaWFTdHJlYW0uY2FsbFNpZCA9IGNhbGxTaWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHtAbGluayBDb25uZWN0aW9ufSBjbGFzcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIENvbm5lY3Rpb24udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnW1R3aWxpby5Db25uZWN0aW9uIGNsYXNzXSc7IH07XG4gICAgcmV0dXJuIENvbm5lY3Rpb247XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogUG9zc2libGUgc3RhdGVzIG9mIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0uXG4gICAgICovXG4gICAgdmFyIFN0YXRlO1xuICAgIChmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICAgICAgU3RhdGVbXCJDbG9zZWRcIl0gPSBcImNsb3NlZFwiO1xuICAgICAgICBTdGF0ZVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICAgICAgU3RhdGVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XG4gICAgICAgIFN0YXRlW1wiUGVuZGluZ1wiXSA9IFwicGVuZGluZ1wiO1xuICAgICAgICBTdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gICAgICAgIFN0YXRlW1wiUmluZ2luZ1wiXSA9IFwicmluZ2luZ1wiO1xuICAgIH0pKFN0YXRlID0gQ29ubmVjdGlvbi5TdGF0ZSB8fCAoQ29ubmVjdGlvbi5TdGF0ZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogRGlmZmVyZW50IGlzc3VlcyB0aGF0IG1heSBoYXZlIGJlZW4gZXhwZXJpZW5jZWQgZHVyaW5nIGEgY2FsbCwgdGhhdCBjYW4gYmVcbiAgICAgKiByZXBvcnRlZCB0byBUd2lsaW8gSW5zaWdodHMgdmlhIHtAbGluayBDb25uZWN0aW9ufS5wb3N0RmVlZGJhY2soKS5cbiAgICAgKi9cbiAgICB2YXIgRmVlZGJhY2tJc3N1ZTtcbiAgICAoZnVuY3Rpb24gKEZlZWRiYWNrSXNzdWUpIHtcbiAgICAgICAgRmVlZGJhY2tJc3N1ZVtcIkF1ZGlvTGF0ZW5jeVwiXSA9IFwiYXVkaW8tbGF0ZW5jeVwiO1xuICAgICAgICBGZWVkYmFja0lzc3VlW1wiQ2hvcHB5QXVkaW9cIl0gPSBcImNob3BweS1hdWRpb1wiO1xuICAgICAgICBGZWVkYmFja0lzc3VlW1wiRHJvcHBlZENhbGxcIl0gPSBcImRyb3BwZWQtY2FsbFwiO1xuICAgICAgICBGZWVkYmFja0lzc3VlW1wiRWNob1wiXSA9IFwiZWNob1wiO1xuICAgICAgICBGZWVkYmFja0lzc3VlW1wiTm9pc3lDYWxsXCJdID0gXCJub2lzeS1jYWxsXCI7XG4gICAgICAgIEZlZWRiYWNrSXNzdWVbXCJPbmVXYXlBdWRpb1wiXSA9IFwib25lLXdheS1hdWRpb1wiO1xuICAgIH0pKEZlZWRiYWNrSXNzdWUgPSBDb25uZWN0aW9uLkZlZWRiYWNrSXNzdWUgfHwgKENvbm5lY3Rpb24uRmVlZGJhY2tJc3N1ZSA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogQSByYXRpbmcgb2YgY2FsbCBxdWFsaXR5IGV4cGVyaWVuY2VkIGR1cmluZyBhIGNhbGwsIHRvIGJlIHJlcG9ydGVkIHRvIFR3aWxpbyBJbnNpZ2h0c1xuICAgICAqIHZpYSB7QGxpbmsgQ29ubmVjdGlvbn0ucG9zdEZlZWRiYWNrKCkuXG4gICAgICovXG4gICAgdmFyIEZlZWRiYWNrU2NvcmU7XG4gICAgKGZ1bmN0aW9uIChGZWVkYmFja1Njb3JlKSB7XG4gICAgICAgIEZlZWRiYWNrU2NvcmVbRmVlZGJhY2tTY29yZVtcIk9uZVwiXSA9IDFdID0gXCJPbmVcIjtcbiAgICAgICAgRmVlZGJhY2tTY29yZVtGZWVkYmFja1Njb3JlW1wiVHdvXCJdID0gMl0gPSBcIlR3b1wiO1xuICAgICAgICBGZWVkYmFja1Njb3JlW0ZlZWRiYWNrU2NvcmVbXCJUaHJlZVwiXSA9IDNdID0gXCJUaHJlZVwiO1xuICAgICAgICBGZWVkYmFja1Njb3JlW0ZlZWRiYWNrU2NvcmVbXCJGb3VyXCJdID0gNF0gPSBcIkZvdXJcIjtcbiAgICAgICAgRmVlZGJhY2tTY29yZVtGZWVkYmFja1Njb3JlW1wiRml2ZVwiXSA9IDVdID0gXCJGaXZlXCI7XG4gICAgfSkoRmVlZGJhY2tTY29yZSA9IENvbm5lY3Rpb24uRmVlZGJhY2tTY29yZSB8fCAoQ29ubmVjdGlvbi5GZWVkYmFja1Njb3JlID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGlyZWN0aW9uYWxpdHkgb2YgdGhlIHtAbGluayBDb25uZWN0aW9ufSwgd2hldGhlciBpbmNvbWluZyBvciBvdXRnb2luZy5cbiAgICAgKi9cbiAgICB2YXIgQ2FsbERpcmVjdGlvbjtcbiAgICAoZnVuY3Rpb24gKENhbGxEaXJlY3Rpb24pIHtcbiAgICAgICAgQ2FsbERpcmVjdGlvbltcIkluY29taW5nXCJdID0gXCJJTkNPTUlOR1wiO1xuICAgICAgICBDYWxsRGlyZWN0aW9uW1wiT3V0Z29pbmdcIl0gPSBcIk9VVEdPSU5HXCI7XG4gICAgfSkoQ2FsbERpcmVjdGlvbiA9IENvbm5lY3Rpb24uQ2FsbERpcmVjdGlvbiB8fCAoQ29ubmVjdGlvbi5DYWxsRGlyZWN0aW9uID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBWYWxpZCBhdWRpbyBjb2RlY3MgdG8gdXNlIGZvciB0aGUgbWVkaWEgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgQ29kZWM7XG4gICAgKGZ1bmN0aW9uIChDb2RlYykge1xuICAgICAgICBDb2RlY1tcIk9wdXNcIl0gPSBcIm9wdXNcIjtcbiAgICAgICAgQ29kZWNbXCJQQ01VXCJdID0gXCJwY211XCI7XG4gICAgfSkoQ29kZWMgPSBDb25uZWN0aW9uLkNvZGVjIHx8IChDb25uZWN0aW9uLkNvZGVjID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBQb3NzaWJsZSBJQ0UgR2F0aGVyaW5nIGZhaWx1cmVzXG4gICAgICovXG4gICAgdmFyIEljZUdhdGhlcmluZ0ZhaWx1cmVSZWFzb247XG4gICAgKGZ1bmN0aW9uIChJY2VHYXRoZXJpbmdGYWlsdXJlUmVhc29uKSB7XG4gICAgICAgIEljZUdhdGhlcmluZ0ZhaWx1cmVSZWFzb25bXCJOb25lXCJdID0gXCJub25lXCI7XG4gICAgICAgIEljZUdhdGhlcmluZ0ZhaWx1cmVSZWFzb25bXCJUaW1lb3V0XCJdID0gXCJ0aW1lb3V0XCI7XG4gICAgfSkoSWNlR2F0aGVyaW5nRmFpbHVyZVJlYXNvbiA9IENvbm5lY3Rpb24uSWNlR2F0aGVyaW5nRmFpbHVyZVJlYXNvbiB8fCAoQ29ubmVjdGlvbi5JY2VHYXRoZXJpbmdGYWlsdXJlUmVhc29uID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBQb3NzaWJsZSBtZWRpYSBmYWlsdXJlc1xuICAgICAqL1xuICAgIHZhciBNZWRpYUZhaWx1cmU7XG4gICAgKGZ1bmN0aW9uIChNZWRpYUZhaWx1cmUpIHtcbiAgICAgICAgTWVkaWFGYWlsdXJlW1wiQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFwiXSA9IFwiQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFwiO1xuICAgICAgICBNZWRpYUZhaWx1cmVbXCJDb25uZWN0aW9uRmFpbGVkXCJdID0gXCJDb25uZWN0aW9uRmFpbGVkXCI7XG4gICAgICAgIE1lZGlhRmFpbHVyZVtcIkljZUdhdGhlcmluZ0ZhaWxlZFwiXSA9IFwiSWNlR2F0aGVyaW5nRmFpbGVkXCI7XG4gICAgICAgIE1lZGlhRmFpbHVyZVtcIkxvd0J5dGVzXCJdID0gXCJMb3dCeXRlc1wiO1xuICAgIH0pKE1lZGlhRmFpbHVyZSA9IENvbm5lY3Rpb24uTWVkaWFGYWlsdXJlIHx8IChDb25uZWN0aW9uLk1lZGlhRmFpbHVyZSA9IHt9KSk7XG59KShDb25uZWN0aW9uIHx8IChDb25uZWN0aW9uID0ge30pKTtcbmZ1bmN0aW9uIGdlbmVyYXRlVGVtcENhbGxTaWQoKSB7XG4gICAgcmV0dXJuICdUSlN4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZSAqL1xuICAgICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICAgIHZhciB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1iaXR3aXNlICovXG4gICAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aW9uLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/connection.js\n")},"./node_modules/twilio-client/es5/twilio/constants.js":module=>{eval("/**\n * This file is generated on build. To make changes, see /templates/constants.js\n */\nvar PACKAGE_NAME = 'twilio-client';\nvar RELEASE_VERSION = '1.14.0';\nvar SOUNDS_BASE_URL = 'https://sdk.twilio.com/js/client/sounds/releases/1.0.0';\nmodule.exports.COWBELL_AUDIO_URL = SOUNDS_BASE_URL + \"/cowbell.mp3?cache=\" + RELEASE_VERSION;\nmodule.exports.ECHO_TEST_DURATION = 20000;\nmodule.exports.PACKAGE_NAME = PACKAGE_NAME;\nmodule.exports.RELEASE_VERSION = RELEASE_VERSION;\nmodule.exports.SOUNDS_BASE_URL = SOUNDS_BASE_URL;\n/**\n * All errors we plan to use need to be defined here.\n */\nmodule.exports.USED_ERRORS = [\n    'AuthorizationErrors.AccessTokenExpired',\n    'AuthorizationErrors.AccessTokenInvalid',\n    'AuthorizationErrors.AuthenticationFailed',\n    'ClientErrors.BadRequest',\n    'GeneralErrors.ConnectionError',\n    'GeneralErrors.TransportError',\n    'GeneralErrors.UnknownError',\n    'MediaErrors.ClientLocalDescFailed',\n    'MediaErrors.ClientRemoteDescFailed',\n    'MediaErrors.ConnectionError',\n    'SignalingErrors.ConnectionDisconnected',\n    'SignalingErrors.ConnectionError',\n];\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2NvbnN0YW50cy5qcz8wZjA0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2NvbnN0YW50cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBvbiBidWlsZC4gVG8gbWFrZSBjaGFuZ2VzLCBzZWUgL3RlbXBsYXRlcy9jb25zdGFudHMuanNcbiAqL1xudmFyIFBBQ0tBR0VfTkFNRSA9ICd0d2lsaW8tY2xpZW50JztcbnZhciBSRUxFQVNFX1ZFUlNJT04gPSAnMS4xNC4wJztcbnZhciBTT1VORFNfQkFTRV9VUkwgPSAnaHR0cHM6Ly9zZGsudHdpbGlvLmNvbS9qcy9jbGllbnQvc291bmRzL3JlbGVhc2VzLzEuMC4wJztcbm1vZHVsZS5leHBvcnRzLkNPV0JFTExfQVVESU9fVVJMID0gU09VTkRTX0JBU0VfVVJMICsgXCIvY293YmVsbC5tcDM/Y2FjaGU9XCIgKyBSRUxFQVNFX1ZFUlNJT047XG5tb2R1bGUuZXhwb3J0cy5FQ0hPX1RFU1RfRFVSQVRJT04gPSAyMDAwMDtcbm1vZHVsZS5leHBvcnRzLlBBQ0tBR0VfTkFNRSA9IFBBQ0tBR0VfTkFNRTtcbm1vZHVsZS5leHBvcnRzLlJFTEVBU0VfVkVSU0lPTiA9IFJFTEVBU0VfVkVSU0lPTjtcbm1vZHVsZS5leHBvcnRzLlNPVU5EU19CQVNFX1VSTCA9IFNPVU5EU19CQVNFX1VSTDtcbi8qKlxuICogQWxsIGVycm9ycyB3ZSBwbGFuIHRvIHVzZSBuZWVkIHRvIGJlIGRlZmluZWQgaGVyZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMuVVNFRF9FUlJPUlMgPSBbXG4gICAgJ0F1dGhvcml6YXRpb25FcnJvcnMuQWNjZXNzVG9rZW5FeHBpcmVkJyxcbiAgICAnQXV0aG9yaXphdGlvbkVycm9ycy5BY2Nlc3NUb2tlbkludmFsaWQnLFxuICAgICdBdXRob3JpemF0aW9uRXJyb3JzLkF1dGhlbnRpY2F0aW9uRmFpbGVkJyxcbiAgICAnQ2xpZW50RXJyb3JzLkJhZFJlcXVlc3QnLFxuICAgICdHZW5lcmFsRXJyb3JzLkNvbm5lY3Rpb25FcnJvcicsXG4gICAgJ0dlbmVyYWxFcnJvcnMuVHJhbnNwb3J0RXJyb3InLFxuICAgICdHZW5lcmFsRXJyb3JzLlVua25vd25FcnJvcicsXG4gICAgJ01lZGlhRXJyb3JzLkNsaWVudExvY2FsRGVzY0ZhaWxlZCcsXG4gICAgJ01lZGlhRXJyb3JzLkNsaWVudFJlbW90ZURlc2NGYWlsZWQnLFxuICAgICdNZWRpYUVycm9ycy5Db25uZWN0aW9uRXJyb3InLFxuICAgICdTaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCcsXG4gICAgJ1NpZ25hbGluZ0Vycm9ycy5Db25uZWN0aW9uRXJyb3InLFxuXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/constants.js\n")},"./node_modules/twilio-client/es5/twilio/deferred.js":(__unused_webpack_module,exports)=>{"use strict";eval('\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * Deferred Promise\n */\nvar Deferred = /** @class */ (function () {\n    /**\n     * @constructor\n     */\n    function Deferred() {\n        var _this = this;\n        this._promise = new Promise(function (resolve, reject) {\n            _this._resolve = resolve;\n            _this._reject = reject;\n        });\n    }\n    Object.defineProperty(Deferred.prototype, "promise", {\n        /**\n         * @returns The {@link Deferred} Promise\n         */\n        get: function () {\n            return this._promise;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Rejects this promise\n     */\n    Deferred.prototype.reject = function (reason) {\n        this._reject(reason);\n    };\n    /**\n     * Resolves this promise\n     */\n    Deferred.prototype.resolve = function (value) {\n        this._resolve(value);\n    };\n    return Deferred;\n}());\nexports.default = Deferred;\n//# sourceMappingURL=deferred.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2RlZmVycmVkLmpzP2Q5MzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2RlZmVycmVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBWb2ljZVxuICogQGludGVybmFsYXBpXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRGVmZXJyZWQgUHJvbWlzZVxuICovXG52YXIgRGVmZXJyZWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmVycmVkLnByb3RvdHlwZSwgXCJwcm9taXNlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGVmZXJyZWR9IFByb21pc2VcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhpcyBwcm9taXNlXG4gICAgICovXG4gICAgRGVmZXJyZWQucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhpcy5fcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGlzIHByb21pc2VcbiAgICAgKi9cbiAgICBEZWZlcnJlZC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZlcnJlZDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZlcnJlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVycmVkLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/deferred.js\n')},"./node_modules/twilio-client/es5/twilio/device.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar audiohelper_1 = __webpack_require__(/*! ./audiohelper */ \"./node_modules/twilio-client/es5/twilio/audiohelper.js\");\nvar connection_1 = __webpack_require__(/*! ./connection */ \"./node_modules/twilio-client/es5/twilio/connection.js\");\nvar dialtonePlayer_1 = __webpack_require__(/*! ./dialtonePlayer */ \"./node_modules/twilio-client/es5/twilio/dialtonePlayer.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar log_1 = __webpack_require__(/*! ./log */ \"./node_modules/twilio-client/es5/twilio/log.js\");\nvar preflight_1 = __webpack_require__(/*! ./preflight/preflight */ \"./node_modules/twilio-client/es5/twilio/preflight/preflight.js\");\nvar regions_1 = __webpack_require__(/*! ./regions */ \"./node_modules/twilio-client/es5/twilio/regions.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\nvar C = __webpack_require__(/*! ./constants */ \"./node_modules/twilio-client/es5/twilio/constants.js\");\nvar Publisher = __webpack_require__(/*! ./eventpublisher */ \"./node_modules/twilio-client/es5/twilio/eventpublisher.js\");\nvar PStream = __webpack_require__(/*! ./pstream */ \"./node_modules/twilio-client/es5/twilio/pstream.js\");\nvar rtc = __webpack_require__(/*! ./rtc */ \"./node_modules/twilio-client/es5/twilio/rtc/index.js\");\nvar getUserMedia = __webpack_require__(/*! ./rtc/getusermedia */ \"./node_modules/twilio-client/es5/twilio/rtc/getusermedia.js\");\nvar Sound = __webpack_require__(/*! ./sound */ \"./node_modules/twilio-client/es5/twilio/sound.js\");\nvar REGISTRATION_INTERVAL = 30000;\nvar RINGTONE_PLAY_TIMEOUT = 2000;\nvar hasBeenWarnedHandlers = false;\nvar hasBeenWarnedSounds = false;\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\nvar Device = /** @class */ (function (_super) {\n    __extends(Device, _super);\n    function Device(token, options) {\n        var _a;\n        var _this = _super.call(this) || this;\n        /**\n         * The AudioHelper instance associated with this {@link Device}.\n         */\n        _this.audio = null;\n        /**\n         * An array of {@link Connection}s. Though only one can be active, multiple may exist when there\n         * are multiple incoming, unanswered {@link Connection}s.\n         */\n        _this.connections = [];\n        /**\n         * Whether or not {@link Device.setup} has been called.\n         */\n        _this.isInitialized = false;\n        /**\n         * Methods to enable/disable each sound. Empty if the {@link Device} has not\n         * yet been set up.\n         */\n        _this.sounds = {};\n        /**\n         * The JWT string currently being used to authenticate this {@link Device}.\n         */\n        _this.token = null;\n        /**\n         * The currently active {@link Connection}, if there is one.\n         */\n        _this._activeConnection = null;\n        /**\n         * The list of chunder URIs that will be passed to PStream\n         */\n        _this._chunderURIs = [];\n        /**\n         * An audio input MediaStream to pass to new {@link Connection} instances.\n         */\n        _this._connectionInputStream = null;\n        /**\n         * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n         * new {@link Connection} instances.\n         */\n        _this._connectionSinkIds = ['default'];\n        /**\n         * The name of the edge the {@link Device} is connected to.\n         */\n        _this._edge = null;\n        /**\n         * Whether each sound is enabled.\n         */\n        _this._enabledSounds = (_a = {},\n            _a[Device.SoundName.Disconnect] = true,\n            _a[Device.SoundName.Incoming] = true,\n            _a[Device.SoundName.Outgoing] = true,\n            _a);\n        /**\n         * An instance of Logger to use.\n         */\n        _this._log = log_1.default.getInstance();\n        /**\n         * An Insights Event Publisher.\n         */\n        _this._publisher = null;\n        /**\n         * The region the {@link Device} is connected to.\n         */\n        _this._region = null;\n        /**\n         * The current status of the {@link Device}.\n         */\n        _this._status = Device.Status.Offline;\n        /**\n         * Value of 'audio' determines whether we should be registered for incoming calls.\n         */\n        _this.mediaPresence = { audio: true };\n        /**\n         * The options passed to {@link Device} constructor or Device.setup.\n         */\n        _this.options = {\n            allowIncomingWhileBusy: false,\n            audioConstraints: true,\n            closeProtection: false,\n            codecPreferences: [connection_1.default.Codec.PCMU, connection_1.default.Codec.Opus],\n            connectionFactory: connection_1.default,\n            debug: false,\n            dscp: true,\n            enableIceRestart: false,\n            eventgw: 'eventgw.twilio.com',\n            forceAggressiveIceNomination: false,\n            iceServers: [],\n            noRegister: false,\n            pStreamFactory: PStream,\n            preflight: false,\n            rtcConstraints: {},\n            soundFactory: Sound,\n            sounds: {},\n            warnings: true,\n        };\n        /**\n         * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n         */\n        _this.regTimer = null;\n        /**\n         * A Map of Sounds to play.\n         */\n        _this.soundcache = new Map();\n        /**\n         * The Signaling stream.\n         */\n        _this.stream = null;\n        /**\n         * Destroy the {@link Device}, freeing references to be garbage collected.\n         */\n        _this.destroy = function () {\n            _this._disconnectAll();\n            _this._stopRegistrationTimer();\n            if (_this.audio) {\n                _this.audio._unbind();\n            }\n            if (_this.stream) {\n                _this.stream.destroy();\n                _this.stream = null;\n            }\n            if (_this._networkInformation && typeof _this._networkInformation.removeEventListener === 'function') {\n                _this._networkInformation.removeEventListener('change', _this._publishNetworkChange);\n            }\n            if (typeof window !== 'undefined' && window.removeEventListener) {\n                window.removeEventListener('beforeunload', _this._confirmClose);\n                window.removeEventListener('unload', _this.destroy);\n                window.removeEventListener('pagehide', _this.destroy);\n            }\n        };\n        /**\n         * Called on window's beforeunload event if closeProtection is enabled,\n         * preventing users from accidentally navigating away from an active call.\n         * @param event\n         */\n        _this._confirmClose = function (event) {\n            if (!_this._activeConnection) {\n                return '';\n            }\n            var closeProtection = _this.options.closeProtection || false;\n            var confirmationMsg = typeof closeProtection !== 'string'\n                ? 'A call is currently in-progress. Leaving or reloading this page will end the call.'\n                : closeProtection;\n            (event || window.event).returnValue = confirmationMsg;\n            return confirmationMsg;\n        };\n        /**\n         * Create the default Insights payload\n         * @param [connection]\n         */\n        _this._createDefaultPayload = function (connection) {\n            var payload = {\n                aggressive_nomination: _this.options.forceAggressiveIceNomination,\n                browser_extension: _this._isBrowserExtension,\n                dscp: !!_this.options.dscp,\n                ice_restart_enabled: _this.options.enableIceRestart,\n                platform: rtc.getMediaEngine(),\n                sdk_version: C.RELEASE_VERSION,\n            };\n            function setIfDefined(propertyName, value) {\n                if (value) {\n                    payload[propertyName] = value;\n                }\n            }\n            if (connection) {\n                var callSid = connection.parameters.CallSid;\n                setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n                setIfDefined('temp_call_sid', connection.outboundConnectionId);\n                setIfDefined('audio_codec', connection.codec);\n                payload.direction = connection.direction;\n            }\n            setIfDefined('gateway', _this.stream && _this.stream.gateway);\n            setIfDefined('selected_region', _this.options.region);\n            setIfDefined('region', _this.stream && _this.stream.region);\n            return payload;\n        };\n        /**\n         * Disconnect all {@link Connection}s.\n         */\n        _this._disconnectAll = function () {\n            var connections = _this.connections.splice(0);\n            connections.forEach(function (conn) { return conn.disconnect(); });\n            if (_this._activeConnection) {\n                _this._activeConnection.disconnect();\n            }\n        };\n        /**\n         * Called when a 'close' event is received from the signaling stream.\n         */\n        _this._onSignalingClose = function () {\n            _this.stream = null;\n        };\n        /**\n         * Called when a 'connected' event is received from the signaling stream.\n         */\n        _this._onSignalingConnected = function (payload) {\n            var region = regions_1.getRegionShortcode(payload.region);\n            _this._edge = regions_1.regionToEdge[region] || payload.region;\n            _this._region = region || payload.region;\n            _this._sendPresence();\n        };\n        /**\n         * Called when an 'error' event is received from the signaling stream.\n         */\n        _this._onSignalingError = function (payload) {\n            if (!payload.error) {\n                return;\n            }\n            var error = __assign({}, payload.error);\n            var sid = payload.callsid;\n            if (sid) {\n                error.connection = _this._findConnection(sid);\n            }\n            if (error.code === 31201) {\n                error.twilioError = new errors_1.AuthorizationErrors.AuthenticationFailed();\n            }\n            else if (error.code === 31204) {\n                error.twilioError = new errors_1.AuthorizationErrors.AccessTokenInvalid();\n            }\n            else if (error.code === 31205) {\n                // Stop trying to register presence after token expires\n                _this._stopRegistrationTimer();\n                error.twilioError = new errors_1.AuthorizationErrors.AccessTokenExpired();\n            }\n            else if (!error.twilioError) {\n                error.twilioError = new errors_1.GeneralErrors.UnknownError();\n            }\n            _this._log.info('Received error: ', error);\n            _this.emit('error', error);\n        };\n        /**\n         * Called when an 'invite' event is received from the signaling stream.\n         */\n        _this._onSignalingInvite = function (payload) {\n            var wasBusy = !!_this._activeConnection;\n            if (wasBusy && !_this.options.allowIncomingWhileBusy) {\n                _this._log.info('Device busy; ignoring incoming invite');\n                return;\n            }\n            if (!payload.callsid || !payload.sdp) {\n                _this.emit('error', { message: 'Malformed invite from gateway', twilioError: new errors_1.ClientErrors.BadRequest() });\n                return;\n            }\n            var callParameters = payload.parameters || {};\n            callParameters.CallSid = callParameters.CallSid || payload.callsid;\n            var customParameters = Object.assign({}, util_1.queryToJson(callParameters.Params));\n            var connection = _this._makeConnection(customParameters, {\n                callParameters: callParameters,\n                offerSdp: payload.sdp,\n            });\n            _this.connections.push(connection);\n            connection.once('accept', function () {\n                _this.soundcache.get(Device.SoundName.Incoming).stop();\n                _this._publishNetworkChange();\n            });\n            var play = (_this._enabledSounds.incoming && !wasBusy)\n                ? function () { return _this.soundcache.get(Device.SoundName.Incoming).play(); }\n                : function () { return Promise.resolve(); };\n            _this._showIncomingConnection(connection, play);\n        };\n        /**\n         * Called when an 'offline' event is received from the signaling stream.\n         */\n        _this._onSignalingOffline = function () {\n            _this._log.info('Stream is offline');\n            _this._status = Device.Status.Offline;\n            _this._edge = null;\n            _this._region = null;\n            _this.emit('offline', _this);\n        };\n        /**\n         * Called when a 'ready' event is received from the signaling stream.\n         */\n        _this._onSignalingReady = function () {\n            _this._log.info('Stream is ready');\n            _this._status = Device.Status.Ready;\n            _this.emit('ready', _this);\n        };\n        /**\n         * Publish a NetworkInformation#change event to Insights if there's an active {@link Connection}.\n         */\n        _this._publishNetworkChange = function () {\n            if (!_this._activeConnection) {\n                return;\n            }\n            if (_this._networkInformation) {\n                _this._publisher.info('network-information', 'network-change', {\n                    connection_type: _this._networkInformation.type,\n                    downlink: _this._networkInformation.downlink,\n                    downlinkMax: _this._networkInformation.downlinkMax,\n                    effective_type: _this._networkInformation.effectiveType,\n                    rtt: _this._networkInformation.rtt,\n                }, _this._activeConnection);\n            }\n        };\n        /**\n         * Update the input stream being used for calls so that any current call and all future calls\n         * will use the new input stream.\n         * @param inputStream\n         */\n        _this._updateInputStream = function (inputStream) {\n            var connection = _this._activeConnection;\n            if (connection && !inputStream) {\n                return Promise.reject(new errors_1.InvalidStateError('Cannot unset input device while a call is in progress.'));\n            }\n            _this._connectionInputStream = inputStream;\n            return connection\n                ? connection._setInputTracksFromStream(inputStream)\n                : Promise.resolve();\n        };\n        /**\n         * Update the device IDs of output devices being used to play sounds through.\n         * @param type - Whether to update ringtone or speaker sounds\n         * @param sinkIds - An array of device IDs\n         */\n        _this._updateSinkIds = function (type, sinkIds) {\n            var promise = type === 'ringtone'\n                ? _this._updateRingtoneSinkIds(sinkIds)\n                : _this._updateSpeakerSinkIds(sinkIds);\n            return promise.then(function () {\n                _this._publisher.info('audio', type + \"-devices-set\", {\n                    audio_device_ids: sinkIds,\n                }, _this._activeConnection);\n            }, function (error) {\n                _this._publisher.error('audio', type + \"-devices-set-failed\", {\n                    audio_device_ids: sinkIds,\n                    message: error.message,\n                }, _this._activeConnection);\n                throw error;\n            });\n        };\n        if (window) {\n            var root = window;\n            var browser = root.msBrowser || root.browser || root.chrome;\n            _this._isBrowserExtension = (!!browser && !!browser.runtime && !!browser.runtime.id)\n                || (!!root.safari && !!root.safari.extension);\n        }\n        if (_this._isBrowserExtension) {\n            _this._log.info('Running as browser extension.');\n        }\n        if (navigator) {\n            var n = navigator;\n            _this._networkInformation = n.connection\n                || n.mozConnection\n                || n.webkitConnection;\n        }\n        if (token) {\n            _this.setup(token, options);\n        }\n        else if (options) {\n            throw new errors_1.InvalidArgumentError('Cannot construct a Device with options but without a token');\n        }\n        return _this;\n    }\n    Object.defineProperty(Device, \"audioContext\", {\n        /**\n         * The AudioContext to be used by {@link Device} instances.\n         * @private\n         */\n        get: function () {\n            return Device._audioContext;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Device, \"extension\", {\n        /**\n         * Which sound file extension is supported.\n         * @private\n         */\n        get: function () {\n            // NOTE(mroberts): Node workaround.\n            var a = typeof document !== 'undefined'\n                ? document.createElement('audio') : { canPlayType: false };\n            var canPlayMp3;\n            try {\n                canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n            }\n            catch (e) {\n                canPlayMp3 = false;\n            }\n            var canPlayVorbis;\n            try {\n                canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n            }\n            catch (e) {\n                canPlayVorbis = false;\n            }\n            return (canPlayVorbis && !canPlayMp3) ? 'ogg' : 'mp3';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Device, \"isSupported\", {\n        /**\n         * Whether or not this SDK is supported by the current browser.\n         */\n        get: function () { return rtc.enabled(); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Device, \"packageName\", {\n        /**\n         * Package name of the SDK.\n         */\n        get: function () { return C.PACKAGE_NAME; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Run some tests to identify issues, if any, prohibiting successful calling.\n     * @param token - A Twilio JWT token string\n     * @param options\n     */\n    Device.runPreflight = function (token, options) {\n        return new preflight_1.PreflightTest(token, __assign({ audioContext: Device._getOrCreateAudioContext() }, options));\n    };\n    /**\n     * String representation of {@link Device} class.\n     * @private\n     */\n    Device.toString = function () {\n        return '[Twilio.Device class]';\n    };\n    Object.defineProperty(Device, \"version\", {\n        /**\n         * Current SDK version.\n         */\n        get: function () { return C.RELEASE_VERSION; },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Initializes the AudioContext instance shared across the Client SDK,\n     * or returns the existing instance if one has already been initialized.\n     */\n    Device._getOrCreateAudioContext = function () {\n        if (!Device._audioContext) {\n            if (typeof AudioContext !== 'undefined') {\n                Device._audioContext = new AudioContext();\n            }\n            else if (typeof webkitAudioContext !== 'undefined') {\n                Device._audioContext = new webkitAudioContext();\n            }\n        }\n        return Device._audioContext;\n    };\n    /**\n     * Return the active {@link Connection}. Null or undefined for backward compatibility.\n     */\n    Device.prototype.activeConnection = function () {\n        if (!this.isInitialized) {\n            return null;\n        }\n        // @rrowland This should only return activeConnection, but customers have built around this\n        // broken behavior and in order to not break their apps we are including this until\n        // the next big release.\n        return this._activeConnection || this.connections[0];\n    };\n    /**\n     * @deprecated Set a handler for the cancel event.\n     * @param handler\n     */\n    Device.prototype.cancel = function (handler) {\n        return this._addHandler(Device.EventName.Cancel, handler);\n    };\n    Device.prototype.connect = function (paramsOrHandler, audioConstraints, rtcConfiguration) {\n        if (typeof paramsOrHandler === 'function') {\n            this._addHandler(Device.EventName.Connect, paramsOrHandler);\n            return null;\n        }\n        this._throwUnlessSetup('connect');\n        if (this._activeConnection) {\n            throw new errors_1.InvalidStateError('A Connection is already active');\n        }\n        var params = paramsOrHandler || {};\n        audioConstraints = audioConstraints || this.options && this.options.audioConstraints || {};\n        rtcConfiguration = rtcConfiguration || this.options.rtcConfiguration;\n        var connection = this._activeConnection = this._makeConnection(params, { rtcConfiguration: rtcConfiguration });\n        // Make sure any incoming connections are ignored\n        this.connections.splice(0).forEach(function (conn) { return conn.ignore(); });\n        // Stop the incoming sound if it's playing\n        this.soundcache.get(Device.SoundName.Incoming).stop();\n        connection.accept(audioConstraints);\n        this._publishNetworkChange();\n        return connection;\n    };\n    /**\n     * Set a handler for the disconnect event.\n     * @deprecated Use {@link Device.on}.\n     * @param handler\n     */\n    Device.prototype.disconnect = function (handler) {\n        return this._addHandler(Device.EventName.Disconnect, handler);\n    };\n    /**\n     * Disconnect all {@link Connection}s.\n     */\n    Device.prototype.disconnectAll = function () {\n        this._throwUnlessSetup('disconnectAll');\n        this._disconnectAll();\n    };\n    Object.defineProperty(Device.prototype, \"edge\", {\n        /**\n         * Returns the {@link Edge} value the {@link Device} is currently connected\n         * to. The value will be `null` when the {@link Device} is offline.\n         */\n        get: function () {\n            return this._edge;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Set a handler for the error event.\n     * @deprecated Use {@link Device.on}.\n     * @param handler\n     */\n    Device.prototype.error = function (handler) {\n        return this._addHandler(Device.EventName.Error, handler);\n    };\n    /**\n     * Set a handler for the incoming event.\n     * @deprecated Use {@link Device.on}.\n     * @param handler\n     */\n    Device.prototype.incoming = function (handler) {\n        return this._addHandler(Device.EventName.Incoming, handler);\n    };\n    /**\n     * Set a handler for the offline event.\n     * @deprecated Use {@link Device.on}.\n     * @param handler\n     */\n    Device.prototype.offline = function (handler) {\n        return this._addHandler(Device.EventName.Offline, handler);\n    };\n    /**\n     * Set a handler for the ready event.\n     * @deprecated Use {@link Device.on}.\n     * @param handler\n     */\n    Device.prototype.ready = function (handler) {\n        return this._addHandler(Device.EventName.Ready, handler);\n    };\n    /**\n     * Get the {@link Region} string the {@link Device} is currently connected to, or 'offline'\n     * if not connected.\n     */\n    Device.prototype.region = function () {\n        this._log.warn('`Device.region` is deprecated and will be removed in the next major ' +\n            'release. Please use `Device.edge` instead.');\n        this._throwUnlessSetup('region');\n        return typeof this._region === 'string' ? this._region : 'offline';\n    };\n    /**\n     * Register to receive incoming calls. Does not need to be called unless {@link Device.unregisterPresence}\n     * has been called directly.\n     */\n    Device.prototype.registerPresence = function () {\n        this._throwUnlessSetup('registerPresence');\n        this.mediaPresence.audio = true;\n        this._sendPresence();\n        return this;\n    };\n    /**\n     * Remove an event listener\n     * @param event - The event name to stop listening for\n     * @param listener - The callback to remove\n     */\n    Device.prototype.removeListener = function (event, listener) {\n        events_1.EventEmitter.prototype.removeListener.call(this, event, listener);\n        return this;\n    };\n    /**\n     * Initialize the {@link Device}.\n     * @param token - A Twilio JWT token string granting this {@link Device} access.\n     * @param [options]\n     */\n    Device.prototype.setup = function (token, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        if (util_1.isLegacyEdge()) {\n            throw new errors_1.NotSupportedError('Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' +\n                'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' +\n                'Please see this documentation for a list of supported browsers ' +\n                'https://www.twilio.com/docs/voice/client/javascript#supported-browsers');\n        }\n        if (!Device.isSupported && !options.ignoreBrowserSupport) {\n            if (window && window.location && window.location.protocol === 'http:') {\n                throw new errors_1.NotSupportedError(\"twilio.js wasn't able to find WebRTC browser support.           This is most likely because this page is served over http rather than https,           which does not support WebRTC in many browsers. Please load this page over https and           try again.\");\n            }\n            throw new errors_1.NotSupportedError(\"twilio.js 1.3+ SDKs require WebRTC browser support.         For more information, see <https://www.twilio.com/docs/api/client/twilio-js>.         If you have any questions about this announcement, please contact         Twilio Support at <help@twilio.com>.\");\n        }\n        if (!token) {\n            throw new errors_1.InvalidArgumentError('Token is required for Device.setup()');\n        }\n        Object.assign(this.options, options);\n        this._log.setDefaultLevel(this.options.debug\n            ? log_1.default.levels.DEBUG\n            : this.options.warnings\n                ? log_1.default.levels.WARN\n                : log_1.default.levels.SILENT);\n        this._chunderURIs = this.options.chunderw\n            ? [\"wss://\" + this.options.chunderw + \"/signal\"]\n            : regions_1.getChunderURIs(this.options.edge, this.options.region, this._log.warn.bind(this._log)).map(function (uri) { return \"wss://\" + uri + \"/signal\"; });\n        if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n            Device._isUnifiedPlanDefault = typeof window !== 'undefined'\n                && typeof RTCPeerConnection !== 'undefined'\n                && typeof RTCRtpTransceiver !== 'undefined'\n                ? util_1.isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver)\n                : false;\n        }\n        Device._getOrCreateAudioContext();\n        if (Device._audioContext && options.fakeLocalDTMF) {\n            if (!Device._dialtonePlayer) {\n                Device._dialtonePlayer = new dialtonePlayer_1.default(Device._audioContext);\n            }\n        }\n        else if (Device._dialtonePlayer) {\n            Device._dialtonePlayer.cleanup();\n            delete Device._dialtonePlayer;\n        }\n        if (this.isInitialized) {\n            this._log.info('Found existing Device; using new token but ignoring options');\n            this.updateToken(token);\n            return this;\n        }\n        this.isInitialized = true;\n        if (this.options.dscp) {\n            this.options.rtcConstraints.optional = [{ googDscp: true }];\n        }\n        var getOrSetSound = function (key, value) {\n            if (!hasBeenWarnedSounds) {\n                _this._log.warn('Device.sounds is deprecated and will be removed in the next breaking ' +\n                    'release. Please use the new functionality available on Device.audio.');\n                hasBeenWarnedSounds = true;\n            }\n            if (typeof value !== 'undefined') {\n                _this._enabledSounds[key] = value;\n            }\n            return _this._enabledSounds[key];\n        };\n        [Device.SoundName.Disconnect, Device.SoundName.Incoming, Device.SoundName.Outgoing]\n            .forEach(function (eventName) {\n            _this.sounds[eventName] = getOrSetSound.bind(null, eventName);\n        });\n        var defaultSounds = {\n            disconnect: { filename: 'disconnect', maxDuration: 3000 },\n            dtmf0: { filename: 'dtmf-0', maxDuration: 1000 },\n            dtmf1: { filename: 'dtmf-1', maxDuration: 1000 },\n            dtmf2: { filename: 'dtmf-2', maxDuration: 1000 },\n            dtmf3: { filename: 'dtmf-3', maxDuration: 1000 },\n            dtmf4: { filename: 'dtmf-4', maxDuration: 1000 },\n            dtmf5: { filename: 'dtmf-5', maxDuration: 1000 },\n            dtmf6: { filename: 'dtmf-6', maxDuration: 1000 },\n            dtmf7: { filename: 'dtmf-7', maxDuration: 1000 },\n            dtmf8: { filename: 'dtmf-8', maxDuration: 1000 },\n            dtmf9: { filename: 'dtmf-9', maxDuration: 1000 },\n            dtmfh: { filename: 'dtmf-hash', maxDuration: 1000 },\n            dtmfs: { filename: 'dtmf-star', maxDuration: 1000 },\n            incoming: { filename: 'incoming', shouldLoop: true },\n            outgoing: { filename: 'outgoing', maxDuration: 3000 },\n        };\n        for (var _i = 0, _a = Object.keys(defaultSounds); _i < _a.length; _i++) {\n            var name_1 = _a[_i];\n            var soundDef = defaultSounds[name_1];\n            var defaultUrl = C.SOUNDS_BASE_URL + \"/\" + soundDef.filename + \".\" + Device.extension\n                + (\"?cache=\" + C.RELEASE_VERSION);\n            var soundUrl = this.options.sounds && this.options.sounds[name_1] || defaultUrl;\n            var sound = new this.options.soundFactory(name_1, soundUrl, {\n                audioContext: this.options.disableAudioContextSounds ? null : Device.audioContext,\n                maxDuration: soundDef.maxDuration,\n                shouldLoop: soundDef.shouldLoop,\n            });\n            this.soundcache.set(name_1, sound);\n        }\n        this._publisher = (this.options.Publisher || Publisher)('twilio-js-sdk', token, {\n            defaultPayload: this._createDefaultPayload,\n            host: this.options.eventgw,\n            metadata: {\n                app_name: this.options.appName,\n                app_version: this.options.appVersion,\n            },\n        });\n        if (this.options.publishEvents === false) {\n            this._publisher.disable();\n        }\n        else {\n            this._publisher.on('error', function (error) {\n                _this._log.warn('Cannot connect to insights.', error);\n            });\n        }\n        if (this._networkInformation && typeof this._networkInformation.addEventListener === 'function') {\n            this._networkInformation.addEventListener('change', this._publishNetworkChange);\n        }\n        this.audio = new (this.options.AudioHelper || audiohelper_1.default)(this._updateSinkIds, this._updateInputStream, getUserMedia, {\n            audioContext: Device.audioContext,\n            enabledSounds: this._enabledSounds,\n        });\n        this.audio.on('deviceChange', function (lostActiveDevices) {\n            var activeConnection = _this._activeConnection;\n            var deviceIds = lostActiveDevices.map(function (device) { return device.deviceId; });\n            _this._publisher.info('audio', 'device-change', {\n                lost_active_device_ids: deviceIds,\n            }, activeConnection);\n            if (activeConnection) {\n                activeConnection.mediaStream._onInputDevicesChanged();\n            }\n        });\n        this.mediaPresence.audio = !this.options.noRegister;\n        this.updateToken(token);\n        // Setup close protection and make sure we clean up ongoing calls on unload.\n        if (typeof window !== 'undefined' && window.addEventListener) {\n            window.addEventListener('unload', this.destroy);\n            window.addEventListener('pagehide', this.destroy);\n            if (this.options.closeProtection) {\n                window.addEventListener('beforeunload', this._confirmClose);\n            }\n        }\n        // (rrowland) This maintains backward compatibility, but we should look at\n        // removing this next breaking change. Any error should be caught by the\n        // customer, and anything that's not a fatal error should not be emitted\n        // via error event.\n        this.on(Device.EventName.Error, function () {\n            if (_this.listenerCount('error') > 1) {\n                return;\n            }\n            _this._log.info('Uncaught error event suppressed.');\n        });\n        return this;\n    };\n    /**\n     * Get the status of this {@link Device} instance\n     */\n    Device.prototype.status = function () {\n        this._throwUnlessSetup('status');\n        return this._activeConnection ? Device.Status.Busy : this._status;\n    };\n    /**\n     * String representation of {@link Device} instance.\n     * @private\n     */\n    Device.prototype.toString = function () {\n        return '[Twilio.Device instance]';\n    };\n    /**\n     * Unregister to receiving incoming calls.\n     */\n    Device.prototype.unregisterPresence = function () {\n        this._throwUnlessSetup('unregisterPresence');\n        this.mediaPresence.audio = false;\n        this._sendPresence();\n        return this;\n    };\n    /**\n     * Update the token and re-register.\n     * @param token - The new token JWT string to register with.\n     */\n    Device.prototype.updateToken = function (token) {\n        this._throwUnlessSetup('updateToken');\n        this.token = token;\n        this.register(token);\n    };\n    /**\n     * Add a handler for an EventEmitter and emit a deprecation warning on first call.\n     * @param eventName - Name of the event\n     * @param handler - A handler to call when the event is emitted\n     */\n    Device.prototype._addHandler = function (eventName, handler) {\n        if (!hasBeenWarnedHandlers) {\n            this._log.warn(\"Device callback handlers (connect, error, offline, incoming, cancel, ready, disconnect)         have been deprecated and will be removed in the next breaking release. Instead, the EventEmitter         interface can be used to set event listeners. Example: device.on('\" + eventName + \"', handler)\");\n            hasBeenWarnedHandlers = true;\n        }\n        this.addListener(eventName, handler);\n        return this;\n    };\n    /**\n     * Calls the emit API such that it is asynchronous.\n     * Only use this internal API if you don't want to break the execution after raising an event.\n     * This prevents the issue where events are not dispatched to all handlers when one of the handlers throws an error.\n     * For example, our connection:accept is not triggered if the handler for device:connect handler throws an error.\n     * As a side effect, we are not able to perform our internal routines such as stopping incoming sounds.\n     * See connection:accept inside _makeConnection where we call emit('connect'). This can throw an error.\n     * See connection:accept inside _onSignalingInvite. This handler won't get called if the error above is thrown.\n     * @private\n     */\n    Device.prototype._asyncEmit = function (event) {\n        var _this = this;\n        var args = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n        }\n        setTimeout(function () { return _this.emit.apply(_this, __spreadArrays([event], args)); });\n    };\n    /**\n     * Find a {@link Connection} by its CallSid.\n     * @param callSid\n     */\n    Device.prototype._findConnection = function (callSid) {\n        return this.connections.find(function (conn) { return conn.parameters.CallSid === callSid\n            || conn.outboundConnectionId === callSid; }) || null;\n    };\n    /**\n     * Create a new {@link Connection}.\n     * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n     * @param [options] - Options to be used to instantiate the {@link Connection}.\n     */\n    Device.prototype._makeConnection = function (twimlParams, options) {\n        var _this = this;\n        if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n            throw new errors_1.InvalidStateError('Device has not been initialized.');\n        }\n        var config = {\n            audioHelper: this.audio,\n            getUserMedia: getUserMedia,\n            isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n            pstream: this.stream,\n            publisher: this._publisher,\n            soundcache: this.soundcache,\n        };\n        options = Object.assign({\n            MediaStream: this.options.MediaStream\n                || this.options.mediaStreamFactory\n                || rtc.PeerConnection,\n            audioConstraints: this.options.audioConstraints,\n            beforeAccept: function (conn) {\n                if (!_this._activeConnection || _this._activeConnection === conn) {\n                    return;\n                }\n                _this._activeConnection.disconnect();\n                _this._removeConnection(_this._activeConnection);\n            },\n            codecPreferences: this.options.codecPreferences,\n            dialtonePlayer: Device._dialtonePlayer,\n            dscp: this.options.dscp,\n            enableIceRestart: this.options.enableIceRestart,\n            enableRingingState: this.options.enableRingingState,\n            forceAggressiveIceNomination: this.options.forceAggressiveIceNomination,\n            getInputStream: function () { return _this.options.fileInputStream || _this._connectionInputStream; },\n            getSinkIds: function () { return _this._connectionSinkIds; },\n            maxAverageBitrate: this.options.maxAverageBitrate,\n            preflight: this.options.preflight,\n            rtcConfiguration: this.options.rtcConfiguration || { iceServers: this.options.iceServers },\n            rtcConstraints: this.options.rtcConstraints,\n            shouldPlayDisconnect: function () { return _this._enabledSounds.disconnect; },\n            twimlParams: twimlParams,\n        }, options);\n        var connection = new this.options.connectionFactory(config, options);\n        connection.once('accept', function () {\n            _this._removeConnection(connection);\n            _this._activeConnection = connection;\n            if (_this.audio) {\n                _this.audio._maybeStartPollingVolume();\n            }\n            if (connection.direction === connection_1.default.CallDirection.Outgoing && _this._enabledSounds.outgoing) {\n                _this.soundcache.get(Device.SoundName.Outgoing).play();\n            }\n            var data = { edge: _this._edge || _this._region };\n            var selectedEdge = _this.options.edge;\n            if (selectedEdge) {\n                data['selected_edge'] = Array.isArray(selectedEdge) ? selectedEdge : [selectedEdge];\n            }\n            _this._publisher.info('settings', 'edge', data, connection);\n            _this._asyncEmit('connect', connection);\n        });\n        connection.addListener('error', function (error) {\n            if (connection.status() === 'closed') {\n                _this._removeConnection(connection);\n            }\n            if (_this.audio) {\n                _this.audio._maybeStopPollingVolume();\n            }\n            _this._maybeStopIncomingSound();\n            _this._asyncEmit('error', error);\n        });\n        connection.once('cancel', function () {\n            _this._log.info(\"Canceled: \" + connection.parameters.CallSid);\n            _this._removeConnection(connection);\n            if (_this.audio) {\n                _this.audio._maybeStopPollingVolume();\n            }\n            _this._maybeStopIncomingSound();\n            _this._asyncEmit('cancel', connection);\n        });\n        connection.once('disconnect', function () {\n            if (_this.audio) {\n                _this.audio._maybeStopPollingVolume();\n            }\n            _this._removeConnection(connection);\n            _this._asyncEmit('disconnect', connection);\n        });\n        connection.once('reject', function () {\n            _this._log.info(\"Rejected: \" + connection.parameters.CallSid);\n            if (_this.audio) {\n                _this.audio._maybeStopPollingVolume();\n            }\n            _this._removeConnection(connection);\n            _this._maybeStopIncomingSound();\n        });\n        connection.once('transportClose', function () {\n            if (connection.status() !== connection_1.default.State.Pending) {\n                return;\n            }\n            if (_this.audio) {\n                _this.audio._maybeStopPollingVolume();\n            }\n            _this._removeConnection(connection);\n            _this._maybeStopIncomingSound();\n        });\n        return connection;\n    };\n    /**\n     * Stop the incoming sound if no {@link Connection}s remain.\n     */\n    Device.prototype._maybeStopIncomingSound = function () {\n        if (!this.connections.length) {\n            this.soundcache.get(Device.SoundName.Incoming).stop();\n        }\n    };\n    /**\n     * Remove a {@link Connection} from device.connections by reference\n     * @param connection\n     */\n    Device.prototype._removeConnection = function (connection) {\n        if (this._activeConnection === connection) {\n            this._activeConnection = null;\n        }\n        for (var i = this.connections.length - 1; i >= 0; i--) {\n            if (connection === this.connections[i]) {\n                this.connections.splice(i, 1);\n            }\n        }\n    };\n    /**\n     * Register with the signaling server.\n     */\n    Device.prototype._sendPresence = function () {\n        if (!this.stream) {\n            return;\n        }\n        this.stream.register({ audio: this.mediaPresence.audio });\n        if (this.mediaPresence.audio) {\n            this._startRegistrationTimer();\n        }\n        else {\n            this._stopRegistrationTimer();\n        }\n    };\n    /**\n     * Set up the connection to the signaling server.\n     * @param token\n     */\n    Device.prototype._setupStream = function (token) {\n        this._log.info('Setting up VSP');\n        this.stream = this.options.pStreamFactory(token, this._chunderURIs, {\n            backoffMaxMs: this.options.backoffMaxMs,\n        });\n        this.stream.addListener('close', this._onSignalingClose);\n        this.stream.addListener('connected', this._onSignalingConnected);\n        this.stream.addListener('error', this._onSignalingError);\n        this.stream.addListener('invite', this._onSignalingInvite);\n        this.stream.addListener('offline', this._onSignalingOffline);\n        this.stream.addListener('ready', this._onSignalingReady);\n    };\n    /**\n     * Start playing the incoming ringtone, and subsequently emit the incoming event.\n     * @param connection\n     * @param play - The function to be used to play the sound. Must return a Promise.\n     */\n    Device.prototype._showIncomingConnection = function (connection, play) {\n        var _this = this;\n        var timeout;\n        return Promise.race([\n            play(),\n            new Promise(function (resolve, reject) {\n                timeout = setTimeout(function () {\n                    var msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n                    reject(new Error(msg));\n                }, RINGTONE_PLAY_TIMEOUT);\n            }),\n        ]).catch(function (reason) {\n            _this._log.info(reason.message);\n        }).then(function () {\n            clearTimeout(timeout);\n            _this.emit('incoming', connection);\n        });\n    };\n    /**\n     * Set a timeout to send another register message to the signaling server.\n     */\n    Device.prototype._startRegistrationTimer = function () {\n        var _this = this;\n        this._stopRegistrationTimer();\n        this.regTimer = setTimeout(function () {\n            _this._sendPresence();\n        }, REGISTRATION_INTERVAL);\n    };\n    /**\n     * Stop sending registration messages to the signaling server.\n     */\n    Device.prototype._stopRegistrationTimer = function () {\n        if (this.regTimer) {\n            clearTimeout(this.regTimer);\n        }\n    };\n    /**\n     * Throw an Error if Device.setup has not been called for this instance.\n     * @param methodName - The name of the method being called before setup()\n     */\n    Device.prototype._throwUnlessSetup = function (methodName) {\n        if (!this.isInitialized) {\n            throw new errors_1.InvalidStateError(\"Call Device.setup() before \" + methodName);\n        }\n    };\n    /**\n     * Update the device IDs of output devices being used to play the incoming ringtone through.\n     * @param sinkIds - An array of device IDs\n     */\n    Device.prototype._updateRingtoneSinkIds = function (sinkIds) {\n        return Promise.resolve(this.soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n    };\n    /**\n     * Update the device IDs of output devices being used to play the non-ringtone sounds\n     * and Call audio through.\n     * @param sinkIds - An array of device IDs\n     */\n    Device.prototype._updateSpeakerSinkIds = function (sinkIds) {\n        Array.from(this.soundcache.entries())\n            .filter(function (entry) { return entry[0] !== Device.SoundName.Incoming; })\n            .forEach(function (entry) { return entry[1].setSinkIds(sinkIds); });\n        this._connectionSinkIds = sinkIds;\n        var connection = this._activeConnection;\n        return connection\n            ? connection._setSinkIds(sinkIds)\n            : Promise.resolve();\n    };\n    /**\n     * Register the {@link Device}\n     * @param token\n     */\n    Device.prototype.register = function (token) {\n        if (this.stream) {\n            this.stream.setToken(token);\n            this._publisher.setToken(token);\n        }\n        else {\n            this._setupStream(token);\n        }\n    };\n    return Device;\n}(events_1.EventEmitter));\n(function (Device) {\n    /**\n     * All valid {@link Device} event names.\n     */\n    var EventName;\n    (function (EventName) {\n        EventName[\"Cancel\"] = \"cancel\";\n        EventName[\"Connect\"] = \"connect\";\n        EventName[\"Disconnect\"] = \"disconnect\";\n        EventName[\"Error\"] = \"error\";\n        EventName[\"Incoming\"] = \"incoming\";\n        EventName[\"Offline\"] = \"offline\";\n        EventName[\"Ready\"] = \"ready\";\n    })(EventName = Device.EventName || (Device.EventName = {}));\n    /**\n     * All possible {@link Device} statuses.\n     */\n    var Status;\n    (function (Status) {\n        Status[\"Busy\"] = \"busy\";\n        Status[\"Offline\"] = \"offline\";\n        Status[\"Ready\"] = \"ready\";\n    })(Status = Device.Status || (Device.Status = {}));\n    /**\n     * Names of all sounds handled by the {@link Device}.\n     */\n    var SoundName;\n    (function (SoundName) {\n        SoundName[\"Incoming\"] = \"incoming\";\n        SoundName[\"Outgoing\"] = \"outgoing\";\n        SoundName[\"Disconnect\"] = \"disconnect\";\n        SoundName[\"Dtmf0\"] = \"dtmf0\";\n        SoundName[\"Dtmf1\"] = \"dtmf1\";\n        SoundName[\"Dtmf2\"] = \"dtmf2\";\n        SoundName[\"Dtmf3\"] = \"dtmf3\";\n        SoundName[\"Dtmf4\"] = \"dtmf4\";\n        SoundName[\"Dtmf5\"] = \"dtmf5\";\n        SoundName[\"Dtmf6\"] = \"dtmf6\";\n        SoundName[\"Dtmf7\"] = \"dtmf7\";\n        SoundName[\"Dtmf8\"] = \"dtmf8\";\n        SoundName[\"Dtmf9\"] = \"dtmf9\";\n        SoundName[\"DtmfS\"] = \"dtmfs\";\n        SoundName[\"DtmfH\"] = \"dtmfh\";\n    })(SoundName = Device.SoundName || (Device.SoundName = {}));\n})(Device || (Device = {}));\nexports.default = Device;\n//# sourceMappingURL=device.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2RldmljZS5qcz9mYWY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pELHdDQUF3QyxRQUFRO0FBQ2hELHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxDQUFDLGNBQWMsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsK0NBQVE7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsNkVBQWU7QUFDM0MsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWM7QUFDekMsdUJBQXVCLG1CQUFPLENBQUMsbUZBQWtCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyx5RUFBVTtBQUNqQyxZQUFZLG1CQUFPLENBQUMsNkRBQU87QUFDM0Isa0JBQWtCLG1CQUFPLENBQUMsNkZBQXVCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHFFQUFXO0FBQ25DLGFBQWEsbUJBQU8sQ0FBQywrREFBUTtBQUM3QixRQUFRLG1CQUFPLENBQUMseUVBQWE7QUFDN0IsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWtCO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxxRUFBVztBQUNqQyxVQUFVLG1CQUFPLENBQUMsbUVBQU87QUFDekIsbUJBQW1CLG1CQUFPLENBQUMsdUZBQW9CO0FBQy9DLFlBQVksbUJBQU8sQ0FBQyxp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d0JBQXdCO0FBQ3pCLGVBQWU7QUFDZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vZGV2aWNlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19zcHJlYWRBcnJheXMgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXlzKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xuICAgIHJldHVybiByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFZvaWNlXG4gKiBAcHJlZmVycmVkXG4gKiBAcHVibGljYXBpXG4gKi9cbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgYXVkaW9oZWxwZXJfMSA9IHJlcXVpcmUoXCIuL2F1ZGlvaGVscGVyXCIpO1xudmFyIGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpb25cIik7XG52YXIgZGlhbHRvbmVQbGF5ZXJfMSA9IHJlcXVpcmUoXCIuL2RpYWx0b25lUGxheWVyXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGxvZ18xID0gcmVxdWlyZShcIi4vbG9nXCIpO1xudmFyIHByZWZsaWdodF8xID0gcmVxdWlyZShcIi4vcHJlZmxpZ2h0L3ByZWZsaWdodFwiKTtcbnZhciByZWdpb25zXzEgPSByZXF1aXJlKFwiLi9yZWdpb25zXCIpO1xudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgQyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG52YXIgUHVibGlzaGVyID0gcmVxdWlyZSgnLi9ldmVudHB1Ymxpc2hlcicpO1xudmFyIFBTdHJlYW0gPSByZXF1aXJlKCcuL3BzdHJlYW0nKTtcbnZhciBydGMgPSByZXF1aXJlKCcuL3J0YycpO1xudmFyIGdldFVzZXJNZWRpYSA9IHJlcXVpcmUoJy4vcnRjL2dldHVzZXJtZWRpYScpO1xudmFyIFNvdW5kID0gcmVxdWlyZSgnLi9zb3VuZCcpO1xudmFyIFJFR0lTVFJBVElPTl9JTlRFUlZBTCA9IDMwMDAwO1xudmFyIFJJTkdUT05FX1BMQVlfVElNRU9VVCA9IDIwMDA7XG52YXIgaGFzQmVlbldhcm5lZEhhbmRsZXJzID0gZmFsc2U7XG52YXIgaGFzQmVlbldhcm5lZFNvdW5kcyA9IGZhbHNlO1xuLyoqXG4gKiBUd2lsaW8gRGV2aWNlLiBBbGxvd3MgcmVnaXN0cmF0aW9uIGZvciBpbmNvbWluZyBjYWxscywgYW5kIHBsYWNpbmcgb3V0Z29pbmcgY2FsbHMuXG4gKiBAcHVibGljYXBpXG4gKi9cbnZhciBEZXZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERldmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZXZpY2UodG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEF1ZGlvSGVscGVyIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHtAbGluayBEZXZpY2V9LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuYXVkaW8gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2Yge0BsaW5rIENvbm5lY3Rpb259cy4gVGhvdWdoIG9ubHkgb25lIGNhbiBiZSBhY3RpdmUsIG11bHRpcGxlIG1heSBleGlzdCB3aGVuIHRoZXJlXG4gICAgICAgICAqIGFyZSBtdWx0aXBsZSBpbmNvbWluZywgdW5hbnN3ZXJlZCB7QGxpbmsgQ29ubmVjdGlvbn1zLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHtAbGluayBEZXZpY2Uuc2V0dXB9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZHMgdG8gZW5hYmxlL2Rpc2FibGUgZWFjaCBzb3VuZC4gRW1wdHkgaWYgdGhlIHtAbGluayBEZXZpY2V9IGhhcyBub3RcbiAgICAgICAgICogeWV0IGJlZW4gc2V0IHVwLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc291bmRzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgSldUIHN0cmluZyBjdXJyZW50bHkgYmVpbmcgdXNlZCB0byBhdXRoZW50aWNhdGUgdGhpcyB7QGxpbmsgRGV2aWNlfS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnRva2VuID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIHtAbGluayBDb25uZWN0aW9ufSwgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2YgY2h1bmRlciBVUklzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gUFN0cmVhbVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2NodW5kZXJVUklzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhdWRpbyBpbnB1dCBNZWRpYVN0cmVhbSB0byBwYXNzIHRvIG5ldyB7QGxpbmsgQ29ubmVjdGlvbn0gaW5zdGFuY2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2Nvbm5lY3Rpb25JbnB1dFN0cmVhbSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBhcnJheSBvZiB7QGxpbmsgRGV2aWNlfSBJRHMgdG8gYmUgdXNlZCB0byBwbGF5IHNvdW5kcyB0aHJvdWdoLCB0byBiZSBwYXNzZWQgdG9cbiAgICAgICAgICogbmV3IHtAbGluayBDb25uZWN0aW9ufSBpbnN0YW5jZXMuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY29ubmVjdGlvblNpbmtJZHMgPSBbJ2RlZmF1bHQnXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSBlZGdlIHRoZSB7QGxpbmsgRGV2aWNlfSBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fZWRnZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIGVhY2ggc291bmQgaXMgZW5hYmxlZC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9lbmFibGVkU291bmRzID0gKF9hID0ge30sXG4gICAgICAgICAgICBfYVtEZXZpY2UuU291bmROYW1lLkRpc2Nvbm5lY3RdID0gdHJ1ZSxcbiAgICAgICAgICAgIF9hW0RldmljZS5Tb3VuZE5hbWUuSW5jb21pbmddID0gdHJ1ZSxcbiAgICAgICAgICAgIF9hW0RldmljZS5Tb3VuZE5hbWUuT3V0Z29pbmddID0gdHJ1ZSxcbiAgICAgICAgICAgIF9hKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGluc3RhbmNlIG9mIExvZ2dlciB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbG9nID0gbG9nXzEuZGVmYXVsdC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gSW5zaWdodHMgRXZlbnQgUHVibGlzaGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3B1Ymxpc2hlciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVnaW9uIHRoZSB7QGxpbmsgRGV2aWNlfSBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fcmVnaW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUge0BsaW5rIERldmljZX0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fc3RhdHVzID0gRGV2aWNlLlN0YXR1cy5PZmZsaW5lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgb2YgJ2F1ZGlvJyBkZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGJlIHJlZ2lzdGVyZWQgZm9yIGluY29taW5nIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubWVkaWFQcmVzZW5jZSA9IHsgYXVkaW86IHRydWUgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCB0byB7QGxpbmsgRGV2aWNlfSBjb25zdHJ1Y3RvciBvciBEZXZpY2Uuc2V0dXAuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsb3dJbmNvbWluZ1doaWxlQnVzeTogZmFsc2UsXG4gICAgICAgICAgICBhdWRpb0NvbnN0cmFpbnRzOiB0cnVlLFxuICAgICAgICAgICAgY2xvc2VQcm90ZWN0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIGNvZGVjUHJlZmVyZW5jZXM6IFtjb25uZWN0aW9uXzEuZGVmYXVsdC5Db2RlYy5QQ01VLCBjb25uZWN0aW9uXzEuZGVmYXVsdC5Db2RlYy5PcHVzXSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25GYWN0b3J5OiBjb25uZWN0aW9uXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgICAgIGRzY3A6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVJY2VSZXN0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgIGV2ZW50Z3c6ICdldmVudGd3LnR3aWxpby5jb20nLFxuICAgICAgICAgICAgZm9yY2VBZ2dyZXNzaXZlSWNlTm9taW5hdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIG5vUmVnaXN0ZXI6IGZhbHNlLFxuICAgICAgICAgICAgcFN0cmVhbUZhY3Rvcnk6IFBTdHJlYW0sXG4gICAgICAgICAgICBwcmVmbGlnaHQ6IGZhbHNlLFxuICAgICAgICAgICAgcnRjQ29uc3RyYWludHM6IHt9LFxuICAgICAgICAgICAgc291bmRGYWN0b3J5OiBTb3VuZCxcbiAgICAgICAgICAgIHNvdW5kczoge30sXG4gICAgICAgICAgICB3YXJuaW5nczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZW91dCBJRCBmb3IgYSBzZXRUaW1lb3V0IHNjaGVkdWxlIHRvIHJlLXJlZ2lzdGVyIHRoZSB7QGxpbmsgRGV2aWNlfS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLnJlZ1RpbWVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTWFwIG9mIFNvdW5kcyB0byBwbGF5LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc291bmRjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTaWduYWxpbmcgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc3RyZWFtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3Ryb3kgdGhlIHtAbGluayBEZXZpY2V9LCBmcmVlaW5nIHJlZmVyZW5jZXMgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2Rpc2Nvbm5lY3RBbGwoKTtcbiAgICAgICAgICAgIF90aGlzLl9zdG9wUmVnaXN0cmF0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hdWRpbykge1xuICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvLl91bmJpbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuX25ldHdvcmtJbmZvcm1hdGlvbiAmJiB0eXBlb2YgX3RoaXMuX25ldHdvcmtJbmZvcm1hdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX25ldHdvcmtJbmZvcm1hdGlvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBfdGhpcy5fcHVibGlzaE5ldHdvcmtDaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIF90aGlzLl9jb25maXJtQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1bmxvYWQnLCBfdGhpcy5kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCBfdGhpcy5kZXN0cm95KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBvbiB3aW5kb3cncyBiZWZvcmV1bmxvYWQgZXZlbnQgaWYgY2xvc2VQcm90ZWN0aW9uIGlzIGVuYWJsZWQsXG4gICAgICAgICAqIHByZXZlbnRpbmcgdXNlcnMgZnJvbSBhY2NpZGVudGFsbHkgbmF2aWdhdGluZyBhd2F5IGZyb20gYW4gYWN0aXZlIGNhbGwuXG4gICAgICAgICAqIEBwYXJhbSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2NvbmZpcm1DbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYWN0aXZlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbG9zZVByb3RlY3Rpb24gPSBfdGhpcy5vcHRpb25zLmNsb3NlUHJvdGVjdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb25maXJtYXRpb25Nc2cgPSB0eXBlb2YgY2xvc2VQcm90ZWN0aW9uICE9PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gJ0EgY2FsbCBpcyBjdXJyZW50bHkgaW4tcHJvZ3Jlc3MuIExlYXZpbmcgb3IgcmVsb2FkaW5nIHRoaXMgcGFnZSB3aWxsIGVuZCB0aGUgY2FsbC4nXG4gICAgICAgICAgICAgICAgOiBjbG9zZVByb3RlY3Rpb247XG4gICAgICAgICAgICAoZXZlbnQgfHwgd2luZG93LmV2ZW50KS5yZXR1cm5WYWx1ZSA9IGNvbmZpcm1hdGlvbk1zZztcbiAgICAgICAgICAgIHJldHVybiBjb25maXJtYXRpb25Nc2c7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgdGhlIGRlZmF1bHQgSW5zaWdodHMgcGF5bG9hZFxuICAgICAgICAgKiBAcGFyYW0gW2Nvbm5lY3Rpb25dXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fY3JlYXRlRGVmYXVsdFBheWxvYWQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgYWdncmVzc2l2ZV9ub21pbmF0aW9uOiBfdGhpcy5vcHRpb25zLmZvcmNlQWdncmVzc2l2ZUljZU5vbWluYXRpb24sXG4gICAgICAgICAgICAgICAgYnJvd3Nlcl9leHRlbnNpb246IF90aGlzLl9pc0Jyb3dzZXJFeHRlbnNpb24sXG4gICAgICAgICAgICAgICAgZHNjcDogISFfdGhpcy5vcHRpb25zLmRzY3AsXG4gICAgICAgICAgICAgICAgaWNlX3Jlc3RhcnRfZW5hYmxlZDogX3RoaXMub3B0aW9ucy5lbmFibGVJY2VSZXN0YXJ0LFxuICAgICAgICAgICAgICAgIHBsYXRmb3JtOiBydGMuZ2V0TWVkaWFFbmdpbmUoKSxcbiAgICAgICAgICAgICAgICBzZGtfdmVyc2lvbjogQy5SRUxFQVNFX1ZFUlNJT04sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZnVuY3Rpb24gc2V0SWZEZWZpbmVkKHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbFNpZCA9IGNvbm5lY3Rpb24ucGFyYW1ldGVycy5DYWxsU2lkO1xuICAgICAgICAgICAgICAgIHNldElmRGVmaW5lZCgnY2FsbF9zaWQnLCAvXlRKLy50ZXN0KGNhbGxTaWQpID8gdW5kZWZpbmVkIDogY2FsbFNpZCk7XG4gICAgICAgICAgICAgICAgc2V0SWZEZWZpbmVkKCd0ZW1wX2NhbGxfc2lkJywgY29ubmVjdGlvbi5vdXRib3VuZENvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgc2V0SWZEZWZpbmVkKCdhdWRpb19jb2RlYycsIGNvbm5lY3Rpb24uY29kZWMpO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuZGlyZWN0aW9uID0gY29ubmVjdGlvbi5kaXJlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJZkRlZmluZWQoJ2dhdGV3YXknLCBfdGhpcy5zdHJlYW0gJiYgX3RoaXMuc3RyZWFtLmdhdGV3YXkpO1xuICAgICAgICAgICAgc2V0SWZEZWZpbmVkKCdzZWxlY3RlZF9yZWdpb24nLCBfdGhpcy5vcHRpb25zLnJlZ2lvbik7XG4gICAgICAgICAgICBzZXRJZkRlZmluZWQoJ3JlZ2lvbicsIF90aGlzLnN0cmVhbSAmJiBfdGhpcy5zdHJlYW0ucmVnaW9uKTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzY29ubmVjdCBhbGwge0BsaW5rIENvbm5lY3Rpb259cy5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9kaXNjb25uZWN0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25zID0gX3RoaXMuY29ubmVjdGlvbnMuc3BsaWNlKDApO1xuICAgICAgICAgICAgY29ubmVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoY29ubikgeyByZXR1cm4gY29ubi5kaXNjb25uZWN0KCk7IH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLl9hY3RpdmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb24uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSAnY2xvc2UnIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25TaWduYWxpbmdDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBhICdjb25uZWN0ZWQnIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25TaWduYWxpbmdDb25uZWN0ZWQgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNfMS5nZXRSZWdpb25TaG9ydGNvZGUocGF5bG9hZC5yZWdpb24pO1xuICAgICAgICAgICAgX3RoaXMuX2VkZ2UgPSByZWdpb25zXzEucmVnaW9uVG9FZGdlW3JlZ2lvbl0gfHwgcGF5bG9hZC5yZWdpb247XG4gICAgICAgICAgICBfdGhpcy5fcmVnaW9uID0gcmVnaW9uIHx8IHBheWxvYWQucmVnaW9uO1xuICAgICAgICAgICAgX3RoaXMuX3NlbmRQcmVzZW5jZSgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYW4gJ2Vycm9yJyBldmVudCBpcyByZWNlaXZlZCBmcm9tIHRoZSBzaWduYWxpbmcgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uU2lnbmFsaW5nRXJyb3IgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgaWYgKCFwYXlsb2FkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9yID0gX19hc3NpZ24oe30sIHBheWxvYWQuZXJyb3IpO1xuICAgICAgICAgICAgdmFyIHNpZCA9IHBheWxvYWQuY2FsbHNpZDtcbiAgICAgICAgICAgIGlmIChzaWQpIHtcbiAgICAgICAgICAgICAgICBlcnJvci5jb25uZWN0aW9uID0gX3RoaXMuX2ZpbmRDb25uZWN0aW9uKHNpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gMzEyMDEpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50d2lsaW9FcnJvciA9IG5ldyBlcnJvcnNfMS5BdXRob3JpemF0aW9uRXJyb3JzLkF1dGhlbnRpY2F0aW9uRmFpbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci5jb2RlID09PSAzMTIwNCkge1xuICAgICAgICAgICAgICAgIGVycm9yLnR3aWxpb0Vycm9yID0gbmV3IGVycm9yc18xLkF1dGhvcml6YXRpb25FcnJvcnMuQWNjZXNzVG9rZW5JbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvci5jb2RlID09PSAzMTIwNSkge1xuICAgICAgICAgICAgICAgIC8vIFN0b3AgdHJ5aW5nIHRvIHJlZ2lzdGVyIHByZXNlbmNlIGFmdGVyIHRva2VuIGV4cGlyZXNcbiAgICAgICAgICAgICAgICBfdGhpcy5fc3RvcFJlZ2lzdHJhdGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgZXJyb3IudHdpbGlvRXJyb3IgPSBuZXcgZXJyb3JzXzEuQXV0aG9yaXphdGlvbkVycm9ycy5BY2Nlc3NUb2tlbkV4cGlyZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFlcnJvci50d2lsaW9FcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yLnR3aWxpb0Vycm9yID0gbmV3IGVycm9yc18xLkdlbmVyYWxFcnJvcnMuVW5rbm93bkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ1JlY2VpdmVkIGVycm9yOiAnLCBlcnJvcik7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGFuICdpbnZpdGUnIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25TaWduYWxpbmdJbnZpdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICAgICAgdmFyIHdhc0J1c3kgPSAhIV90aGlzLl9hY3RpdmVDb25uZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHdhc0J1c3kgJiYgIV90aGlzLm9wdGlvbnMuYWxsb3dJbmNvbWluZ1doaWxlQnVzeSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbygnRGV2aWNlIGJ1c3k7IGlnbm9yaW5nIGluY29taW5nIGludml0ZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF5bG9hZC5jYWxsc2lkIHx8ICFwYXlsb2FkLnNkcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgeyBtZXNzYWdlOiAnTWFsZm9ybWVkIGludml0ZSBmcm9tIGdhdGV3YXknLCB0d2lsaW9FcnJvcjogbmV3IGVycm9yc18xLkNsaWVudEVycm9ycy5CYWRSZXF1ZXN0KCkgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbGxQYXJhbWV0ZXJzID0gcGF5bG9hZC5wYXJhbWV0ZXJzIHx8IHt9O1xuICAgICAgICAgICAgY2FsbFBhcmFtZXRlcnMuQ2FsbFNpZCA9IGNhbGxQYXJhbWV0ZXJzLkNhbGxTaWQgfHwgcGF5bG9hZC5jYWxsc2lkO1xuICAgICAgICAgICAgdmFyIGN1c3RvbVBhcmFtZXRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB1dGlsXzEucXVlcnlUb0pzb24oY2FsbFBhcmFtZXRlcnMuUGFyYW1zKSk7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IF90aGlzLl9tYWtlQ29ubmVjdGlvbihjdXN0b21QYXJhbWV0ZXJzLCB7XG4gICAgICAgICAgICAgICAgY2FsbFBhcmFtZXRlcnM6IGNhbGxQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIG9mZmVyU2RwOiBwYXlsb2FkLnNkcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25jZSgnYWNjZXB0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNvdW5kY2FjaGUuZ2V0KERldmljZS5Tb3VuZE5hbWUuSW5jb21pbmcpLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaE5ldHdvcmtDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBsYXkgPSAoX3RoaXMuX2VuYWJsZWRTb3VuZHMuaW5jb21pbmcgJiYgIXdhc0J1c3kpXG4gICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zb3VuZGNhY2hlLmdldChEZXZpY2UuU291bmROYW1lLkluY29taW5nKS5wbGF5KCk7IH1cbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9O1xuICAgICAgICAgICAgX3RoaXMuX3Nob3dJbmNvbWluZ0Nvbm5lY3Rpb24oY29ubmVjdGlvbiwgcGxheSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBhbiAnb2ZmbGluZScgZXZlbnQgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2lnbmFsaW5nIHN0cmVhbS5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblNpZ25hbGluZ09mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ1N0cmVhbSBpcyBvZmZsaW5lJyk7XG4gICAgICAgICAgICBfdGhpcy5fc3RhdHVzID0gRGV2aWNlLlN0YXR1cy5PZmZsaW5lO1xuICAgICAgICAgICAgX3RoaXMuX2VkZ2UgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuX3JlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdvZmZsaW5lJywgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYSAncmVhZHknIGV2ZW50IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNpZ25hbGluZyBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25TaWduYWxpbmdSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbygnU3RyZWFtIGlzIHJlYWR5Jyk7XG4gICAgICAgICAgICBfdGhpcy5fc3RhdHVzID0gRGV2aWNlLlN0YXR1cy5SZWFkeTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3JlYWR5JywgX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUHVibGlzaCBhIE5ldHdvcmtJbmZvcm1hdGlvbiNjaGFuZ2UgZXZlbnQgdG8gSW5zaWdodHMgaWYgdGhlcmUncyBhbiBhY3RpdmUge0BsaW5rIENvbm5lY3Rpb259LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3B1Ymxpc2hOZXR3b3JrQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5fYWN0aXZlQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5fbmV0d29ya0luZm9ybWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCduZXR3b3JrLWluZm9ybWF0aW9uJywgJ25ldHdvcmstY2hhbmdlJywge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uX3R5cGU6IF90aGlzLl9uZXR3b3JrSW5mb3JtYXRpb24udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgZG93bmxpbms6IF90aGlzLl9uZXR3b3JrSW5mb3JtYXRpb24uZG93bmxpbmssXG4gICAgICAgICAgICAgICAgICAgIGRvd25saW5rTWF4OiBfdGhpcy5fbmV0d29ya0luZm9ybWF0aW9uLmRvd25saW5rTWF4LFxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RpdmVfdHlwZTogX3RoaXMuX25ldHdvcmtJbmZvcm1hdGlvbi5lZmZlY3RpdmVUeXBlLFxuICAgICAgICAgICAgICAgICAgICBydHQ6IF90aGlzLl9uZXR3b3JrSW5mb3JtYXRpb24ucnR0LFxuICAgICAgICAgICAgICAgIH0sIF90aGlzLl9hY3RpdmVDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgaW5wdXQgc3RyZWFtIGJlaW5nIHVzZWQgZm9yIGNhbGxzIHNvIHRoYXQgYW55IGN1cnJlbnQgY2FsbCBhbmQgYWxsIGZ1dHVyZSBjYWxsc1xuICAgICAgICAgKiB3aWxsIHVzZSB0aGUgbmV3IGlucHV0IHN0cmVhbS5cbiAgICAgICAgICogQHBhcmFtIGlucHV0U3RyZWFtXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdXBkYXRlSW5wdXRTdHJlYW0gPSBmdW5jdGlvbiAoaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb247XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiAhaW5wdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdDYW5ub3QgdW5zZXQgaW5wdXQgZGV2aWNlIHdoaWxlIGEgY2FsbCBpcyBpbiBwcm9ncmVzcy4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fY29ubmVjdGlvbklucHV0U3RyZWFtID0gaW5wdXRTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvblxuICAgICAgICAgICAgICAgID8gY29ubmVjdGlvbi5fc2V0SW5wdXRUcmFja3NGcm9tU3RyZWFtKGlucHV0U3RyZWFtKVxuICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGRldmljZSBJRHMgb2Ygb3V0cHV0IGRldmljZXMgYmVpbmcgdXNlZCB0byBwbGF5IHNvdW5kcyB0aHJvdWdoLlxuICAgICAgICAgKiBAcGFyYW0gdHlwZSAtIFdoZXRoZXIgdG8gdXBkYXRlIHJpbmd0b25lIG9yIHNwZWFrZXIgc291bmRzXG4gICAgICAgICAqIEBwYXJhbSBzaW5rSWRzIC0gQW4gYXJyYXkgb2YgZGV2aWNlIElEc1xuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3VwZGF0ZVNpbmtJZHMgPSBmdW5jdGlvbiAodHlwZSwgc2lua0lkcykge1xuICAgICAgICAgICAgdmFyIHByb21pc2UgPSB0eXBlID09PSAncmluZ3RvbmUnXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5fdXBkYXRlUmluZ3RvbmVTaW5rSWRzKHNpbmtJZHMpXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5fdXBkYXRlU3BlYWtlclNpbmtJZHMoc2lua0lkcyk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmluZm8oJ2F1ZGlvJywgdHlwZSArIFwiLWRldmljZXMtc2V0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9fZGV2aWNlX2lkczogc2lua0lkcyxcbiAgICAgICAgICAgICAgICB9LCBfdGhpcy5fYWN0aXZlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmVycm9yKCdhdWRpbycsIHR5cGUgKyBcIi1kZXZpY2VzLXNldC1mYWlsZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBhdWRpb19kZXZpY2VfaWRzOiBzaW5rSWRzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0sIF90aGlzLl9hY3RpdmVDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAod2luZG93KSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IHdpbmRvdztcbiAgICAgICAgICAgIHZhciBicm93c2VyID0gcm9vdC5tc0Jyb3dzZXIgfHwgcm9vdC5icm93c2VyIHx8IHJvb3QuY2hyb21lO1xuICAgICAgICAgICAgX3RoaXMuX2lzQnJvd3NlckV4dGVuc2lvbiA9ICghIWJyb3dzZXIgJiYgISFicm93c2VyLnJ1bnRpbWUgJiYgISFicm93c2VyLnJ1bnRpbWUuaWQpXG4gICAgICAgICAgICAgICAgfHwgKCEhcm9vdC5zYWZhcmkgJiYgISFyb290LnNhZmFyaS5leHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpcy5faXNCcm93c2VyRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ1J1bm5pbmcgYXMgYnJvd3NlciBleHRlbnNpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hdmlnYXRvcikge1xuICAgICAgICAgICAgdmFyIG4gPSBuYXZpZ2F0b3I7XG4gICAgICAgICAgICBfdGhpcy5fbmV0d29ya0luZm9ybWF0aW9uID0gbi5jb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgfHwgbi5tb3pDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgfHwgbi53ZWJraXRDb25uZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgX3RoaXMuc2V0dXAodG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQXJndW1lbnRFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBhIERldmljZSB3aXRoIG9wdGlvbnMgYnV0IHdpdGhvdXQgYSB0b2tlbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZSwgXCJhdWRpb0NvbnRleHRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEF1ZGlvQ29udGV4dCB0byBiZSB1c2VkIGJ5IHtAbGluayBEZXZpY2V9IGluc3RhbmNlcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIERldmljZS5fYXVkaW9Db250ZXh0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlLCBcImV4dGVuc2lvblwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGljaCBzb3VuZCBmaWxlIGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE5PVEUobXJvYmVydHMpOiBOb2RlIHdvcmthcm91bmQuXG4gICAgICAgICAgICB2YXIgYSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJykgOiB7IGNhblBsYXlUeXBlOiBmYWxzZSB9O1xuICAgICAgICAgICAgdmFyIGNhblBsYXlNcDM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhblBsYXlNcDMgPSBhLmNhblBsYXlUeXBlICYmICEhYS5jYW5QbGF5VHlwZSgnYXVkaW8vbXBlZycpLnJlcGxhY2UoL25vLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYW5QbGF5TXAzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2FuUGxheVZvcmJpcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY2FuUGxheVZvcmJpcyA9IGEuY2FuUGxheVR5cGUgJiYgISFhLmNhblBsYXlUeXBlKCdhdWRpby9vZ2c7Y29kZWNzPVxcJ3ZvcmJpc1xcJycpLnJlcGxhY2UoL25vLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYW5QbGF5Vm9yYmlzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGNhblBsYXlWb3JiaXMgJiYgIWNhblBsYXlNcDMpID8gJ29nZycgOiAnbXAzJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZSwgXCJpc1N1cHBvcnRlZFwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIFNESyBpcyBzdXBwb3J0ZWQgYnkgdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcnRjLmVuYWJsZWQoKTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERldmljZSwgXCJwYWNrYWdlTmFtZVwiLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWNrYWdlIG5hbWUgb2YgdGhlIFNESy5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQy5QQUNLQUdFX05BTUU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFJ1biBzb21lIHRlc3RzIHRvIGlkZW50aWZ5IGlzc3VlcywgaWYgYW55LCBwcm9oaWJpdGluZyBzdWNjZXNzZnVsIGNhbGxpbmcuXG4gICAgICogQHBhcmFtIHRva2VuIC0gQSBUd2lsaW8gSldUIHRva2VuIHN0cmluZ1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgRGV2aWNlLnJ1blByZWZsaWdodCA9IGZ1bmN0aW9uICh0b2tlbiwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IHByZWZsaWdodF8xLlByZWZsaWdodFRlc3QodG9rZW4sIF9fYXNzaWduKHsgYXVkaW9Db250ZXh0OiBEZXZpY2UuX2dldE9yQ3JlYXRlQXVkaW9Db250ZXh0KCkgfSwgb3B0aW9ucykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHtAbGluayBEZXZpY2V9IGNsYXNzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGV2aWNlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1tUd2lsaW8uRGV2aWNlIGNsYXNzXSc7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlLCBcInZlcnNpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBTREsgdmVyc2lvbi5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQy5SRUxFQVNFX1ZFUlNJT047IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBdWRpb0NvbnRleHQgaW5zdGFuY2Ugc2hhcmVkIGFjcm9zcyB0aGUgQ2xpZW50IFNESyxcbiAgICAgKiBvciByZXR1cm5zIHRoZSBleGlzdGluZyBpbnN0YW5jZSBpZiBvbmUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZC5cbiAgICAgKi9cbiAgICBEZXZpY2UuX2dldE9yQ3JlYXRlQXVkaW9Db250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIURldmljZS5fYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIEF1ZGlvQ29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBEZXZpY2UuX2F1ZGlvQ29udGV4dCA9IG5ldyBBdWRpb0NvbnRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3ZWJraXRBdWRpb0NvbnRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgRGV2aWNlLl9hdWRpb0NvbnRleHQgPSBuZXcgd2Via2l0QXVkaW9Db250ZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERldmljZS5fYXVkaW9Db250ZXh0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhY3RpdmUge0BsaW5rIENvbm5lY3Rpb259LiBOdWxsIG9yIHVuZGVmaW5lZCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLmFjdGl2ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBAcnJvd2xhbmQgVGhpcyBzaG91bGQgb25seSByZXR1cm4gYWN0aXZlQ29ubmVjdGlvbiwgYnV0IGN1c3RvbWVycyBoYXZlIGJ1aWx0IGFyb3VuZCB0aGlzXG4gICAgICAgIC8vIGJyb2tlbiBiZWhhdmlvciBhbmQgaW4gb3JkZXIgdG8gbm90IGJyZWFrIHRoZWlyIGFwcHMgd2UgYXJlIGluY2x1ZGluZyB0aGlzIHVudGlsXG4gICAgICAgIC8vIHRoZSBuZXh0IGJpZyByZWxlYXNlLlxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlQ29ubmVjdGlvbiB8fCB0aGlzLmNvbm5lY3Rpb25zWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgU2V0IGEgaGFuZGxlciBmb3IgdGhlIGNhbmNlbCBldmVudC5cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEhhbmRsZXIoRGV2aWNlLkV2ZW50TmFtZS5DYW5jZWwsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgRGV2aWNlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHBhcmFtc09ySGFuZGxlciwgYXVkaW9Db25zdHJhaW50cywgcnRjQ29uZmlndXJhdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtc09ySGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fYWRkSGFuZGxlcihEZXZpY2UuRXZlbnROYW1lLkNvbm5lY3QsIHBhcmFtc09ySGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90aHJvd1VubGVzc1NldHVwKCdjb25uZWN0Jyk7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ0EgQ29ubmVjdGlvbiBpcyBhbHJlYWR5IGFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJhbXMgPSBwYXJhbXNPckhhbmRsZXIgfHwge307XG4gICAgICAgIGF1ZGlvQ29uc3RyYWludHMgPSBhdWRpb0NvbnN0cmFpbnRzIHx8IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuYXVkaW9Db25zdHJhaW50cyB8fCB7fTtcbiAgICAgICAgcnRjQ29uZmlndXJhdGlvbiA9IHJ0Y0NvbmZpZ3VyYXRpb24gfHwgdGhpcy5vcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb247XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fYWN0aXZlQ29ubmVjdGlvbiA9IHRoaXMuX21ha2VDb25uZWN0aW9uKHBhcmFtcywgeyBydGNDb25maWd1cmF0aW9uOiBydGNDb25maWd1cmF0aW9uIH0pO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW55IGluY29taW5nIGNvbm5lY3Rpb25zIGFyZSBpZ25vcmVkXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc3BsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKGNvbm4pIHsgcmV0dXJuIGNvbm4uaWdub3JlKCk7IH0pO1xuICAgICAgICAvLyBTdG9wIHRoZSBpbmNvbWluZyBzb3VuZCBpZiBpdCdzIHBsYXlpbmdcbiAgICAgICAgdGhpcy5zb3VuZGNhY2hlLmdldChEZXZpY2UuU291bmROYW1lLkluY29taW5nKS5zdG9wKCk7XG4gICAgICAgIGNvbm5lY3Rpb24uYWNjZXB0KGF1ZGlvQ29uc3RyYWludHMpO1xuICAgICAgICB0aGlzLl9wdWJsaXNoTmV0d29ya0NoYW5nZSgpO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGhhbmRsZXIgZm9yIHRoZSBkaXNjb25uZWN0IGV2ZW50LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRGV2aWNlLm9ufS5cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRIYW5kbGVyKERldmljZS5FdmVudE5hbWUuRGlzY29ubmVjdCwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFsbCB7QGxpbmsgQ29ubmVjdGlvbn1zLlxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuZGlzY29ubmVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dVbmxlc3NTZXR1cCgnZGlzY29ubmVjdEFsbCcpO1xuICAgICAgICB0aGlzLl9kaXNjb25uZWN0QWxsKCk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGV2aWNlLnByb3RvdHlwZSwgXCJlZGdlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHtAbGluayBFZGdlfSB2YWx1ZSB0aGUge0BsaW5rIERldmljZX0gaXMgY3VycmVudGx5IGNvbm5lY3RlZFxuICAgICAgICAgKiB0by4gVGhlIHZhbHVlIHdpbGwgYmUgYG51bGxgIHdoZW4gdGhlIHtAbGluayBEZXZpY2V9IGlzIG9mZmxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lZGdlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBoYW5kbGVyIGZvciB0aGUgZXJyb3IgZXZlbnQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEZXZpY2Uub259LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRIYW5kbGVyKERldmljZS5FdmVudE5hbWUuRXJyb3IsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgaGFuZGxlciBmb3IgdGhlIGluY29taW5nIGV2ZW50LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRGV2aWNlLm9ufS5cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuaW5jb21pbmcgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkSGFuZGxlcihEZXZpY2UuRXZlbnROYW1lLkluY29taW5nLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGhhbmRsZXIgZm9yIHRoZSBvZmZsaW5lIGV2ZW50LlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRGV2aWNlLm9ufS5cbiAgICAgKiBAcGFyYW0gaGFuZGxlclxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUub2ZmbGluZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRIYW5kbGVyKERldmljZS5FdmVudE5hbWUuT2ZmbGluZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBoYW5kbGVyIGZvciB0aGUgcmVhZHkgZXZlbnQuXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBEZXZpY2Uub259LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRIYW5kbGVyKERldmljZS5FdmVudE5hbWUuUmVhZHksIGhhbmRsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB7QGxpbmsgUmVnaW9ufSBzdHJpbmcgdGhlIHtAbGluayBEZXZpY2V9IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8sIG9yICdvZmZsaW5lJ1xuICAgICAqIGlmIG5vdCBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5yZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2xvZy53YXJuKCdgRGV2aWNlLnJlZ2lvbmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yICcgK1xuICAgICAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSB1c2UgYERldmljZS5lZGdlYCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLl90aHJvd1VubGVzc1NldHVwKCdyZWdpb24nKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9yZWdpb24gPT09ICdzdHJpbmcnID8gdGhpcy5fcmVnaW9uIDogJ29mZmxpbmUnO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgdG8gcmVjZWl2ZSBpbmNvbWluZyBjYWxscy4gRG9lcyBub3QgbmVlZCB0byBiZSBjYWxsZWQgdW5sZXNzIHtAbGluayBEZXZpY2UudW5yZWdpc3RlclByZXNlbmNlfVxuICAgICAqIGhhcyBiZWVuIGNhbGxlZCBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLnJlZ2lzdGVyUHJlc2VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Rocm93VW5sZXNzU2V0dXAoJ3JlZ2lzdGVyUHJlc2VuY2UnKTtcbiAgICAgICAgdGhpcy5tZWRpYVByZXNlbmNlLmF1ZGlvID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2VuZFByZXNlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUgdG8gc3RvcCBsaXN0ZW5pbmcgZm9yXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGNhbGxiYWNrIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHtAbGluayBEZXZpY2V9LlxuICAgICAqIEBwYXJhbSB0b2tlbiAtIEEgVHdpbGlvIEpXVCB0b2tlbiBzdHJpbmcgZ3JhbnRpbmcgdGhpcyB7QGxpbmsgRGV2aWNlfSBhY2Nlc3MuXG4gICAgICogQHBhcmFtIFtvcHRpb25zXVxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAodG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKHV0aWxfMS5pc0xlZ2FjeUVkZ2UoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdFN1cHBvcnRlZEVycm9yKCdNaWNyb3NvZnQgRWRnZSBMZWdhY3kgKGh0dHBzOi8vc3VwcG9ydC5taWNyb3NvZnQuY29tL2VuLXVzL2hlbHAvNDUzMzUwNS93aGF0LWlzLW1pY3Jvc29mdC1lZGdlLWxlZ2FjeSkgJyArXG4gICAgICAgICAgICAgICAgJ2lzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm90IGJlIGFibGUgdG8gY29ubmVjdCB0byBUd2lsaW8gdG8gbWFrZSBvciByZWNlaXZlIGNhbGxzIGFmdGVyIFNlcHRlbWJlciAxc3QsIDIwMjAuICcgK1xuICAgICAgICAgICAgICAgICdQbGVhc2Ugc2VlIHRoaXMgZG9jdW1lbnRhdGlvbiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCBicm93c2VycyAnICtcbiAgICAgICAgICAgICAgICAnaHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL3ZvaWNlL2NsaWVudC9qYXZhc2NyaXB0I3N1cHBvcnRlZC1icm93c2VycycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRGV2aWNlLmlzU3VwcG9ydGVkICYmICFvcHRpb25zLmlnbm9yZUJyb3dzZXJTdXBwb3J0KSB7XG4gICAgICAgICAgICBpZiAod2luZG93ICYmIHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90U3VwcG9ydGVkRXJyb3IoXCJ0d2lsaW8uanMgd2Fzbid0IGFibGUgdG8gZmluZCBXZWJSVEMgYnJvd3NlciBzdXBwb3J0LiAgICAgICAgICAgVGhpcyBpcyBtb3N0IGxpa2VseSBiZWNhdXNlIHRoaXMgcGFnZSBpcyBzZXJ2ZWQgb3ZlciBodHRwIHJhdGhlciB0aGFuIGh0dHBzLCAgICAgICAgICAgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBXZWJSVEMgaW4gbWFueSBicm93c2Vycy4gUGxlYXNlIGxvYWQgdGhpcyBwYWdlIG92ZXIgaHR0cHMgYW5kICAgICAgICAgICB0cnkgYWdhaW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdFN1cHBvcnRlZEVycm9yKFwidHdpbGlvLmpzIDEuMysgU0RLcyByZXF1aXJlIFdlYlJUQyBicm93c2VyIHN1cHBvcnQuICAgICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSA8aHR0cHM6Ly93d3cudHdpbGlvLmNvbS9kb2NzL2FwaS9jbGllbnQvdHdpbGlvLWpzPi4gICAgICAgICBJZiB5b3UgaGF2ZSBhbnkgcXVlc3Rpb25zIGFib3V0IHRoaXMgYW5ub3VuY2VtZW50LCBwbGVhc2UgY29udGFjdCAgICAgICAgIFR3aWxpbyBTdXBwb3J0IGF0IDxoZWxwQHR3aWxpby5jb20+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ1Rva2VuIGlzIHJlcXVpcmVkIGZvciBEZXZpY2Uuc2V0dXAoKScpO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbG9nLnNldERlZmF1bHRMZXZlbCh0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgICAgICAgID8gbG9nXzEuZGVmYXVsdC5sZXZlbHMuREVCVUdcbiAgICAgICAgICAgIDogdGhpcy5vcHRpb25zLndhcm5pbmdzXG4gICAgICAgICAgICAgICAgPyBsb2dfMS5kZWZhdWx0LmxldmVscy5XQVJOXG4gICAgICAgICAgICAgICAgOiBsb2dfMS5kZWZhdWx0LmxldmVscy5TSUxFTlQpO1xuICAgICAgICB0aGlzLl9jaHVuZGVyVVJJcyA9IHRoaXMub3B0aW9ucy5jaHVuZGVyd1xuICAgICAgICAgICAgPyBbXCJ3c3M6Ly9cIiArIHRoaXMub3B0aW9ucy5jaHVuZGVydyArIFwiL3NpZ25hbFwiXVxuICAgICAgICAgICAgOiByZWdpb25zXzEuZ2V0Q2h1bmRlclVSSXModGhpcy5vcHRpb25zLmVkZ2UsIHRoaXMub3B0aW9ucy5yZWdpb24sIHRoaXMuX2xvZy53YXJuLmJpbmQodGhpcy5fbG9nKSkubWFwKGZ1bmN0aW9uICh1cmkpIHsgcmV0dXJuIFwid3NzOi8vXCIgKyB1cmkgKyBcIi9zaWduYWxcIjsgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgRGV2aWNlLl9pc1VuaWZpZWRQbGFuRGVmYXVsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIERldmljZS5faXNVbmlmaWVkUGxhbkRlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgICYmIHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAmJiB0eXBlb2YgUlRDUnRwVHJhbnNjZWl2ZXIgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB1dGlsXzEuaXNVbmlmaWVkUGxhbkRlZmF1bHQod2luZG93LCB3aW5kb3cubmF2aWdhdG9yLCBSVENQZWVyQ29ubmVjdGlvbiwgUlRDUnRwVHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBEZXZpY2UuX2dldE9yQ3JlYXRlQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIGlmIChEZXZpY2UuX2F1ZGlvQ29udGV4dCAmJiBvcHRpb25zLmZha2VMb2NhbERUTUYpIHtcbiAgICAgICAgICAgIGlmICghRGV2aWNlLl9kaWFsdG9uZVBsYXllcikge1xuICAgICAgICAgICAgICAgIERldmljZS5fZGlhbHRvbmVQbGF5ZXIgPSBuZXcgZGlhbHRvbmVQbGF5ZXJfMS5kZWZhdWx0KERldmljZS5fYXVkaW9Db250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChEZXZpY2UuX2RpYWx0b25lUGxheWVyKSB7XG4gICAgICAgICAgICBEZXZpY2UuX2RpYWx0b25lUGxheWVyLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGRlbGV0ZSBEZXZpY2UuX2RpYWx0b25lUGxheWVyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKCdGb3VuZCBleGlzdGluZyBEZXZpY2U7IHVzaW5nIG5ldyB0b2tlbiBidXQgaWdub3Jpbmcgb3B0aW9ucycpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRzY3ApIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5ydGNDb25zdHJhaW50cy5vcHRpb25hbCA9IFt7IGdvb2dEc2NwOiB0cnVlIH1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXRPclNldFNvdW5kID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzQmVlbldhcm5lZFNvdW5kcykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sb2cud2FybignRGV2aWNlLnNvdW5kcyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgYnJlYWtpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICdyZWxlYXNlLiBQbGVhc2UgdXNlIHRoZSBuZXcgZnVuY3Rpb25hbGl0eSBhdmFpbGFibGUgb24gRGV2aWNlLmF1ZGlvLicpO1xuICAgICAgICAgICAgICAgIGhhc0JlZW5XYXJuZWRTb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fZW5hYmxlZFNvdW5kc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuX2VuYWJsZWRTb3VuZHNba2V5XTtcbiAgICAgICAgfTtcbiAgICAgICAgW0RldmljZS5Tb3VuZE5hbWUuRGlzY29ubmVjdCwgRGV2aWNlLlNvdW5kTmFtZS5JbmNvbWluZywgRGV2aWNlLlNvdW5kTmFtZS5PdXRnb2luZ11cbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdW5kc1tldmVudE5hbWVdID0gZ2V0T3JTZXRTb3VuZC5iaW5kKG51bGwsIGV2ZW50TmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVmYXVsdFNvdW5kcyA9IHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHsgZmlsZW5hbWU6ICdkaXNjb25uZWN0JywgbWF4RHVyYXRpb246IDMwMDAgfSxcbiAgICAgICAgICAgIGR0bWYwOiB7IGZpbGVuYW1lOiAnZHRtZi0wJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWYxOiB7IGZpbGVuYW1lOiAnZHRtZi0xJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWYyOiB7IGZpbGVuYW1lOiAnZHRtZi0yJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWYzOiB7IGZpbGVuYW1lOiAnZHRtZi0zJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY0OiB7IGZpbGVuYW1lOiAnZHRtZi00JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY1OiB7IGZpbGVuYW1lOiAnZHRtZi01JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY2OiB7IGZpbGVuYW1lOiAnZHRtZi02JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY3OiB7IGZpbGVuYW1lOiAnZHRtZi03JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY4OiB7IGZpbGVuYW1lOiAnZHRtZi04JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWY5OiB7IGZpbGVuYW1lOiAnZHRtZi05JywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWZoOiB7IGZpbGVuYW1lOiAnZHRtZi1oYXNoJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGR0bWZzOiB7IGZpbGVuYW1lOiAnZHRtZi1zdGFyJywgbWF4RHVyYXRpb246IDEwMDAgfSxcbiAgICAgICAgICAgIGluY29taW5nOiB7IGZpbGVuYW1lOiAnaW5jb21pbmcnLCBzaG91bGRMb29wOiB0cnVlIH0sXG4gICAgICAgICAgICBvdXRnb2luZzogeyBmaWxlbmFtZTogJ291dGdvaW5nJywgbWF4RHVyYXRpb246IDMwMDAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IE9iamVjdC5rZXlzKGRlZmF1bHRTb3VuZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciBzb3VuZERlZiA9IGRlZmF1bHRTb3VuZHNbbmFtZV8xXTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VXJsID0gQy5TT1VORFNfQkFTRV9VUkwgKyBcIi9cIiArIHNvdW5kRGVmLmZpbGVuYW1lICsgXCIuXCIgKyBEZXZpY2UuZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgKyAoXCI/Y2FjaGU9XCIgKyBDLlJFTEVBU0VfVkVSU0lPTik7XG4gICAgICAgICAgICB2YXIgc291bmRVcmwgPSB0aGlzLm9wdGlvbnMuc291bmRzICYmIHRoaXMub3B0aW9ucy5zb3VuZHNbbmFtZV8xXSB8fCBkZWZhdWx0VXJsO1xuICAgICAgICAgICAgdmFyIHNvdW5kID0gbmV3IHRoaXMub3B0aW9ucy5zb3VuZEZhY3RvcnkobmFtZV8xLCBzb3VuZFVybCwge1xuICAgICAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogdGhpcy5vcHRpb25zLmRpc2FibGVBdWRpb0NvbnRleHRTb3VuZHMgPyBudWxsIDogRGV2aWNlLmF1ZGlvQ29udGV4dCxcbiAgICAgICAgICAgICAgICBtYXhEdXJhdGlvbjogc291bmREZWYubWF4RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgc2hvdWxkTG9vcDogc291bmREZWYuc2hvdWxkTG9vcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zb3VuZGNhY2hlLnNldChuYW1lXzEsIHNvdW5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wdWJsaXNoZXIgPSAodGhpcy5vcHRpb25zLlB1Ymxpc2hlciB8fCBQdWJsaXNoZXIpKCd0d2lsaW8tanMtc2RrJywgdG9rZW4sIHtcbiAgICAgICAgICAgIGRlZmF1bHRQYXlsb2FkOiB0aGlzLl9jcmVhdGVEZWZhdWx0UGF5bG9hZCxcbiAgICAgICAgICAgIGhvc3Q6IHRoaXMub3B0aW9ucy5ldmVudGd3LFxuICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICBhcHBfbmFtZTogdGhpcy5vcHRpb25zLmFwcE5hbWUsXG4gICAgICAgICAgICAgICAgYXBwX3ZlcnNpb246IHRoaXMub3B0aW9ucy5hcHBWZXJzaW9uLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHVibGlzaEV2ZW50cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3B1Ymxpc2hlci5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaXNoZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xvZy53YXJuKCdDYW5ub3QgY29ubmVjdCB0byBpbnNpZ2h0cy4nLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmV0d29ya0luZm9ybWF0aW9uICYmIHR5cGVvZiB0aGlzLl9uZXR3b3JrSW5mb3JtYXRpb24uYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fbmV0d29ya0luZm9ybWF0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3B1Ymxpc2hOZXR3b3JrQ2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1ZGlvID0gbmV3ICh0aGlzLm9wdGlvbnMuQXVkaW9IZWxwZXIgfHwgYXVkaW9oZWxwZXJfMS5kZWZhdWx0KSh0aGlzLl91cGRhdGVTaW5rSWRzLCB0aGlzLl91cGRhdGVJbnB1dFN0cmVhbSwgZ2V0VXNlck1lZGlhLCB7XG4gICAgICAgICAgICBhdWRpb0NvbnRleHQ6IERldmljZS5hdWRpb0NvbnRleHQsXG4gICAgICAgICAgICBlbmFibGVkU291bmRzOiB0aGlzLl9lbmFibGVkU291bmRzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdWRpby5vbignZGV2aWNlQ2hhbmdlJywgZnVuY3Rpb24gKGxvc3RBY3RpdmVEZXZpY2VzKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ29ubmVjdGlvbiA9IF90aGlzLl9hY3RpdmVDb25uZWN0aW9uO1xuICAgICAgICAgICAgdmFyIGRldmljZUlkcyA9IGxvc3RBY3RpdmVEZXZpY2VzLm1hcChmdW5jdGlvbiAoZGV2aWNlKSB7IHJldHVybiBkZXZpY2UuZGV2aWNlSWQ7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX3B1Ymxpc2hlci5pbmZvKCdhdWRpbycsICdkZXZpY2UtY2hhbmdlJywge1xuICAgICAgICAgICAgICAgIGxvc3RfYWN0aXZlX2RldmljZV9pZHM6IGRldmljZUlkcyxcbiAgICAgICAgICAgIH0sIGFjdGl2ZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVDb25uZWN0aW9uLm1lZGlhU3RyZWFtLl9vbklucHV0RGV2aWNlc0NoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVkaWFQcmVzZW5jZS5hdWRpbyA9ICF0aGlzLm9wdGlvbnMubm9SZWdpc3RlcjtcbiAgICAgICAgdGhpcy51cGRhdGVUb2tlbih0b2tlbik7XG4gICAgICAgIC8vIFNldHVwIGNsb3NlIHByb3RlY3Rpb24gYW5kIG1ha2Ugc3VyZSB3ZSBjbGVhbiB1cCBvbmdvaW5nIGNhbGxzIG9uIHVubG9hZC5cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgdGhpcy5kZXN0cm95KTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMuZGVzdHJveSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlUHJvdGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9jb25maXJtQ2xvc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIChycm93bGFuZCkgVGhpcyBtYWludGFpbnMgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgYnV0IHdlIHNob3VsZCBsb29rIGF0XG4gICAgICAgIC8vIHJlbW92aW5nIHRoaXMgbmV4dCBicmVha2luZyBjaGFuZ2UuIEFueSBlcnJvciBzaG91bGQgYmUgY2F1Z2h0IGJ5IHRoZVxuICAgICAgICAvLyBjdXN0b21lciwgYW5kIGFueXRoaW5nIHRoYXQncyBub3QgYSBmYXRhbCBlcnJvciBzaG91bGQgbm90IGJlIGVtaXR0ZWRcbiAgICAgICAgLy8gdmlhIGVycm9yIGV2ZW50LlxuICAgICAgICB0aGlzLm9uKERldmljZS5FdmVudE5hbWUuRXJyb3IsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5saXN0ZW5lckNvdW50KCdlcnJvcicpID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbygnVW5jYXVnaHQgZXJyb3IgZXZlbnQgc3VwcHJlc3NlZC4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgdGhpcyB7QGxpbmsgRGV2aWNlfSBpbnN0YW5jZVxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl90aHJvd1VubGVzc1NldHVwKCdzdGF0dXMnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gPyBEZXZpY2UuU3RhdHVzLkJ1c3kgOiB0aGlzLl9zdGF0dXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2Yge0BsaW5rIERldmljZX0gaW5zdGFuY2UuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ1tUd2lsaW8uRGV2aWNlIGluc3RhbmNlXSc7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIHRvIHJlY2VpdmluZyBpbmNvbWluZyBjYWxscy5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLnVucmVnaXN0ZXJQcmVzZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdGhyb3dVbmxlc3NTZXR1cCgndW5yZWdpc3RlclByZXNlbmNlJyk7XG4gICAgICAgIHRoaXMubWVkaWFQcmVzZW5jZS5hdWRpbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZW5kUHJlc2VuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHRva2VuIGFuZCByZS1yZWdpc3Rlci5cbiAgICAgKiBAcGFyYW0gdG9rZW4gLSBUaGUgbmV3IHRva2VuIEpXVCBzdHJpbmcgdG8gcmVnaXN0ZXIgd2l0aC5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLnVwZGF0ZVRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHRoaXMuX3Rocm93VW5sZXNzU2V0dXAoJ3VwZGF0ZVRva2VuJyk7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih0b2tlbik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgYSBoYW5kbGVyIGZvciBhbiBFdmVudEVtaXR0ZXIgYW5kIGVtaXQgYSBkZXByZWNhdGlvbiB3YXJuaW5nIG9uIGZpcnN0IGNhbGwuXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBBIGhhbmRsZXIgdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5fYWRkSGFuZGxlciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKCFoYXNCZWVuV2FybmVkSGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy53YXJuKFwiRGV2aWNlIGNhbGxiYWNrIGhhbmRsZXJzIChjb25uZWN0LCBlcnJvciwgb2ZmbGluZSwgaW5jb21pbmcsIGNhbmNlbCwgcmVhZHksIGRpc2Nvbm5lY3QpICAgICAgICAgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBicmVha2luZyByZWxlYXNlLiBJbnN0ZWFkLCB0aGUgRXZlbnRFbWl0dGVyICAgICAgICAgaW50ZXJmYWNlIGNhbiBiZSB1c2VkIHRvIHNldCBldmVudCBsaXN0ZW5lcnMuIEV4YW1wbGU6IGRldmljZS5vbignXCIgKyBldmVudE5hbWUgKyBcIicsIGhhbmRsZXIpXCIpO1xuICAgICAgICAgICAgaGFzQmVlbldhcm5lZEhhbmRsZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGVtaXQgQVBJIHN1Y2ggdGhhdCBpdCBpcyBhc3luY2hyb25vdXMuXG4gICAgICogT25seSB1c2UgdGhpcyBpbnRlcm5hbCBBUEkgaWYgeW91IGRvbid0IHdhbnQgdG8gYnJlYWsgdGhlIGV4ZWN1dGlvbiBhZnRlciByYWlzaW5nIGFuIGV2ZW50LlxuICAgICAqIFRoaXMgcHJldmVudHMgdGhlIGlzc3VlIHdoZXJlIGV2ZW50cyBhcmUgbm90IGRpc3BhdGNoZWQgdG8gYWxsIGhhbmRsZXJzIHdoZW4gb25lIG9mIHRoZSBoYW5kbGVycyB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICogRm9yIGV4YW1wbGUsIG91ciBjb25uZWN0aW9uOmFjY2VwdCBpcyBub3QgdHJpZ2dlcmVkIGlmIHRoZSBoYW5kbGVyIGZvciBkZXZpY2U6Y29ubmVjdCBoYW5kbGVyIHRocm93cyBhbiBlcnJvci5cbiAgICAgKiBBcyBhIHNpZGUgZWZmZWN0LCB3ZSBhcmUgbm90IGFibGUgdG8gcGVyZm9ybSBvdXIgaW50ZXJuYWwgcm91dGluZXMgc3VjaCBhcyBzdG9wcGluZyBpbmNvbWluZyBzb3VuZHMuXG4gICAgICogU2VlIGNvbm5lY3Rpb246YWNjZXB0IGluc2lkZSBfbWFrZUNvbm5lY3Rpb24gd2hlcmUgd2UgY2FsbCBlbWl0KCdjb25uZWN0JykuIFRoaXMgY2FuIHRocm93IGFuIGVycm9yLlxuICAgICAqIFNlZSBjb25uZWN0aW9uOmFjY2VwdCBpbnNpZGUgX29uU2lnbmFsaW5nSW52aXRlLiBUaGlzIGhhbmRsZXIgd29uJ3QgZ2V0IGNhbGxlZCBpZiB0aGUgZXJyb3IgYWJvdmUgaXMgdGhyb3duLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5fYXN5bmNFbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZW1pdC5hcHBseShfdGhpcywgX19zcHJlYWRBcnJheXMoW2V2ZW50XSwgYXJncykpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQgYSB7QGxpbmsgQ29ubmVjdGlvbn0gYnkgaXRzIENhbGxTaWQuXG4gICAgICogQHBhcmFtIGNhbGxTaWRcbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9maW5kQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChjYWxsU2lkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25zLmZpbmQoZnVuY3Rpb24gKGNvbm4pIHsgcmV0dXJuIGNvbm4ucGFyYW1ldGVycy5DYWxsU2lkID09PSBjYWxsU2lkXG4gICAgICAgICAgICB8fCBjb25uLm91dGJvdW5kQ29ubmVjdGlvbklkID09PSBjYWxsU2lkOyB9KSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHtAbGluayBDb25uZWN0aW9ufS5cbiAgICAgKiBAcGFyYW0gdHdpbWxQYXJhbXMgLSBBIGZsYXQgb2JqZWN0IGNvbnRhaW5pbmcga2V5OnZhbHVlIHBhaXJzIHRvIGJlIHNlbnQgdG8gdGhlIFR3aU1MIGFwcC5cbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gT3B0aW9ucyB0byBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSB7QGxpbmsgQ29ubmVjdGlvbn0uXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5fbWFrZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAodHdpbWxQYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBEZXZpY2UuX2lzVW5pZmllZFBsYW5EZWZhdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdEZXZpY2UgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBhdWRpb0hlbHBlcjogdGhpcy5hdWRpbyxcbiAgICAgICAgICAgIGdldFVzZXJNZWRpYTogZ2V0VXNlck1lZGlhLFxuICAgICAgICAgICAgaXNVbmlmaWVkUGxhbkRlZmF1bHQ6IERldmljZS5faXNVbmlmaWVkUGxhbkRlZmF1bHQsXG4gICAgICAgICAgICBwc3RyZWFtOiB0aGlzLnN0cmVhbSxcbiAgICAgICAgICAgIHB1Ymxpc2hlcjogdGhpcy5fcHVibGlzaGVyLFxuICAgICAgICAgICAgc291bmRjYWNoZTogdGhpcy5zb3VuZGNhY2hlLFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBNZWRpYVN0cmVhbTogdGhpcy5vcHRpb25zLk1lZGlhU3RyZWFtXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5vcHRpb25zLm1lZGlhU3RyZWFtRmFjdG9yeVxuICAgICAgICAgICAgICAgIHx8IHJ0Yy5QZWVyQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGF1ZGlvQ29uc3RyYWludHM6IHRoaXMub3B0aW9ucy5hdWRpb0NvbnN0cmFpbnRzLFxuICAgICAgICAgICAgYmVmb3JlQWNjZXB0OiBmdW5jdGlvbiAoY29ubikge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gfHwgX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gPT09IGNvbm4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fYWN0aXZlQ29ubmVjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3JlbW92ZUNvbm5lY3Rpb24oX3RoaXMuX2FjdGl2ZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvZGVjUHJlZmVyZW5jZXM6IHRoaXMub3B0aW9ucy5jb2RlY1ByZWZlcmVuY2VzLFxuICAgICAgICAgICAgZGlhbHRvbmVQbGF5ZXI6IERldmljZS5fZGlhbHRvbmVQbGF5ZXIsXG4gICAgICAgICAgICBkc2NwOiB0aGlzLm9wdGlvbnMuZHNjcCxcbiAgICAgICAgICAgIGVuYWJsZUljZVJlc3RhcnQ6IHRoaXMub3B0aW9ucy5lbmFibGVJY2VSZXN0YXJ0LFxuICAgICAgICAgICAgZW5hYmxlUmluZ2luZ1N0YXRlOiB0aGlzLm9wdGlvbnMuZW5hYmxlUmluZ2luZ1N0YXRlLFxuICAgICAgICAgICAgZm9yY2VBZ2dyZXNzaXZlSWNlTm9taW5hdGlvbjogdGhpcy5vcHRpb25zLmZvcmNlQWdncmVzc2l2ZUljZU5vbWluYXRpb24sXG4gICAgICAgICAgICBnZXRJbnB1dFN0cmVhbTogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3B0aW9ucy5maWxlSW5wdXRTdHJlYW0gfHwgX3RoaXMuX2Nvbm5lY3Rpb25JbnB1dFN0cmVhbTsgfSxcbiAgICAgICAgICAgIGdldFNpbmtJZHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9jb25uZWN0aW9uU2lua0lkczsgfSxcbiAgICAgICAgICAgIG1heEF2ZXJhZ2VCaXRyYXRlOiB0aGlzLm9wdGlvbnMubWF4QXZlcmFnZUJpdHJhdGUsXG4gICAgICAgICAgICBwcmVmbGlnaHQ6IHRoaXMub3B0aW9ucy5wcmVmbGlnaHQsXG4gICAgICAgICAgICBydGNDb25maWd1cmF0aW9uOiB0aGlzLm9wdGlvbnMucnRjQ29uZmlndXJhdGlvbiB8fCB7IGljZVNlcnZlcnM6IHRoaXMub3B0aW9ucy5pY2VTZXJ2ZXJzIH0sXG4gICAgICAgICAgICBydGNDb25zdHJhaW50czogdGhpcy5vcHRpb25zLnJ0Y0NvbnN0cmFpbnRzLFxuICAgICAgICAgICAgc2hvdWxkUGxheURpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9lbmFibGVkU291bmRzLmRpc2Nvbm5lY3Q7IH0sXG4gICAgICAgICAgICB0d2ltbFBhcmFtczogdHdpbWxQYXJhbXMsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyB0aGlzLm9wdGlvbnMuY29ubmVjdGlvbkZhY3RvcnkoY29uZmlnLCBvcHRpb25zKTtcbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdhY2NlcHQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIF90aGlzLl9hY3RpdmVDb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hdWRpbykge1xuICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvLl9tYXliZVN0YXJ0UG9sbGluZ1ZvbHVtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uZGlyZWN0aW9uID09PSBjb25uZWN0aW9uXzEuZGVmYXVsdC5DYWxsRGlyZWN0aW9uLk91dGdvaW5nICYmIF90aGlzLl9lbmFibGVkU291bmRzLm91dGdvaW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc291bmRjYWNoZS5nZXQoRGV2aWNlLlNvdW5kTmFtZS5PdXRnb2luZykucGxheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7IGVkZ2U6IF90aGlzLl9lZGdlIHx8IF90aGlzLl9yZWdpb24gfTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZEVkZ2UgPSBfdGhpcy5vcHRpb25zLmVkZ2U7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRFZGdlKSB7XG4gICAgICAgICAgICAgICAgZGF0YVsnc2VsZWN0ZWRfZWRnZSddID0gQXJyYXkuaXNBcnJheShzZWxlY3RlZEVkZ2UpID8gc2VsZWN0ZWRFZGdlIDogW3NlbGVjdGVkRWRnZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaGVyLmluZm8oJ3NldHRpbmdzJywgJ2VkZ2UnLCBkYXRhLCBjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIF90aGlzLl9hc3luY0VtaXQoJ2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24uYWRkTGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0dXMoKSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hdWRpbykge1xuICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvLl9tYXliZVN0b3BQb2xsaW5nVm9sdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbWF5YmVTdG9wSW5jb21pbmdTb3VuZCgpO1xuICAgICAgICAgICAgX3RoaXMuX2FzeW5jRW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2NhbmNlbCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhcIkNhbmNlbGVkOiBcIiArIGNvbm5lY3Rpb24ucGFyYW1ldGVycy5DYWxsU2lkKTtcbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgaWYgKF90aGlzLmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXVkaW8uX21heWJlU3RvcFBvbGxpbmdWb2x1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9tYXliZVN0b3BJbmNvbWluZ1NvdW5kKCk7XG4gICAgICAgICAgICBfdGhpcy5fYXN5bmNFbWl0KCdjYW5jZWwnLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgnZGlzY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5hdWRpbykge1xuICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvLl9tYXliZVN0b3BQb2xsaW5nVm9sdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIF90aGlzLl9hc3luY0VtaXQoJ2Rpc2Nvbm5lY3QnLCBjb25uZWN0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgncmVqZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX2xvZy5pbmZvKFwiUmVqZWN0ZWQ6IFwiICsgY29ubmVjdGlvbi5wYXJhbWV0ZXJzLkNhbGxTaWQpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmF1ZGlvKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXVkaW8uX21heWJlU3RvcFBvbGxpbmdWb2x1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9yZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgX3RoaXMuX21heWJlU3RvcEluY29taW5nU291bmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub25jZSgndHJhbnNwb3J0Q2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5zdGF0dXMoKSAhPT0gY29ubmVjdGlvbl8xLmRlZmF1bHQuU3RhdGUuUGVuZGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5hdWRpbykge1xuICAgICAgICAgICAgICAgIF90aGlzLmF1ZGlvLl9tYXliZVN0b3BQb2xsaW5nVm9sdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmVtb3ZlQ29ubmVjdGlvbihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIF90aGlzLl9tYXliZVN0b3BJbmNvbWluZ1NvdW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGluY29taW5nIHNvdW5kIGlmIG5vIHtAbGluayBDb25uZWN0aW9ufXMgcmVtYWluLlxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuX21heWJlU3RvcEluY29taW5nU291bmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc291bmRjYWNoZS5nZXQoRGV2aWNlLlNvdW5kTmFtZS5JbmNvbWluZykuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB7QGxpbmsgQ29ubmVjdGlvbn0gZnJvbSBkZXZpY2UuY29ubmVjdGlvbnMgYnkgcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9yZW1vdmVDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmNvbm5lY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiA9PT0gdGhpcy5jb25uZWN0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciB3aXRoIHRoZSBzaWduYWxpbmcgc2VydmVyLlxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUuX3NlbmRQcmVzZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlZ2lzdGVyKHsgYXVkaW86IHRoaXMubWVkaWFQcmVzZW5jZS5hdWRpbyB9KTtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFQcmVzZW5jZS5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRSZWdpc3RyYXRpb25UaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlZ2lzdHJhdGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB1cCB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlci5cbiAgICAgKiBAcGFyYW0gdG9rZW5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9zZXR1cFN0cmVhbSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB0aGlzLl9sb2cuaW5mbygnU2V0dGluZyB1cCBWU1AnKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSB0aGlzLm9wdGlvbnMucFN0cmVhbUZhY3RvcnkodG9rZW4sIHRoaXMuX2NodW5kZXJVUklzLCB7XG4gICAgICAgICAgICBiYWNrb2ZmTWF4TXM6IHRoaXMub3B0aW9ucy5iYWNrb2ZmTWF4TXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5hZGRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vblNpZ25hbGluZ0Nsb3NlKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkTGlzdGVuZXIoJ2Nvbm5lY3RlZCcsIHRoaXMuX29uU2lnbmFsaW5nQ29ubmVjdGVkKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25TaWduYWxpbmdFcnJvcik7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZExpc3RlbmVyKCdpbnZpdGUnLCB0aGlzLl9vblNpZ25hbGluZ0ludml0ZSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLmFkZExpc3RlbmVyKCdvZmZsaW5lJywgdGhpcy5fb25TaWduYWxpbmdPZmZsaW5lKTtcbiAgICAgICAgdGhpcy5zdHJlYW0uYWRkTGlzdGVuZXIoJ3JlYWR5JywgdGhpcy5fb25TaWduYWxpbmdSZWFkeSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBwbGF5aW5nIHRoZSBpbmNvbWluZyByaW5ndG9uZSwgYW5kIHN1YnNlcXVlbnRseSBlbWl0IHRoZSBpbmNvbWluZyBldmVudC5cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvblxuICAgICAqIEBwYXJhbSBwbGF5IC0gVGhlIGZ1bmN0aW9uIHRvIGJlIHVzZWQgdG8gcGxheSB0aGUgc291bmQuIE11c3QgcmV0dXJuIGEgUHJvbWlzZS5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9zaG93SW5jb21pbmdDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb24sIHBsYXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgcGxheSgpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdQbGF5aW5nIGluY29taW5nIHJpbmd0b25lIHRvb2sgdG9vIGxvbmc7IGl0IG1pZ2h0IG5vdCBwbGF5LiBDb250aW51aW5nIGV4ZWN1dGlvbi4uLic7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IobXNnKSk7XG4gICAgICAgICAgICAgICAgfSwgUklOR1RPTkVfUExBWV9USU1FT1VUKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8ocmVhc29uLm1lc3NhZ2UpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2luY29taW5nJywgY29ubmVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0IGEgdGltZW91dCB0byBzZW5kIGFub3RoZXIgcmVnaXN0ZXIgbWVzc2FnZSB0byB0aGUgc2lnbmFsaW5nIHNlcnZlci5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9zdGFydFJlZ2lzdHJhdGlvblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9zdG9wUmVnaXN0cmF0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5yZWdUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3NlbmRQcmVzZW5jZSgpO1xuICAgICAgICB9LCBSRUdJU1RSQVRJT05fSU5URVJWQUwpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RvcCBzZW5kaW5nIHJlZ2lzdHJhdGlvbiBtZXNzYWdlcyB0byB0aGUgc2lnbmFsaW5nIHNlcnZlci5cbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl9zdG9wUmVnaXN0cmF0aW9uVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWdUaW1lcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRocm93IGFuIEVycm9yIGlmIERldmljZS5zZXR1cCBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBtZXRob2ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCBiZWluZyBjYWxsZWQgYmVmb3JlIHNldHVwKClcbiAgICAgKi9cbiAgICBEZXZpY2UucHJvdG90eXBlLl90aHJvd1VubGVzc1NldHVwID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcihcIkNhbGwgRGV2aWNlLnNldHVwKCkgYmVmb3JlIFwiICsgbWV0aG9kTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgZGV2aWNlIElEcyBvZiBvdXRwdXQgZGV2aWNlcyBiZWluZyB1c2VkIHRvIHBsYXkgdGhlIGluY29taW5nIHJpbmd0b25lIHRocm91Z2guXG4gICAgICogQHBhcmFtIHNpbmtJZHMgLSBBbiBhcnJheSBvZiBkZXZpY2UgSURzXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5fdXBkYXRlUmluZ3RvbmVTaW5rSWRzID0gZnVuY3Rpb24gKHNpbmtJZHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnNvdW5kY2FjaGUuZ2V0KERldmljZS5Tb3VuZE5hbWUuSW5jb21pbmcpLnNldFNpbmtJZHMoc2lua0lkcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBkZXZpY2UgSURzIG9mIG91dHB1dCBkZXZpY2VzIGJlaW5nIHVzZWQgdG8gcGxheSB0aGUgbm9uLXJpbmd0b25lIHNvdW5kc1xuICAgICAqIGFuZCBDYWxsIGF1ZGlvIHRocm91Z2guXG4gICAgICogQHBhcmFtIHNpbmtJZHMgLSBBbiBhcnJheSBvZiBkZXZpY2UgSURzXG4gICAgICovXG4gICAgRGV2aWNlLnByb3RvdHlwZS5fdXBkYXRlU3BlYWtlclNpbmtJZHMgPSBmdW5jdGlvbiAoc2lua0lkcykge1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuc291bmRjYWNoZS5lbnRyaWVzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gZW50cnlbMF0gIT09IERldmljZS5Tb3VuZE5hbWUuSW5jb21pbmc7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIGVudHJ5WzFdLnNldFNpbmtJZHMoc2lua0lkcyk7IH0pO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU2lua0lkcyA9IHNpbmtJZHM7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fYWN0aXZlQ29ubmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25cbiAgICAgICAgICAgID8gY29ubmVjdGlvbi5fc2V0U2lua0lkcyhzaW5rSWRzKVxuICAgICAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIHRoZSB7QGxpbmsgRGV2aWNlfVxuICAgICAqIEBwYXJhbSB0b2tlblxuICAgICAqL1xuICAgIERldmljZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5zZXRUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB0aGlzLl9wdWJsaXNoZXIuc2V0VG9rZW4odG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBTdHJlYW0odG9rZW4pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGV2aWNlO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbihmdW5jdGlvbiAoRGV2aWNlKSB7XG4gICAgLyoqXG4gICAgICogQWxsIHZhbGlkIHtAbGluayBEZXZpY2V9IGV2ZW50IG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBFdmVudE5hbWU7XG4gICAgKGZ1bmN0aW9uIChFdmVudE5hbWUpIHtcbiAgICAgICAgRXZlbnROYW1lW1wiQ2FuY2VsXCJdID0gXCJjYW5jZWxcIjtcbiAgICAgICAgRXZlbnROYW1lW1wiQ29ubmVjdFwiXSA9IFwiY29ubmVjdFwiO1xuICAgICAgICBFdmVudE5hbWVbXCJEaXNjb25uZWN0XCJdID0gXCJkaXNjb25uZWN0XCI7XG4gICAgICAgIEV2ZW50TmFtZVtcIkVycm9yXCJdID0gXCJlcnJvclwiO1xuICAgICAgICBFdmVudE5hbWVbXCJJbmNvbWluZ1wiXSA9IFwiaW5jb21pbmdcIjtcbiAgICAgICAgRXZlbnROYW1lW1wiT2ZmbGluZVwiXSA9IFwib2ZmbGluZVwiO1xuICAgICAgICBFdmVudE5hbWVbXCJSZWFkeVwiXSA9IFwicmVhZHlcIjtcbiAgICB9KShFdmVudE5hbWUgPSBEZXZpY2UuRXZlbnROYW1lIHx8IChEZXZpY2UuRXZlbnROYW1lID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBBbGwgcG9zc2libGUge0BsaW5rIERldmljZX0gc3RhdHVzZXMuXG4gICAgICovXG4gICAgdmFyIFN0YXR1cztcbiAgICAoZnVuY3Rpb24gKFN0YXR1cykge1xuICAgICAgICBTdGF0dXNbXCJCdXN5XCJdID0gXCJidXN5XCI7XG4gICAgICAgIFN0YXR1c1tcIk9mZmxpbmVcIl0gPSBcIm9mZmxpbmVcIjtcbiAgICAgICAgU3RhdHVzW1wiUmVhZHlcIl0gPSBcInJlYWR5XCI7XG4gICAgfSkoU3RhdHVzID0gRGV2aWNlLlN0YXR1cyB8fCAoRGV2aWNlLlN0YXR1cyA9IHt9KSk7XG4gICAgLyoqXG4gICAgICogTmFtZXMgb2YgYWxsIHNvdW5kcyBoYW5kbGVkIGJ5IHRoZSB7QGxpbmsgRGV2aWNlfS5cbiAgICAgKi9cbiAgICB2YXIgU291bmROYW1lO1xuICAgIChmdW5jdGlvbiAoU291bmROYW1lKSB7XG4gICAgICAgIFNvdW5kTmFtZVtcIkluY29taW5nXCJdID0gXCJpbmNvbWluZ1wiO1xuICAgICAgICBTb3VuZE5hbWVbXCJPdXRnb2luZ1wiXSA9IFwib3V0Z29pbmdcIjtcbiAgICAgICAgU291bmROYW1lW1wiRGlzY29ubmVjdFwiXSA9IFwiZGlzY29ubmVjdFwiO1xuICAgICAgICBTb3VuZE5hbWVbXCJEdG1mMFwiXSA9IFwiZHRtZjBcIjtcbiAgICAgICAgU291bmROYW1lW1wiRHRtZjFcIl0gPSBcImR0bWYxXCI7XG4gICAgICAgIFNvdW5kTmFtZVtcIkR0bWYyXCJdID0gXCJkdG1mMlwiO1xuICAgICAgICBTb3VuZE5hbWVbXCJEdG1mM1wiXSA9IFwiZHRtZjNcIjtcbiAgICAgICAgU291bmROYW1lW1wiRHRtZjRcIl0gPSBcImR0bWY0XCI7XG4gICAgICAgIFNvdW5kTmFtZVtcIkR0bWY1XCJdID0gXCJkdG1mNVwiO1xuICAgICAgICBTb3VuZE5hbWVbXCJEdG1mNlwiXSA9IFwiZHRtZjZcIjtcbiAgICAgICAgU291bmROYW1lW1wiRHRtZjdcIl0gPSBcImR0bWY3XCI7XG4gICAgICAgIFNvdW5kTmFtZVtcIkR0bWY4XCJdID0gXCJkdG1mOFwiO1xuICAgICAgICBTb3VuZE5hbWVbXCJEdG1mOVwiXSA9IFwiZHRtZjlcIjtcbiAgICAgICAgU291bmROYW1lW1wiRHRtZlNcIl0gPSBcImR0bWZzXCI7XG4gICAgICAgIFNvdW5kTmFtZVtcIkR0bWZIXCJdID0gXCJkdG1maFwiO1xuICAgIH0pKFNvdW5kTmFtZSA9IERldmljZS5Tb3VuZE5hbWUgfHwgKERldmljZS5Tb3VuZE5hbWUgPSB7fSkpO1xufSkoRGV2aWNlIHx8IChEZXZpY2UgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRGV2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV2aWNlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/device.js\n")},"./node_modules/twilio-client/es5/twilio/dialtonePlayer.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\n/**\n * A Map of DTMF Sound Names to their mock frequency pairs.\n */\nvar bandFrequencies = {\n    dtmf0: [1360, 960],\n    dtmf1: [1230, 720],\n    dtmf2: [1360, 720],\n    dtmf3: [1480, 720],\n    dtmf4: [1230, 790],\n    dtmf5: [1360, 790],\n    dtmf6: [1480, 790],\n    dtmf7: [1230, 870],\n    dtmf8: [1360, 870],\n    dtmf9: [1480, 870],\n    dtmfh: [1480, 960],\n    dtmfs: [1230, 960],\n};\nvar DialtonePlayer = /** @class */ (function () {\n    function DialtonePlayer(_context) {\n        var _this = this;\n        this._context = _context;\n        /**\n         * Gain nodes, reducing the frequency.\n         */\n        this._gainNodes = [];\n        this._gainNodes = [\n            this._context.createGain(),\n            this._context.createGain(),\n        ];\n        this._gainNodes.forEach(function (gainNode) {\n            gainNode.connect(_this._context.destination);\n            gainNode.gain.value = 0.1;\n            _this._gainNodes.push(gainNode);\n        });\n    }\n    DialtonePlayer.prototype.cleanup = function () {\n        this._gainNodes.forEach(function (gainNode) {\n            gainNode.disconnect();\n        });\n    };\n    /**\n     * Play the dual frequency tone for the passed DTMF name.\n     * @param sound\n     */\n    DialtonePlayer.prototype.play = function (sound) {\n        var _this = this;\n        var frequencies = bandFrequencies[sound];\n        if (!frequencies) {\n            throw new errors_1.InvalidArgumentError('Invalid DTMF sound name');\n        }\n        var oscillators = [\n            this._context.createOscillator(),\n            this._context.createOscillator(),\n        ];\n        oscillators.forEach(function (oscillator, i) {\n            oscillator.type = 'sine';\n            oscillator.frequency.value = frequencies[i];\n            oscillator.connect(_this._gainNodes[i]);\n            oscillator.start();\n            oscillator.stop(_this._context.currentTime + 0.1);\n            oscillator.addEventListener('ended', function () { return oscillator.disconnect(); });\n        });\n    };\n    return DialtonePlayer;\n}());\nexports.default = DialtonePlayer;\n//# sourceMappingURL=dialtonePlayer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2RpYWx0b25lUGxheWVyLmpzPzExNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyx5RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGdDQUFnQyxFQUFFO0FBQ2hHLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWU7QUFDZiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vZGlhbHRvbmVQbGF5ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFRvb2xzXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBBIE1hcCBvZiBEVE1GIFNvdW5kIE5hbWVzIHRvIHRoZWlyIG1vY2sgZnJlcXVlbmN5IHBhaXJzLlxuICovXG52YXIgYmFuZEZyZXF1ZW5jaWVzID0ge1xuICAgIGR0bWYwOiBbMTM2MCwgOTYwXSxcbiAgICBkdG1mMTogWzEyMzAsIDcyMF0sXG4gICAgZHRtZjI6IFsxMzYwLCA3MjBdLFxuICAgIGR0bWYzOiBbMTQ4MCwgNzIwXSxcbiAgICBkdG1mNDogWzEyMzAsIDc5MF0sXG4gICAgZHRtZjU6IFsxMzYwLCA3OTBdLFxuICAgIGR0bWY2OiBbMTQ4MCwgNzkwXSxcbiAgICBkdG1mNzogWzEyMzAsIDg3MF0sXG4gICAgZHRtZjg6IFsxMzYwLCA4NzBdLFxuICAgIGR0bWY5OiBbMTQ4MCwgODcwXSxcbiAgICBkdG1maDogWzE0ODAsIDk2MF0sXG4gICAgZHRtZnM6IFsxMjMwLCA5NjBdLFxufTtcbnZhciBEaWFsdG9uZVBsYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaWFsdG9uZVBsYXllcihfY29udGV4dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gX2NvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHYWluIG5vZGVzLCByZWR1Y2luZyB0aGUgZnJlcXVlbmN5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGVzID0gW107XG4gICAgICAgIHRoaXMuX2dhaW5Ob2RlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY3JlYXRlR2FpbigpLFxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jcmVhdGVHYWluKCksXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2dhaW5Ob2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChnYWluTm9kZSkge1xuICAgICAgICAgICAgZ2Fpbk5vZGUuY29ubmVjdChfdGhpcy5fY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICBnYWluTm9kZS5nYWluLnZhbHVlID0gMC4xO1xuICAgICAgICAgICAgX3RoaXMuX2dhaW5Ob2Rlcy5wdXNoKGdhaW5Ob2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIERpYWx0b25lUGxheWVyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9nYWluTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZ2Fpbk5vZGUpIHtcbiAgICAgICAgICAgIGdhaW5Ob2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBQbGF5IHRoZSBkdWFsIGZyZXF1ZW5jeSB0b25lIGZvciB0aGUgcGFzc2VkIERUTUYgbmFtZS5cbiAgICAgKiBAcGFyYW0gc291bmRcbiAgICAgKi9cbiAgICBEaWFsdG9uZVBsYXllci5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChzb3VuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJlcXVlbmNpZXMgPSBiYW5kRnJlcXVlbmNpZXNbc291bmRdO1xuICAgICAgICBpZiAoIWZyZXF1ZW5jaWVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgRFRNRiBzb3VuZCBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9zY2lsbGF0b3JzID0gW1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jcmVhdGVPc2NpbGxhdG9yKCksXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKSxcbiAgICAgICAgXTtcbiAgICAgICAgb3NjaWxsYXRvcnMuZm9yRWFjaChmdW5jdGlvbiAob3NjaWxsYXRvciwgaSkge1xuICAgICAgICAgICAgb3NjaWxsYXRvci50eXBlID0gJ3NpbmUnO1xuICAgICAgICAgICAgb3NjaWxsYXRvci5mcmVxdWVuY3kudmFsdWUgPSBmcmVxdWVuY2llc1tpXTtcbiAgICAgICAgICAgIG9zY2lsbGF0b3IuY29ubmVjdChfdGhpcy5fZ2Fpbk5vZGVzW2ldKTtcbiAgICAgICAgICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICAgICAgICAgIG9zY2lsbGF0b3Iuc3RvcChfdGhpcy5fY29udGV4dC5jdXJyZW50VGltZSArIDAuMSk7XG4gICAgICAgICAgICBvc2NpbGxhdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gb3NjaWxsYXRvci5kaXNjb25uZWN0KCk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEaWFsdG9uZVBsYXllcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEaWFsdG9uZVBsYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpYWx0b25lUGxheWVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/dialtonePlayer.js\n")},"./node_modules/twilio-client/es5/twilio/errors/generated.js":function(__unused_webpack_module,exports){"use strict";eval("\n/* tslint:disable max-classes-per-file max-line-length */\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// TypeScript doesn't allow extending Error so we need to run constructor logic on every one of these\n// individually. Ideally this logic would be run in a constructor on a TwilioError class but\n// due to this limitation TwilioError is an interface.\n// https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes\nfunction construct(context, messageOrError, originalError) {\n    if (typeof messageOrError === 'string') {\n        context.message = messageOrError;\n        if (originalError instanceof Error) {\n            context.originalError = originalError;\n        }\n    }\n    else if (messageOrError instanceof Error) {\n        context.originalError = messageOrError;\n    }\n}\nvar AuthorizationErrors;\n(function (AuthorizationErrors) {\n    var AccessTokenInvalid = /** @class */ (function (_super) {\n        __extends(AccessTokenInvalid, _super);\n        function AccessTokenInvalid(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 20101;\n            _this.description = 'Invalid access token';\n            _this.explanation = 'Twilio was unable to validate your Access Token';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, AuthorizationErrors.AccessTokenInvalid.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return AccessTokenInvalid;\n    }(Error));\n    AuthorizationErrors.AccessTokenInvalid = AccessTokenInvalid;\n    var AccessTokenExpired = /** @class */ (function (_super) {\n        __extends(AccessTokenExpired, _super);\n        function AccessTokenExpired(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 20104;\n            _this.description = 'Access token expired or expiration date invalid';\n            _this.explanation = 'The Access Token provided to the Twilio API has expired, the expiration time specified in the token was invalid, or the expiration time specified was too far in the future';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, AuthorizationErrors.AccessTokenExpired.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return AccessTokenExpired;\n    }(Error));\n    AuthorizationErrors.AccessTokenExpired = AccessTokenExpired;\n    var AuthenticationFailed = /** @class */ (function (_super) {\n        __extends(AuthenticationFailed, _super);\n        function AuthenticationFailed(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 20151;\n            _this.description = 'Authentication Failed';\n            _this.explanation = 'The Authentication with the provided JWT failed';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, AuthorizationErrors.AuthenticationFailed.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return AuthenticationFailed;\n    }(Error));\n    AuthorizationErrors.AuthenticationFailed = AuthenticationFailed;\n})(AuthorizationErrors = exports.AuthorizationErrors || (exports.AuthorizationErrors = {}));\nvar ClientErrors;\n(function (ClientErrors) {\n    var BadRequest = /** @class */ (function (_super) {\n        __extends(BadRequest, _super);\n        function BadRequest(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 31400;\n            _this.description = 'Bad Request (HTTP/SIP)';\n            _this.explanation = 'The request could not be understood due to malformed syntax.';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, ClientErrors.BadRequest.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return BadRequest;\n    }(Error));\n    ClientErrors.BadRequest = BadRequest;\n})(ClientErrors = exports.ClientErrors || (exports.ClientErrors = {}));\nvar GeneralErrors;\n(function (GeneralErrors) {\n    var UnknownError = /** @class */ (function (_super) {\n        __extends(UnknownError, _super);\n        function UnknownError(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 31000;\n            _this.description = 'Unknown Error';\n            _this.explanation = 'An unknown error has occurred. See error details for more information.';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, GeneralErrors.UnknownError.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return UnknownError;\n    }(Error));\n    GeneralErrors.UnknownError = UnknownError;\n    var ConnectionError = /** @class */ (function (_super) {\n        __extends(ConnectionError, _super);\n        function ConnectionError(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 31005;\n            _this.description = 'Connection error';\n            _this.explanation = 'A connection error occurred during the call';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, GeneralErrors.ConnectionError.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ConnectionError;\n    }(Error));\n    GeneralErrors.ConnectionError = ConnectionError;\n    var TransportError = /** @class */ (function (_super) {\n        __extends(TransportError, _super);\n        function TransportError(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 31009;\n            _this.description = 'Transport error';\n            _this.explanation = 'No transport available to send or receive messages';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, GeneralErrors.TransportError.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return TransportError;\n    }(Error));\n    GeneralErrors.TransportError = TransportError;\n})(GeneralErrors = exports.GeneralErrors || (exports.GeneralErrors = {}));\nvar SignalingErrors;\n(function (SignalingErrors) {\n    var ConnectionError = /** @class */ (function (_super) {\n        __extends(ConnectionError, _super);\n        function ConnectionError(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [];\n            _this.code = 53000;\n            _this.description = 'Signaling connection error';\n            _this.explanation = 'Raised whenever a signaling connection error occurs that is not covered by a more specific error code.';\n            _this.solutions = [];\n            Object.setPrototypeOf(_this, SignalingErrors.ConnectionError.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ConnectionError;\n    }(Error));\n    SignalingErrors.ConnectionError = ConnectionError;\n    var ConnectionDisconnected = /** @class */ (function (_super) {\n        __extends(ConnectionDisconnected, _super);\n        function ConnectionDisconnected(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [\n                'The device running your application lost its Internet connection.',\n            ];\n            _this.code = 53001;\n            _this.description = 'Signaling connection disconnected';\n            _this.explanation = 'Raised whenever the signaling connection is unexpectedly disconnected.';\n            _this.solutions = [\n                'Ensure the device running your application has access to a stable Internet connection.',\n            ];\n            Object.setPrototypeOf(_this, SignalingErrors.ConnectionDisconnected.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ConnectionDisconnected;\n    }(Error));\n    SignalingErrors.ConnectionDisconnected = ConnectionDisconnected;\n})(SignalingErrors = exports.SignalingErrors || (exports.SignalingErrors = {}));\nvar MediaErrors;\n(function (MediaErrors) {\n    var ClientLocalDescFailed = /** @class */ (function (_super) {\n        __extends(ClientLocalDescFailed, _super);\n        function ClientLocalDescFailed(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [\n                'The Client may not be using a supported WebRTC implementation.',\n                'The Client may not have the necessary resources to create or apply a new media description.',\n            ];\n            _this.code = 53400;\n            _this.description = 'Client is unable to create or apply a local media description';\n            _this.explanation = 'Raised whenever a Client is unable to create or apply a local media description.';\n            _this.solutions = [\n                'If you are experiencing this error using the JavaScript SDK, ensure you are running it with a supported WebRTC implementation.',\n            ];\n            Object.setPrototypeOf(_this, MediaErrors.ClientLocalDescFailed.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ClientLocalDescFailed;\n    }(Error));\n    MediaErrors.ClientLocalDescFailed = ClientLocalDescFailed;\n    var ClientRemoteDescFailed = /** @class */ (function (_super) {\n        __extends(ClientRemoteDescFailed, _super);\n        function ClientRemoteDescFailed(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [\n                'The Client may not be using a supported WebRTC implementation.',\n                'The Client may be connecting peer-to-peer with another Participant that is not using a supported WebRTC implementation.',\n                'The Client may not have the necessary resources to apply a new media description.',\n            ];\n            _this.code = 53402;\n            _this.description = 'Client is unable to apply a remote media description';\n            _this.explanation = 'Raised whenever the Client receives a remote media description but is unable to apply it.';\n            _this.solutions = [\n                'If you are experiencing this error using the JavaScript SDK, ensure you are running it with a supported WebRTC implementation.',\n            ];\n            Object.setPrototypeOf(_this, MediaErrors.ClientRemoteDescFailed.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ClientRemoteDescFailed;\n    }(Error));\n    MediaErrors.ClientRemoteDescFailed = ClientRemoteDescFailed;\n    var ConnectionError = /** @class */ (function (_super) {\n        __extends(ConnectionError, _super);\n        function ConnectionError(messageOrError, originalError) {\n            var _this = _super.call(this, '') || this;\n            _this.causes = [\n                'The Client was unable to establish a media connection.',\n                'A media connection which was active failed liveliness checks.',\n            ];\n            _this.code = 53405;\n            _this.description = 'Media connection failed';\n            _this.explanation = 'Raised by the Client or Server whenever a media connection fails.';\n            _this.solutions = [\n                'If the problem persists, try connecting to another region.',\n                'Check your Client\\'s network connectivity.',\n                'If you\\'ve provided custom ICE Servers then ensure that the URLs and credentials are valid.',\n            ];\n            Object.setPrototypeOf(_this, MediaErrors.ConnectionError.prototype);\n            construct(_this, messageOrError, originalError);\n            return _this;\n        }\n        return ConnectionError;\n    }(Error));\n    MediaErrors.ConnectionError = ConnectionError;\n})(MediaErrors = exports.MediaErrors || (exports.MediaErrors = {}));\n/**\n * @private\n */\nexports.errorsByCode = new Map([\n    [20101, AuthorizationErrors.AccessTokenInvalid],\n    [20104, AuthorizationErrors.AccessTokenExpired],\n    [20151, AuthorizationErrors.AuthenticationFailed],\n    [31400, ClientErrors.BadRequest],\n    [31000, GeneralErrors.UnknownError],\n    [31005, GeneralErrors.ConnectionError],\n    [31009, GeneralErrors.TransportError],\n    [53000, SignalingErrors.ConnectionError],\n    [53001, SignalingErrors.ConnectionDisconnected],\n    [53400, MediaErrors.ClientLocalDescFailed],\n    [53402, MediaErrors.ClientRemoteDescFailed],\n    [53405, MediaErrors.ConnectionError],\n]);\nObject.freeze(exports.errorsByCode);\n//# sourceMappingURL=generated.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2Vycm9ycy9nZW5lcmF0ZWQuanM/MWRjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLHdEQUF3RCwyQkFBMkIsS0FBSztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLDRDQUE0QyxxQkFBcUIsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsZ0RBQWdELHVCQUF1QixLQUFLO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLHdDQUF3QyxtQkFBbUIsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9lcnJvcnMvZ2VuZXJhdGVkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSBtYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFZvaWNlXG4gKiBAcHVibGljYXBpXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBUeXBlU2NyaXB0IGRvZXNuJ3QgYWxsb3cgZXh0ZW5kaW5nIEVycm9yIHNvIHdlIG5lZWQgdG8gcnVuIGNvbnN0cnVjdG9yIGxvZ2ljIG9uIGV2ZXJ5IG9uZSBvZiB0aGVzZVxuLy8gaW5kaXZpZHVhbGx5LiBJZGVhbGx5IHRoaXMgbG9naWMgd291bGQgYmUgcnVuIGluIGEgY29uc3RydWN0b3Igb24gYSBUd2lsaW9FcnJvciBjbGFzcyBidXRcbi8vIGR1ZSB0byB0aGlzIGxpbWl0YXRpb24gVHdpbGlvRXJyb3IgaXMgYW4gaW50ZXJmYWNlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L3dpa2kvQnJlYWtpbmctQ2hhbmdlc1xuZnVuY3Rpb24gY29uc3RydWN0KGNvbnRleHQsIG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlT3JFcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGV4dC5tZXNzYWdlID0gbWVzc2FnZU9yRXJyb3I7XG4gICAgICAgIGlmIChvcmlnaW5hbEVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRleHQub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobWVzc2FnZU9yRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb250ZXh0Lm9yaWdpbmFsRXJyb3IgPSBtZXNzYWdlT3JFcnJvcjtcbiAgICB9XG59XG52YXIgQXV0aG9yaXphdGlvbkVycm9ycztcbihmdW5jdGlvbiAoQXV0aG9yaXphdGlvbkVycm9ycykge1xuICAgIHZhciBBY2Nlc3NUb2tlbkludmFsaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhBY2Nlc3NUb2tlbkludmFsaWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEFjY2Vzc1Rva2VuSW52YWxpZChtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJycpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5jYXVzZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSAyMDEwMTtcbiAgICAgICAgICAgIF90aGlzLmRlc2NyaXB0aW9uID0gJ0ludmFsaWQgYWNjZXNzIHRva2VuJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1R3aWxpbyB3YXMgdW5hYmxlIHRvIHZhbGlkYXRlIHlvdXIgQWNjZXNzIFRva2VuJztcbiAgICAgICAgICAgIF90aGlzLnNvbHV0aW9ucyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBdXRob3JpemF0aW9uRXJyb3JzLkFjY2Vzc1Rva2VuSW52YWxpZC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjY2Vzc1Rva2VuSW52YWxpZDtcbiAgICB9KEVycm9yKSk7XG4gICAgQXV0aG9yaXphdGlvbkVycm9ycy5BY2Nlc3NUb2tlbkludmFsaWQgPSBBY2Nlc3NUb2tlbkludmFsaWQ7XG4gICAgdmFyIEFjY2Vzc1Rva2VuRXhwaXJlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEFjY2Vzc1Rva2VuRXhwaXJlZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQWNjZXNzVG9rZW5FeHBpcmVkKG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnJykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhdXNlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IDIwMTA0O1xuICAgICAgICAgICAgX3RoaXMuZGVzY3JpcHRpb24gPSAnQWNjZXNzIHRva2VuIGV4cGlyZWQgb3IgZXhwaXJhdGlvbiBkYXRlIGludmFsaWQnO1xuICAgICAgICAgICAgX3RoaXMuZXhwbGFuYXRpb24gPSAnVGhlIEFjY2VzcyBUb2tlbiBwcm92aWRlZCB0byB0aGUgVHdpbGlvIEFQSSBoYXMgZXhwaXJlZCwgdGhlIGV4cGlyYXRpb24gdGltZSBzcGVjaWZpZWQgaW4gdGhlIHRva2VuIHdhcyBpbnZhbGlkLCBvciB0aGUgZXhwaXJhdGlvbiB0aW1lIHNwZWNpZmllZCB3YXMgdG9vIGZhciBpbiB0aGUgZnV0dXJlJztcbiAgICAgICAgICAgIF90aGlzLnNvbHV0aW9ucyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBdXRob3JpemF0aW9uRXJyb3JzLkFjY2Vzc1Rva2VuRXhwaXJlZC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFjY2Vzc1Rva2VuRXhwaXJlZDtcbiAgICB9KEVycm9yKSk7XG4gICAgQXV0aG9yaXphdGlvbkVycm9ycy5BY2Nlc3NUb2tlbkV4cGlyZWQgPSBBY2Nlc3NUb2tlbkV4cGlyZWQ7XG4gICAgdmFyIEF1dGhlbnRpY2F0aW9uRmFpbGVkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQXV0aGVudGljYXRpb25GYWlsZWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEF1dGhlbnRpY2F0aW9uRmFpbGVkKG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnJykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhdXNlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IDIwMTUxO1xuICAgICAgICAgICAgX3RoaXMuZGVzY3JpcHRpb24gPSAnQXV0aGVudGljYXRpb24gRmFpbGVkJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1RoZSBBdXRoZW50aWNhdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBKV1QgZmFpbGVkJztcbiAgICAgICAgICAgIF90aGlzLnNvbHV0aW9ucyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBBdXRob3JpemF0aW9uRXJyb3JzLkF1dGhlbnRpY2F0aW9uRmFpbGVkLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdHJ1Y3QoX3RoaXMsIG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXV0aGVudGljYXRpb25GYWlsZWQ7XG4gICAgfShFcnJvcikpO1xuICAgIEF1dGhvcml6YXRpb25FcnJvcnMuQXV0aGVudGljYXRpb25GYWlsZWQgPSBBdXRoZW50aWNhdGlvbkZhaWxlZDtcbn0pKEF1dGhvcml6YXRpb25FcnJvcnMgPSBleHBvcnRzLkF1dGhvcml6YXRpb25FcnJvcnMgfHwgKGV4cG9ydHMuQXV0aG9yaXphdGlvbkVycm9ycyA9IHt9KSk7XG52YXIgQ2xpZW50RXJyb3JzO1xuKGZ1bmN0aW9uIChDbGllbnRFcnJvcnMpIHtcbiAgICB2YXIgQmFkUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEJhZFJlcXVlc3QsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIEJhZFJlcXVlc3QobWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICcnKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2F1c2VzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gMzE0MDA7XG4gICAgICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9ICdCYWQgUmVxdWVzdCAoSFRUUC9TSVApJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1RoZSByZXF1ZXN0IGNvdWxkIG5vdCBiZSB1bmRlcnN0b29kIGR1ZSB0byBtYWxmb3JtZWQgc3ludGF4Lic7XG4gICAgICAgICAgICBfdGhpcy5zb2x1dGlvbnMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgQ2xpZW50RXJyb3JzLkJhZFJlcXVlc3QucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdChfdGhpcywgbWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCYWRSZXF1ZXN0O1xuICAgIH0oRXJyb3IpKTtcbiAgICBDbGllbnRFcnJvcnMuQmFkUmVxdWVzdCA9IEJhZFJlcXVlc3Q7XG59KShDbGllbnRFcnJvcnMgPSBleHBvcnRzLkNsaWVudEVycm9ycyB8fCAoZXhwb3J0cy5DbGllbnRFcnJvcnMgPSB7fSkpO1xudmFyIEdlbmVyYWxFcnJvcnM7XG4oZnVuY3Rpb24gKEdlbmVyYWxFcnJvcnMpIHtcbiAgICB2YXIgVW5rbm93bkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoVW5rbm93bkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBVbmtub3duRXJyb3IobWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICcnKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2F1c2VzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gMzEwMDA7XG4gICAgICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9ICdVbmtub3duIEVycm9yJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ0FuIHVua25vd24gZXJyb3IgaGFzIG9jY3VycmVkLiBTZWUgZXJyb3IgZGV0YWlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25zID0gW107XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEdlbmVyYWxFcnJvcnMuVW5rbm93bkVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdHJ1Y3QoX3RoaXMsIG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVW5rbm93bkVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICBHZW5lcmFsRXJyb3JzLlVua25vd25FcnJvciA9IFVua25vd25FcnJvcjtcbiAgICB2YXIgQ29ubmVjdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ29ubmVjdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBDb25uZWN0aW9uRXJyb3IobWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICcnKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2F1c2VzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gMzEwMDU7XG4gICAgICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9ICdDb25uZWN0aW9uIGVycm9yJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ0EgY29ubmVjdGlvbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIGNhbGwnO1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25zID0gW107XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEdlbmVyYWxFcnJvcnMuQ29ubmVjdGlvbkVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBjb25zdHJ1Y3QoX3RoaXMsIG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29ubmVjdGlvbkVycm9yO1xuICAgIH0oRXJyb3IpKTtcbiAgICBHZW5lcmFsRXJyb3JzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbiAgICB2YXIgVHJhbnNwb3J0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhUcmFuc3BvcnRFcnJvciwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gVHJhbnNwb3J0RXJyb3IobWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICcnKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2F1c2VzID0gW107XG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gMzEwMDk7XG4gICAgICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9ICdUcmFuc3BvcnQgZXJyb3InO1xuICAgICAgICAgICAgX3RoaXMuZXhwbGFuYXRpb24gPSAnTm8gdHJhbnNwb3J0IGF2YWlsYWJsZSB0byBzZW5kIG9yIHJlY2VpdmUgbWVzc2FnZXMnO1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25zID0gW107XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIEdlbmVyYWxFcnJvcnMuVHJhbnNwb3J0RXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdChfdGhpcywgbWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUcmFuc3BvcnRFcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgR2VuZXJhbEVycm9ycy5UcmFuc3BvcnRFcnJvciA9IFRyYW5zcG9ydEVycm9yO1xufSkoR2VuZXJhbEVycm9ycyA9IGV4cG9ydHMuR2VuZXJhbEVycm9ycyB8fCAoZXhwb3J0cy5HZW5lcmFsRXJyb3JzID0ge30pKTtcbnZhciBTaWduYWxpbmdFcnJvcnM7XG4oZnVuY3Rpb24gKFNpZ25hbGluZ0Vycm9ycykge1xuICAgIHZhciBDb25uZWN0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDb25uZWN0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25FcnJvcihtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJycpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5jYXVzZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSA1MzAwMDtcbiAgICAgICAgICAgIF90aGlzLmRlc2NyaXB0aW9uID0gJ1NpZ25hbGluZyBjb25uZWN0aW9uIGVycm9yJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1JhaXNlZCB3aGVuZXZlciBhIHNpZ25hbGluZyBjb25uZWN0aW9uIGVycm9yIG9jY3VycyB0aGF0IGlzIG5vdCBjb3ZlcmVkIGJ5IGEgbW9yZSBzcGVjaWZpYyBlcnJvciBjb2RlLic7XG4gICAgICAgICAgICBfdGhpcy5zb2x1dGlvbnMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgU2lnbmFsaW5nRXJyb3JzLkNvbm5lY3Rpb25FcnJvci5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25FcnJvcjtcbiAgICB9KEVycm9yKSk7XG4gICAgU2lnbmFsaW5nRXJyb3JzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbiAgICB2YXIgQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENvbm5lY3Rpb25EaXNjb25uZWN0ZWQsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25EaXNjb25uZWN0ZWQobWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICcnKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY2F1c2VzID0gW1xuICAgICAgICAgICAgICAgICdUaGUgZGV2aWNlIHJ1bm5pbmcgeW91ciBhcHBsaWNhdGlvbiBsb3N0IGl0cyBJbnRlcm5ldCBjb25uZWN0aW9uLicsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgX3RoaXMuY29kZSA9IDUzMDAxO1xuICAgICAgICAgICAgX3RoaXMuZGVzY3JpcHRpb24gPSAnU2lnbmFsaW5nIGNvbm5lY3Rpb24gZGlzY29ubmVjdGVkJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1JhaXNlZCB3aGVuZXZlciB0aGUgc2lnbmFsaW5nIGNvbm5lY3Rpb24gaXMgdW5leHBlY3RlZGx5IGRpc2Nvbm5lY3RlZC4nO1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25zID0gW1xuICAgICAgICAgICAgICAgICdFbnN1cmUgdGhlIGRldmljZSBydW5uaW5nIHlvdXIgYXBwbGljYXRpb24gaGFzIGFjY2VzcyB0byBhIHN0YWJsZSBJbnRlcm5ldCBjb25uZWN0aW9uLicsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBTaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbm5lY3Rpb25EaXNjb25uZWN0ZWQ7XG4gICAgfShFcnJvcikpO1xuICAgIFNpZ25hbGluZ0Vycm9ycy5Db25uZWN0aW9uRGlzY29ubmVjdGVkID0gQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZDtcbn0pKFNpZ25hbGluZ0Vycm9ycyA9IGV4cG9ydHMuU2lnbmFsaW5nRXJyb3JzIHx8IChleHBvcnRzLlNpZ25hbGluZ0Vycm9ycyA9IHt9KSk7XG52YXIgTWVkaWFFcnJvcnM7XG4oZnVuY3Rpb24gKE1lZGlhRXJyb3JzKSB7XG4gICAgdmFyIENsaWVudExvY2FsRGVzY0ZhaWxlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKENsaWVudExvY2FsRGVzY0ZhaWxlZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2xpZW50TG9jYWxEZXNjRmFpbGVkKG1lc3NhZ2VPckVycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnJykgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmNhdXNlcyA9IFtcbiAgICAgICAgICAgICAgICAnVGhlIENsaWVudCBtYXkgbm90IGJlIHVzaW5nIGEgc3VwcG9ydGVkIFdlYlJUQyBpbXBsZW1lbnRhdGlvbi4nLFxuICAgICAgICAgICAgICAgICdUaGUgQ2xpZW50IG1heSBub3QgaGF2ZSB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyB0byBjcmVhdGUgb3IgYXBwbHkgYSBuZXcgbWVkaWEgZGVzY3JpcHRpb24uJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gNTM0MDA7XG4gICAgICAgICAgICBfdGhpcy5kZXNjcmlwdGlvbiA9ICdDbGllbnQgaXMgdW5hYmxlIHRvIGNyZWF0ZSBvciBhcHBseSBhIGxvY2FsIG1lZGlhIGRlc2NyaXB0aW9uJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1JhaXNlZCB3aGVuZXZlciBhIENsaWVudCBpcyB1bmFibGUgdG8gY3JlYXRlIG9yIGFwcGx5IGEgbG9jYWwgbWVkaWEgZGVzY3JpcHRpb24uJztcbiAgICAgICAgICAgIF90aGlzLnNvbHV0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAnSWYgeW91IGFyZSBleHBlcmllbmNpbmcgdGhpcyBlcnJvciB1c2luZyB0aGUgSmF2YVNjcmlwdCBTREssIGVuc3VyZSB5b3UgYXJlIHJ1bm5pbmcgaXQgd2l0aCBhIHN1cHBvcnRlZCBXZWJSVEMgaW1wbGVtZW50YXRpb24uJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1lZGlhRXJyb3JzLkNsaWVudExvY2FsRGVzY0ZhaWxlZC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsaWVudExvY2FsRGVzY0ZhaWxlZDtcbiAgICB9KEVycm9yKSk7XG4gICAgTWVkaWFFcnJvcnMuQ2xpZW50TG9jYWxEZXNjRmFpbGVkID0gQ2xpZW50TG9jYWxEZXNjRmFpbGVkO1xuICAgIHZhciBDbGllbnRSZW1vdGVEZXNjRmFpbGVkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZChtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJycpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5jYXVzZXMgPSBbXG4gICAgICAgICAgICAgICAgJ1RoZSBDbGllbnQgbWF5IG5vdCBiZSB1c2luZyBhIHN1cHBvcnRlZCBXZWJSVEMgaW1wbGVtZW50YXRpb24uJyxcbiAgICAgICAgICAgICAgICAnVGhlIENsaWVudCBtYXkgYmUgY29ubmVjdGluZyBwZWVyLXRvLXBlZXIgd2l0aCBhbm90aGVyIFBhcnRpY2lwYW50IHRoYXQgaXMgbm90IHVzaW5nIGEgc3VwcG9ydGVkIFdlYlJUQyBpbXBsZW1lbnRhdGlvbi4nLFxuICAgICAgICAgICAgICAgICdUaGUgQ2xpZW50IG1heSBub3QgaGF2ZSB0aGUgbmVjZXNzYXJ5IHJlc291cmNlcyB0byBhcHBseSBhIG5ldyBtZWRpYSBkZXNjcmlwdGlvbi4nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSA1MzQwMjtcbiAgICAgICAgICAgIF90aGlzLmRlc2NyaXB0aW9uID0gJ0NsaWVudCBpcyB1bmFibGUgdG8gYXBwbHkgYSByZW1vdGUgbWVkaWEgZGVzY3JpcHRpb24nO1xuICAgICAgICAgICAgX3RoaXMuZXhwbGFuYXRpb24gPSAnUmFpc2VkIHdoZW5ldmVyIHRoZSBDbGllbnQgcmVjZWl2ZXMgYSByZW1vdGUgbWVkaWEgZGVzY3JpcHRpb24gYnV0IGlzIHVuYWJsZSB0byBhcHBseSBpdC4nO1xuICAgICAgICAgICAgX3RoaXMuc29sdXRpb25zID0gW1xuICAgICAgICAgICAgICAgICdJZiB5b3UgYXJlIGV4cGVyaWVuY2luZyB0aGlzIGVycm9yIHVzaW5nIHRoZSBKYXZhU2NyaXB0IFNESywgZW5zdXJlIHlvdSBhcmUgcnVubmluZyBpdCB3aXRoIGEgc3VwcG9ydGVkIFdlYlJUQyBpbXBsZW1lbnRhdGlvbi4nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVkaWFFcnJvcnMuQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZC5wcm90b3R5cGUpO1xuICAgICAgICAgICAgY29uc3RydWN0KF90aGlzLCBtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENsaWVudFJlbW90ZURlc2NGYWlsZWQ7XG4gICAgfShFcnJvcikpO1xuICAgIE1lZGlhRXJyb3JzLkNsaWVudFJlbW90ZURlc2NGYWlsZWQgPSBDbGllbnRSZW1vdGVEZXNjRmFpbGVkO1xuICAgIHZhciBDb25uZWN0aW9uRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhDb25uZWN0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25FcnJvcihtZXNzYWdlT3JFcnJvciwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJycpIHx8IHRoaXM7XG4gICAgICAgICAgICBfdGhpcy5jYXVzZXMgPSBbXG4gICAgICAgICAgICAgICAgJ1RoZSBDbGllbnQgd2FzIHVuYWJsZSB0byBlc3RhYmxpc2ggYSBtZWRpYSBjb25uZWN0aW9uLicsXG4gICAgICAgICAgICAgICAgJ0EgbWVkaWEgY29ubmVjdGlvbiB3aGljaCB3YXMgYWN0aXZlIGZhaWxlZCBsaXZlbGluZXNzIGNoZWNrcy4nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIF90aGlzLmNvZGUgPSA1MzQwNTtcbiAgICAgICAgICAgIF90aGlzLmRlc2NyaXB0aW9uID0gJ01lZGlhIGNvbm5lY3Rpb24gZmFpbGVkJztcbiAgICAgICAgICAgIF90aGlzLmV4cGxhbmF0aW9uID0gJ1JhaXNlZCBieSB0aGUgQ2xpZW50IG9yIFNlcnZlciB3aGVuZXZlciBhIG1lZGlhIGNvbm5lY3Rpb24gZmFpbHMuJztcbiAgICAgICAgICAgIF90aGlzLnNvbHV0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAnSWYgdGhlIHByb2JsZW0gcGVyc2lzdHMsIHRyeSBjb25uZWN0aW5nIHRvIGFub3RoZXIgcmVnaW9uLicsXG4gICAgICAgICAgICAgICAgJ0NoZWNrIHlvdXIgQ2xpZW50XFwncyBuZXR3b3JrIGNvbm5lY3Rpdml0eS4nLFxuICAgICAgICAgICAgICAgICdJZiB5b3VcXCd2ZSBwcm92aWRlZCBjdXN0b20gSUNFIFNlcnZlcnMgdGhlbiBlbnN1cmUgdGhhdCB0aGUgVVJMcyBhbmQgY3JlZGVudGlhbHMgYXJlIHZhbGlkLicsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWRpYUVycm9ycy5Db25uZWN0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdChfdGhpcywgbWVzc2FnZU9yRXJyb3IsIG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb25uZWN0aW9uRXJyb3I7XG4gICAgfShFcnJvcikpO1xuICAgIE1lZGlhRXJyb3JzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbn0pKE1lZGlhRXJyb3JzID0gZXhwb3J0cy5NZWRpYUVycm9ycyB8fCAoZXhwb3J0cy5NZWRpYUVycm9ycyA9IHt9KSk7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydHMuZXJyb3JzQnlDb2RlID0gbmV3IE1hcChbXG4gICAgWzIwMTAxLCBBdXRob3JpemF0aW9uRXJyb3JzLkFjY2Vzc1Rva2VuSW52YWxpZF0sXG4gICAgWzIwMTA0LCBBdXRob3JpemF0aW9uRXJyb3JzLkFjY2Vzc1Rva2VuRXhwaXJlZF0sXG4gICAgWzIwMTUxLCBBdXRob3JpemF0aW9uRXJyb3JzLkF1dGhlbnRpY2F0aW9uRmFpbGVkXSxcbiAgICBbMzE0MDAsIENsaWVudEVycm9ycy5CYWRSZXF1ZXN0XSxcbiAgICBbMzEwMDAsIEdlbmVyYWxFcnJvcnMuVW5rbm93bkVycm9yXSxcbiAgICBbMzEwMDUsIEdlbmVyYWxFcnJvcnMuQ29ubmVjdGlvbkVycm9yXSxcbiAgICBbMzEwMDksIEdlbmVyYWxFcnJvcnMuVHJhbnNwb3J0RXJyb3JdLFxuICAgIFs1MzAwMCwgU2lnbmFsaW5nRXJyb3JzLkNvbm5lY3Rpb25FcnJvcl0sXG4gICAgWzUzMDAxLCBTaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZF0sXG4gICAgWzUzNDAwLCBNZWRpYUVycm9ycy5DbGllbnRMb2NhbERlc2NGYWlsZWRdLFxuICAgIFs1MzQwMiwgTWVkaWFFcnJvcnMuQ2xpZW50UmVtb3RlRGVzY0ZhaWxlZF0sXG4gICAgWzUzNDA1LCBNZWRpYUVycm9ycy5Db25uZWN0aW9uRXJyb3JdLFxuXSk7XG5PYmplY3QuZnJlZXplKGV4cG9ydHMuZXJyb3JzQnlDb2RlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlZC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/errors/generated.js\n")},"./node_modules/twilio-client/es5/twilio/errors/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * @packageDocumentation\n * @internalapi\n */\n/* tslint:disable max-classes-per-file */\nvar generated_1 = __webpack_require__(/*! ./generated */ "./node_modules/twilio-client/es5/twilio/errors/generated.js");\nexports.AuthorizationErrors = generated_1.AuthorizationErrors;\nexports.ClientErrors = generated_1.ClientErrors;\nexports.GeneralErrors = generated_1.GeneralErrors;\nexports.MediaErrors = generated_1.MediaErrors;\nexports.SignalingErrors = generated_1.SignalingErrors;\n// Application errors that can be avoided by good app logic\nvar InvalidArgumentError = /** @class */ (function (_super) {\n    __extends(InvalidArgumentError, _super);\n    function InvalidArgumentError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \'InvalidArgumentError\';\n        return _this;\n    }\n    return InvalidArgumentError;\n}(Error));\nexports.InvalidArgumentError = InvalidArgumentError;\nvar InvalidStateError = /** @class */ (function (_super) {\n    __extends(InvalidStateError, _super);\n    function InvalidStateError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \'InvalidStateError\';\n        return _this;\n    }\n    return InvalidStateError;\n}(Error));\nexports.InvalidStateError = InvalidStateError;\nvar NotSupportedError = /** @class */ (function (_super) {\n    __extends(NotSupportedError, _super);\n    function NotSupportedError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = \'NotSupportedError\';\n        return _this;\n    }\n    return NotSupportedError;\n}(Error));\nexports.NotSupportedError = NotSupportedError;\n// This should only be used to look up error codes returned by a server\n// using the same repo of error codes.\nfunction getErrorByCode(code) {\n    var error = generated_1.errorsByCode.get(code);\n    if (!error) {\n        throw new InvalidArgumentError("Error code " + code + " not found");\n    }\n    return error;\n}\nexports.getErrorByCode = getErrorByCode;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2Vycm9ycy9pbmRleC5qcz9mNzU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN2QywyQkFBMkI7QUFDM0Isb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9lcnJvcnMvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBpbnRlcm5hbGFwaVxuICovXG4vKiB0c2xpbnQ6ZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xudmFyIGdlbmVyYXRlZF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkXCIpO1xuZXhwb3J0cy5BdXRob3JpemF0aW9uRXJyb3JzID0gZ2VuZXJhdGVkXzEuQXV0aG9yaXphdGlvbkVycm9ycztcbmV4cG9ydHMuQ2xpZW50RXJyb3JzID0gZ2VuZXJhdGVkXzEuQ2xpZW50RXJyb3JzO1xuZXhwb3J0cy5HZW5lcmFsRXJyb3JzID0gZ2VuZXJhdGVkXzEuR2VuZXJhbEVycm9ycztcbmV4cG9ydHMuTWVkaWFFcnJvcnMgPSBnZW5lcmF0ZWRfMS5NZWRpYUVycm9ycztcbmV4cG9ydHMuU2lnbmFsaW5nRXJyb3JzID0gZ2VuZXJhdGVkXzEuU2lnbmFsaW5nRXJyb3JzO1xuLy8gQXBwbGljYXRpb24gZXJyb3JzIHRoYXQgY2FuIGJlIGF2b2lkZWQgYnkgZ29vZCBhcHAgbG9naWNcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW52YWxpZEFyZ3VtZW50RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW52YWxpZEFyZ3VtZW50RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZEFyZ3VtZW50RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkludmFsaWRBcmd1bWVudEVycm9yID0gSW52YWxpZEFyZ3VtZW50RXJyb3I7XG52YXIgSW52YWxpZFN0YXRlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEludmFsaWRTdGF0ZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEludmFsaWRTdGF0ZUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdJbnZhbGlkU3RhdGVFcnJvcic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEludmFsaWRTdGF0ZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IEludmFsaWRTdGF0ZUVycm9yO1xudmFyIE5vdFN1cHBvcnRlZEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb3RTdXBwb3J0ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOb3RTdXBwb3J0ZWRFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnTm90U3VwcG9ydGVkRXJyb3InO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOb3RTdXBwb3J0ZWRFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuTm90U3VwcG9ydGVkRXJyb3IgPSBOb3RTdXBwb3J0ZWRFcnJvcjtcbi8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBsb29rIHVwIGVycm9yIGNvZGVzIHJldHVybmVkIGJ5IGEgc2VydmVyXG4vLyB1c2luZyB0aGUgc2FtZSByZXBvIG9mIGVycm9yIGNvZGVzLlxuZnVuY3Rpb24gZ2V0RXJyb3JCeUNvZGUoY29kZSkge1xuICAgIHZhciBlcnJvciA9IGdlbmVyYXRlZF8xLmVycm9yc0J5Q29kZS5nZXQoY29kZSk7XG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJFcnJvciBjb2RlIFwiICsgY29kZSArIFwiIG5vdCBmb3VuZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5nZXRFcnJvckJ5Q29kZSA9IGdldEVycm9yQnlDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/errors/index.js\n')},"./node_modules/twilio-client/es5/twilio/eventpublisher.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar request = __webpack_require__(/*! ./request */ \"./node_modules/twilio-client/es5/twilio/request.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n/**\n * Builds Endpoint Analytics (EA) event payloads and sends them to\n *   the EA server.\n * @constructor\n * @param {String} productName - Name of the product publishing events.\n * @param {String} token - The JWT token to use to authenticate with\n *   the EA server.\n * @param {EventPublisher.Options} options\n * @property {Boolean} isEnabled - Whether or not this publisher is publishing\n *   to the server. Currently ignores the request altogether, in the future this\n *   may store them in case publishing is re-enabled later. Defaults to true.\n */ /**\n    * @typedef {Object} EventPublisher.Options\n    * @property {Object} [metadata=undefined] - A publisher_metadata object to send\n    *   with each payload.\n    * @property {String} [host='eventgw.twilio.com'] - The host address of the EA\n    *   server to publish to.\n    * @property {Object|Function} [defaultPayload] - A default payload to extend\n    *   when creating and sending event payloads. Also takes a function that\n    *   should return an object representing the default payload. This is\n    *   useful for fields that should always be present when they are\n    *   available, but are not always available.\n    */\nfunction EventPublisher(productName, token, options) {\n  if (!(this instanceof EventPublisher)) {\n    return new EventPublisher(productName, token, options);\n  }\n\n  // Apply default options\n  options = Object.assign({\n    defaultPayload: function defaultPayload() {\n      return {};\n    },\n\n    host: 'eventgw.twilio.com'\n  }, options);\n\n  var defaultPayload = options.defaultPayload;\n\n  if (typeof defaultPayload !== 'function') {\n    defaultPayload = function defaultPayload() {\n      return Object.assign({}, options.defaultPayload);\n    };\n  }\n\n  var isEnabled = true;\n  // eslint-disable-next-line camelcase,no-undefined\n  var metadata = Object.assign({ app_name: undefined, app_version: undefined }, options.metadata);\n\n  Object.defineProperties(this, {\n    _defaultPayload: { value: defaultPayload },\n    _isEnabled: {\n      get: function get() {\n        return isEnabled;\n      },\n      set: function set(_isEnabled) {\n        isEnabled = _isEnabled;\n      }\n    },\n    _host: { value: options.host },\n    _request: { value: options.request || request, writable: true },\n    _token: { value: token, writable: true },\n    isEnabled: {\n      enumerable: true,\n      get: function get() {\n        return isEnabled;\n      }\n    },\n    metadata: {\n      enumerable: true,\n      get: function get() {\n        return metadata;\n      }\n    },\n    productName: { enumerable: true, value: productName },\n    token: {\n      enumerable: true,\n      get: function get() {\n        return this._token;\n      }\n    }\n  });\n}\n\nutil.inherits(EventPublisher, EventEmitter);\n\n/**\n * Post to an EA server.\n * @private\n * @param {String} endpointName - Endpoint to post the event to\n * @param {String} level - ['debug', 'info', 'warning', 'error']\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @param {?Boolean} [force=false] - Whether or not to send this even if\n *    publishing is disabled.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype._post = function _post(endpointName, level, group, name, payload, connection, force) {\n  var _this = this;\n\n  if (!this.isEnabled && !force) {\n    return Promise.resolve();\n  }\n\n  if (!connection || (!connection.parameters || !connection.parameters.CallSid) && !connection.outboundConnectionId) {\n    return Promise.resolve();\n  }\n\n  var event = {\n    /* eslint-disable camelcase */\n    publisher: this.productName,\n    group: group,\n    name: name,\n    timestamp: new Date().toISOString(),\n    level: level.toUpperCase(),\n    payload_type: 'application/json',\n    private: false,\n    payload: payload && payload.forEach ? payload.slice(0) : Object.assign(this._defaultPayload(connection), payload)\n    /* eslint-enable camelcase */\n  };\n\n  if (this.metadata) {\n    // eslint-disable-next-line camelcase\n    event.publisher_metadata = this.metadata;\n  }\n\n  var requestParams = {\n    url: 'https://' + this._host + '/v4/' + endpointName,\n    body: event,\n    headers: {\n      'Content-Type': 'application/json',\n      'X-Twilio-Token': this.token\n    }\n  };\n\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    self._request.post(requestParams, function (err) {\n      if (err) {\n        _this.emit('error', err);\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n};\n\n/**\n * Post an event to the EA server. Use this method when the level\n *  is dynamic. Otherwise, it's better practice to use the sugar\n *  methods named for the specific level.\n * @param {String} level - ['debug', 'info', 'warning', 'error']\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.post = function post(level, group, name, payload, connection, force) {\n  return this._post('EndpointEvents', level, group, name, payload, connection, force);\n};\n\n/**\n * Post a debug-level event to the EA server.\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.debug = function debug(group, name, payload, connection) {\n  return this.post('debug', group, name, payload, connection);\n};\n\n/**\n * Post an info-level event to the EA server.\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.info = function info(group, name, payload, connection) {\n  return this.post('info', group, name, payload, connection);\n};\n\n/**\n * Post a warning-level event to the EA server.\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.warn = function warn(group, name, payload, connection) {\n  return this.post('warning', group, name, payload, connection);\n};\n\n/**\n * Post an error-level event to the EA server.\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {?Object} [payload=null] - The payload to pass. This will be extended\n *    onto the default payload object, if one exists.\n * @param {?Connection} [connection=null] - The {@link Connection} which is posting this payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.error = function error(group, name, payload, connection) {\n  return this.post('error', group, name, payload, connection);\n};\n\n/**\n * Post a metrics event to the EA server.\n * @param {String} group - The name of the group the event belongs to.\n * @param {String} name - The designated event name.\n * @param {Array<Object>} metrics - The metrics to post.\n * @param {?Object} [customFields] - Custom fields to append to each payload.\n * @returns {Promise} Fulfilled if the HTTP response is 20x.\n */\nEventPublisher.prototype.postMetrics = function postMetrics(group, name, metrics, customFields, connection) {\n  var _this2 = this;\n\n  return new Promise(function (resolve) {\n    var samples = metrics.map(formatMetric).map(function (sample) {\n      return Object.assign(sample, customFields);\n    });\n\n    resolve(_this2._post('EndpointMetrics', 'info', group, name, samples, connection));\n  });\n};\n\n/**\n * Update the token to use to authenticate requests.\n * @param {string} token\n * @returns {void}\n */\nEventPublisher.prototype.setToken = function setToken(token) {\n  this._token = token;\n};\n\n/**\n * Enable the publishing of events.\n */\nEventPublisher.prototype.enable = function enable() {\n  this._isEnabled = true;\n};\n\n/**\n * Disable the publishing of events.\n */\nEventPublisher.prototype.disable = function disable() {\n  this._isEnabled = false;\n};\n\nfunction formatMetric(sample) {\n  return {\n    /* eslint-disable camelcase */\n    timestamp: new Date(sample.timestamp).toISOString(),\n    total_packets_received: sample.totals.packetsReceived,\n    total_packets_lost: sample.totals.packetsLost,\n    total_packets_sent: sample.totals.packetsSent,\n    total_bytes_received: sample.totals.bytesReceived,\n    total_bytes_sent: sample.totals.bytesSent,\n    packets_received: sample.packetsReceived,\n    packets_lost: sample.packetsLost,\n    packets_lost_fraction: sample.packetsLostFraction && Math.round(sample.packetsLostFraction * 100) / 100,\n    bytes_received: sample.bytesReceived,\n    bytes_sent: sample.bytesSent,\n    audio_codec: sample.codecName,\n    audio_level_in: sample.audioInputLevel,\n    audio_level_out: sample.audioOutputLevel,\n    call_volume_input: sample.inputVolume,\n    call_volume_output: sample.outputVolume,\n    jitter: sample.jitter,\n    rtt: sample.rtt,\n    mos: sample.mos && Math.round(sample.mos * 100) / 100\n    /* eslint-enable camelcase */\n  };\n}\n\nmodule.exports = EventPublisher;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2V2ZW50cHVibGlzaGVyLmpzPzJjYzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsbUJBQW1CLGlGQUE4QjtBQUNqRCxjQUFjLG1CQUFPLENBQUMscUVBQVc7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHlDQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDOztBQUU5RTtBQUNBLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNCQUFzQjtBQUNsQyxlQUFlLG9EQUFvRDtBQUNuRSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsWUFBWSwwQkFBMEIsaUJBQWlCO0FBQ2xFLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFlBQVksMEJBQTBCLGlCQUFpQjtBQUNsRSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxZQUFZLDBCQUEwQixpQkFBaUI7QUFDbEUsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsWUFBWSwwQkFBMEIsaUJBQWlCO0FBQ2xFLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFlBQVksMEJBQTBCLGlCQUFpQjtBQUNsRSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxZQUFZLDBCQUEwQixpQkFBaUI7QUFDbEUsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2V2ZW50cHVibGlzaGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCcuL3JlcXVlc3QnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vKipcbiAqIEJ1aWxkcyBFbmRwb2ludCBBbmFseXRpY3MgKEVBKSBldmVudCBwYXlsb2FkcyBhbmQgc2VuZHMgdGhlbSB0b1xuICogICB0aGUgRUEgc2VydmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvZHVjdE5hbWUgLSBOYW1lIG9mIHRoZSBwcm9kdWN0IHB1Ymxpc2hpbmcgZXZlbnRzLlxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIC0gVGhlIEpXVCB0b2tlbiB0byB1c2UgdG8gYXV0aGVudGljYXRlIHdpdGhcbiAqICAgdGhlIEVBIHNlcnZlci5cbiAqIEBwYXJhbSB7RXZlbnRQdWJsaXNoZXIuT3B0aW9uc30gb3B0aW9uc1xuICogQHByb3BlcnR5IHtCb29sZWFufSBpc0VuYWJsZWQgLSBXaGV0aGVyIG9yIG5vdCB0aGlzIHB1Ymxpc2hlciBpcyBwdWJsaXNoaW5nXG4gKiAgIHRvIHRoZSBzZXJ2ZXIuIEN1cnJlbnRseSBpZ25vcmVzIHRoZSByZXF1ZXN0IGFsdG9nZXRoZXIsIGluIHRoZSBmdXR1cmUgdGhpc1xuICogICBtYXkgc3RvcmUgdGhlbSBpbiBjYXNlIHB1Ymxpc2hpbmcgaXMgcmUtZW5hYmxlZCBsYXRlci4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqLyAvKipcbiAgICAqIEB0eXBlZGVmIHtPYmplY3R9IEV2ZW50UHVibGlzaGVyLk9wdGlvbnNcbiAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YWRhdGE9dW5kZWZpbmVkXSAtIEEgcHVibGlzaGVyX21ldGFkYXRhIG9iamVjdCB0byBzZW5kXG4gICAgKiAgIHdpdGggZWFjaCBwYXlsb2FkLlxuICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtob3N0PSdldmVudGd3LnR3aWxpby5jb20nXSAtIFRoZSBob3N0IGFkZHJlc3Mgb2YgdGhlIEVBXG4gICAgKiAgIHNlcnZlciB0byBwdWJsaXNoIHRvLlxuICAgICogQHByb3BlcnR5IHtPYmplY3R8RnVuY3Rpb259IFtkZWZhdWx0UGF5bG9hZF0gLSBBIGRlZmF1bHQgcGF5bG9hZCB0byBleHRlbmRcbiAgICAqICAgd2hlbiBjcmVhdGluZyBhbmQgc2VuZGluZyBldmVudCBwYXlsb2Fkcy4gQWxzbyB0YWtlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAqICAgc2hvdWxkIHJldHVybiBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkZWZhdWx0IHBheWxvYWQuIFRoaXMgaXNcbiAgICAqICAgdXNlZnVsIGZvciBmaWVsZHMgdGhhdCBzaG91bGQgYWx3YXlzIGJlIHByZXNlbnQgd2hlbiB0aGV5IGFyZVxuICAgICogICBhdmFpbGFibGUsIGJ1dCBhcmUgbm90IGFsd2F5cyBhdmFpbGFibGUuXG4gICAgKi9cbmZ1bmN0aW9uIEV2ZW50UHVibGlzaGVyKHByb2R1Y3ROYW1lLCB0b2tlbiwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRXZlbnRQdWJsaXNoZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBFdmVudFB1Ymxpc2hlcihwcm9kdWN0TmFtZSwgdG9rZW4sIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gQXBwbHkgZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBkZWZhdWx0UGF5bG9hZDogZnVuY3Rpb24gZGVmYXVsdFBheWxvYWQoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfSxcblxuICAgIGhvc3Q6ICdldmVudGd3LnR3aWxpby5jb20nXG4gIH0sIG9wdGlvbnMpO1xuXG4gIHZhciBkZWZhdWx0UGF5bG9hZCA9IG9wdGlvbnMuZGVmYXVsdFBheWxvYWQ7XG5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UGF5bG9hZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlZmF1bHRQYXlsb2FkID0gZnVuY3Rpb24gZGVmYXVsdFBheWxvYWQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5kZWZhdWx0UGF5bG9hZCk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpc0VuYWJsZWQgPSB0cnVlO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlLG5vLXVuZGVmaW5lZFxuICB2YXIgbWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHsgYXBwX25hbWU6IHVuZGVmaW5lZCwgYXBwX3ZlcnNpb246IHVuZGVmaW5lZCB9LCBvcHRpb25zLm1ldGFkYXRhKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgX2RlZmF1bHRQYXlsb2FkOiB7IHZhbHVlOiBkZWZhdWx0UGF5bG9hZCB9LFxuICAgIF9pc0VuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gaXNFbmFibGVkO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KF9pc0VuYWJsZWQpIHtcbiAgICAgICAgaXNFbmFibGVkID0gX2lzRW5hYmxlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9ob3N0OiB7IHZhbHVlOiBvcHRpb25zLmhvc3QgfSxcbiAgICBfcmVxdWVzdDogeyB2YWx1ZTogb3B0aW9ucy5yZXF1ZXN0IHx8IHJlcXVlc3QsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX3Rva2VuOiB7IHZhbHVlOiB0b2tlbiwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBpc0VuYWJsZWQ6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGlzRW5hYmxlZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1ldGFkYXRhOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb2R1Y3ROYW1lOiB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBwcm9kdWN0TmFtZSB9LFxuICAgIHRva2VuOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKEV2ZW50UHVibGlzaGVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFBvc3QgdG8gYW4gRUEgc2VydmVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRwb2ludE5hbWUgLSBFbmRwb2ludCB0byBwb3N0IHRoZSBldmVudCB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGxldmVsIC0gWydkZWJ1ZycsICdpbmZvJywgJ3dhcm5pbmcnLCAnZXJyb3InXVxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgZGVzaWduYXRlZCBldmVudCBuYW1lLlxuICogQHBhcmFtIHs/T2JqZWN0fSBbcGF5bG9hZD1udWxsXSAtIFRoZSBwYXlsb2FkIHRvIHBhc3MuIFRoaXMgd2lsbCBiZSBleHRlbmRlZFxuICogICAgb250byB0aGUgZGVmYXVsdCBwYXlsb2FkIG9iamVjdCwgaWYgb25lIGV4aXN0cy5cbiAqIEBwYXJhbSB7P0Nvbm5lY3Rpb259IFtjb25uZWN0aW9uPW51bGxdIC0gVGhlIHtAbGluayBDb25uZWN0aW9ufSB3aGljaCBpcyBwb3N0aW5nIHRoaXMgcGF5bG9hZC5cbiAqIEBwYXJhbSB7P0Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBzZW5kIHRoaXMgZXZlbiBpZlxuICogICAgcHVibGlzaGluZyBpcyBkaXNhYmxlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBGdWxmaWxsZWQgaWYgdGhlIEhUVFAgcmVzcG9uc2UgaXMgMjB4LlxuICovXG5FdmVudFB1Ymxpc2hlci5wcm90b3R5cGUuX3Bvc3QgPSBmdW5jdGlvbiBfcG9zdChlbmRwb2ludE5hbWUsIGxldmVsLCBncm91cCwgbmFtZSwgcGF5bG9hZCwgY29ubmVjdGlvbiwgZm9yY2UpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBpZiAoIXRoaXMuaXNFbmFibGVkICYmICFmb3JjZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxuXG4gIGlmICghY29ubmVjdGlvbiB8fCAoIWNvbm5lY3Rpb24ucGFyYW1ldGVycyB8fCAhY29ubmVjdGlvbi5wYXJhbWV0ZXJzLkNhbGxTaWQpICYmICFjb25uZWN0aW9uLm91dGJvdW5kQ29ubmVjdGlvbklkKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICAgIHB1Ymxpc2hlcjogdGhpcy5wcm9kdWN0TmFtZSxcbiAgICBncm91cDogZ3JvdXAsXG4gICAgbmFtZTogbmFtZSxcbiAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBsZXZlbDogbGV2ZWwudG9VcHBlckNhc2UoKSxcbiAgICBwYXlsb2FkX3R5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICBwcml2YXRlOiBmYWxzZSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkICYmIHBheWxvYWQuZm9yRWFjaCA/IHBheWxvYWQuc2xpY2UoMCkgOiBPYmplY3QuYXNzaWduKHRoaXMuX2RlZmF1bHRQYXlsb2FkKGNvbm5lY3Rpb24pLCBwYXlsb2FkKVxuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gIH07XG5cbiAgaWYgKHRoaXMubWV0YWRhdGEpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG4gICAgZXZlbnQucHVibGlzaGVyX21ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgfVxuXG4gIHZhciByZXF1ZXN0UGFyYW1zID0ge1xuICAgIHVybDogJ2h0dHBzOi8vJyArIHRoaXMuX2hvc3QgKyAnL3Y0LycgKyBlbmRwb2ludE5hbWUsXG4gICAgYm9keTogZXZlbnQsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdYLVR3aWxpby1Ub2tlbic6IHRoaXMudG9rZW5cbiAgICB9XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHNlbGYuX3JlcXVlc3QucG9zdChyZXF1ZXN0UGFyYW1zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQb3N0IGFuIGV2ZW50IHRvIHRoZSBFQSBzZXJ2ZXIuIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHRoZSBsZXZlbFxuICogIGlzIGR5bmFtaWMuIE90aGVyd2lzZSwgaXQncyBiZXR0ZXIgcHJhY3RpY2UgdG8gdXNlIHRoZSBzdWdhclxuICogIG1ldGhvZHMgbmFtZWQgZm9yIHRoZSBzcGVjaWZpYyBsZXZlbC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbCAtIFsnZGVidWcnLCAnaW5mbycsICd3YXJuaW5nJywgJ2Vycm9yJ11cbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCAtIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGUgZXZlbnQgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGRlc2lnbmF0ZWQgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7P09iamVjdH0gW3BheWxvYWQ9bnVsbF0gLSBUaGUgcGF5bG9hZCB0byBwYXNzLiBUaGlzIHdpbGwgYmUgZXh0ZW5kZWRcbiAqICAgIG9udG8gdGhlIGRlZmF1bHQgcGF5bG9hZCBvYmplY3QsIGlmIG9uZSBleGlzdHMuXG4gKiBAcGFyYW0gez9Db25uZWN0aW9ufSBbY29ubmVjdGlvbj1udWxsXSAtIFRoZSB7QGxpbmsgQ29ubmVjdGlvbn0gd2hpY2ggaXMgcG9zdGluZyB0aGlzIHBheWxvYWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gRnVsZmlsbGVkIGlmIHRoZSBIVFRQIHJlc3BvbnNlIGlzIDIweC5cbiAqL1xuRXZlbnRQdWJsaXNoZXIucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiBwb3N0KGxldmVsLCBncm91cCwgbmFtZSwgcGF5bG9hZCwgY29ubmVjdGlvbiwgZm9yY2UpIHtcbiAgcmV0dXJuIHRoaXMuX3Bvc3QoJ0VuZHBvaW50RXZlbnRzJywgbGV2ZWwsIGdyb3VwLCBuYW1lLCBwYXlsb2FkLCBjb25uZWN0aW9uLCBmb3JjZSk7XG59O1xuXG4vKipcbiAqIFBvc3QgYSBkZWJ1Zy1sZXZlbCBldmVudCB0byB0aGUgRUEgc2VydmVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgZGVzaWduYXRlZCBldmVudCBuYW1lLlxuICogQHBhcmFtIHs/T2JqZWN0fSBbcGF5bG9hZD1udWxsXSAtIFRoZSBwYXlsb2FkIHRvIHBhc3MuIFRoaXMgd2lsbCBiZSBleHRlbmRlZFxuICogICAgb250byB0aGUgZGVmYXVsdCBwYXlsb2FkIG9iamVjdCwgaWYgb25lIGV4aXN0cy5cbiAqIEBwYXJhbSB7P0Nvbm5lY3Rpb259IFtjb25uZWN0aW9uPW51bGxdIC0gVGhlIHtAbGluayBDb25uZWN0aW9ufSB3aGljaCBpcyBwb3N0aW5nIHRoaXMgcGF5bG9hZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBGdWxmaWxsZWQgaWYgdGhlIEhUVFAgcmVzcG9uc2UgaXMgMjB4LlxuICovXG5FdmVudFB1Ymxpc2hlci5wcm90b3R5cGUuZGVidWcgPSBmdW5jdGlvbiBkZWJ1Zyhncm91cCwgbmFtZSwgcGF5bG9hZCwgY29ubmVjdGlvbikge1xuICByZXR1cm4gdGhpcy5wb3N0KCdkZWJ1ZycsIGdyb3VwLCBuYW1lLCBwYXlsb2FkLCBjb25uZWN0aW9uKTtcbn07XG5cbi8qKlxuICogUG9zdCBhbiBpbmZvLWxldmVsIGV2ZW50IHRvIHRoZSBFQSBzZXJ2ZXIuXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXAgLSBUaGUgbmFtZSBvZiB0aGUgZ3JvdXAgdGhlIGV2ZW50IGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBkZXNpZ25hdGVkIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0gez9PYmplY3R9IFtwYXlsb2FkPW51bGxdIC0gVGhlIHBheWxvYWQgdG8gcGFzcy4gVGhpcyB3aWxsIGJlIGV4dGVuZGVkXG4gKiAgICBvbnRvIHRoZSBkZWZhdWx0IHBheWxvYWQgb2JqZWN0LCBpZiBvbmUgZXhpc3RzLlxuICogQHBhcmFtIHs/Q29ubmVjdGlvbn0gW2Nvbm5lY3Rpb249bnVsbF0gLSBUaGUge0BsaW5rIENvbm5lY3Rpb259IHdoaWNoIGlzIHBvc3RpbmcgdGhpcyBwYXlsb2FkLlxuICogQHJldHVybnMge1Byb21pc2V9IEZ1bGZpbGxlZCBpZiB0aGUgSFRUUCByZXNwb25zZSBpcyAyMHguXG4gKi9cbkV2ZW50UHVibGlzaGVyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gaW5mbyhncm91cCwgbmFtZSwgcGF5bG9hZCwgY29ubmVjdGlvbikge1xuICByZXR1cm4gdGhpcy5wb3N0KCdpbmZvJywgZ3JvdXAsIG5hbWUsIHBheWxvYWQsIGNvbm5lY3Rpb24pO1xufTtcblxuLyoqXG4gKiBQb3N0IGEgd2FybmluZy1sZXZlbCBldmVudCB0byB0aGUgRUEgc2VydmVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgZGVzaWduYXRlZCBldmVudCBuYW1lLlxuICogQHBhcmFtIHs/T2JqZWN0fSBbcGF5bG9hZD1udWxsXSAtIFRoZSBwYXlsb2FkIHRvIHBhc3MuIFRoaXMgd2lsbCBiZSBleHRlbmRlZFxuICogICAgb250byB0aGUgZGVmYXVsdCBwYXlsb2FkIG9iamVjdCwgaWYgb25lIGV4aXN0cy5cbiAqIEBwYXJhbSB7P0Nvbm5lY3Rpb259IFtjb25uZWN0aW9uPW51bGxdIC0gVGhlIHtAbGluayBDb25uZWN0aW9ufSB3aGljaCBpcyBwb3N0aW5nIHRoaXMgcGF5bG9hZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBGdWxmaWxsZWQgaWYgdGhlIEhUVFAgcmVzcG9uc2UgaXMgMjB4LlxuICovXG5FdmVudFB1Ymxpc2hlci5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIHdhcm4oZ3JvdXAsIG5hbWUsIHBheWxvYWQsIGNvbm5lY3Rpb24pIHtcbiAgcmV0dXJuIHRoaXMucG9zdCgnd2FybmluZycsIGdyb3VwLCBuYW1lLCBwYXlsb2FkLCBjb25uZWN0aW9uKTtcbn07XG5cbi8qKlxuICogUG9zdCBhbiBlcnJvci1sZXZlbCBldmVudCB0byB0aGUgRUEgc2VydmVyLlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwIHRoZSBldmVudCBiZWxvbmdzIHRvLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgZGVzaWduYXRlZCBldmVudCBuYW1lLlxuICogQHBhcmFtIHs/T2JqZWN0fSBbcGF5bG9hZD1udWxsXSAtIFRoZSBwYXlsb2FkIHRvIHBhc3MuIFRoaXMgd2lsbCBiZSBleHRlbmRlZFxuICogICAgb250byB0aGUgZGVmYXVsdCBwYXlsb2FkIG9iamVjdCwgaWYgb25lIGV4aXN0cy5cbiAqIEBwYXJhbSB7P0Nvbm5lY3Rpb259IFtjb25uZWN0aW9uPW51bGxdIC0gVGhlIHtAbGluayBDb25uZWN0aW9ufSB3aGljaCBpcyBwb3N0aW5nIHRoaXMgcGF5bG9hZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBGdWxmaWxsZWQgaWYgdGhlIEhUVFAgcmVzcG9uc2UgaXMgMjB4LlxuICovXG5FdmVudFB1Ymxpc2hlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihncm91cCwgbmFtZSwgcGF5bG9hZCwgY29ubmVjdGlvbikge1xuICByZXR1cm4gdGhpcy5wb3N0KCdlcnJvcicsIGdyb3VwLCBuYW1lLCBwYXlsb2FkLCBjb25uZWN0aW9uKTtcbn07XG5cbi8qKlxuICogUG9zdCBhIG1ldHJpY3MgZXZlbnQgdG8gdGhlIEVBIHNlcnZlci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCAtIFRoZSBuYW1lIG9mIHRoZSBncm91cCB0aGUgZXZlbnQgYmVsb25ncyB0by5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGRlc2lnbmF0ZWQgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gbWV0cmljcyAtIFRoZSBtZXRyaWNzIHRvIHBvc3QuXG4gKiBAcGFyYW0gez9PYmplY3R9IFtjdXN0b21GaWVsZHNdIC0gQ3VzdG9tIGZpZWxkcyB0byBhcHBlbmQgdG8gZWFjaCBwYXlsb2FkLlxuICogQHJldHVybnMge1Byb21pc2V9IEZ1bGZpbGxlZCBpZiB0aGUgSFRUUCByZXNwb25zZSBpcyAyMHguXG4gKi9cbkV2ZW50UHVibGlzaGVyLnByb3RvdHlwZS5wb3N0TWV0cmljcyA9IGZ1bmN0aW9uIHBvc3RNZXRyaWNzKGdyb3VwLCBuYW1lLCBtZXRyaWNzLCBjdXN0b21GaWVsZHMsIGNvbm5lY3Rpb24pIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgdmFyIHNhbXBsZXMgPSBtZXRyaWNzLm1hcChmb3JtYXRNZXRyaWMpLm1hcChmdW5jdGlvbiAoc2FtcGxlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzYW1wbGUsIGN1c3RvbUZpZWxkcyk7XG4gICAgfSk7XG5cbiAgICByZXNvbHZlKF90aGlzMi5fcG9zdCgnRW5kcG9pbnRNZXRyaWNzJywgJ2luZm8nLCBncm91cCwgbmFtZSwgc2FtcGxlcywgY29ubmVjdGlvbikpO1xuICB9KTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSB0b2tlbiB0byB1c2UgdG8gYXV0aGVudGljYXRlIHJlcXVlc3RzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqL1xuRXZlbnRQdWJsaXNoZXIucHJvdG90eXBlLnNldFRva2VuID0gZnVuY3Rpb24gc2V0VG9rZW4odG9rZW4pIHtcbiAgdGhpcy5fdG9rZW4gPSB0b2tlbjtcbn07XG5cbi8qKlxuICogRW5hYmxlIHRoZSBwdWJsaXNoaW5nIG9mIGV2ZW50cy5cbiAqL1xuRXZlbnRQdWJsaXNoZXIucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogRGlzYWJsZSB0aGUgcHVibGlzaGluZyBvZiBldmVudHMuXG4gKi9cbkV2ZW50UHVibGlzaGVyLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBmb3JtYXRNZXRyaWMoc2FtcGxlKSB7XG4gIHJldHVybiB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gICAgdGltZXN0YW1wOiBuZXcgRGF0ZShzYW1wbGUudGltZXN0YW1wKS50b0lTT1N0cmluZygpLFxuICAgIHRvdGFsX3BhY2tldHNfcmVjZWl2ZWQ6IHNhbXBsZS50b3RhbHMucGFja2V0c1JlY2VpdmVkLFxuICAgIHRvdGFsX3BhY2tldHNfbG9zdDogc2FtcGxlLnRvdGFscy5wYWNrZXRzTG9zdCxcbiAgICB0b3RhbF9wYWNrZXRzX3NlbnQ6IHNhbXBsZS50b3RhbHMucGFja2V0c1NlbnQsXG4gICAgdG90YWxfYnl0ZXNfcmVjZWl2ZWQ6IHNhbXBsZS50b3RhbHMuYnl0ZXNSZWNlaXZlZCxcbiAgICB0b3RhbF9ieXRlc19zZW50OiBzYW1wbGUudG90YWxzLmJ5dGVzU2VudCxcbiAgICBwYWNrZXRzX3JlY2VpdmVkOiBzYW1wbGUucGFja2V0c1JlY2VpdmVkLFxuICAgIHBhY2tldHNfbG9zdDogc2FtcGxlLnBhY2tldHNMb3N0LFxuICAgIHBhY2tldHNfbG9zdF9mcmFjdGlvbjogc2FtcGxlLnBhY2tldHNMb3N0RnJhY3Rpb24gJiYgTWF0aC5yb3VuZChzYW1wbGUucGFja2V0c0xvc3RGcmFjdGlvbiAqIDEwMCkgLyAxMDAsXG4gICAgYnl0ZXNfcmVjZWl2ZWQ6IHNhbXBsZS5ieXRlc1JlY2VpdmVkLFxuICAgIGJ5dGVzX3NlbnQ6IHNhbXBsZS5ieXRlc1NlbnQsXG4gICAgYXVkaW9fY29kZWM6IHNhbXBsZS5jb2RlY05hbWUsXG4gICAgYXVkaW9fbGV2ZWxfaW46IHNhbXBsZS5hdWRpb0lucHV0TGV2ZWwsXG4gICAgYXVkaW9fbGV2ZWxfb3V0OiBzYW1wbGUuYXVkaW9PdXRwdXRMZXZlbCxcbiAgICBjYWxsX3ZvbHVtZV9pbnB1dDogc2FtcGxlLmlucHV0Vm9sdW1lLFxuICAgIGNhbGxfdm9sdW1lX291dHB1dDogc2FtcGxlLm91dHB1dFZvbHVtZSxcbiAgICBqaXR0ZXI6IHNhbXBsZS5qaXR0ZXIsXG4gICAgcnR0OiBzYW1wbGUucnR0LFxuICAgIG1vczogc2FtcGxlLm1vcyAmJiBNYXRoLnJvdW5kKHNhbXBsZS5tb3MgKiAxMDApIC8gMTAwXG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFB1Ymxpc2hlcjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/eventpublisher.js\n")},"./node_modules/twilio-client/es5/twilio/log.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nvar LogLevelModule = __webpack_require__(/*! loglevel */ "./node_modules/loglevel/lib/loglevel.js");\nvar constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/twilio-client/es5/twilio/constants.js");\n/**\n * {@link Log} provides logging features throught the sdk using loglevel module\n * See https://github.com/pimterry/loglevel for documentation\n */\nvar Log = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param [options] - Optional settings\n     */\n    function Log(options) {\n        this._log = (options && options.LogLevelModule ? options.LogLevelModule : LogLevelModule).getLogger(constants_1.PACKAGE_NAME);\n    }\n    /**\n     * Create the logger singleton instance if it doesn\'t exists\n     * @returns The singleton {@link Log} instance\n     */\n    Log.getInstance = function () {\n        if (!Log.instance) {\n            Log.instance = new Log();\n        }\n        return Log.instance;\n    };\n    /**\n     * Log a debug message\n     * @param args - Any number of arguments to be passed to loglevel.debug\n     */\n    Log.prototype.debug = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this._log).debug.apply(_a, args);\n    };\n    /**\n     * Log an error message\n     * @param args - Any number of arguments to be passed to loglevel.error\n     */\n    Log.prototype.error = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this._log).error.apply(_a, args);\n    };\n    /**\n     * Log an info message\n     * @param args - Any number of arguments to be passed to loglevel.info\n     */\n    Log.prototype.info = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this._log).info.apply(_a, args);\n    };\n    /**\n     * Set a default log level to disable all logging below the given level\n     */\n    Log.prototype.setDefaultLevel = function (level) {\n        this._log.setDefaultLevel(level);\n    };\n    /**\n     * Log a warning message\n     * @param args - Any number of arguments to be passed to loglevel.warn\n     */\n    Log.prototype.warn = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this._log).warn.apply(_a, args);\n    };\n    /**\n     * Log levels\n     */\n    Log.levels = LogLevelModule.levels;\n    return Log;\n}());\nexports.default = Log;\n//# sourceMappingURL=log.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2xvZy5qcz84MDIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxDQUFDLGNBQWMsRUFBQztBQUM3RCxxQkFBcUIsbUJBQU8sQ0FBQyx5REFBVTtBQUN2QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RUFBYTtBQUN2QztBQUNBLElBQUksVUFBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2YiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL2xvZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgVm9pY2VcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTG9nTGV2ZWxNb2R1bGUgPSByZXF1aXJlKFwibG9nbGV2ZWxcIik7XG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIHtAbGluayBMb2d9IHByb3ZpZGVzIGxvZ2dpbmcgZmVhdHVyZXMgdGhyb3VnaHQgdGhlIHNkayB1c2luZyBsb2dsZXZlbCBtb2R1bGVcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRvY3VtZW50YXRpb25cbiAqL1xudmFyIExvZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gT3B0aW9uYWwgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2cob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9sb2cgPSAob3B0aW9ucyAmJiBvcHRpb25zLkxvZ0xldmVsTW9kdWxlID8gb3B0aW9ucy5Mb2dMZXZlbE1vZHVsZSA6IExvZ0xldmVsTW9kdWxlKS5nZXRMb2dnZXIoY29uc3RhbnRzXzEuUEFDS0FHRV9OQU1FKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBsb2dnZXIgc2luZ2xldG9uIGluc3RhbmNlIGlmIGl0IGRvZXNuJ3QgZXhpc3RzXG4gICAgICogQHJldHVybnMgVGhlIHNpbmdsZXRvbiB7QGxpbmsgTG9nfSBpbnN0YW5jZVxuICAgICAqL1xuICAgIExvZy5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFMb2cuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIExvZy5pbnN0YW5jZSA9IG5ldyBMb2coKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTG9nLmluc3RhbmNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGEgZGVidWcgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGxvZ2xldmVsLmRlYnVnXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5kZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX2xvZykuZGVidWcuYXBwbHkoX2EsIGFyZ3MpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9nIGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gYXJncyAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBsb2dsZXZlbC5lcnJvclxuICAgICAqL1xuICAgIExvZy5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLl9sb2cpLmVycm9yLmFwcGx5KF9hLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBhbiBpbmZvIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gYXJncyAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBsb2dsZXZlbC5pbmZvXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fbG9nKS5pbmZvLmFwcGx5KF9hLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGRlZmF1bHQgbG9nIGxldmVsIHRvIGRpc2FibGUgYWxsIGxvZ2dpbmcgYmVsb3cgdGhlIGdpdmVuIGxldmVsXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbG9nLnNldERlZmF1bHRMZXZlbChsZXZlbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb2cgYSB3YXJuaW5nIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gYXJncyAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byBsb2dsZXZlbC53YXJuXG4gICAgICovXG4gICAgTG9nLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fbG9nKS53YXJuLmFwcGx5KF9hLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIExvZyBsZXZlbHNcbiAgICAgKi9cbiAgICBMb2cubGV2ZWxzID0gTG9nTGV2ZWxNb2R1bGUubGV2ZWxzO1xuICAgIHJldHVybiBMb2c7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/log.js\n')},"./node_modules/twilio-client/es5/twilio/outputdevicecollection.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n */\nvar constants_1 = __webpack_require__(/*! ./constants */ \"./node_modules/twilio-client/es5/twilio/constants.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar DEFAULT_TEST_SOUND_URL = constants_1.SOUNDS_BASE_URL + \"/outgoing.mp3\";\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\nvar OutputDeviceCollection = /** @class */ (function () {\n    /**\n     * @private\n     */\n    function OutputDeviceCollection(_name, _availableDevices, _beforeChange, _isSupported) {\n        this._name = _name;\n        this._availableDevices = _availableDevices;\n        this._beforeChange = _beforeChange;\n        this._isSupported = _isSupported;\n        /**\n         * The currently active output devices.\n         */\n        this._activeDevices = new Set();\n    }\n    /**\n     * Delete a device from the collection. If no devices remain, the 'default'\n     * device will be added as the sole device. If no `default` device exists,\n     * the first available device will be used.\n     * @param device - The device to delete from the collection\n     * @returns whether the device was present before it was deleted\n     */\n    OutputDeviceCollection.prototype.delete = function (device) {\n        var wasDeleted = !!(this._activeDevices.delete(device));\n        var defaultDevice = this._availableDevices.get('default')\n            || Array.from(this._availableDevices.values())[0];\n        if (!this._activeDevices.size && defaultDevice) {\n            this._activeDevices.add(defaultDevice);\n        }\n        // Call _beforeChange so that the implementation can react when a device is\n        // removed or lost.\n        var deviceIds = Array.from(this._activeDevices.values()).map(function (deviceInfo) { return deviceInfo.deviceId; });\n        this._beforeChange(this._name, deviceIds);\n        return !!wasDeleted;\n    };\n    /**\n     * Get the current set of devices.\n     */\n    OutputDeviceCollection.prototype.get = function () {\n        return this._activeDevices;\n    };\n    /**\n     * Replace the current set of devices with a new set of devices.\n     * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n     * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n     * or no IDs are passed.\n     */\n    OutputDeviceCollection.prototype.set = function (deviceIdOrIds) {\n        var _this = this;\n        if (!this._isSupported) {\n            return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n        }\n        var deviceIds = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n        if (!deviceIds.length) {\n            return Promise.reject(new errors_1.InvalidArgumentError('Must specify at least one device to set'));\n        }\n        var missingIds = [];\n        var devices = deviceIds.map(function (id) {\n            var device = _this._availableDevices.get(id);\n            if (!device) {\n                missingIds.push(id);\n            }\n            return device;\n        });\n        if (missingIds.length) {\n            return Promise.reject(new errors_1.InvalidArgumentError(\"Devices not found: \" + missingIds.join(', ')));\n        }\n        return new Promise(function (resolve) {\n            resolve(_this._beforeChange(_this._name, deviceIds));\n        }).then(function () {\n            _this._activeDevices.clear();\n            devices.forEach(_this._activeDevices.add, _this._activeDevices);\n        });\n    };\n    /**\n     * Test the devices by playing audio through them.\n     * @param [soundUrl] - An optional URL. If none is specified, we will\n     *   play a default test tone.\n     * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n     */\n    OutputDeviceCollection.prototype.test = function (soundUrl) {\n        if (soundUrl === void 0) { soundUrl = DEFAULT_TEST_SOUND_URL; }\n        if (!this._isSupported) {\n            return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n        }\n        if (!this._activeDevices.size) {\n            return Promise.reject(new errors_1.InvalidStateError('No active output devices to test'));\n        }\n        return Promise.all(Array.from(this._activeDevices).map(function (device) {\n            var el;\n            // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n            // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n            return new Promise(function (resolve) {\n                el = new Audio(soundUrl);\n                el.oncanplay = resolve;\n            }).then(function () { return el.setSinkId(device.deviceId).then(function () { return el.play(); }); });\n        }));\n    };\n    return OutputDeviceCollection;\n}());\nexports.default = OutputDeviceCollection;\n//# sourceMappingURL=outputdevicecollection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL291dHB1dGRldmljZWNvbGxlY3Rpb24uanM/YmE0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxDQUFDLGNBQWMsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyx5RUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDRCQUE0QixFQUFFO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1DQUFtQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLHdEQUF3RCxrQkFBa0IsRUFBRSxFQUFFLEVBQUU7QUFDakgsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9vdXRwdXRkZXZpY2Vjb2xsZWN0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBWb2ljZVxuICovXG52YXIgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG52YXIgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG52YXIgREVGQVVMVF9URVNUX1NPVU5EX1VSTCA9IGNvbnN0YW50c18xLlNPVU5EU19CQVNFX1VSTCArIFwiL291dGdvaW5nLm1wM1wiO1xuLyoqXG4gKiBBIHNtYXJ0IGNvbGxlY3Rpb24gY29udGFpbmluZyBhIFNldCBvZiBhY3RpdmUgb3V0cHV0IGRldmljZXMuXG4gKiBAcHVibGljYXBpXG4gKi9cbnZhciBPdXRwdXREZXZpY2VDb2xsZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gT3V0cHV0RGV2aWNlQ29sbGVjdGlvbihfbmFtZSwgX2F2YWlsYWJsZURldmljZXMsIF9iZWZvcmVDaGFuZ2UsIF9pc1N1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgICAgIHRoaXMuX2F2YWlsYWJsZURldmljZXMgPSBfYXZhaWxhYmxlRGV2aWNlcztcbiAgICAgICAgdGhpcy5fYmVmb3JlQ2hhbmdlID0gX2JlZm9yZUNoYW5nZTtcbiAgICAgICAgdGhpcy5faXNTdXBwb3J0ZWQgPSBfaXNTdXBwb3J0ZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBvdXRwdXQgZGV2aWNlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjdGl2ZURldmljZXMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGRldmljZSBmcm9tIHRoZSBjb2xsZWN0aW9uLiBJZiBubyBkZXZpY2VzIHJlbWFpbiwgdGhlICdkZWZhdWx0J1xuICAgICAqIGRldmljZSB3aWxsIGJlIGFkZGVkIGFzIHRoZSBzb2xlIGRldmljZS4gSWYgbm8gYGRlZmF1bHRgIGRldmljZSBleGlzdHMsXG4gICAgICogdGhlIGZpcnN0IGF2YWlsYWJsZSBkZXZpY2Ugd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwYXJhbSBkZXZpY2UgLSBUaGUgZGV2aWNlIHRvIGRlbGV0ZSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHJldHVybnMgd2hldGhlciB0aGUgZGV2aWNlIHdhcyBwcmVzZW50IGJlZm9yZSBpdCB3YXMgZGVsZXRlZFxuICAgICAqL1xuICAgIE91dHB1dERldmljZUNvbGxlY3Rpb24ucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgdmFyIHdhc0RlbGV0ZWQgPSAhISh0aGlzLl9hY3RpdmVEZXZpY2VzLmRlbGV0ZShkZXZpY2UpKTtcbiAgICAgICAgdmFyIGRlZmF1bHREZXZpY2UgPSB0aGlzLl9hdmFpbGFibGVEZXZpY2VzLmdldCgnZGVmYXVsdCcpXG4gICAgICAgICAgICB8fCBBcnJheS5mcm9tKHRoaXMuX2F2YWlsYWJsZURldmljZXMudmFsdWVzKCkpWzBdO1xuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZURldmljZXMuc2l6ZSAmJiBkZWZhdWx0RGV2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVEZXZpY2VzLmFkZChkZWZhdWx0RGV2aWNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYWxsIF9iZWZvcmVDaGFuZ2Ugc28gdGhhdCB0aGUgaW1wbGVtZW50YXRpb24gY2FuIHJlYWN0IHdoZW4gYSBkZXZpY2UgaXNcbiAgICAgICAgLy8gcmVtb3ZlZCBvciBsb3N0LlxuICAgICAgICB2YXIgZGV2aWNlSWRzID0gQXJyYXkuZnJvbSh0aGlzLl9hY3RpdmVEZXZpY2VzLnZhbHVlcygpKS5tYXAoZnVuY3Rpb24gKGRldmljZUluZm8pIHsgcmV0dXJuIGRldmljZUluZm8uZGV2aWNlSWQ7IH0pO1xuICAgICAgICB0aGlzLl9iZWZvcmVDaGFuZ2UodGhpcy5fbmFtZSwgZGV2aWNlSWRzKTtcbiAgICAgICAgcmV0dXJuICEhd2FzRGVsZXRlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzZXQgb2YgZGV2aWNlcy5cbiAgICAgKi9cbiAgICBPdXRwdXREZXZpY2VDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmVEZXZpY2VzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgY3VycmVudCBzZXQgb2YgZGV2aWNlcyB3aXRoIGEgbmV3IHNldCBvZiBkZXZpY2VzLlxuICAgICAqIEBwYXJhbSBkZXZpY2VJZE9ySWRzIC0gQW4gSUQgb3IgYXJyYXkgb2YgSURzIG9mIGRldmljZXMgdG8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgZGV2aWNlcyB3aXRoLlxuICAgICAqIEByZXR1cm5zIFJlamVjdHMgaWYgdGhpcyBmZWF0dXJlIGlzIG5vdCBzdXBwb3J0ZWQsIGFueSBvZiB0aGUgc3VwcGxpZWQgSURzIGFyZSBub3QgZm91bmQsXG4gICAgICogb3Igbm8gSURzIGFyZSBwYXNzZWQuXG4gICAgICovXG4gICAgT3V0cHV0RGV2aWNlQ29sbGVjdGlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGRldmljZUlkT3JJZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5Ob3RTdXBwb3J0ZWRFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYXVkaW8gb3V0cHV0IHNlbGVjdGlvbicpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV2aWNlSWRzID0gQXJyYXkuaXNBcnJheShkZXZpY2VJZE9ySWRzKSA/IGRldmljZUlkT3JJZHMgOiBbZGV2aWNlSWRPcklkc107XG4gICAgICAgIGlmICghZGV2aWNlSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5JbnZhbGlkQXJndW1lbnRFcnJvcignTXVzdCBzcGVjaWZ5IGF0IGxlYXN0IG9uZSBkZXZpY2UgdG8gc2V0JykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtaXNzaW5nSWRzID0gW107XG4gICAgICAgIHZhciBkZXZpY2VzID0gZGV2aWNlSWRzLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2UgPSBfdGhpcy5fYXZhaWxhYmxlRGV2aWNlcy5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFkZXZpY2UpIHtcbiAgICAgICAgICAgICAgICBtaXNzaW5nSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRldmljZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nSWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5JbnZhbGlkQXJndW1lbnRFcnJvcihcIkRldmljZXMgbm90IGZvdW5kOiBcIiArIG1pc3NpbmdJZHMuam9pbignLCAnKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5fYmVmb3JlQ2hhbmdlKF90aGlzLl9uYW1lLCBkZXZpY2VJZHMpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fYWN0aXZlRGV2aWNlcy5jbGVhcigpO1xuICAgICAgICAgICAgZGV2aWNlcy5mb3JFYWNoKF90aGlzLl9hY3RpdmVEZXZpY2VzLmFkZCwgX3RoaXMuX2FjdGl2ZURldmljZXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3QgdGhlIGRldmljZXMgYnkgcGxheWluZyBhdWRpbyB0aHJvdWdoIHRoZW0uXG4gICAgICogQHBhcmFtIFtzb3VuZFVybF0gLSBBbiBvcHRpb25hbCBVUkwuIElmIG5vbmUgaXMgc3BlY2lmaWVkLCB3ZSB3aWxsXG4gICAgICogICBwbGF5IGEgZGVmYXVsdCB0ZXN0IHRvbmUuXG4gICAgICogQHJldHVybnMgUmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSB1bmRlcmx5aW5nIEhUTUxBdWRpb0VsZW1lbnRzJyBwbGF5KCkgY2FsbHMuXG4gICAgICovXG4gICAgT3V0cHV0RGV2aWNlQ29sbGVjdGlvbi5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uIChzb3VuZFVybCkge1xuICAgICAgICBpZiAoc291bmRVcmwgPT09IHZvaWQgMCkgeyBzb3VuZFVybCA9IERFRkFVTFRfVEVTVF9TT1VORF9VUkw7IH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5Ob3RTdXBwb3J0ZWRFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYXVkaW8gb3V0cHV0IHNlbGVjdGlvbicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2FjdGl2ZURldmljZXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignTm8gYWN0aXZlIG91dHB1dCBkZXZpY2VzIHRvIHRlc3QnKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKEFycmF5LmZyb20odGhpcy5fYWN0aXZlRGV2aWNlcykubWFwKGZ1bmN0aW9uIChkZXZpY2UpIHtcbiAgICAgICAgICAgIHZhciBlbDtcbiAgICAgICAgICAgIC8vIChycm93bGFuZCkgV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgb25jYW5wbGF5IGV2ZW50IGJlY2F1c2Ugb2YgYSByZWdyZXNzaW9uIGludHJvZHVjZWRcbiAgICAgICAgICAgIC8vIGluIENocm9tZSBNNzI6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzMDg3NlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgZWwgPSBuZXcgQXVkaW8oc291bmRVcmwpO1xuICAgICAgICAgICAgICAgIGVsLm9uY2FucGxheSA9IHJlc29sdmU7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVsLnNldFNpbmtJZChkZXZpY2UuZGV2aWNlSWQpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gZWwucGxheSgpOyB9KTsgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRwdXREZXZpY2VDb2xsZWN0aW9uO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE91dHB1dERldmljZUNvbGxlY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdXRwdXRkZXZpY2Vjb2xsZWN0aW9uLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/outputdevicecollection.js\n")},"./node_modules/twilio-client/es5/twilio/preflight/preflight.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nvar events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");\nvar connection_1 = __webpack_require__(/*! ../connection */ "./node_modules/twilio-client/es5/twilio/connection.js");\nvar device_1 = __webpack_require__(/*! ../device */ "./node_modules/twilio-client/es5/twilio/device.js");\nvar errors_1 = __webpack_require__(/*! ../errors */ "./node_modules/twilio-client/es5/twilio/errors/index.js");\nvar stats_1 = __webpack_require__(/*! ../rtc/stats */ "./node_modules/twilio-client/es5/twilio/rtc/stats.js");\nvar _a = __webpack_require__(/*! ../constants */ "./node_modules/twilio-client/es5/twilio/constants.js"), COWBELL_AUDIO_URL = _a.COWBELL_AUDIO_URL, ECHO_TEST_DURATION = _a.ECHO_TEST_DURATION;\n/**\n * Runs some tests to identify issues, if any, prohibiting successful calling.\n */\nvar PreflightTest = /** @class */ (function (_super) {\n    __extends(PreflightTest, _super);\n    /**\n     * Construct a {@link PreflightTest} instance.\n     * @constructor\n     * @param token - A Twilio JWT token string.\n     * @param options\n     */\n    function PreflightTest(token, options) {\n        var _this = _super.call(this) || this;\n        /**\n         * Whether this test has already logged an insights-connection-warning.\n         */\n        _this._hasInsightsErrored = false;\n        /**\n         * Network related timing measurements for this test\n         */\n        _this._networkTiming = {};\n        /**\n         * The options passed to {@link PreflightTest} constructor\n         */\n        _this._options = {\n            codecPreferences: [connection_1.default.Codec.PCMU, connection_1.default.Codec.Opus],\n            debug: false,\n            edge: \'roaming\',\n            fakeMicInput: false,\n            signalingTimeoutMs: 10000,\n        };\n        /**\n         * Current status of this test\n         */\n        _this._status = PreflightTest.Status.Connecting;\n        Object.assign(_this._options, options);\n        _this._samples = [];\n        _this._warnings = [];\n        _this._startTime = Date.now();\n        _this._initDevice(token, __assign(__assign({}, _this._options), { fileInputStream: _this._options.fakeMicInput ?\n                _this._getStreamFromFile() : undefined }));\n        return _this;\n    }\n    /**\n     * Stops the current test and raises a failed event.\n     */\n    PreflightTest.prototype.stop = function () {\n        var _this = this;\n        var error = {\n            code: 31008,\n            message: \'Call cancelled\',\n        };\n        if (this._device) {\n            this._device.once(\'offline\', function () { return _this._onFailed(error); });\n            this._device.destroy();\n        }\n        else {\n            this._onFailed(error);\n        }\n    };\n    /**\n     * Emit a {PreflightTest.Warning}\n     */\n    PreflightTest.prototype._emitWarning = function (name, description, rtcWarning) {\n        var warning = { name: name, description: description };\n        if (rtcWarning) {\n            warning.rtcWarning = rtcWarning;\n        }\n        this._warnings.push(warning);\n        this.emit(PreflightTest.Events.Warning, warning);\n    };\n    /**\n     * Returns call quality base on the RTC Stats\n     */\n    PreflightTest.prototype._getCallQuality = function (mos) {\n        if (mos > 4.2) {\n            return PreflightTest.CallQuality.Excellent;\n        }\n        else if (mos >= 4.1 && mos <= 4.2) {\n            return PreflightTest.CallQuality.Great;\n        }\n        else if (mos >= 3.7 && mos <= 4) {\n            return PreflightTest.CallQuality.Good;\n        }\n        else if (mos >= 3.1 && mos <= 3.6) {\n            return PreflightTest.CallQuality.Fair;\n        }\n        else {\n            return PreflightTest.CallQuality.Degraded;\n        }\n    };\n    /**\n     * Returns the report for this test.\n     */\n    PreflightTest.prototype._getReport = function () {\n        var stats = this._getRTCStats();\n        var testTiming = { start: this._startTime };\n        if (this._endTime) {\n            testTiming.end = this._endTime;\n            testTiming.duration = this._endTime - this._startTime;\n        }\n        var report = {\n            callSid: this._callSid,\n            edge: this._edge,\n            iceCandidateStats: this._rtcIceCandidateStatsReport.iceCandidateStats,\n            networkTiming: this._networkTiming,\n            samples: this._samples,\n            selectedEdge: this._options.edge,\n            stats: stats,\n            testTiming: testTiming,\n            totals: this._getRTCSampleTotals(),\n            warnings: this._warnings,\n        };\n        var selectedIceCandidatePairStats = this._rtcIceCandidateStatsReport.selectedIceCandidatePairStats;\n        if (selectedIceCandidatePairStats) {\n            report.selectedIceCandidatePairStats = selectedIceCandidatePairStats;\n            report.isTurnRequired = selectedIceCandidatePairStats.localCandidate.candidateType === \'relay\'\n                || selectedIceCandidatePairStats.remoteCandidate.candidateType === \'relay\';\n        }\n        if (stats) {\n            report.callQuality = this._getCallQuality(stats.mos.average);\n        }\n        return report;\n    };\n    /**\n     * Returns RTC stats totals for this test\n     */\n    PreflightTest.prototype._getRTCSampleTotals = function () {\n        if (!this._latestSample) {\n            return;\n        }\n        return __assign({}, this._latestSample.totals);\n    };\n    /**\n     * Returns RTC related stats captured during the test call\n     */\n    PreflightTest.prototype._getRTCStats = function () {\n        var firstMosSampleIdx = this._samples.findIndex(function (sample) { return typeof sample.mos === \'number\' && sample.mos > 0; });\n        var samples = firstMosSampleIdx >= 0\n            ? this._samples.slice(firstMosSampleIdx)\n            : [];\n        if (!samples || !samples.length) {\n            return;\n        }\n        return [\'jitter\', \'mos\', \'rtt\'].reduce(function (statObj, stat) {\n            var _a;\n            var values = samples.map(function (s) { return s[stat]; });\n            return __assign(__assign({}, statObj), (_a = {}, _a[stat] = {\n                average: Number((values.reduce(function (total, value) { return total + value; }) / values.length).toPrecision(5)),\n                max: Math.max.apply(Math, values),\n                min: Math.min.apply(Math, values),\n            }, _a));\n        }, {});\n    };\n    /**\n     * Returns a MediaStream from a media file\n     */\n    PreflightTest.prototype._getStreamFromFile = function () {\n        var audioContext = this._options.audioContext;\n        if (!audioContext) {\n            throw new errors_1.NotSupportedError(\'Cannot fake input audio stream: AudioContext is not supported by this browser.\');\n        }\n        var audioEl = new Audio(COWBELL_AUDIO_URL);\n        audioEl.addEventListener(\'canplaythrough\', function () { return audioEl.play(); });\n        if (typeof audioEl.setAttribute === \'function\') {\n            audioEl.setAttribute(\'crossorigin\', \'anonymous\');\n        }\n        var src = audioContext.createMediaElementSource(audioEl);\n        var dest = audioContext.createMediaStreamDestination();\n        src.connect(dest);\n        return dest.stream;\n    };\n    /**\n     * Initialize the device\n     */\n    PreflightTest.prototype._initDevice = function (token, options) {\n        var _this = this;\n        try {\n            this._device = new (options.deviceFactory || device_1.default)(token, {\n                codecPreferences: options.codecPreferences,\n                debug: options.debug,\n                edge: options.edge,\n                fileInputStream: options.fileInputStream,\n                iceServers: options.iceServers,\n                preflight: true,\n                rtcConfiguration: options.rtcConfiguration,\n            });\n        }\n        catch (error) {\n            // We want to return before failing so the consumer can capture the event\n            setTimeout(function () {\n                _this._onFailed(error);\n            });\n            return;\n        }\n        this._device.once(\'ready\', function () {\n            _this._onDeviceReady();\n        });\n        this._device.once(\'error\', function (error) {\n            _this._onDeviceError(error);\n        });\n        this._signalingTimeoutTimer = setTimeout(function () {\n            _this._onDeviceError({\n                code: 31901,\n                message: \'WebSocket - Connection Timeout\',\n            });\n        }, options.signalingTimeoutMs);\n    };\n    /**\n     * Called on {@link Device} error event\n     * @param error\n     */\n    PreflightTest.prototype._onDeviceError = function (error) {\n        this._device.destroy();\n        this._onFailed(error);\n    };\n    /**\n     * Called on {@link Device} ready event\n     */\n    PreflightTest.prototype._onDeviceReady = function () {\n        var _this = this;\n        clearTimeout(this._echoTimer);\n        clearTimeout(this._signalingTimeoutTimer);\n        this._connection = this._device.connect();\n        this._networkTiming.signaling = { start: Date.now() };\n        this._setupConnectionHandlers(this._connection);\n        this._edge = this._device.edge || undefined;\n        if (this._options.fakeMicInput) {\n            this._echoTimer = setTimeout(function () { return _this._device.disconnectAll(); }, ECHO_TEST_DURATION);\n            var audio = this._device.audio;\n            if (audio) {\n                audio.disconnect(false);\n                audio.outgoing(false);\n            }\n        }\n        this._device.once(\'disconnect\', function () {\n            _this._device.once(\'offline\', function () { return _this._onOffline(); });\n            _this._device.destroy();\n        });\n        var publisher = this._connection[\'_publisher\'];\n        publisher.on(\'error\', function () {\n            if (!_this._hasInsightsErrored) {\n                _this._emitWarning(\'insights-connection-error\', \'Received an error when attempting to connect to Insights gateway\');\n            }\n            _this._hasInsightsErrored = true;\n        });\n    };\n    /**\n     * Called when there is a fatal error\n     * @param error\n     */\n    PreflightTest.prototype._onFailed = function (error) {\n        clearTimeout(this._echoTimer);\n        clearTimeout(this._signalingTimeoutTimer);\n        this._releaseHandlers();\n        this._endTime = Date.now();\n        this._status = PreflightTest.Status.Failed;\n        this.emit(PreflightTest.Events.Failed, error);\n    };\n    /**\n     * Called when the device goes offline.\n     * This indicates that the test has been completed, but we won\'t know if it failed or not.\n     * The onError event will be the indicator whether the test failed.\n     */\n    PreflightTest.prototype._onOffline = function () {\n        var _this = this;\n        // We need to make sure we always execute preflight.on(\'completed\') last\n        // as client SDK sometimes emits \'offline\' event before emitting fatal errors.\n        setTimeout(function () {\n            if (_this._status === PreflightTest.Status.Failed) {\n                return;\n            }\n            clearTimeout(_this._echoTimer);\n            clearTimeout(_this._signalingTimeoutTimer);\n            _this._releaseHandlers();\n            _this._endTime = Date.now();\n            _this._status = PreflightTest.Status.Completed;\n            _this._report = _this._getReport();\n            _this.emit(PreflightTest.Events.Completed, _this._report);\n        }, 10);\n    };\n    /**\n     * Clean up all handlers for device and connection\n     */\n    PreflightTest.prototype._releaseHandlers = function () {\n        [this._device, this._connection].forEach(function (emitter) {\n            if (emitter) {\n                emitter.eventNames().forEach(function (name) { return emitter.removeAllListeners(name); });\n            }\n        });\n    };\n    /**\n     * Setup the event handlers for the {@link Connection} of the test call\n     * @param connection\n     */\n    PreflightTest.prototype._setupConnectionHandlers = function (connection) {\n        var _this = this;\n        if (this._options.fakeMicInput) {\n            // When volume events start emitting, it means all audio outputs have been created.\n            // Let\'s mute them if we\'re using fake mic input.\n            connection.once(\'volume\', function () {\n                connection.mediaStream.outputs\n                    .forEach(function (output) { return output.audio.muted = true; });\n            });\n        }\n        connection.on(\'warning\', function (name, data) {\n            _this._emitWarning(name, \'Received an RTCWarning. See .rtcWarning for the RTCWarning\', data);\n        });\n        connection.once(\'accept\', function () {\n            _this._callSid = connection.mediaStream.callSid;\n            _this._status = PreflightTest.Status.Connected;\n            _this.emit(PreflightTest.Events.Connected);\n        });\n        connection.on(\'sample\', function (sample) { return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!!this._latestSample) return [3 /*break*/, 2];\n                        _a = this;\n                        return [4 /*yield*/, (this._options.getRTCIceCandidateStatsReport || stats_1.getRTCIceCandidateStatsReport)(connection.mediaStream.version.pc)];\n                    case 1:\n                        _a._rtcIceCandidateStatsReport = _b.sent();\n                        _b.label = 2;\n                    case 2:\n                        this._latestSample = sample;\n                        this._samples.push(sample);\n                        this.emit(PreflightTest.Events.Sample, sample);\n                        return [2 /*return*/];\n                }\n            });\n        }); });\n        // TODO: Update the following once the SDK supports emitting these events\n        // Let\'s shim for now\n        [{\n                reportLabel: \'peerConnection\',\n                type: \'pcconnection\',\n            }, {\n                reportLabel: \'ice\',\n                type: \'iceconnection\',\n            }, {\n                reportLabel: \'dtls\',\n                type: \'dtlstransport\',\n            }, {\n                reportLabel: \'signaling\',\n                type: \'signaling\',\n            }].forEach(function (_a) {\n            var type = _a.type, reportLabel = _a.reportLabel;\n            var handlerName = "on" + type + "statechange";\n            var originalHandler = connection.mediaStream[handlerName];\n            connection.mediaStream[handlerName] = function (state) {\n                var timing = _this._networkTiming[reportLabel]\n                    = _this._networkTiming[reportLabel] || { start: 0 };\n                if (state === \'connecting\' || state === \'checking\') {\n                    timing.start = Date.now();\n                }\n                else if ((state === \'connected\' || state === \'stable\') && !timing.duration) {\n                    timing.end = Date.now();\n                    timing.duration = timing.end - timing.start;\n                }\n                originalHandler(state);\n            };\n        });\n    };\n    Object.defineProperty(PreflightTest.prototype, "callSid", {\n        /**\n         * The callsid generated for the test call.\n         */\n        get: function () {\n            return this._callSid;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PreflightTest.prototype, "endTime", {\n        /**\n         * A timestamp in milliseconds of when the test ended.\n         */\n        get: function () {\n            return this._endTime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PreflightTest.prototype, "latestSample", {\n        /**\n         * The latest WebRTC sample collected.\n         */\n        get: function () {\n            return this._latestSample;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PreflightTest.prototype, "report", {\n        /**\n         * The report for this test.\n         */\n        get: function () {\n            return this._report;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PreflightTest.prototype, "startTime", {\n        /**\n         * A timestamp in milliseconds of when the test started.\n         */\n        get: function () {\n            return this._startTime;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(PreflightTest.prototype, "status", {\n        /**\n         * The status of the test.\n         */\n        get: function () {\n            return this._status;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return PreflightTest;\n}(events_1.EventEmitter));\nexports.PreflightTest = PreflightTest;\n(function (PreflightTest) {\n    /**\n     * The quality of the call determined by different mos ranges.\n     * Mos is calculated base on the WebRTC stats - rtt, jitter, and packet lost.\n     */\n    var CallQuality;\n    (function (CallQuality) {\n        /**\n         * If the average mos is over 4.2.\n         */\n        CallQuality["Excellent"] = "excellent";\n        /**\n         * If the average mos is between 4.1 and 4.2 both inclusive.\n         */\n        CallQuality["Great"] = "great";\n        /**\n         * If the average mos is between 3.7 and 4.0 both inclusive.\n         */\n        CallQuality["Good"] = "good";\n        /**\n         * If the average mos is between 3.1 and 3.6 both inclusive.\n         */\n        CallQuality["Fair"] = "fair";\n        /**\n         * If the average mos is 3.0 or below.\n         */\n        CallQuality["Degraded"] = "degraded";\n    })(CallQuality = PreflightTest.CallQuality || (PreflightTest.CallQuality = {}));\n    /**\n     * Possible events that a [[PreflightTest]] might emit.\n     */\n    var Events;\n    (function (Events) {\n        /**\n         * See [[PreflightTest.completedEvent]]\n         */\n        Events["Completed"] = "completed";\n        /**\n         * See [[PreflightTest.connectedEvent]]\n         */\n        Events["Connected"] = "connected";\n        /**\n         * See [[PreflightTest.failedEvent]]\n         */\n        Events["Failed"] = "failed";\n        /**\n         * See [[PreflightTest.sampleEvent]]\n         */\n        Events["Sample"] = "sample";\n        /**\n         * See [[PreflightTest.warningEvent]]\n         */\n        Events["Warning"] = "warning";\n    })(Events = PreflightTest.Events || (PreflightTest.Events = {}));\n    /**\n     * Possible status of the test.\n     */\n    var Status;\n    (function (Status) {\n        /**\n         * Connection to Twilio has initiated.\n         */\n        Status["Connecting"] = "connecting";\n        /**\n         * Connection to Twilio has been established.\n         */\n        Status["Connected"] = "connected";\n        /**\n         * The connection to Twilio has been disconnected and the test call has completed.\n         */\n        Status["Completed"] = "completed";\n        /**\n         * The test has stopped and failed.\n         */\n        Status["Failed"] = "failed";\n    })(Status = PreflightTest.Status || (PreflightTest.Status = {}));\n})(PreflightTest = exports.PreflightTest || (exports.PreflightTest = {}));\nexports.PreflightTest = PreflightTest;\n//# sourceMappingURL=preflight.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3ByZWZsaWdodC9wcmVmbGlnaHQuanM/Yjc4YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QiwwQkFBMEIsYUFBYSxFQUFFLHFCQUFxQjtBQUN4RyxnQkFBZ0IscURBQXFELG9FQUFvRSxhQUFhLEVBQUU7QUFDeEosc0JBQXNCLHNCQUFzQixxQkFBcUIsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsa0NBQWtDLFNBQVM7QUFDM0Msa0NBQWtDLFdBQVcsVUFBVTtBQUN2RCx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDZHQUE2RyxPQUFPLFVBQVU7QUFDOUgsZ0ZBQWdGLGlCQUFpQixPQUFPO0FBQ3hHLHdEQUF3RCxnQkFBZ0IsUUFBUSxPQUFPO0FBQ3ZGLDhDQUE4QyxnQkFBZ0IsZ0JBQWdCLE9BQU87QUFDckY7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVMsWUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw0RUFBNEU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZEQUE2RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDZEQUE2RDtBQUNsRSxDQUFDLDRDQUE0QyxxQkFBcUIsS0FBSztBQUN2RSxxQkFBcUI7QUFDckIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3ByZWZsaWdodC9wcmVmbGlnaHQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBWb2ljZVxuICogQHByZWZlcnJlZFxuICogQHB1YmxpY2FwaVxuICovXG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uXCIpO1xudmFyIGRldmljZV8xID0gcmVxdWlyZShcIi4uL2RldmljZVwiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG52YXIgc3RhdHNfMSA9IHJlcXVpcmUoXCIuLi9ydGMvc3RhdHNcIik7XG52YXIgX2EgPSByZXF1aXJlKCcuLi9jb25zdGFudHMnKSwgQ09XQkVMTF9BVURJT19VUkwgPSBfYS5DT1dCRUxMX0FVRElPX1VSTCwgRUNIT19URVNUX0RVUkFUSU9OID0gX2EuRUNIT19URVNUX0RVUkFUSU9OO1xuLyoqXG4gKiBSdW5zIHNvbWUgdGVzdHMgdG8gaWRlbnRpZnkgaXNzdWVzLCBpZiBhbnksIHByb2hpYml0aW5nIHN1Y2Nlc3NmdWwgY2FsbGluZy5cbiAqL1xudmFyIFByZWZsaWdodFRlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByZWZsaWdodFRlc3QsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEge0BsaW5rIFByZWZsaWdodFRlc3R9IGluc3RhbmNlLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB0b2tlbiAtIEEgVHdpbGlvIEpXVCB0b2tlbiBzdHJpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQcmVmbGlnaHRUZXN0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgdGVzdCBoYXMgYWxyZWFkeSBsb2dnZWQgYW4gaW5zaWdodHMtY29ubmVjdGlvbi13YXJuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2hhc0luc2lnaHRzRXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmV0d29yayByZWxhdGVkIHRpbWluZyBtZWFzdXJlbWVudHMgZm9yIHRoaXMgdGVzdFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX25ldHdvcmtUaW1pbmcgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCB0byB7QGxpbmsgUHJlZmxpZ2h0VGVzdH0gY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vcHRpb25zID0ge1xuICAgICAgICAgICAgY29kZWNQcmVmZXJlbmNlczogW2Nvbm5lY3Rpb25fMS5kZWZhdWx0LkNvZGVjLlBDTVUsIGNvbm5lY3Rpb25fMS5kZWZhdWx0LkNvZGVjLk9wdXNdLFxuICAgICAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICAgICAgZWRnZTogJ3JvYW1pbmcnLFxuICAgICAgICAgICAgZmFrZU1pY0lucHV0OiBmYWxzZSxcbiAgICAgICAgICAgIHNpZ25hbGluZ1RpbWVvdXRNczogMTAwMDAsXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHN0YXR1cyBvZiB0aGlzIHRlc3RcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zdGF0dXMgPSBQcmVmbGlnaHRUZXN0LlN0YXR1cy5Db25uZWN0aW5nO1xuICAgICAgICBPYmplY3QuYXNzaWduKF90aGlzLl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgX3RoaXMuX3NhbXBsZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuX3dhcm5pbmdzID0gW107XG4gICAgICAgIF90aGlzLl9zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBfdGhpcy5faW5pdERldmljZSh0b2tlbiwgX19hc3NpZ24oX19hc3NpZ24oe30sIF90aGlzLl9vcHRpb25zKSwgeyBmaWxlSW5wdXRTdHJlYW06IF90aGlzLl9vcHRpb25zLmZha2VNaWNJbnB1dCA/XG4gICAgICAgICAgICAgICAgX3RoaXMuX2dldFN0cmVhbUZyb21GaWxlKCkgOiB1bmRlZmluZWQgfSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBjdXJyZW50IHRlc3QgYW5kIHJhaXNlcyBhIGZhaWxlZCBldmVudC5cbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiAzMTAwOCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDYWxsIGNhbmNlbGxlZCcsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9kZXZpY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2RldmljZS5vbmNlKCdvZmZsaW5lJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uRmFpbGVkKGVycm9yKTsgfSk7XG4gICAgICAgICAgICB0aGlzLl9kZXZpY2UuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25GYWlsZWQoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBFbWl0IGEge1ByZWZsaWdodFRlc3QuV2FybmluZ31cbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fZW1pdFdhcm5pbmcgPSBmdW5jdGlvbiAobmFtZSwgZGVzY3JpcHRpb24sIHJ0Y1dhcm5pbmcpIHtcbiAgICAgICAgdmFyIHdhcm5pbmcgPSB7IG5hbWU6IG5hbWUsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9O1xuICAgICAgICBpZiAocnRjV2FybmluZykge1xuICAgICAgICAgICAgd2FybmluZy5ydGNXYXJuaW5nID0gcnRjV2FybmluZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93YXJuaW5ncy5wdXNoKHdhcm5pbmcpO1xuICAgICAgICB0aGlzLmVtaXQoUHJlZmxpZ2h0VGVzdC5FdmVudHMuV2FybmluZywgd2FybmluZyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNhbGwgcXVhbGl0eSBiYXNlIG9uIHRoZSBSVEMgU3RhdHNcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fZ2V0Q2FsbFF1YWxpdHkgPSBmdW5jdGlvbiAobW9zKSB7XG4gICAgICAgIGlmIChtb3MgPiA0LjIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmVmbGlnaHRUZXN0LkNhbGxRdWFsaXR5LkV4Y2VsbGVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3MgPj0gNC4xICYmIG1vcyA8PSA0LjIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmVmbGlnaHRUZXN0LkNhbGxRdWFsaXR5LkdyZWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vcyA+PSAzLjcgJiYgbW9zIDw9IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBQcmVmbGlnaHRUZXN0LkNhbGxRdWFsaXR5Lkdvb2Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9zID49IDMuMSAmJiBtb3MgPD0gMy42KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJlZmxpZ2h0VGVzdC5DYWxsUXVhbGl0eS5GYWlyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByZWZsaWdodFRlc3QuQ2FsbFF1YWxpdHkuRGVncmFkZWQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlcG9ydCBmb3IgdGhpcyB0ZXN0LlxuICAgICAqL1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9nZXRSZXBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMuX2dldFJUQ1N0YXRzKCk7XG4gICAgICAgIHZhciB0ZXN0VGltaW5nID0geyBzdGFydDogdGhpcy5fc3RhcnRUaW1lIH07XG4gICAgICAgIGlmICh0aGlzLl9lbmRUaW1lKSB7XG4gICAgICAgICAgICB0ZXN0VGltaW5nLmVuZCA9IHRoaXMuX2VuZFRpbWU7XG4gICAgICAgICAgICB0ZXN0VGltaW5nLmR1cmF0aW9uID0gdGhpcy5fZW5kVGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwb3J0ID0ge1xuICAgICAgICAgICAgY2FsbFNpZDogdGhpcy5fY2FsbFNpZCxcbiAgICAgICAgICAgIGVkZ2U6IHRoaXMuX2VkZ2UsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVTdGF0czogdGhpcy5fcnRjSWNlQ2FuZGlkYXRlU3RhdHNSZXBvcnQuaWNlQ2FuZGlkYXRlU3RhdHMsXG4gICAgICAgICAgICBuZXR3b3JrVGltaW5nOiB0aGlzLl9uZXR3b3JrVGltaW5nLFxuICAgICAgICAgICAgc2FtcGxlczogdGhpcy5fc2FtcGxlcyxcbiAgICAgICAgICAgIHNlbGVjdGVkRWRnZTogdGhpcy5fb3B0aW9ucy5lZGdlLFxuICAgICAgICAgICAgc3RhdHM6IHN0YXRzLFxuICAgICAgICAgICAgdGVzdFRpbWluZzogdGVzdFRpbWluZyxcbiAgICAgICAgICAgIHRvdGFsczogdGhpcy5fZ2V0UlRDU2FtcGxlVG90YWxzKCksXG4gICAgICAgICAgICB3YXJuaW5nczogdGhpcy5fd2FybmluZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IHRoaXMuX3J0Y0ljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0LnNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMpIHtcbiAgICAgICAgICAgIHJlcG9ydC5zZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyA9IHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzO1xuICAgICAgICAgICAgcmVwb3J0LmlzVHVyblJlcXVpcmVkID0gc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHMubG9jYWxDYW5kaWRhdGUuY2FuZGlkYXRlVHlwZSA9PT0gJ3JlbGF5J1xuICAgICAgICAgICAgICAgIHx8IHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzLnJlbW90ZUNhbmRpZGF0ZS5jYW5kaWRhdGVUeXBlID09PSAncmVsYXknO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0cykge1xuICAgICAgICAgICAgcmVwb3J0LmNhbGxRdWFsaXR5ID0gdGhpcy5fZ2V0Q2FsbFF1YWxpdHkoc3RhdHMubW9zLmF2ZXJhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXBvcnQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIFJUQyBzdGF0cyB0b3RhbHMgZm9yIHRoaXMgdGVzdFxuICAgICAqL1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9nZXRSVENTYW1wbGVUb3RhbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fbGF0ZXN0U2FtcGxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHt9LCB0aGlzLl9sYXRlc3RTYW1wbGUudG90YWxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgUlRDIHJlbGF0ZWQgc3RhdHMgY2FwdHVyZWQgZHVyaW5nIHRoZSB0ZXN0IGNhbGxcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fZ2V0UlRDU3RhdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaXJzdE1vc1NhbXBsZUlkeCA9IHRoaXMuX3NhbXBsZXMuZmluZEluZGV4KGZ1bmN0aW9uIChzYW1wbGUpIHsgcmV0dXJuIHR5cGVvZiBzYW1wbGUubW9zID09PSAnbnVtYmVyJyAmJiBzYW1wbGUubW9zID4gMDsgfSk7XG4gICAgICAgIHZhciBzYW1wbGVzID0gZmlyc3RNb3NTYW1wbGVJZHggPj0gMFxuICAgICAgICAgICAgPyB0aGlzLl9zYW1wbGVzLnNsaWNlKGZpcnN0TW9zU2FtcGxlSWR4KVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgaWYgKCFzYW1wbGVzIHx8ICFzYW1wbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ2ppdHRlcicsICdtb3MnLCAncnR0J10ucmVkdWNlKGZ1bmN0aW9uIChzdGF0T2JqLCBzdGF0KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gc2FtcGxlcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHNbc3RhdF07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBzdGF0T2JqKSwgKF9hID0ge30sIF9hW3N0YXRdID0ge1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2U6IE51bWJlcigodmFsdWVzLnJlZHVjZShmdW5jdGlvbiAodG90YWwsIHZhbHVlKSB7IHJldHVybiB0b3RhbCArIHZhbHVlOyB9KSAvIHZhbHVlcy5sZW5ndGgpLnRvUHJlY2lzaW9uKDUpKSxcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyksXG4gICAgICAgICAgICAgICAgbWluOiBNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXMpLFxuICAgICAgICAgICAgfSwgX2EpKTtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIE1lZGlhU3RyZWFtIGZyb20gYSBtZWRpYSBmaWxlXG4gICAgICovXG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX2dldFN0cmVhbUZyb21GaWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5fb3B0aW9ucy5hdWRpb0NvbnRleHQ7XG4gICAgICAgIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90U3VwcG9ydGVkRXJyb3IoJ0Nhbm5vdCBmYWtlIGlucHV0IGF1ZGlvIHN0cmVhbTogQXVkaW9Db250ZXh0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdWRpb0VsID0gbmV3IEF1ZGlvKENPV0JFTExfQVVESU9fVVJMKTtcbiAgICAgICAgYXVkaW9FbC5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1ZGlvRWwucGxheSgpOyB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBhdWRpb0VsLnNldEF0dHJpYnV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXVkaW9FbC5zZXRBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJywgJ2Fub255bW91cycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzcmMgPSBhdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFFbGVtZW50U291cmNlKGF1ZGlvRWwpO1xuICAgICAgICB2YXIgZGVzdCA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgICAgIHNyYy5jb25uZWN0KGRlc3QpO1xuICAgICAgICByZXR1cm4gZGVzdC5zdHJlYW07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBkZXZpY2VcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5faW5pdERldmljZSA9IGZ1bmN0aW9uICh0b2tlbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fZGV2aWNlID0gbmV3IChvcHRpb25zLmRldmljZUZhY3RvcnkgfHwgZGV2aWNlXzEuZGVmYXVsdCkodG9rZW4sIHtcbiAgICAgICAgICAgICAgICBjb2RlY1ByZWZlcmVuY2VzOiBvcHRpb25zLmNvZGVjUHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgZGVidWc6IG9wdGlvbnMuZGVidWcsXG4gICAgICAgICAgICAgICAgZWRnZTogb3B0aW9ucy5lZGdlLFxuICAgICAgICAgICAgICAgIGZpbGVJbnB1dFN0cmVhbTogb3B0aW9ucy5maWxlSW5wdXRTdHJlYW0sXG4gICAgICAgICAgICAgICAgaWNlU2VydmVyczogb3B0aW9ucy5pY2VTZXJ2ZXJzLFxuICAgICAgICAgICAgICAgIHByZWZsaWdodDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBydGNDb25maWd1cmF0aW9uOiBvcHRpb25zLnJ0Y0NvbmZpZ3VyYXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gcmV0dXJuIGJlZm9yZSBmYWlsaW5nIHNvIHRoZSBjb25zdW1lciBjYW4gY2FwdHVyZSB0aGUgZXZlbnRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9vbkZhaWxlZChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kZXZpY2Uub25jZSgncmVhZHknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25EZXZpY2VSZWFkeSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGV2aWNlLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25EZXZpY2VFcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zaWduYWxpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9vbkRldmljZUVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiAzMTkwMSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnV2ViU29ja2V0IC0gQ29ubmVjdGlvbiBUaW1lb3V0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBvcHRpb25zLnNpZ25hbGluZ1RpbWVvdXRNcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24ge0BsaW5rIERldmljZX0gZXJyb3IgZXZlbnRcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fb25EZXZpY2VFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aGlzLl9kZXZpY2UuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9vbkZhaWxlZChlcnJvcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24ge0BsaW5rIERldmljZX0gcmVhZHkgZXZlbnRcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fb25EZXZpY2VSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2VjaG9UaW1lcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaWduYWxpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gdGhpcy5fZGV2aWNlLmNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya1RpbWluZy5zaWduYWxpbmcgPSB7IHN0YXJ0OiBEYXRlLm5vdygpIH07XG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKHRoaXMuX2Nvbm5lY3Rpb24pO1xuICAgICAgICB0aGlzLl9lZGdlID0gdGhpcy5fZGV2aWNlLmVkZ2UgfHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mYWtlTWljSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VjaG9UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2RldmljZS5kaXNjb25uZWN0QWxsKCk7IH0sIEVDSE9fVEVTVF9EVVJBVElPTik7XG4gICAgICAgICAgICB2YXIgYXVkaW8gPSB0aGlzLl9kZXZpY2UuYXVkaW87XG4gICAgICAgICAgICBpZiAoYXVkaW8pIHtcbiAgICAgICAgICAgICAgICBhdWRpby5kaXNjb25uZWN0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhdWRpby5vdXRnb2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGV2aWNlLm9uY2UoJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fZGV2aWNlLm9uY2UoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25PZmZsaW5lKCk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuX2RldmljZS5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHVibGlzaGVyID0gdGhpcy5fY29ubmVjdGlvblsnX3B1Ymxpc2hlciddO1xuICAgICAgICBwdWJsaXNoZXIub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5faGFzSW5zaWdodHNFcnJvcmVkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2VtaXRXYXJuaW5nKCdpbnNpZ2h0cy1jb25uZWN0aW9uLWVycm9yJywgJ1JlY2VpdmVkIGFuIGVycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBjb25uZWN0IHRvIEluc2lnaHRzIGdhdGV3YXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9oYXNJbnNpZ2h0c0Vycm9yZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZXJlIGlzIGEgZmF0YWwgZXJyb3JcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKi9cbiAgICBQcmVmbGlnaHRUZXN0LnByb3RvdHlwZS5fb25GYWlsZWQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2VjaG9UaW1lcik7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zaWduYWxpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLl9yZWxlYXNlSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fZW5kVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IFByZWZsaWdodFRlc3QuU3RhdHVzLkZhaWxlZDtcbiAgICAgICAgdGhpcy5lbWl0KFByZWZsaWdodFRlc3QuRXZlbnRzLkZhaWxlZCwgZXJyb3IpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGRldmljZSBnb2VzIG9mZmxpbmUuXG4gICAgICogVGhpcyBpbmRpY2F0ZXMgdGhhdCB0aGUgdGVzdCBoYXMgYmVlbiBjb21wbGV0ZWQsIGJ1dCB3ZSB3b24ndCBrbm93IGlmIGl0IGZhaWxlZCBvciBub3QuXG4gICAgICogVGhlIG9uRXJyb3IgZXZlbnQgd2lsbCBiZSB0aGUgaW5kaWNhdG9yIHdoZXRoZXIgdGhlIHRlc3QgZmFpbGVkLlxuICAgICAqL1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9vbk9mZmxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFsd2F5cyBleGVjdXRlIHByZWZsaWdodC5vbignY29tcGxldGVkJykgbGFzdFxuICAgICAgICAvLyBhcyBjbGllbnQgU0RLIHNvbWV0aW1lcyBlbWl0cyAnb2ZmbGluZScgZXZlbnQgYmVmb3JlIGVtaXR0aW5nIGZhdGFsIGVycm9ycy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0YXR1cyA9PT0gUHJlZmxpZ2h0VGVzdC5TdGF0dXMuRmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9lY2hvVGltZXIpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9zaWduYWxpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgX3RoaXMuX3JlbGVhc2VIYW5kbGVycygpO1xuICAgICAgICAgICAgX3RoaXMuX2VuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgX3RoaXMuX3N0YXR1cyA9IFByZWZsaWdodFRlc3QuU3RhdHVzLkNvbXBsZXRlZDtcbiAgICAgICAgICAgIF90aGlzLl9yZXBvcnQgPSBfdGhpcy5fZ2V0UmVwb3J0KCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KFByZWZsaWdodFRlc3QuRXZlbnRzLkNvbXBsZXRlZCwgX3RoaXMuX3JlcG9ydCk7XG4gICAgICAgIH0sIDEwKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIGFsbCBoYW5kbGVycyBmb3IgZGV2aWNlIGFuZCBjb25uZWN0aW9uXG4gICAgICovXG4gICAgUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUuX3JlbGVhc2VIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgW3RoaXMuX2RldmljZSwgdGhpcy5fY29ubmVjdGlvbl0uZm9yRWFjaChmdW5jdGlvbiAoZW1pdHRlcikge1xuICAgICAgICAgICAgaWYgKGVtaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmV2ZW50TmFtZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBlbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycyhuYW1lKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0dXAgdGhlIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUge0BsaW5rIENvbm5lY3Rpb259IG9mIHRoZSB0ZXN0IGNhbGxcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvblxuICAgICAqL1xuICAgIFByZWZsaWdodFRlc3QucHJvdG90eXBlLl9zZXR1cENvbm5lY3Rpb25IYW5kbGVycyA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZha2VNaWNJbnB1dCkge1xuICAgICAgICAgICAgLy8gV2hlbiB2b2x1bWUgZXZlbnRzIHN0YXJ0IGVtaXR0aW5nLCBpdCBtZWFucyBhbGwgYXVkaW8gb3V0cHV0cyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICAgIC8vIExldCdzIG11dGUgdGhlbSBpZiB3ZSdyZSB1c2luZyBmYWtlIG1pYyBpbnB1dC5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24ub25jZSgndm9sdW1lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubWVkaWFTdHJlYW0ub3V0cHV0c1xuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAob3V0cHV0KSB7IHJldHVybiBvdXRwdXQuYXVkaW8ubXV0ZWQgPSB0cnVlOyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ3dhcm5pbmcnLCBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuX2VtaXRXYXJuaW5nKG5hbWUsICdSZWNlaXZlZCBhbiBSVENXYXJuaW5nLiBTZWUgLnJ0Y1dhcm5pbmcgZm9yIHRoZSBSVENXYXJuaW5nJywgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2FjY2VwdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9jYWxsU2lkID0gY29ubmVjdGlvbi5tZWRpYVN0cmVhbS5jYWxsU2lkO1xuICAgICAgICAgICAgX3RoaXMuX3N0YXR1cyA9IFByZWZsaWdodFRlc3QuU3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoUHJlZmxpZ2h0VGVzdC5FdmVudHMuQ29ubmVjdGVkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbm5lY3Rpb24ub24oJ3NhbXBsZScsIGZ1bmN0aW9uIChzYW1wbGUpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXRoaXMuX2xhdGVzdFNhbXBsZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAodGhpcy5fb3B0aW9ucy5nZXRSVENJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydCB8fCBzdGF0c18xLmdldFJUQ0ljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0KShjb25uZWN0aW9uLm1lZGlhU3RyZWFtLnZlcnNpb24ucGMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EuX3J0Y0ljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0ID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXRlc3RTYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zYW1wbGVzLnB1c2goc2FtcGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChQcmVmbGlnaHRUZXN0LkV2ZW50cy5TYW1wbGUsIHNhbXBsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9KTtcbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRoZSBmb2xsb3dpbmcgb25jZSB0aGUgU0RLIHN1cHBvcnRzIGVtaXR0aW5nIHRoZXNlIGV2ZW50c1xuICAgICAgICAvLyBMZXQncyBzaGltIGZvciBub3dcbiAgICAgICAgW3tcbiAgICAgICAgICAgICAgICByZXBvcnRMYWJlbDogJ3BlZXJDb25uZWN0aW9uJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAncGNjb25uZWN0aW9uJyxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICByZXBvcnRMYWJlbDogJ2ljZScsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2ljZWNvbm5lY3Rpb24nLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlcG9ydExhYmVsOiAnZHRscycsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2R0bHN0cmFuc3BvcnQnLFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHJlcG9ydExhYmVsOiAnc2lnbmFsaW5nJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc2lnbmFsaW5nJyxcbiAgICAgICAgICAgIH1dLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IF9hLnR5cGUsIHJlcG9ydExhYmVsID0gX2EucmVwb3J0TGFiZWw7XG4gICAgICAgICAgICB2YXIgaGFuZGxlck5hbWUgPSBcIm9uXCIgKyB0eXBlICsgXCJzdGF0ZWNoYW5nZVwiO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsSGFuZGxlciA9IGNvbm5lY3Rpb24ubWVkaWFTdHJlYW1baGFuZGxlck5hbWVdO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5tZWRpYVN0cmVhbVtoYW5kbGVyTmFtZV0gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltaW5nID0gX3RoaXMuX25ldHdvcmtUaW1pbmdbcmVwb3J0TGFiZWxdXG4gICAgICAgICAgICAgICAgICAgID0gX3RoaXMuX25ldHdvcmtUaW1pbmdbcmVwb3J0TGFiZWxdIHx8IHsgc3RhcnQ6IDAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09ICdjb25uZWN0aW5nJyB8fCBzdGF0ZSA9PT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aW1pbmcuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoc3RhdGUgPT09ICdjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnc3RhYmxlJykgJiYgIXRpbWluZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aW1pbmcuZW5kID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdGltaW5nLmR1cmF0aW9uID0gdGltaW5nLmVuZCAtIHRpbWluZy5zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxIYW5kbGVyKHN0YXRlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByZWZsaWdodFRlc3QucHJvdG90eXBlLCBcImNhbGxTaWRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbGxzaWQgZ2VuZXJhdGVkIGZvciB0aGUgdGVzdCBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFNpZDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFByZWZsaWdodFRlc3QucHJvdG90eXBlLCBcImVuZFRpbWVcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzIG9mIHdoZW4gdGhlIHRlc3QgZW5kZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRUaW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUsIFwibGF0ZXN0U2FtcGxlXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXRlc3QgV2ViUlRDIHNhbXBsZSBjb2xsZWN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXRlc3RTYW1wbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVmbGlnaHRUZXN0LnByb3RvdHlwZSwgXCJyZXBvcnRcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlcG9ydCBmb3IgdGhpcyB0ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwb3J0O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHJlZmxpZ2h0VGVzdC5wcm90b3R5cGUsIFwic3RhcnRUaW1lXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyBvZiB3aGVuIHRoZSB0ZXN0IHN0YXJ0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydFRpbWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcmVmbGlnaHRUZXN0LnByb3RvdHlwZSwgXCJzdGF0dXNcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXR1cyBvZiB0aGUgdGVzdC5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByZWZsaWdodFRlc3Q7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5QcmVmbGlnaHRUZXN0ID0gUHJlZmxpZ2h0VGVzdDtcbihmdW5jdGlvbiAoUHJlZmxpZ2h0VGVzdCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBxdWFsaXR5IG9mIHRoZSBjYWxsIGRldGVybWluZWQgYnkgZGlmZmVyZW50IG1vcyByYW5nZXMuXG4gICAgICogTW9zIGlzIGNhbGN1bGF0ZWQgYmFzZSBvbiB0aGUgV2ViUlRDIHN0YXRzIC0gcnR0LCBqaXR0ZXIsIGFuZCBwYWNrZXQgbG9zdC5cbiAgICAgKi9cbiAgICB2YXIgQ2FsbFF1YWxpdHk7XG4gICAgKGZ1bmN0aW9uIChDYWxsUXVhbGl0eSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGF2ZXJhZ2UgbW9zIGlzIG92ZXIgNC4yLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2FsbFF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGF2ZXJhZ2UgbW9zIGlzIGJldHdlZW4gNC4xIGFuZCA0LjIgYm90aCBpbmNsdXNpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBDYWxsUXVhbGl0eVtcIkdyZWF0XCJdID0gXCJncmVhdFwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGF2ZXJhZ2UgbW9zIGlzIGJldHdlZW4gMy43IGFuZCA0LjAgYm90aCBpbmNsdXNpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBDYWxsUXVhbGl0eVtcIkdvb2RcIl0gPSBcImdvb2RcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBhdmVyYWdlIG1vcyBpcyBiZXR3ZWVuIDMuMSBhbmQgMy42IGJvdGggaW5jbHVzaXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgQ2FsbFF1YWxpdHlbXCJGYWlyXCJdID0gXCJmYWlyXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgYXZlcmFnZSBtb3MgaXMgMy4wIG9yIGJlbG93LlxuICAgICAgICAgKi9cbiAgICAgICAgQ2FsbFF1YWxpdHlbXCJEZWdyYWRlZFwiXSA9IFwiZGVncmFkZWRcIjtcbiAgICB9KShDYWxsUXVhbGl0eSA9IFByZWZsaWdodFRlc3QuQ2FsbFF1YWxpdHkgfHwgKFByZWZsaWdodFRlc3QuQ2FsbFF1YWxpdHkgPSB7fSkpO1xuICAgIC8qKlxuICAgICAqIFBvc3NpYmxlIGV2ZW50cyB0aGF0IGEgW1tQcmVmbGlnaHRUZXN0XV0gbWlnaHQgZW1pdC5cbiAgICAgKi9cbiAgICB2YXIgRXZlbnRzO1xuICAgIChmdW5jdGlvbiAoRXZlbnRzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgW1tQcmVmbGlnaHRUZXN0LmNvbXBsZXRlZEV2ZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50c1tcIkNvbXBsZXRlZFwiXSA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgW1tQcmVmbGlnaHRUZXN0LmNvbm5lY3RlZEV2ZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50c1tcIkNvbm5lY3RlZFwiXSA9IFwiY29ubmVjdGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgW1tQcmVmbGlnaHRUZXN0LmZhaWxlZEV2ZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50c1tcIkZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgW1tQcmVmbGlnaHRUZXN0LnNhbXBsZUV2ZW50XV1cbiAgICAgICAgICovXG4gICAgICAgIEV2ZW50c1tcIlNhbXBsZVwiXSA9IFwic2FtcGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgW1tQcmVmbGlnaHRUZXN0Lndhcm5pbmdFdmVudF1dXG4gICAgICAgICAqL1xuICAgICAgICBFdmVudHNbXCJXYXJuaW5nXCJdID0gXCJ3YXJuaW5nXCI7XG4gICAgfSkoRXZlbnRzID0gUHJlZmxpZ2h0VGVzdC5FdmVudHMgfHwgKFByZWZsaWdodFRlc3QuRXZlbnRzID0ge30pKTtcbiAgICAvKipcbiAgICAgKiBQb3NzaWJsZSBzdGF0dXMgb2YgdGhlIHRlc3QuXG4gICAgICovXG4gICAgdmFyIFN0YXR1cztcbiAgICAoZnVuY3Rpb24gKFN0YXR1cykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29ubmVjdGlvbiB0byBUd2lsaW8gaGFzIGluaXRpYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIFN0YXR1c1tcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbm5lY3Rpb24gdG8gVHdpbGlvIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdHVzW1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb25uZWN0aW9uIHRvIFR3aWxpbyBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgYW5kIHRoZSB0ZXN0IGNhbGwgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIFN0YXR1c1tcIkNvbXBsZXRlZFwiXSA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGVzdCBoYXMgc3RvcHBlZCBhbmQgZmFpbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgU3RhdHVzW1wiRmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICB9KShTdGF0dXMgPSBQcmVmbGlnaHRUZXN0LlN0YXR1cyB8fCAoUHJlZmxpZ2h0VGVzdC5TdGF0dXMgPSB7fSkpO1xufSkoUHJlZmxpZ2h0VGVzdCA9IGV4cG9ydHMuUHJlZmxpZ2h0VGVzdCB8fCAoZXhwb3J0cy5QcmVmbGlnaHRUZXN0ID0ge30pKTtcbmV4cG9ydHMuUHJlZmxpZ2h0VGVzdCA9IFByZWZsaWdodFRlc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmbGlnaHQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/preflight/preflight.js\n')},"./node_modules/twilio-client/es5/twilio/pstream.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar C = __webpack_require__(/*! ./constants */ \"./node_modules/twilio-client/es5/twilio/constants.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar Log = __webpack_require__(/*! ./log */ \"./node_modules/twilio-client/es5/twilio/log.js\").default;\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nvar WSTransport = __webpack_require__(/*! ./wstransport */ \"./node_modules/twilio-client/es5/twilio/wstransport.js\").default;\n\nvar _require = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\"),\n    GeneralErrors = _require.GeneralErrors,\n    SignalingErrors = _require.SignalingErrors;\n\nvar PSTREAM_VERSION = '1.5';\n\n/**\n * Constructor for PStream objects.\n *\n * @exports PStream as Twilio.PStream\n * @memberOf Twilio\n * @borrows EventEmitter#addListener as #addListener\n * @borrows EventEmitter#removeListener as #removeListener\n * @borrows EventEmitter#emit as #emit\n * @borrows EventEmitter#hasListener as #hasListener\n * @constructor\n * @param {string} token The Twilio capabilities JWT\n * @param {string[]} uris An array of PStream endpoint URIs\n * @param {object} [options]\n * @config {boolean} [options.backoffMaxMs=20000] Enable debugging\n */\nfunction PStream(token, uris, options) {\n  if (!(this instanceof PStream)) {\n    return new PStream(token, uris, options);\n  }\n  var defaults = {\n    TransportFactory: WSTransport\n  };\n  options = options || {};\n  for (var prop in defaults) {\n    if (prop in options) continue;\n    options[prop] = defaults[prop];\n  }\n  this.options = options;\n  this.token = token || '';\n  this.status = 'disconnected';\n  this.gateway = null;\n  this.region = null;\n  this._messageQueue = [];\n  this._uris = uris;\n\n  this._handleTransportClose = this._handleTransportClose.bind(this);\n  this._handleTransportError = this._handleTransportError.bind(this);\n  this._handleTransportMessage = this._handleTransportMessage.bind(this);\n  this._handleTransportOpen = this._handleTransportOpen.bind(this);\n\n  this._log = Log.getInstance();\n\n  // NOTE(mroberts): EventEmitter requires that we catch all errors.\n  this.on('error', function () {});\n\n  /*\n   *events used by device\n   *'invite',\n   *'ready',\n   *'error',\n   *'offline',\n   *\n   *'cancel',\n   *'presence',\n   *'roster',\n   *'answer',\n   *'candidate',\n   *'hangup'\n   */\n\n  var self = this;\n\n  this.addListener('ready', function () {\n    self.status = 'ready';\n  });\n\n  this.addListener('offline', function () {\n    self.status = 'offline';\n  });\n\n  this.addListener('close', function () {\n    self._log.info('Received \"close\" from server. Destroying PStream...');\n    self._destroy();\n  });\n\n  this.transport = new this.options.TransportFactory(this._uris, {\n    backoffMaxMs: this.options.backoffMaxMs\n  });\n\n  Object.defineProperties(this, {\n    uri: {\n      enumerable: true,\n      get: function get() {\n        return this.transport.uri;\n      }\n    }\n  });\n\n  this.transport.on('close', this._handleTransportClose);\n  this.transport.on('error', this._handleTransportError);\n  this.transport.on('message', this._handleTransportMessage);\n  this.transport.on('open', this._handleTransportOpen);\n  this.transport.open();\n\n  return this;\n}\n\nutil.inherits(PStream, EventEmitter);\n\nPStream.prototype._handleTransportClose = function () {\n  this.emit('transportClose');\n\n  if (this.status !== 'disconnected') {\n    if (this.status !== 'offline') {\n      this.emit('offline', this);\n    }\n    this.status = 'disconnected';\n  }\n};\n\nPStream.prototype._handleTransportError = function (error) {\n  if (!error) {\n    this.emit('error', { error: {\n        code: 31000,\n        message: 'Websocket closed without a provided reason',\n        twilioError: new SignalingErrors.ConnectionDisconnected()\n      } });\n    return;\n  }\n  // We receive some errors without call metadata (just the error). We need to convert these\n  // to be contained within the 'error' field so that these errors match the expected format.\n  this.emit('error', typeof error.code !== 'undefined' ? { error: error } : error);\n};\n\nPStream.prototype._handleTransportMessage = function (msg) {\n  if (!msg || !msg.data || typeof msg.data !== 'string') {\n    return;\n  }\n\n  var _JSON$parse = JSON.parse(msg.data),\n      type = _JSON$parse.type,\n      _JSON$parse$payload = _JSON$parse.payload,\n      payload = _JSON$parse$payload === undefined ? {} : _JSON$parse$payload;\n\n  this.gateway = payload.gateway || this.gateway;\n  this.region = payload.region || this.region;\n\n  if (type === 'error' && payload.error) {\n    payload.error.twilioError = new SignalingErrors.ConnectionError();\n  }\n\n  this.emit(type, payload);\n};\n\nPStream.prototype._handleTransportOpen = function () {\n  var _this = this;\n\n  this.status = 'connected';\n  this.setToken(this.token);\n\n  var messages = this._messageQueue.splice(0, this._messageQueue.length);\n  messages.forEach(function (message) {\n    return _this._publish.apply(_this, _toConsumableArray(message));\n  });\n};\n\n/**\n * @return {string}\n */\nPStream.toString = function () {\n  return '[Twilio.PStream class]';\n};\nPStream.prototype.toString = function () {\n  return '[Twilio.PStream instance]';\n};\n\nPStream.prototype.setToken = function (token) {\n  this._log.info('Setting token and publishing listen');\n  this.token = token;\n  var payload = {\n    token: token,\n    browserinfo: getBrowserInfo()\n  };\n  this._publish('listen', payload);\n};\n\nPStream.prototype.register = function (mediaCapabilities) {\n  var regPayload = {\n    media: mediaCapabilities\n  };\n  this._publish('register', regPayload, true);\n};\n\nPStream.prototype.invite = function (sdp, callsid, preflight, params) {\n  var payload = {\n    callsid: callsid,\n    sdp: sdp,\n    preflight: !!preflight,\n    twilio: params ? { params: params } : {}\n  };\n  this._publish('invite', payload, true);\n};\n\nPStream.prototype.answer = function (sdp, callsid) {\n  this._publish('answer', { sdp: sdp, callsid: callsid }, true);\n};\n\nPStream.prototype.dtmf = function (callsid, digits) {\n  this._publish('dtmf', { callsid: callsid, dtmf: digits }, true);\n};\n\nPStream.prototype.hangup = function (callsid, message) {\n  var payload = message ? { callsid: callsid, message: message } : { callsid: callsid };\n  this._publish('hangup', payload, true);\n};\n\nPStream.prototype.reject = function (callsid) {\n  this._publish('reject', { callsid: callsid }, true);\n};\n\nPStream.prototype.reinvite = function (sdp, callsid) {\n  this._publish('reinvite', { sdp: sdp, callsid: callsid }, false);\n};\n\nPStream.prototype._destroy = function () {\n  this.transport.removeListener('close', this._handleTransportClose);\n  this.transport.removeListener('error', this._handleTransportError);\n  this.transport.removeListener('message', this._handleTransportMessage);\n  this.transport.removeListener('open', this._handleTransportOpen);\n  this.transport.close();\n\n  this.emit('offline', this);\n};\n\nPStream.prototype.destroy = function () {\n  this._log.info('PStream.destroy() called...');\n  this._destroy();\n  return this;\n};\n\nPStream.prototype.publish = function (type, payload) {\n  return this._publish(type, payload, true);\n};\n\nPStream.prototype._publish = function (type, payload, shouldRetry) {\n  var msg = JSON.stringify({\n    type: type,\n    version: PSTREAM_VERSION,\n    payload: payload\n  });\n  var isSent = !!this.transport.send(msg);\n\n  if (!isSent) {\n    this.emit('error', { error: {\n        code: 31009,\n        message: 'No transport available to send or receive messages',\n        twilioError: new GeneralErrors.TransportError()\n      } });\n\n    if (shouldRetry) {\n      this._messageQueue.push([type, payload, true]);\n    }\n  }\n};\n\nfunction getBrowserInfo() {\n  var nav = typeof navigator !== 'undefined' ? navigator : {};\n\n  var info = {\n    p: 'browser',\n    v: C.RELEASE_VERSION,\n    browser: {\n      userAgent: nav.userAgent || 'unknown',\n      platform: nav.platform || 'unknown'\n    },\n    plugin: 'rtc'\n  };\n\n  return info;\n}\n\nmodule.exports = PStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3BzdHJlYW0uanM/NWMyMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0MsMEJBQTBCLDBDQUEwQyxnQkFBZ0IsT0FBTyxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsT0FBTyx3QkFBd0IsRUFBRTs7QUFFak0sUUFBUSxtQkFBTyxDQUFDLHlFQUFhO0FBQzdCLG1CQUFtQixpRkFBOEI7QUFDakQsVUFBVSwwRkFBd0I7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLHlDQUFNOztBQUV6QixrQkFBa0IsMEdBQWdDOztBQUVsRCxlQUFlLG1CQUFPLENBQUMseUVBQVU7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7O0FBRUE7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEOztBQUVBO0FBQ0EsMkJBQTJCLHFDQUFxQyxJQUFJO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsbUJBQW1CO0FBQzlDOztBQUVBO0FBQ0EsNkJBQTZCLDZCQUE2QjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcHN0cmVhbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBDID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgTG9nID0gcmVxdWlyZSgnLi9sb2cnKS5kZWZhdWx0O1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBXU1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4vd3N0cmFuc3BvcnQnKS5kZWZhdWx0O1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2Vycm9ycycpLFxuICAgIEdlbmVyYWxFcnJvcnMgPSBfcmVxdWlyZS5HZW5lcmFsRXJyb3JzLFxuICAgIFNpZ25hbGluZ0Vycm9ycyA9IF9yZXF1aXJlLlNpZ25hbGluZ0Vycm9ycztcblxudmFyIFBTVFJFQU1fVkVSU0lPTiA9ICcxLjUnO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIGZvciBQU3RyZWFtIG9iamVjdHMuXG4gKlxuICogQGV4cG9ydHMgUFN0cmVhbSBhcyBUd2lsaW8uUFN0cmVhbVxuICogQG1lbWJlck9mIFR3aWxpb1xuICogQGJvcnJvd3MgRXZlbnRFbWl0dGVyI2FkZExpc3RlbmVyIGFzICNhZGRMaXN0ZW5lclxuICogQGJvcnJvd3MgRXZlbnRFbWl0dGVyI3JlbW92ZUxpc3RlbmVyIGFzICNyZW1vdmVMaXN0ZW5lclxuICogQGJvcnJvd3MgRXZlbnRFbWl0dGVyI2VtaXQgYXMgI2VtaXRcbiAqIEBib3Jyb3dzIEV2ZW50RW1pdHRlciNoYXNMaXN0ZW5lciBhcyAjaGFzTGlzdGVuZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIFRoZSBUd2lsaW8gY2FwYWJpbGl0aWVzIEpXVFxuICogQHBhcmFtIHtzdHJpbmdbXX0gdXJpcyBBbiBhcnJheSBvZiBQU3RyZWFtIGVuZHBvaW50IFVSSXNcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25maWcge2Jvb2xlYW59IFtvcHRpb25zLmJhY2tvZmZNYXhNcz0yMDAwMF0gRW5hYmxlIGRlYnVnZ2luZ1xuICovXG5mdW5jdGlvbiBQU3RyZWFtKHRva2VuLCB1cmlzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQU3RyZWFtKSkge1xuICAgIHJldHVybiBuZXcgUFN0cmVhbSh0b2tlbiwgdXJpcywgb3B0aW9ucyk7XG4gIH1cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIFRyYW5zcG9ydEZhY3Rvcnk6IFdTVHJhbnNwb3J0XG4gIH07XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHByb3AgaW4gb3B0aW9ucykgY29udGludWU7XG4gICAgb3B0aW9uc1twcm9wXSA9IGRlZmF1bHRzW3Byb3BdO1xuICB9XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMudG9rZW4gPSB0b2tlbiB8fCAnJztcbiAgdGhpcy5zdGF0dXMgPSAnZGlzY29ubmVjdGVkJztcbiAgdGhpcy5nYXRld2F5ID0gbnVsbDtcbiAgdGhpcy5yZWdpb24gPSBudWxsO1xuICB0aGlzLl9tZXNzYWdlUXVldWUgPSBbXTtcbiAgdGhpcy5fdXJpcyA9IHVyaXM7XG5cbiAgdGhpcy5faGFuZGxlVHJhbnNwb3J0Q2xvc2UgPSB0aGlzLl9oYW5kbGVUcmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpO1xuICB0aGlzLl9oYW5kbGVUcmFuc3BvcnRFcnJvciA9IHRoaXMuX2hhbmRsZVRyYW5zcG9ydEVycm9yLmJpbmQodGhpcyk7XG4gIHRoaXMuX2hhbmRsZVRyYW5zcG9ydE1lc3NhZ2UgPSB0aGlzLl9oYW5kbGVUcmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcyk7XG4gIHRoaXMuX2hhbmRsZVRyYW5zcG9ydE9wZW4gPSB0aGlzLl9oYW5kbGVUcmFuc3BvcnRPcGVuLmJpbmQodGhpcyk7XG5cbiAgdGhpcy5fbG9nID0gTG9nLmdldEluc3RhbmNlKCk7XG5cbiAgLy8gTk9URShtcm9iZXJ0cyk6IEV2ZW50RW1pdHRlciByZXF1aXJlcyB0aGF0IHdlIGNhdGNoIGFsbCBlcnJvcnMuXG4gIHRoaXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKCkge30pO1xuXG4gIC8qXG4gICAqZXZlbnRzIHVzZWQgYnkgZGV2aWNlXG4gICAqJ2ludml0ZScsXG4gICAqJ3JlYWR5JyxcbiAgIConZXJyb3InLFxuICAgKidvZmZsaW5lJyxcbiAgICpcbiAgIConY2FuY2VsJyxcbiAgIConcHJlc2VuY2UnLFxuICAgKidyb3N0ZXInLFxuICAgKidhbnN3ZXInLFxuICAgKidjYW5kaWRhdGUnLFxuICAgKidoYW5ndXAnXG4gICAqL1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmFkZExpc3RlbmVyKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnN0YXR1cyA9ICdyZWFkeSc7XG4gIH0pO1xuXG4gIHRoaXMuYWRkTGlzdGVuZXIoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5zdGF0dXMgPSAnb2ZmbGluZSc7XG4gIH0pO1xuXG4gIHRoaXMuYWRkTGlzdGVuZXIoJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2xvZy5pbmZvKCdSZWNlaXZlZCBcImNsb3NlXCIgZnJvbSBzZXJ2ZXIuIERlc3Ryb3lpbmcgUFN0cmVhbS4uLicpO1xuICAgIHNlbGYuX2Rlc3Ryb3koKTtcbiAgfSk7XG5cbiAgdGhpcy50cmFuc3BvcnQgPSBuZXcgdGhpcy5vcHRpb25zLlRyYW5zcG9ydEZhY3RvcnkodGhpcy5fdXJpcywge1xuICAgIGJhY2tvZmZNYXhNczogdGhpcy5vcHRpb25zLmJhY2tvZmZNYXhNc1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgdXJpOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC51cmk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB0aGlzLnRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl9oYW5kbGVUcmFuc3BvcnRDbG9zZSk7XG4gIHRoaXMudHJhbnNwb3J0Lm9uKCdlcnJvcicsIHRoaXMuX2hhbmRsZVRyYW5zcG9ydEVycm9yKTtcbiAgdGhpcy50cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVUcmFuc3BvcnRNZXNzYWdlKTtcbiAgdGhpcy50cmFuc3BvcnQub24oJ29wZW4nLCB0aGlzLl9oYW5kbGVUcmFuc3BvcnRPcGVuKTtcbiAgdGhpcy50cmFuc3BvcnQub3BlbigpO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG51dGlsLmluaGVyaXRzKFBTdHJlYW0sIEV2ZW50RW1pdHRlcik7XG5cblBTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVUcmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCd0cmFuc3BvcnRDbG9zZScpO1xuXG4gIGlmICh0aGlzLnN0YXR1cyAhPT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICBpZiAodGhpcy5zdGF0dXMgIT09ICdvZmZsaW5lJykge1xuICAgICAgdGhpcy5lbWl0KCdvZmZsaW5lJywgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdHVzID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gIH1cbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVUcmFuc3BvcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICBpZiAoIWVycm9yKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIHsgZXJyb3I6IHtcbiAgICAgICAgY29kZTogMzEwMDAsXG4gICAgICAgIG1lc3NhZ2U6ICdXZWJzb2NrZXQgY2xvc2VkIHdpdGhvdXQgYSBwcm92aWRlZCByZWFzb24nLFxuICAgICAgICB0d2lsaW9FcnJvcjogbmV3IFNpZ25hbGluZ0Vycm9ycy5Db25uZWN0aW9uRGlzY29ubmVjdGVkKClcbiAgICAgIH0gfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFdlIHJlY2VpdmUgc29tZSBlcnJvcnMgd2l0aG91dCBjYWxsIG1ldGFkYXRhIChqdXN0IHRoZSBlcnJvcikuIFdlIG5lZWQgdG8gY29udmVydCB0aGVzZVxuICAvLyB0byBiZSBjb250YWluZWQgd2l0aGluIHRoZSAnZXJyb3InIGZpZWxkIHNvIHRoYXQgdGhlc2UgZXJyb3JzIG1hdGNoIHRoZSBleHBlY3RlZCBmb3JtYXQuXG4gIHRoaXMuZW1pdCgnZXJyb3InLCB0eXBlb2YgZXJyb3IuY29kZSAhPT0gJ3VuZGVmaW5lZCcgPyB7IGVycm9yOiBlcnJvciB9IDogZXJyb3IpO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUuX2hhbmRsZVRyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnKSB7XG4gIGlmICghbXNnIHx8ICFtc2cuZGF0YSB8fCB0eXBlb2YgbXNnLmRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9KU09OJHBhcnNlID0gSlNPTi5wYXJzZShtc2cuZGF0YSksXG4gICAgICB0eXBlID0gX0pTT04kcGFyc2UudHlwZSxcbiAgICAgIF9KU09OJHBhcnNlJHBheWxvYWQgPSBfSlNPTiRwYXJzZS5wYXlsb2FkLFxuICAgICAgcGF5bG9hZCA9IF9KU09OJHBhcnNlJHBheWxvYWQgPT09IHVuZGVmaW5lZCA/IHt9IDogX0pTT04kcGFyc2UkcGF5bG9hZDtcblxuICB0aGlzLmdhdGV3YXkgPSBwYXlsb2FkLmdhdGV3YXkgfHwgdGhpcy5nYXRld2F5O1xuICB0aGlzLnJlZ2lvbiA9IHBheWxvYWQucmVnaW9uIHx8IHRoaXMucmVnaW9uO1xuXG4gIGlmICh0eXBlID09PSAnZXJyb3InICYmIHBheWxvYWQuZXJyb3IpIHtcbiAgICBwYXlsb2FkLmVycm9yLnR3aWxpb0Vycm9yID0gbmV3IFNpZ25hbGluZ0Vycm9ycy5Db25uZWN0aW9uRXJyb3IoKTtcbiAgfVxuXG4gIHRoaXMuZW1pdCh0eXBlLCBwYXlsb2FkKTtcbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLl9oYW5kbGVUcmFuc3BvcnRPcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMuc3RhdHVzID0gJ2Nvbm5lY3RlZCc7XG4gIHRoaXMuc2V0VG9rZW4odGhpcy50b2tlbik7XG5cbiAgdmFyIG1lc3NhZ2VzID0gdGhpcy5fbWVzc2FnZVF1ZXVlLnNwbGljZSgwLCB0aGlzLl9tZXNzYWdlUXVldWUubGVuZ3RoKTtcbiAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHJldHVybiBfdGhpcy5fcHVibGlzaC5hcHBseShfdGhpcywgX3RvQ29uc3VtYWJsZUFycmF5KG1lc3NhZ2UpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUFN0cmVhbS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdbVHdpbGlvLlBTdHJlYW0gY2xhc3NdJztcbn07XG5QU3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdbVHdpbGlvLlBTdHJlYW0gaW5zdGFuY2VdJztcbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLnNldFRva2VuID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHRoaXMuX2xvZy5pbmZvKCdTZXR0aW5nIHRva2VuIGFuZCBwdWJsaXNoaW5nIGxpc3RlbicpO1xuICB0aGlzLnRva2VuID0gdG9rZW47XG4gIHZhciBwYXlsb2FkID0ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBicm93c2VyaW5mbzogZ2V0QnJvd3NlckluZm8oKVxuICB9O1xuICB0aGlzLl9wdWJsaXNoKCdsaXN0ZW4nLCBwYXlsb2FkKTtcbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKG1lZGlhQ2FwYWJpbGl0aWVzKSB7XG4gIHZhciByZWdQYXlsb2FkID0ge1xuICAgIG1lZGlhOiBtZWRpYUNhcGFiaWxpdGllc1xuICB9O1xuICB0aGlzLl9wdWJsaXNoKCdyZWdpc3RlcicsIHJlZ1BheWxvYWQsIHRydWUpO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24gKHNkcCwgY2FsbHNpZCwgcHJlZmxpZ2h0LCBwYXJhbXMpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgY2FsbHNpZDogY2FsbHNpZCxcbiAgICBzZHA6IHNkcCxcbiAgICBwcmVmbGlnaHQ6ICEhcHJlZmxpZ2h0LFxuICAgIHR3aWxpbzogcGFyYW1zID8geyBwYXJhbXM6IHBhcmFtcyB9IDoge31cbiAgfTtcbiAgdGhpcy5fcHVibGlzaCgnaW52aXRlJywgcGF5bG9hZCwgdHJ1ZSk7XG59O1xuXG5QU3RyZWFtLnByb3RvdHlwZS5hbnN3ZXIgPSBmdW5jdGlvbiAoc2RwLCBjYWxsc2lkKSB7XG4gIHRoaXMuX3B1Ymxpc2goJ2Fuc3dlcicsIHsgc2RwOiBzZHAsIGNhbGxzaWQ6IGNhbGxzaWQgfSwgdHJ1ZSk7XG59O1xuXG5QU3RyZWFtLnByb3RvdHlwZS5kdG1mID0gZnVuY3Rpb24gKGNhbGxzaWQsIGRpZ2l0cykge1xuICB0aGlzLl9wdWJsaXNoKCdkdG1mJywgeyBjYWxsc2lkOiBjYWxsc2lkLCBkdG1mOiBkaWdpdHMgfSwgdHJ1ZSk7XG59O1xuXG5QU3RyZWFtLnByb3RvdHlwZS5oYW5ndXAgPSBmdW5jdGlvbiAoY2FsbHNpZCwgbWVzc2FnZSkge1xuICB2YXIgcGF5bG9hZCA9IG1lc3NhZ2UgPyB7IGNhbGxzaWQ6IGNhbGxzaWQsIG1lc3NhZ2U6IG1lc3NhZ2UgfSA6IHsgY2FsbHNpZDogY2FsbHNpZCB9O1xuICB0aGlzLl9wdWJsaXNoKCdoYW5ndXAnLCBwYXlsb2FkLCB0cnVlKTtcbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChjYWxsc2lkKSB7XG4gIHRoaXMuX3B1Ymxpc2goJ3JlamVjdCcsIHsgY2FsbHNpZDogY2FsbHNpZCB9LCB0cnVlKTtcbn07XG5cblBTdHJlYW0ucHJvdG90eXBlLnJlaW52aXRlID0gZnVuY3Rpb24gKHNkcCwgY2FsbHNpZCkge1xuICB0aGlzLl9wdWJsaXNoKCdyZWludml0ZScsIHsgc2RwOiBzZHAsIGNhbGxzaWQ6IGNhbGxzaWQgfSwgZmFsc2UpO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHRoaXMuX2hhbmRsZVRyYW5zcG9ydENsb3NlKTtcbiAgdGhpcy50cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5faGFuZGxlVHJhbnNwb3J0RXJyb3IpO1xuICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX2hhbmRsZVRyYW5zcG9ydE1lc3NhZ2UpO1xuICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIHRoaXMuX2hhbmRsZVRyYW5zcG9ydE9wZW4pO1xuICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gIHRoaXMuZW1pdCgnb2ZmbGluZScsIHRoaXMpO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbG9nLmluZm8oJ1BTdHJlYW0uZGVzdHJveSgpIGNhbGxlZC4uLicpO1xuICB0aGlzLl9kZXN0cm95KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICh0eXBlLCBwYXlsb2FkKSB7XG4gIHJldHVybiB0aGlzLl9wdWJsaXNoKHR5cGUsIHBheWxvYWQsIHRydWUpO1xufTtcblxuUFN0cmVhbS5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbiAodHlwZSwgcGF5bG9hZCwgc2hvdWxkUmV0cnkpIHtcbiAgdmFyIG1zZyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZlcnNpb246IFBTVFJFQU1fVkVSU0lPTixcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH0pO1xuICB2YXIgaXNTZW50ID0gISF0aGlzLnRyYW5zcG9ydC5zZW5kKG1zZyk7XG5cbiAgaWYgKCFpc1NlbnQpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgeyBlcnJvcjoge1xuICAgICAgICBjb2RlOiAzMTAwOSxcbiAgICAgICAgbWVzc2FnZTogJ05vIHRyYW5zcG9ydCBhdmFpbGFibGUgdG8gc2VuZCBvciByZWNlaXZlIG1lc3NhZ2VzJyxcbiAgICAgICAgdHdpbGlvRXJyb3I6IG5ldyBHZW5lcmFsRXJyb3JzLlRyYW5zcG9ydEVycm9yKClcbiAgICAgIH0gfSk7XG5cbiAgICBpZiAoc2hvdWxkUmV0cnkpIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZS5wdXNoKFt0eXBlLCBwYXlsb2FkLCB0cnVlXSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpIHtcbiAgdmFyIG5hdiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yIDoge307XG5cbiAgdmFyIGluZm8gPSB7XG4gICAgcDogJ2Jyb3dzZXInLFxuICAgIHY6IEMuUkVMRUFTRV9WRVJTSU9OLFxuICAgIGJyb3dzZXI6IHtcbiAgICAgIHVzZXJBZ2VudDogbmF2LnVzZXJBZ2VudCB8fCAndW5rbm93bicsXG4gICAgICBwbGF0Zm9ybTogbmF2LnBsYXRmb3JtIHx8ICd1bmtub3duJ1xuICAgIH0sXG4gICAgcGx1Z2luOiAncnRjJ1xuICB9O1xuXG4gIHJldHVybiBpbmZvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBTdHJlYW07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/pstream.js\n")},"./node_modules/twilio-client/es5/twilio/regions.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n/**\n * @packageDocumentation\n * @module Voice\n * This module describes valid and deprecated regions.\n */\nvar errors_1 = __webpack_require__(/*! ./errors */ "./node_modules/twilio-client/es5/twilio/errors/index.js");\n/**\n * Valid deprecated regions.\n * @private\n */\nvar DeprecatedRegion;\n(function (DeprecatedRegion) {\n    DeprecatedRegion["Au"] = "au";\n    DeprecatedRegion["Br"] = "br";\n    DeprecatedRegion["Ie"] = "ie";\n    DeprecatedRegion["Jp"] = "jp";\n    DeprecatedRegion["Sg"] = "sg";\n    DeprecatedRegion["UsOr"] = "us-or";\n    DeprecatedRegion["UsVa"] = "us-va";\n})(DeprecatedRegion = exports.DeprecatedRegion || (exports.DeprecatedRegion = {}));\n/**\n * Valid edges.\n * @private\n */\nvar Edge;\n(function (Edge) {\n    /**\n     * Public edges\n     */\n    Edge["Sydney"] = "sydney";\n    Edge["SaoPaulo"] = "sao-paulo";\n    Edge["Dublin"] = "dublin";\n    Edge["Frankfurt"] = "frankfurt";\n    Edge["Tokyo"] = "tokyo";\n    Edge["Singapore"] = "singapore";\n    Edge["Ashburn"] = "ashburn";\n    Edge["Umatilla"] = "umatilla";\n    Edge["Roaming"] = "roaming";\n    /**\n     * Interconnect edges\n     */\n    Edge["AshburnIx"] = "ashburn-ix";\n    Edge["SanJoseIx"] = "san-jose-ix";\n    Edge["LondonIx"] = "london-ix";\n    Edge["FrankfurtIx"] = "frankfurt-ix";\n    Edge["SingaporeIx"] = "singapore-ix";\n    Edge["SydneyIx"] = "sydney-ix";\n    Edge["TokyoIx"] = "tokyo-ix";\n})(Edge = exports.Edge || (exports.Edge = {}));\n/**\n * Valid current regions.\n *\n * @deprecated\n *\n * CLIENT-6831\n * This is no longer used or updated for checking validity of regions in the\n * SDK. We now allow any string to be passed for region. Invalid regions won\'t\n * be able to connect, and won\'t throw an exception.\n *\n * CLIENT-7519\n * This is used again to temporarily convert edge values to regions as part of\n * Phase 1 Regional. This is still considered deprecated.\n *\n * @private\n */\nvar Region;\n(function (Region) {\n    Region["Au1"] = "au1";\n    Region["Au1Ix"] = "au1-ix";\n    Region["Br1"] = "br1";\n    Region["De1"] = "de1";\n    Region["De1Ix"] = "de1-ix";\n    Region["Gll"] = "gll";\n    Region["Ie1"] = "ie1";\n    Region["Ie1Ix"] = "ie1-ix";\n    Region["Ie1Tnx"] = "ie1-tnx";\n    Region["Jp1"] = "jp1";\n    Region["Jp1Ix"] = "jp1-ix";\n    Region["Sg1"] = "sg1";\n    Region["Sg1Ix"] = "sg1-ix";\n    Region["Sg1Tnx"] = "sg1-tnx";\n    Region["Us1"] = "us1";\n    Region["Us1Ix"] = "us1-ix";\n    Region["Us1Tnx"] = "us1-tnx";\n    Region["Us2"] = "us2";\n    Region["Us2Ix"] = "us2-ix";\n    Region["Us2Tnx"] = "us2-tnx";\n})(Region = exports.Region || (exports.Region = {}));\n/**\n * Deprecated regions. Maps the deprecated region to its equivalent up-to-date region.\n * @private\n */\nexports.deprecatedRegions = (_a = {},\n    _a[DeprecatedRegion.Au] = Region.Au1,\n    _a[DeprecatedRegion.Br] = Region.Br1,\n    _a[DeprecatedRegion.Ie] = Region.Ie1,\n    _a[DeprecatedRegion.Jp] = Region.Jp1,\n    _a[DeprecatedRegion.Sg] = Region.Sg1,\n    _a[DeprecatedRegion.UsOr] = Region.Us1,\n    _a[DeprecatedRegion.UsVa] = Region.Us1,\n    _a);\n/**\n * Region shortcodes. Maps the full region name from AWS to the Twilio shortcode.\n * @private\n */\nexports.regionShortcodes = {\n    ASIAPAC_SINGAPORE: Region.Sg1,\n    ASIAPAC_SYDNEY: Region.Au1,\n    ASIAPAC_TOKYO: Region.Jp1,\n    EU_FRANKFURT: Region.De1,\n    EU_IRELAND: Region.Ie1,\n    SOUTH_AMERICA_SAO_PAULO: Region.Br1,\n    US_EAST_VIRGINIA: Region.Us1,\n    US_WEST_OREGON: Region.Us2,\n};\n/**\n * Region URIs. Maps the Twilio shortcode to its Twilio endpoint URI.\n * @private\n */\nvar regionURIs = (_b = {},\n    _b[Region.Au1] = \'chunderw-vpc-gll-au1.twilio.com\',\n    _b[Region.Au1Ix] = \'chunderw-vpc-gll-au1-ix.twilio.com\',\n    _b[Region.Br1] = \'chunderw-vpc-gll-br1.twilio.com\',\n    _b[Region.De1] = \'chunderw-vpc-gll-de1.twilio.com\',\n    _b[Region.De1Ix] = \'chunderw-vpc-gll-de1-ix.twilio.com\',\n    _b[Region.Gll] = \'chunderw-vpc-gll.twilio.com\',\n    _b[Region.Ie1] = \'chunderw-vpc-gll-ie1.twilio.com\',\n    _b[Region.Ie1Ix] = \'chunderw-vpc-gll-ie1-ix.twilio.com\',\n    _b[Region.Ie1Tnx] = \'chunderw-vpc-gll-ie1-tnx.twilio.com\',\n    _b[Region.Jp1] = \'chunderw-vpc-gll-jp1.twilio.com\',\n    _b[Region.Jp1Ix] = \'chunderw-vpc-gll-jp1-ix.twilio.com\',\n    _b[Region.Sg1] = \'chunderw-vpc-gll-sg1.twilio.com\',\n    _b[Region.Sg1Ix] = \'chunderw-vpc-gll-sg1-ix.twilio.com\',\n    _b[Region.Sg1Tnx] = \'chunderw-vpc-gll-sg1-tnx.twilio.com\',\n    _b[Region.Us1] = \'chunderw-vpc-gll-us1.twilio.com\',\n    _b[Region.Us1Ix] = \'chunderw-vpc-gll-us1-ix.twilio.com\',\n    _b[Region.Us1Tnx] = \'chunderw-vpc-gll-us1-tnx.twilio.com\',\n    _b[Region.Us2] = \'chunderw-vpc-gll-us2.twilio.com\',\n    _b[Region.Us2Ix] = \'chunderw-vpc-gll-us2-ix.twilio.com\',\n    _b[Region.Us2Tnx] = \'chunderw-vpc-gll-us2-tnx.twilio.com\',\n    _b);\n/**\n * Edge to region mapping, as part of Phase 1 Regional (CLIENT-7519).\n * Temporary.\n * @private\n */\nexports.edgeToRegion = (_c = {},\n    _c[Edge.Sydney] = Region.Au1,\n    _c[Edge.SaoPaulo] = Region.Br1,\n    _c[Edge.Dublin] = Region.Ie1,\n    _c[Edge.Frankfurt] = Region.De1,\n    _c[Edge.Tokyo] = Region.Jp1,\n    _c[Edge.Singapore] = Region.Sg1,\n    _c[Edge.Ashburn] = Region.Us1,\n    _c[Edge.Umatilla] = Region.Us2,\n    _c[Edge.Roaming] = Region.Gll,\n    /**\n     * Interconnect edges\n     */\n    _c[Edge.AshburnIx] = Region.Us1Ix,\n    _c[Edge.SanJoseIx] = Region.Us2Ix,\n    _c[Edge.LondonIx] = Region.Ie1Ix,\n    _c[Edge.FrankfurtIx] = Region.De1Ix,\n    _c[Edge.SingaporeIx] = Region.Sg1Ix,\n    _c[Edge.SydneyIx] = Region.Au1Ix,\n    _c[Edge.TokyoIx] = Region.Jp1Ix,\n    _c);\n/**\n * Region to edge mapping, as part of Phase 1 Regional (CLIENT-7519).\n * Temporary.\n * @private\n */\nexports.regionToEdge = (_d = {},\n    _d[Region.Au1] = Edge.Sydney,\n    _d[Region.Br1] = Edge.SaoPaulo,\n    _d[Region.Ie1] = Edge.Dublin,\n    _d[Region.De1] = Edge.Frankfurt,\n    _d[Region.Jp1] = Edge.Tokyo,\n    _d[Region.Sg1] = Edge.Singapore,\n    _d[Region.Us1] = Edge.Ashburn,\n    _d[Region.Us2] = Edge.Umatilla,\n    _d[Region.Gll] = Edge.Roaming,\n    /**\n     * Interconnect edges\n     */\n    _d[Region.Us1Ix] = Edge.AshburnIx,\n    _d[Region.Us2Ix] = Edge.SanJoseIx,\n    _d[Region.Ie1Ix] = Edge.LondonIx,\n    _d[Region.De1Ix] = Edge.FrankfurtIx,\n    _d[Region.Sg1Ix] = Edge.SingaporeIx,\n    _d[Region.Au1Ix] = Edge.SydneyIx,\n    _d[Region.Jp1Ix] = Edge.TokyoIx,\n    /**\n     * Tnx regions\n     */\n    _d[Region.Us1Tnx] = Edge.AshburnIx,\n    _d[Region.Us2Tnx] = Edge.AshburnIx,\n    _d[Region.Ie1Tnx] = Edge.LondonIx,\n    _d[Region.Sg1Tnx] = Edge.SingaporeIx,\n    _d);\n/**\n * The default region to connect to and create a chunder uri from if region is\n * not defined.\n * @constant\n * @private\n */\nexports.defaultRegion = \'gll\';\n/**\n * The default edge to connect to and create a chunder uri from, if the edge\n * parameter is not specified during setup in `Device`.\n * @constant\n */\nexports.defaultEdge = Edge.Roaming;\n/**\n * The default chunder URI to connect to, should map to region `gll`.\n * @constant\n * @private\n */\nexports.defaultChunderRegionURI = \'chunderw-vpc-gll.twilio.com\';\n/**\n * String template for a region chunder URI\n * @param region - The region.\n */\nfunction createChunderRegionUri(region) {\n    return region === exports.defaultRegion\n        ? exports.defaultChunderRegionURI\n        : "chunderw-vpc-gll-" + region + ".twilio.com";\n}\n/**\n * String template for an edge chunder URI\n * @param edge - The edge.\n */\nfunction createChunderEdgeUri(edge) {\n    return "voice-js." + edge + ".twilio.com";\n}\n/**\n * Get the URI associated with the passed region or edge. If both are passed,\n * then we want to fail `Device` setup, so we throw an error.\n * As of CLIENT-7519, Regions are deprecated in favor of edges as part of\n * Phase 1 Regional.\n *\n * @private\n * @param edge - A string or an array of edge values\n * @param region - The region shortcode.\n * @param [onDeprecated] - A callback containing the deprecation message to be\n *   warned when the passed parameters are deprecated.\n * @returns An array of chunder URIs\n */\nfunction getChunderURIs(edge, region, onDeprecated) {\n    if (!!region && typeof region !== \'string\') {\n        throw new errors_1.InvalidArgumentError(\'If `region` is provided, it must be of type `string`.\');\n    }\n    if (!!edge && typeof edge !== \'string\' && !Array.isArray(edge)) {\n        throw new errors_1.InvalidArgumentError(\'If `edge` is provided, it must be of type `string` or an array of strings.\');\n    }\n    var deprecatedMessages = [];\n    var uris;\n    if (region && edge) {\n        throw new errors_1.InvalidArgumentError(\'You cannot specify `region` when `edge` is specified in\' +\n            \'`Twilio.Device.Options`.\');\n    }\n    else if (region) {\n        var chunderRegion = region;\n        deprecatedMessages.push(\'Regions are deprecated in favor of edges. Please see this page for \' +\n            \'documentation: https://www.twilio.com/docs/voice/client/edges.\');\n        var isDeprecatedRegion = Object.values(DeprecatedRegion).includes(chunderRegion);\n        if (isDeprecatedRegion) {\n            chunderRegion = exports.deprecatedRegions[chunderRegion];\n        }\n        var isKnownRegion = Object.values(Region).includes(chunderRegion);\n        if (isKnownRegion) {\n            var preferredEdge = exports.regionToEdge[chunderRegion];\n            deprecatedMessages.push("Region \\"" + chunderRegion + "\\" is deprecated, please use `edge` " +\n                ("\\"" + preferredEdge + "\\"."));\n        }\n        uris = [createChunderRegionUri(chunderRegion)];\n    }\n    else if (edge) {\n        var edgeValues_1 = Object.values(Edge);\n        var edgeParams = Array.isArray(edge) ? edge : [edge];\n        uris = edgeParams.map(function (param) { return edgeValues_1.includes(param)\n            ? createChunderRegionUri(exports.edgeToRegion[param])\n            : createChunderEdgeUri(param); });\n    }\n    else {\n        uris = [exports.defaultChunderRegionURI];\n    }\n    if (onDeprecated && deprecatedMessages.length) {\n        setTimeout(function () { return onDeprecated(deprecatedMessages.join(\'\\n\')); });\n    }\n    return uris;\n}\nexports.getChunderURIs = getChunderURIs;\n/**\n * Get the region shortcode by its full AWS region string.\n *\n * @private\n * @param region - The region\'s full AWS string.\n */\nfunction getRegionShortcode(region) {\n    return exports.regionShortcodes[region] || null;\n}\nexports.getRegionShortcode = getRegionShortcode;\n//# sourceMappingURL=regions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3JlZ2lvbnMuanM/MTJjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMseUVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRCx3QkFBd0IsS0FBSztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLFlBQVksS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEIsY0FBYyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFvRCxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3JlZ2lvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfYSwgX2IsIF9jLCBfZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIFZvaWNlXG4gKiBUaGlzIG1vZHVsZSBkZXNjcmliZXMgdmFsaWQgYW5kIGRlcHJlY2F0ZWQgcmVnaW9ucy5cbiAqL1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBWYWxpZCBkZXByZWNhdGVkIHJlZ2lvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgRGVwcmVjYXRlZFJlZ2lvbjtcbihmdW5jdGlvbiAoRGVwcmVjYXRlZFJlZ2lvbikge1xuICAgIERlcHJlY2F0ZWRSZWdpb25bXCJBdVwiXSA9IFwiYXVcIjtcbiAgICBEZXByZWNhdGVkUmVnaW9uW1wiQnJcIl0gPSBcImJyXCI7XG4gICAgRGVwcmVjYXRlZFJlZ2lvbltcIkllXCJdID0gXCJpZVwiO1xuICAgIERlcHJlY2F0ZWRSZWdpb25bXCJKcFwiXSA9IFwianBcIjtcbiAgICBEZXByZWNhdGVkUmVnaW9uW1wiU2dcIl0gPSBcInNnXCI7XG4gICAgRGVwcmVjYXRlZFJlZ2lvbltcIlVzT3JcIl0gPSBcInVzLW9yXCI7XG4gICAgRGVwcmVjYXRlZFJlZ2lvbltcIlVzVmFcIl0gPSBcInVzLXZhXCI7XG59KShEZXByZWNhdGVkUmVnaW9uID0gZXhwb3J0cy5EZXByZWNhdGVkUmVnaW9uIHx8IChleHBvcnRzLkRlcHJlY2F0ZWRSZWdpb24gPSB7fSkpO1xuLyoqXG4gKiBWYWxpZCBlZGdlcy5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBFZGdlO1xuKGZ1bmN0aW9uIChFZGdlKSB7XG4gICAgLyoqXG4gICAgICogUHVibGljIGVkZ2VzXG4gICAgICovXG4gICAgRWRnZVtcIlN5ZG5leVwiXSA9IFwic3lkbmV5XCI7XG4gICAgRWRnZVtcIlNhb1BhdWxvXCJdID0gXCJzYW8tcGF1bG9cIjtcbiAgICBFZGdlW1wiRHVibGluXCJdID0gXCJkdWJsaW5cIjtcbiAgICBFZGdlW1wiRnJhbmtmdXJ0XCJdID0gXCJmcmFua2Z1cnRcIjtcbiAgICBFZGdlW1wiVG9reW9cIl0gPSBcInRva3lvXCI7XG4gICAgRWRnZVtcIlNpbmdhcG9yZVwiXSA9IFwic2luZ2Fwb3JlXCI7XG4gICAgRWRnZVtcIkFzaGJ1cm5cIl0gPSBcImFzaGJ1cm5cIjtcbiAgICBFZGdlW1wiVW1hdGlsbGFcIl0gPSBcInVtYXRpbGxhXCI7XG4gICAgRWRnZVtcIlJvYW1pbmdcIl0gPSBcInJvYW1pbmdcIjtcbiAgICAvKipcbiAgICAgKiBJbnRlcmNvbm5lY3QgZWRnZXNcbiAgICAgKi9cbiAgICBFZGdlW1wiQXNoYnVybkl4XCJdID0gXCJhc2hidXJuLWl4XCI7XG4gICAgRWRnZVtcIlNhbkpvc2VJeFwiXSA9IFwic2FuLWpvc2UtaXhcIjtcbiAgICBFZGdlW1wiTG9uZG9uSXhcIl0gPSBcImxvbmRvbi1peFwiO1xuICAgIEVkZ2VbXCJGcmFua2Z1cnRJeFwiXSA9IFwiZnJhbmtmdXJ0LWl4XCI7XG4gICAgRWRnZVtcIlNpbmdhcG9yZUl4XCJdID0gXCJzaW5nYXBvcmUtaXhcIjtcbiAgICBFZGdlW1wiU3lkbmV5SXhcIl0gPSBcInN5ZG5leS1peFwiO1xuICAgIEVkZ2VbXCJUb2t5b0l4XCJdID0gXCJ0b2t5by1peFwiO1xufSkoRWRnZSA9IGV4cG9ydHMuRWRnZSB8fCAoZXhwb3J0cy5FZGdlID0ge30pKTtcbi8qKlxuICogVmFsaWQgY3VycmVudCByZWdpb25zLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogQ0xJRU5ULTY4MzFcbiAqIFRoaXMgaXMgbm8gbG9uZ2VyIHVzZWQgb3IgdXBkYXRlZCBmb3IgY2hlY2tpbmcgdmFsaWRpdHkgb2YgcmVnaW9ucyBpbiB0aGVcbiAqIFNESy4gV2Ugbm93IGFsbG93IGFueSBzdHJpbmcgdG8gYmUgcGFzc2VkIGZvciByZWdpb24uIEludmFsaWQgcmVnaW9ucyB3b24ndFxuICogYmUgYWJsZSB0byBjb25uZWN0LCBhbmQgd29uJ3QgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICpcbiAqIENMSUVOVC03NTE5XG4gKiBUaGlzIGlzIHVzZWQgYWdhaW4gdG8gdGVtcG9yYXJpbHkgY29udmVydCBlZGdlIHZhbHVlcyB0byByZWdpb25zIGFzIHBhcnQgb2ZcbiAqIFBoYXNlIDEgUmVnaW9uYWwuIFRoaXMgaXMgc3RpbGwgY29uc2lkZXJlZCBkZXByZWNhdGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBSZWdpb247XG4oZnVuY3Rpb24gKFJlZ2lvbikge1xuICAgIFJlZ2lvbltcIkF1MVwiXSA9IFwiYXUxXCI7XG4gICAgUmVnaW9uW1wiQXUxSXhcIl0gPSBcImF1MS1peFwiO1xuICAgIFJlZ2lvbltcIkJyMVwiXSA9IFwiYnIxXCI7XG4gICAgUmVnaW9uW1wiRGUxXCJdID0gXCJkZTFcIjtcbiAgICBSZWdpb25bXCJEZTFJeFwiXSA9IFwiZGUxLWl4XCI7XG4gICAgUmVnaW9uW1wiR2xsXCJdID0gXCJnbGxcIjtcbiAgICBSZWdpb25bXCJJZTFcIl0gPSBcImllMVwiO1xuICAgIFJlZ2lvbltcIkllMUl4XCJdID0gXCJpZTEtaXhcIjtcbiAgICBSZWdpb25bXCJJZTFUbnhcIl0gPSBcImllMS10bnhcIjtcbiAgICBSZWdpb25bXCJKcDFcIl0gPSBcImpwMVwiO1xuICAgIFJlZ2lvbltcIkpwMUl4XCJdID0gXCJqcDEtaXhcIjtcbiAgICBSZWdpb25bXCJTZzFcIl0gPSBcInNnMVwiO1xuICAgIFJlZ2lvbltcIlNnMUl4XCJdID0gXCJzZzEtaXhcIjtcbiAgICBSZWdpb25bXCJTZzFUbnhcIl0gPSBcInNnMS10bnhcIjtcbiAgICBSZWdpb25bXCJVczFcIl0gPSBcInVzMVwiO1xuICAgIFJlZ2lvbltcIlVzMUl4XCJdID0gXCJ1czEtaXhcIjtcbiAgICBSZWdpb25bXCJVczFUbnhcIl0gPSBcInVzMS10bnhcIjtcbiAgICBSZWdpb25bXCJVczJcIl0gPSBcInVzMlwiO1xuICAgIFJlZ2lvbltcIlVzMkl4XCJdID0gXCJ1czItaXhcIjtcbiAgICBSZWdpb25bXCJVczJUbnhcIl0gPSBcInVzMi10bnhcIjtcbn0pKFJlZ2lvbiA9IGV4cG9ydHMuUmVnaW9uIHx8IChleHBvcnRzLlJlZ2lvbiA9IHt9KSk7XG4vKipcbiAqIERlcHJlY2F0ZWQgcmVnaW9ucy4gTWFwcyB0aGUgZGVwcmVjYXRlZCByZWdpb24gdG8gaXRzIGVxdWl2YWxlbnQgdXAtdG8tZGF0ZSByZWdpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRlcHJlY2F0ZWRSZWdpb25zID0gKF9hID0ge30sXG4gICAgX2FbRGVwcmVjYXRlZFJlZ2lvbi5BdV0gPSBSZWdpb24uQXUxLFxuICAgIF9hW0RlcHJlY2F0ZWRSZWdpb24uQnJdID0gUmVnaW9uLkJyMSxcbiAgICBfYVtEZXByZWNhdGVkUmVnaW9uLkllXSA9IFJlZ2lvbi5JZTEsXG4gICAgX2FbRGVwcmVjYXRlZFJlZ2lvbi5KcF0gPSBSZWdpb24uSnAxLFxuICAgIF9hW0RlcHJlY2F0ZWRSZWdpb24uU2ddID0gUmVnaW9uLlNnMSxcbiAgICBfYVtEZXByZWNhdGVkUmVnaW9uLlVzT3JdID0gUmVnaW9uLlVzMSxcbiAgICBfYVtEZXByZWNhdGVkUmVnaW9uLlVzVmFdID0gUmVnaW9uLlVzMSxcbiAgICBfYSk7XG4vKipcbiAqIFJlZ2lvbiBzaG9ydGNvZGVzLiBNYXBzIHRoZSBmdWxsIHJlZ2lvbiBuYW1lIGZyb20gQVdTIHRvIHRoZSBUd2lsaW8gc2hvcnRjb2RlLlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0cy5yZWdpb25TaG9ydGNvZGVzID0ge1xuICAgIEFTSUFQQUNfU0lOR0FQT1JFOiBSZWdpb24uU2cxLFxuICAgIEFTSUFQQUNfU1lETkVZOiBSZWdpb24uQXUxLFxuICAgIEFTSUFQQUNfVE9LWU86IFJlZ2lvbi5KcDEsXG4gICAgRVVfRlJBTktGVVJUOiBSZWdpb24uRGUxLFxuICAgIEVVX0lSRUxBTkQ6IFJlZ2lvbi5JZTEsXG4gICAgU09VVEhfQU1FUklDQV9TQU9fUEFVTE86IFJlZ2lvbi5CcjEsXG4gICAgVVNfRUFTVF9WSVJHSU5JQTogUmVnaW9uLlVzMSxcbiAgICBVU19XRVNUX09SRUdPTjogUmVnaW9uLlVzMixcbn07XG4vKipcbiAqIFJlZ2lvbiBVUklzLiBNYXBzIHRoZSBUd2lsaW8gc2hvcnRjb2RlIHRvIGl0cyBUd2lsaW8gZW5kcG9pbnQgVVJJLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHJlZ2lvblVSSXMgPSAoX2IgPSB7fSxcbiAgICBfYltSZWdpb24uQXUxXSA9ICdjaHVuZGVydy12cGMtZ2xsLWF1MS50d2lsaW8uY29tJyxcbiAgICBfYltSZWdpb24uQXUxSXhdID0gJ2NodW5kZXJ3LXZwYy1nbGwtYXUxLWl4LnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5CcjFdID0gJ2NodW5kZXJ3LXZwYy1nbGwtYnIxLnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5EZTFdID0gJ2NodW5kZXJ3LXZwYy1nbGwtZGUxLnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5EZTFJeF0gPSAnY2h1bmRlcnctdnBjLWdsbC1kZTEtaXgudHdpbGlvLmNvbScsXG4gICAgX2JbUmVnaW9uLkdsbF0gPSAnY2h1bmRlcnctdnBjLWdsbC50d2lsaW8uY29tJyxcbiAgICBfYltSZWdpb24uSWUxXSA9ICdjaHVuZGVydy12cGMtZ2xsLWllMS50d2lsaW8uY29tJyxcbiAgICBfYltSZWdpb24uSWUxSXhdID0gJ2NodW5kZXJ3LXZwYy1nbGwtaWUxLWl4LnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5JZTFUbnhdID0gJ2NodW5kZXJ3LXZwYy1nbGwtaWUxLXRueC50d2lsaW8uY29tJyxcbiAgICBfYltSZWdpb24uSnAxXSA9ICdjaHVuZGVydy12cGMtZ2xsLWpwMS50d2lsaW8uY29tJyxcbiAgICBfYltSZWdpb24uSnAxSXhdID0gJ2NodW5kZXJ3LXZwYy1nbGwtanAxLWl4LnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5TZzFdID0gJ2NodW5kZXJ3LXZwYy1nbGwtc2cxLnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5TZzFJeF0gPSAnY2h1bmRlcnctdnBjLWdsbC1zZzEtaXgudHdpbGlvLmNvbScsXG4gICAgX2JbUmVnaW9uLlNnMVRueF0gPSAnY2h1bmRlcnctdnBjLWdsbC1zZzEtdG54LnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5VczFdID0gJ2NodW5kZXJ3LXZwYy1nbGwtdXMxLnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5VczFJeF0gPSAnY2h1bmRlcnctdnBjLWdsbC11czEtaXgudHdpbGlvLmNvbScsXG4gICAgX2JbUmVnaW9uLlVzMVRueF0gPSAnY2h1bmRlcnctdnBjLWdsbC11czEtdG54LnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5VczJdID0gJ2NodW5kZXJ3LXZwYy1nbGwtdXMyLnR3aWxpby5jb20nLFxuICAgIF9iW1JlZ2lvbi5VczJJeF0gPSAnY2h1bmRlcnctdnBjLWdsbC11czItaXgudHdpbGlvLmNvbScsXG4gICAgX2JbUmVnaW9uLlVzMlRueF0gPSAnY2h1bmRlcnctdnBjLWdsbC11czItdG54LnR3aWxpby5jb20nLFxuICAgIF9iKTtcbi8qKlxuICogRWRnZSB0byByZWdpb24gbWFwcGluZywgYXMgcGFydCBvZiBQaGFzZSAxIFJlZ2lvbmFsIChDTElFTlQtNzUxOSkuXG4gKiBUZW1wb3JhcnkuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmVkZ2VUb1JlZ2lvbiA9IChfYyA9IHt9LFxuICAgIF9jW0VkZ2UuU3lkbmV5XSA9IFJlZ2lvbi5BdTEsXG4gICAgX2NbRWRnZS5TYW9QYXVsb10gPSBSZWdpb24uQnIxLFxuICAgIF9jW0VkZ2UuRHVibGluXSA9IFJlZ2lvbi5JZTEsXG4gICAgX2NbRWRnZS5GcmFua2Z1cnRdID0gUmVnaW9uLkRlMSxcbiAgICBfY1tFZGdlLlRva3lvXSA9IFJlZ2lvbi5KcDEsXG4gICAgX2NbRWRnZS5TaW5nYXBvcmVdID0gUmVnaW9uLlNnMSxcbiAgICBfY1tFZGdlLkFzaGJ1cm5dID0gUmVnaW9uLlVzMSxcbiAgICBfY1tFZGdlLlVtYXRpbGxhXSA9IFJlZ2lvbi5VczIsXG4gICAgX2NbRWRnZS5Sb2FtaW5nXSA9IFJlZ2lvbi5HbGwsXG4gICAgLyoqXG4gICAgICogSW50ZXJjb25uZWN0IGVkZ2VzXG4gICAgICovXG4gICAgX2NbRWRnZS5Bc2hidXJuSXhdID0gUmVnaW9uLlVzMUl4LFxuICAgIF9jW0VkZ2UuU2FuSm9zZUl4XSA9IFJlZ2lvbi5VczJJeCxcbiAgICBfY1tFZGdlLkxvbmRvbkl4XSA9IFJlZ2lvbi5JZTFJeCxcbiAgICBfY1tFZGdlLkZyYW5rZnVydEl4XSA9IFJlZ2lvbi5EZTFJeCxcbiAgICBfY1tFZGdlLlNpbmdhcG9yZUl4XSA9IFJlZ2lvbi5TZzFJeCxcbiAgICBfY1tFZGdlLlN5ZG5leUl4XSA9IFJlZ2lvbi5BdTFJeCxcbiAgICBfY1tFZGdlLlRva3lvSXhdID0gUmVnaW9uLkpwMUl4LFxuICAgIF9jKTtcbi8qKlxuICogUmVnaW9uIHRvIGVkZ2UgbWFwcGluZywgYXMgcGFydCBvZiBQaGFzZSAxIFJlZ2lvbmFsIChDTElFTlQtNzUxOSkuXG4gKiBUZW1wb3JhcnkuXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLnJlZ2lvblRvRWRnZSA9IChfZCA9IHt9LFxuICAgIF9kW1JlZ2lvbi5BdTFdID0gRWRnZS5TeWRuZXksXG4gICAgX2RbUmVnaW9uLkJyMV0gPSBFZGdlLlNhb1BhdWxvLFxuICAgIF9kW1JlZ2lvbi5JZTFdID0gRWRnZS5EdWJsaW4sXG4gICAgX2RbUmVnaW9uLkRlMV0gPSBFZGdlLkZyYW5rZnVydCxcbiAgICBfZFtSZWdpb24uSnAxXSA9IEVkZ2UuVG9reW8sXG4gICAgX2RbUmVnaW9uLlNnMV0gPSBFZGdlLlNpbmdhcG9yZSxcbiAgICBfZFtSZWdpb24uVXMxXSA9IEVkZ2UuQXNoYnVybixcbiAgICBfZFtSZWdpb24uVXMyXSA9IEVkZ2UuVW1hdGlsbGEsXG4gICAgX2RbUmVnaW9uLkdsbF0gPSBFZGdlLlJvYW1pbmcsXG4gICAgLyoqXG4gICAgICogSW50ZXJjb25uZWN0IGVkZ2VzXG4gICAgICovXG4gICAgX2RbUmVnaW9uLlVzMUl4XSA9IEVkZ2UuQXNoYnVybkl4LFxuICAgIF9kW1JlZ2lvbi5VczJJeF0gPSBFZGdlLlNhbkpvc2VJeCxcbiAgICBfZFtSZWdpb24uSWUxSXhdID0gRWRnZS5Mb25kb25JeCxcbiAgICBfZFtSZWdpb24uRGUxSXhdID0gRWRnZS5GcmFua2Z1cnRJeCxcbiAgICBfZFtSZWdpb24uU2cxSXhdID0gRWRnZS5TaW5nYXBvcmVJeCxcbiAgICBfZFtSZWdpb24uQXUxSXhdID0gRWRnZS5TeWRuZXlJeCxcbiAgICBfZFtSZWdpb24uSnAxSXhdID0gRWRnZS5Ub2t5b0l4LFxuICAgIC8qKlxuICAgICAqIFRueCByZWdpb25zXG4gICAgICovXG4gICAgX2RbUmVnaW9uLlVzMVRueF0gPSBFZGdlLkFzaGJ1cm5JeCxcbiAgICBfZFtSZWdpb24uVXMyVG54XSA9IEVkZ2UuQXNoYnVybkl4LFxuICAgIF9kW1JlZ2lvbi5JZTFUbnhdID0gRWRnZS5Mb25kb25JeCxcbiAgICBfZFtSZWdpb24uU2cxVG54XSA9IEVkZ2UuU2luZ2Fwb3JlSXgsXG4gICAgX2QpO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCByZWdpb24gdG8gY29ubmVjdCB0byBhbmQgY3JlYXRlIGEgY2h1bmRlciB1cmkgZnJvbSBpZiByZWdpb24gaXNcbiAqIG5vdCBkZWZpbmVkLlxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRlZmF1bHRSZWdpb24gPSAnZ2xsJztcbi8qKlxuICogVGhlIGRlZmF1bHQgZWRnZSB0byBjb25uZWN0IHRvIGFuZCBjcmVhdGUgYSBjaHVuZGVyIHVyaSBmcm9tLCBpZiB0aGUgZWRnZVxuICogcGFyYW1ldGVyIGlzIG5vdCBzcGVjaWZpZWQgZHVyaW5nIHNldHVwIGluIGBEZXZpY2VgLlxuICogQGNvbnN0YW50XG4gKi9cbmV4cG9ydHMuZGVmYXVsdEVkZ2UgPSBFZGdlLlJvYW1pbmc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGNodW5kZXIgVVJJIHRvIGNvbm5lY3QgdG8sIHNob3VsZCBtYXAgdG8gcmVnaW9uIGBnbGxgLlxuICogQGNvbnN0YW50XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLmRlZmF1bHRDaHVuZGVyUmVnaW9uVVJJID0gJ2NodW5kZXJ3LXZwYy1nbGwudHdpbGlvLmNvbSc7XG4vKipcbiAqIFN0cmluZyB0ZW1wbGF0ZSBmb3IgYSByZWdpb24gY2h1bmRlciBVUklcbiAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVDaHVuZGVyUmVnaW9uVXJpKHJlZ2lvbikge1xuICAgIHJldHVybiByZWdpb24gPT09IGV4cG9ydHMuZGVmYXVsdFJlZ2lvblxuICAgICAgICA/IGV4cG9ydHMuZGVmYXVsdENodW5kZXJSZWdpb25VUklcbiAgICAgICAgOiBcImNodW5kZXJ3LXZwYy1nbGwtXCIgKyByZWdpb24gKyBcIi50d2lsaW8uY29tXCI7XG59XG4vKipcbiAqIFN0cmluZyB0ZW1wbGF0ZSBmb3IgYW4gZWRnZSBjaHVuZGVyIFVSSVxuICogQHBhcmFtIGVkZ2UgLSBUaGUgZWRnZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2h1bmRlckVkZ2VVcmkoZWRnZSkge1xuICAgIHJldHVybiBcInZvaWNlLWpzLlwiICsgZWRnZSArIFwiLnR3aWxpby5jb21cIjtcbn1cbi8qKlxuICogR2V0IHRoZSBVUkkgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXNzZWQgcmVnaW9uIG9yIGVkZ2UuIElmIGJvdGggYXJlIHBhc3NlZCxcbiAqIHRoZW4gd2Ugd2FudCB0byBmYWlsIGBEZXZpY2VgIHNldHVwLCBzbyB3ZSB0aHJvdyBhbiBlcnJvci5cbiAqIEFzIG9mIENMSUVOVC03NTE5LCBSZWdpb25zIGFyZSBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGVkZ2VzIGFzIHBhcnQgb2ZcbiAqIFBoYXNlIDEgUmVnaW9uYWwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSBlZGdlIC0gQSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgZWRnZSB2YWx1ZXNcbiAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uIHNob3J0Y29kZS5cbiAqIEBwYXJhbSBbb25EZXByZWNhdGVkXSAtIEEgY2FsbGJhY2sgY29udGFpbmluZyB0aGUgZGVwcmVjYXRpb24gbWVzc2FnZSB0byBiZVxuICogICB3YXJuZWQgd2hlbiB0aGUgcGFzc2VkIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBjaHVuZGVyIFVSSXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2h1bmRlclVSSXMoZWRnZSwgcmVnaW9uLCBvbkRlcHJlY2F0ZWQpIHtcbiAgICBpZiAoISFyZWdpb24gJiYgdHlwZW9mIHJlZ2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBcmd1bWVudEVycm9yKCdJZiBgcmVnaW9uYCBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBvZiB0eXBlIGBzdHJpbmdgLicpO1xuICAgIH1cbiAgICBpZiAoISFlZGdlICYmIHR5cGVvZiBlZGdlICE9PSAnc3RyaW5nJyAmJiAhQXJyYXkuaXNBcnJheShlZGdlKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0lmIGBlZGdlYCBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBvZiB0eXBlIGBzdHJpbmdgIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MuJyk7XG4gICAgfVxuICAgIHZhciBkZXByZWNhdGVkTWVzc2FnZXMgPSBbXTtcbiAgICB2YXIgdXJpcztcbiAgICBpZiAocmVnaW9uICYmIGVkZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBcmd1bWVudEVycm9yKCdZb3UgY2Fubm90IHNwZWNpZnkgYHJlZ2lvbmAgd2hlbiBgZWRnZWAgaXMgc3BlY2lmaWVkIGluJyArXG4gICAgICAgICAgICAnYFR3aWxpby5EZXZpY2UuT3B0aW9uc2AuJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZ2lvbikge1xuICAgICAgICB2YXIgY2h1bmRlclJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgZGVwcmVjYXRlZE1lc3NhZ2VzLnB1c2goJ1JlZ2lvbnMgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZWRnZXMuIFBsZWFzZSBzZWUgdGhpcyBwYWdlIGZvciAnICtcbiAgICAgICAgICAgICdkb2N1bWVudGF0aW9uOiBodHRwczovL3d3dy50d2lsaW8uY29tL2RvY3Mvdm9pY2UvY2xpZW50L2VkZ2VzLicpO1xuICAgICAgICB2YXIgaXNEZXByZWNhdGVkUmVnaW9uID0gT2JqZWN0LnZhbHVlcyhEZXByZWNhdGVkUmVnaW9uKS5pbmNsdWRlcyhjaHVuZGVyUmVnaW9uKTtcbiAgICAgICAgaWYgKGlzRGVwcmVjYXRlZFJlZ2lvbikge1xuICAgICAgICAgICAgY2h1bmRlclJlZ2lvbiA9IGV4cG9ydHMuZGVwcmVjYXRlZFJlZ2lvbnNbY2h1bmRlclJlZ2lvbl07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzS25vd25SZWdpb24gPSBPYmplY3QudmFsdWVzKFJlZ2lvbikuaW5jbHVkZXMoY2h1bmRlclJlZ2lvbik7XG4gICAgICAgIGlmIChpc0tub3duUmVnaW9uKSB7XG4gICAgICAgICAgICB2YXIgcHJlZmVycmVkRWRnZSA9IGV4cG9ydHMucmVnaW9uVG9FZGdlW2NodW5kZXJSZWdpb25dO1xuICAgICAgICAgICAgZGVwcmVjYXRlZE1lc3NhZ2VzLnB1c2goXCJSZWdpb24gXFxcIlwiICsgY2h1bmRlclJlZ2lvbiArIFwiXFxcIiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBlZGdlYCBcIiArXG4gICAgICAgICAgICAgICAgKFwiXFxcIlwiICsgcHJlZmVycmVkRWRnZSArIFwiXFxcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHVyaXMgPSBbY3JlYXRlQ2h1bmRlclJlZ2lvblVyaShjaHVuZGVyUmVnaW9uKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGVkZ2UpIHtcbiAgICAgICAgdmFyIGVkZ2VWYWx1ZXNfMSA9IE9iamVjdC52YWx1ZXMoRWRnZSk7XG4gICAgICAgIHZhciBlZGdlUGFyYW1zID0gQXJyYXkuaXNBcnJheShlZGdlKSA/IGVkZ2UgOiBbZWRnZV07XG4gICAgICAgIHVyaXMgPSBlZGdlUGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIGVkZ2VWYWx1ZXNfMS5pbmNsdWRlcyhwYXJhbSlcbiAgICAgICAgICAgID8gY3JlYXRlQ2h1bmRlclJlZ2lvblVyaShleHBvcnRzLmVkZ2VUb1JlZ2lvbltwYXJhbV0pXG4gICAgICAgICAgICA6IGNyZWF0ZUNodW5kZXJFZGdlVXJpKHBhcmFtKTsgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1cmlzID0gW2V4cG9ydHMuZGVmYXVsdENodW5kZXJSZWdpb25VUkldO1xuICAgIH1cbiAgICBpZiAob25EZXByZWNhdGVkICYmIGRlcHJlY2F0ZWRNZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBvbkRlcHJlY2F0ZWQoZGVwcmVjYXRlZE1lc3NhZ2VzLmpvaW4oJ1xcbicpKTsgfSk7XG4gICAgfVxuICAgIHJldHVybiB1cmlzO1xufVxuZXhwb3J0cy5nZXRDaHVuZGVyVVJJcyA9IGdldENodW5kZXJVUklzO1xuLyoqXG4gKiBHZXQgdGhlIHJlZ2lvbiBzaG9ydGNvZGUgYnkgaXRzIGZ1bGwgQVdTIHJlZ2lvbiBzdHJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSByZWdpb24gLSBUaGUgcmVnaW9uJ3MgZnVsbCBBV1Mgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRSZWdpb25TaG9ydGNvZGUocmVnaW9uKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMucmVnaW9uU2hvcnRjb2Rlc1tyZWdpb25dIHx8IG51bGw7XG59XG5leHBvcnRzLmdldFJlZ2lvblNob3J0Y29kZSA9IGdldFJlZ2lvblNob3J0Y29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lvbnMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/regions.js\n')},"./node_modules/twilio-client/es5/twilio/request.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar XHR = __webpack_require__(/*! xmlhttprequest */ \"./node_modules/twilio-client/browser/xmlhttprequest.js\").XMLHttpRequest;\n\nfunction request(method, params, callback) {\n  var options = {};\n  options.XMLHttpRequest = options.XMLHttpRequest || XHR;\n  var xhr = new options.XMLHttpRequest();\n\n  xhr.open(method, params.url, true);\n  xhr.onreadystatechange = function onreadystatechange() {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    if (200 <= xhr.status && xhr.status < 300) {\n      callback(null, xhr.responseText);\n      return;\n    }\n\n    callback(new Error(xhr.responseText));\n  };\n\n  for (var headerName in params.headers) {\n    xhr.setRequestHeader(headerName, params.headers[headerName]);\n  }\n\n  xhr.send(JSON.stringify(params.body));\n}\n/**\n * Use XMLHttpRequest to get a network resource.\n * @param {String} method - HTTP Method\n * @param {Object} params - Request parameters\n * @param {String} params.url - URL of the resource\n * @param {Array}  params.headers - An array of headers to pass [{ headerName : headerBody }]\n * @param {Object} params.body - A JSON body to send to the resource\n * @returns {response}\n **/\nvar Request = request;\n\n/**\n * Sugar function for request('GET', params, callback);\n * @param {Object} params - Request parameters\n * @param {Request~get} callback - The callback that handles the response.\n */\nRequest.get = function get(params, callback) {\n  return new this('GET', params, callback);\n};\n\n/**\n * Sugar function for request('POST', params, callback);\n * @param {Object} params - Request parameters\n * @param {Request~post} callback - The callback that handles the response.\n */\nRequest.post = function post(params, callback) {\n  return new this('POST', params, callback);\n};\n\nmodule.exports = Request;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3JlcXVlc3QuanM/ZmI5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixVQUFVLGtIQUF3Qzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTSxpREFBaUQsMEJBQTBCO0FBQzVGLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcmVxdWVzdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFhIUiA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3Q7XG5cbmZ1bmN0aW9uIHJlcXVlc3QobWV0aG9kLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRpb25zID0ge307XG4gIG9wdGlvbnMuWE1MSHR0cFJlcXVlc3QgPSBvcHRpb25zLlhNTEh0dHBSZXF1ZXN0IHx8IFhIUjtcbiAgdmFyIHhociA9IG5ldyBvcHRpb25zLlhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgeGhyLm9wZW4obWV0aG9kLCBwYXJhbXMudXJsLCB0cnVlKTtcbiAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoMjAwIDw9IHhoci5zdGF0dXMgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobmV3IEVycm9yKHhoci5yZXNwb25zZVRleHQpKTtcbiAgfTtcblxuICBmb3IgKHZhciBoZWFkZXJOYW1lIGluIHBhcmFtcy5oZWFkZXJzKSB7XG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyTmFtZSwgcGFyYW1zLmhlYWRlcnNbaGVhZGVyTmFtZV0pO1xuICB9XG5cbiAgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkocGFyYW1zLmJvZHkpKTtcbn1cbi8qKlxuICogVXNlIFhNTEh0dHBSZXF1ZXN0IHRvIGdldCBhIG5ldHdvcmsgcmVzb3VyY2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gSFRUUCBNZXRob2RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXMudXJsIC0gVVJMIG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtBcnJheX0gIHBhcmFtcy5oZWFkZXJzIC0gQW4gYXJyYXkgb2YgaGVhZGVycyB0byBwYXNzIFt7IGhlYWRlck5hbWUgOiBoZWFkZXJCb2R5IH1dXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zLmJvZHkgLSBBIEpTT04gYm9keSB0byBzZW5kIHRvIHRoZSByZXNvdXJjZVxuICogQHJldHVybnMge3Jlc3BvbnNlfVxuICoqL1xudmFyIFJlcXVlc3QgPSByZXF1ZXN0O1xuXG4vKipcbiAqIFN1Z2FyIGZ1bmN0aW9uIGZvciByZXF1ZXN0KCdHRVQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7UmVxdWVzdH5nZXR9IGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgaGFuZGxlcyB0aGUgcmVzcG9uc2UuXG4gKi9cblJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24gZ2V0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyB0aGlzKCdHRVQnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU3VnYXIgZnVuY3Rpb24gZm9yIHJlcXVlc3QoJ1BPU1QnLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZXF1ZXN0IHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7UmVxdWVzdH5wb3N0fSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgdGhlIHJlc3BvbnNlLlxuICovXG5SZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbiBwb3N0KHBhcmFtcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyB0aGlzKCdQT1NUJywgcGFyYW1zLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3Q7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/request.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/getusermedia.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar NotSupportedError = __webpack_require__(/*! ../errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\").NotSupportedError;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\n\nfunction getUserMedia(constraints, options) {\n  options = options || {};\n  options.util = options.util || util;\n  options.navigator = options.navigator || (typeof navigator !== 'undefined' ? navigator : null);\n\n  return new Promise(function (resolve, reject) {\n    if (!options.navigator) {\n      throw new NotSupportedError('getUserMedia is not supported');\n    }\n\n    switch ('function') {\n      case _typeof(options.navigator.mediaDevices && options.navigator.mediaDevices.getUserMedia):\n        return resolve(options.navigator.mediaDevices.getUserMedia(constraints));\n      case _typeof(options.navigator.webkitGetUserMedia):\n        return options.navigator.webkitGetUserMedia(constraints, resolve, reject);\n      case _typeof(options.navigator.mozGetUserMedia):\n        return options.navigator.mozGetUserMedia(constraints, resolve, reject);\n      case _typeof(options.navigator.getUserMedia):\n        return options.navigator.getUserMedia(constraints, resolve, reject);\n      default:\n        throw new NotSupportedError('getUserMedia is not supported');\n    }\n  }).catch(function (e) {\n    throw options.util.isFirefox() && e.name === 'NotReadableError' ? new NotSupportedError('Firefox does not currently support opening multiple audio input tracks' + 'simultaneously, even across different tabs.\\n' + 'Related Bugzilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324') : e;\n  });\n}\n\nmodule.exports = getUserMedia;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9nZXR1c2VybWVkaWEuanM/YWMyNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVEsd0JBQXdCLGlIQUFzQztBQUM5RCxXQUFXLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcnRjL2dldHVzZXJtZWRpYS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgTm90U3VwcG9ydGVkRXJyb3IgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5Ob3RTdXBwb3J0ZWRFcnJvcjtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMudXRpbCA9IG9wdGlvbnMudXRpbCB8fCB1dGlsO1xuICBvcHRpb25zLm5hdmlnYXRvciA9IG9wdGlvbnMubmF2aWdhdG9yIHx8ICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvciA6IG51bGwpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKCFvcHRpb25zLm5hdmlnYXRvcikge1xuICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdnZXRVc2VyTWVkaWEgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoJ2Z1bmN0aW9uJykge1xuICAgICAgY2FzZSBfdHlwZW9mKG9wdGlvbnMubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBvcHRpb25zLm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKTpcbiAgICAgICAgcmV0dXJuIHJlc29sdmUob3B0aW9ucy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykpO1xuICAgICAgY2FzZSBfdHlwZW9mKG9wdGlvbnMubmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSk6XG4gICAgICAgIHJldHVybiBvcHRpb25zLm5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEoY29uc3RyYWludHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICBjYXNlIF90eXBlb2Yob3B0aW9ucy5uYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKTpcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubmF2aWdhdG9yLm1vekdldFVzZXJNZWRpYShjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIGNhc2UgX3R5cGVvZihvcHRpb25zLm5hdmlnYXRvci5nZXRVc2VyTWVkaWEpOlxuICAgICAgICByZXR1cm4gb3B0aW9ucy5uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IE5vdFN1cHBvcnRlZEVycm9yKCdnZXRVc2VyTWVkaWEgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfSkuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICB0aHJvdyBvcHRpb25zLnV0aWwuaXNGaXJlZm94KCkgJiYgZS5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgPyBuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ0ZpcmVmb3ggZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgb3BlbmluZyBtdWx0aXBsZSBhdWRpbyBpbnB1dCB0cmFja3MnICsgJ3NpbXVsdGFuZW91c2x5LCBldmVuIGFjcm9zcyBkaWZmZXJlbnQgdGFicy5cXG4nICsgJ1JlbGF0ZWQgQnVnemlsbGEgdGhyZWFkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjk5MzI0JykgOiBlO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRVc2VyTWVkaWE7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/getusermedia.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/icecandidate.js":(__unused_webpack_module,exports)=>{"use strict";eval("\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * {@link RTCIceCandidate} parses an ICE candidate gathered by the browser\n * and returns a IceCandidate object\n */\nvar IceCandidate = /** @class */ (function () {\n    /**\n     * @constructor\n     * @param iceCandidate RTCIceCandidate coming from the browser\n     */\n    function IceCandidate(iceCandidate, isRemote) {\n        if (isRemote === void 0) { isRemote = false; }\n        /**\n         * Whether this is deleted from the list of candidate gathered\n         */\n        this.deleted = false;\n        var cost;\n        var parts = iceCandidate.candidate.split('network-cost ');\n        if (parts[1]) {\n            cost = parseInt(parts[1], 10);\n        }\n        this.candidateType = iceCandidate.type;\n        this.ip = iceCandidate.ip || iceCandidate.address;\n        this.isRemote = isRemote;\n        this.networkCost = cost;\n        this.port = iceCandidate.port;\n        this.priority = iceCandidate.priority;\n        this.protocol = iceCandidate.protocol;\n        this.relatedAddress = iceCandidate.relatedAddress;\n        this.relatedPort = iceCandidate.relatedPort;\n        this.tcpType = iceCandidate.tcpType;\n        this.transportId = iceCandidate.sdpMid;\n    }\n    /**\n     * Get the payload object for insights\n     */\n    IceCandidate.prototype.toPayload = function () {\n        return {\n            'candidate_type': this.candidateType,\n            'deleted': this.deleted,\n            'ip': this.ip,\n            'is_remote': this.isRemote,\n            'network-cost': this.networkCost,\n            'port': this.port,\n            'priority': this.priority,\n            'protocol': this.protocol,\n            'related_address': this.relatedAddress,\n            'related_port': this.relatedPort,\n            'tcp_type': this.tcpType,\n            'transport_id': this.transportId,\n        };\n    };\n    return IceCandidate;\n}());\nexports.IceCandidate = IceCandidate;\n//# sourceMappingURL=icecandidate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9pY2VjYW5kaWRhdGUuanM/MzI0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0Q7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcnRjL2ljZWNhbmRpZGF0ZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgVm9pY2VcbiAqIEBpbnRlcm5hbGFwaVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIHtAbGluayBSVENJY2VDYW5kaWRhdGV9IHBhcnNlcyBhbiBJQ0UgY2FuZGlkYXRlIGdhdGhlcmVkIGJ5IHRoZSBicm93c2VyXG4gKiBhbmQgcmV0dXJucyBhIEljZUNhbmRpZGF0ZSBvYmplY3RcbiAqL1xudmFyIEljZUNhbmRpZGF0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gaWNlQ2FuZGlkYXRlIFJUQ0ljZUNhbmRpZGF0ZSBjb21pbmcgZnJvbSB0aGUgYnJvd3NlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEljZUNhbmRpZGF0ZShpY2VDYW5kaWRhdGUsIGlzUmVtb3RlKSB7XG4gICAgICAgIGlmIChpc1JlbW90ZSA9PT0gdm9pZCAwKSB7IGlzUmVtb3RlID0gZmFsc2U7IH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBpcyBkZWxldGVkIGZyb20gdGhlIGxpc3Qgb2YgY2FuZGlkYXRlIGdhdGhlcmVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNvc3Q7XG4gICAgICAgIHZhciBwYXJ0cyA9IGljZUNhbmRpZGF0ZS5jYW5kaWRhdGUuc3BsaXQoJ25ldHdvcmstY29zdCAnKTtcbiAgICAgICAgaWYgKHBhcnRzWzFdKSB7XG4gICAgICAgICAgICBjb3N0ID0gcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmRpZGF0ZVR5cGUgPSBpY2VDYW5kaWRhdGUudHlwZTtcbiAgICAgICAgdGhpcy5pcCA9IGljZUNhbmRpZGF0ZS5pcCB8fCBpY2VDYW5kaWRhdGUuYWRkcmVzcztcbiAgICAgICAgdGhpcy5pc1JlbW90ZSA9IGlzUmVtb3RlO1xuICAgICAgICB0aGlzLm5ldHdvcmtDb3N0ID0gY29zdDtcbiAgICAgICAgdGhpcy5wb3J0ID0gaWNlQ2FuZGlkYXRlLnBvcnQ7XG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBpY2VDYW5kaWRhdGUucHJpb3JpdHk7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBpY2VDYW5kaWRhdGUucHJvdG9jb2w7XG4gICAgICAgIHRoaXMucmVsYXRlZEFkZHJlc3MgPSBpY2VDYW5kaWRhdGUucmVsYXRlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMucmVsYXRlZFBvcnQgPSBpY2VDYW5kaWRhdGUucmVsYXRlZFBvcnQ7XG4gICAgICAgIHRoaXMudGNwVHlwZSA9IGljZUNhbmRpZGF0ZS50Y3BUeXBlO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydElkID0gaWNlQ2FuZGlkYXRlLnNkcE1pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwYXlsb2FkIG9iamVjdCBmb3IgaW5zaWdodHNcbiAgICAgKi9cbiAgICBJY2VDYW5kaWRhdGUucHJvdG90eXBlLnRvUGF5bG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdjYW5kaWRhdGVfdHlwZSc6IHRoaXMuY2FuZGlkYXRlVHlwZSxcbiAgICAgICAgICAgICdkZWxldGVkJzogdGhpcy5kZWxldGVkLFxuICAgICAgICAgICAgJ2lwJzogdGhpcy5pcCxcbiAgICAgICAgICAgICdpc19yZW1vdGUnOiB0aGlzLmlzUmVtb3RlLFxuICAgICAgICAgICAgJ25ldHdvcmstY29zdCc6IHRoaXMubmV0d29ya0Nvc3QsXG4gICAgICAgICAgICAncG9ydCc6IHRoaXMucG9ydCxcbiAgICAgICAgICAgICdwcmlvcml0eSc6IHRoaXMucHJpb3JpdHksXG4gICAgICAgICAgICAncHJvdG9jb2wnOiB0aGlzLnByb3RvY29sLFxuICAgICAgICAgICAgJ3JlbGF0ZWRfYWRkcmVzcyc6IHRoaXMucmVsYXRlZEFkZHJlc3MsXG4gICAgICAgICAgICAncmVsYXRlZF9wb3J0JzogdGhpcy5yZWxhdGVkUG9ydCxcbiAgICAgICAgICAgICd0Y3BfdHlwZSc6IHRoaXMudGNwVHlwZSxcbiAgICAgICAgICAgICd0cmFuc3BvcnRfaWQnOiB0aGlzLnRyYW5zcG9ydElkLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIEljZUNhbmRpZGF0ZTtcbn0oKSk7XG5leHBvcnRzLkljZUNhbmRpZGF0ZSA9IEljZUNhbmRpZGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWljZWNhbmRpZGF0ZS5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/icecandidate.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar PeerConnection = __webpack_require__(/*! ./peerconnection */ \"./node_modules/twilio-client/es5/twilio/rtc/peerconnection.js\");\n\nvar _require = __webpack_require__(/*! ./rtcpc */ \"./node_modules/twilio-client/es5/twilio/rtc/rtcpc.js\"),\n    test = _require.test;\n\nfunction enabled() {\n  return test();\n}\n\nfunction getMediaEngine() {\n  return typeof RTCIceGatherer !== 'undefined' ? 'ORTC' : 'WebRTC';\n}\n\nmodule.exports = {\n  enabled: enabled,\n  getMediaEngine: getMediaEngine,\n  PeerConnection: PeerConnection\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9pbmRleC5qcz8xMzlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLHVGQUFrQjs7QUFFL0MsZUFBZSxtQkFBTyxDQUFDLHFFQUFTO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcnRjL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUGVlckNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3BlZXJjb25uZWN0aW9uJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vcnRjcGMnKSxcbiAgICB0ZXN0ID0gX3JlcXVpcmUudGVzdDtcblxuZnVuY3Rpb24gZW5hYmxlZCgpIHtcbiAgcmV0dXJuIHRlc3QoKTtcbn1cblxuZnVuY3Rpb24gZ2V0TWVkaWFFbmdpbmUoKSB7XG4gIHJldHVybiB0eXBlb2YgUlRDSWNlR2F0aGVyZXIgIT09ICd1bmRlZmluZWQnID8gJ09SVEMnIDogJ1dlYlJUQyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmFibGVkOiBlbmFibGVkLFxuICBnZXRNZWRpYUVuZ2luZTogZ2V0TWVkaWFFbmdpbmUsXG4gIFBlZXJDb25uZWN0aW9uOiBQZWVyQ29ubmVjdGlvblxufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/index.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/mockrtcstatsreport.js":module=>{eval("/**\n * This file was imported from another project. If making changes to this file, please don't\n * make them here. Make them on the linked repo below, then copy back:\n * https://code.hq.twilio.com/client/MockRTCStatsReport\n */\n/* eslint-disable no-undefined */\n// The legacy max volume, which is the positive half of a signed short integer.\nvar OLD_MAX_VOLUME = 32767;\nvar NativeRTCStatsReport = typeof window !== 'undefined'\n    ? window.RTCStatsReport : undefined;\n/**\n * Create a MockRTCStatsReport wrapper around a Map of RTCStats objects. If RTCStatsReport is available\n *   natively, it will be inherited so that instanceof checks pass.\n * @constructor\n * @extends RTCStatsReport\n * @param {Map<string, RTCStats>} statsMap - A Map of RTCStats objects to wrap\n *   with a MockRTCStatsReport object.\n */\nfunction MockRTCStatsReport(statsMap) {\n    if (!(this instanceof MockRTCStatsReport)) {\n        return new MockRTCStatsReport(statsMap);\n    }\n    var self = this;\n    Object.defineProperties(this, {\n        size: {\n            enumerable: true,\n            get: function () {\n                return self._map.size;\n            }\n        },\n        _map: { value: statsMap }\n    });\n    this[Symbol.iterator] = statsMap[Symbol.iterator];\n}\n// If RTCStatsReport is available natively, inherit it. Keep our constructor.\nif (NativeRTCStatsReport) {\n    MockRTCStatsReport.prototype = Object.create(NativeRTCStatsReport.prototype);\n    MockRTCStatsReport.prototype.constructor = MockRTCStatsReport;\n}\n// Map the Map-like read methods to the underlying Map\n['entries', 'forEach', 'get', 'has', 'keys', 'values'].forEach(function (key) {\n    MockRTCStatsReport.prototype[key] = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return (_a = this._map)[key].apply(_a, args);\n    };\n});\n/**\n * Convert an array of RTCStats objects into a mock RTCStatsReport object.\n * @param {Array<RTCStats>}\n * @return {MockRTCStatsReport}\n */\nMockRTCStatsReport.fromArray = function fromArray(array) {\n    return new MockRTCStatsReport(array.reduce(function (map, rtcStats) {\n        map.set(rtcStats.id, rtcStats);\n        return map;\n    }, new Map()));\n};\n/**\n * Convert a legacy RTCStatsResponse object into a mock RTCStatsReport object.\n * @param {RTCStatsResponse} statsResponse - An RTCStatsResponse object returned by the\n *   legacy getStats(callback) method in Chrome.\n * @return {MockRTCStatsReport} A mock RTCStatsReport object.\n */\nMockRTCStatsReport.fromRTCStatsResponse = function fromRTCStatsResponse(statsResponse) {\n    var activeCandidatePairId;\n    var transportIds = new Map();\n    var statsMap = statsResponse.result().reduce(function (map, report) {\n        var id = report.id;\n        switch (report.type) {\n            case 'googCertificate':\n                map.set(id, createRTCCertificateStats(report));\n                break;\n            case 'datachannel':\n                map.set(id, createRTCDataChannelStats(report));\n                break;\n            case 'googCandidatePair':\n                if (getBoolean(report, 'googActiveConnection')) {\n                    activeCandidatePairId = id;\n                }\n                map.set(id, createRTCIceCandidatePairStats(report));\n                break;\n            case 'localcandidate':\n                map.set(id, createRTCIceCandidateStats(report, false));\n                break;\n            case 'remotecandidate':\n                map.set(id, createRTCIceCandidateStats(report, true));\n                break;\n            case 'ssrc':\n                if (isPresent(report, 'packetsReceived')) {\n                    map.set(\"rtp-\" + id, createRTCInboundRTPStreamStats(report));\n                }\n                else {\n                    map.set(\"rtp-\" + id, createRTCOutboundRTPStreamStats(report));\n                }\n                map.set(\"track-\" + id, createRTCMediaStreamTrackStats(report));\n                map.set(\"codec-\" + id, createRTCCodecStats(report));\n                break;\n            case 'googComponent':\n                var transportReport = createRTCTransportStats(report);\n                transportIds.set(transportReport.selectedCandidatePairId, id);\n                map.set(id, createRTCTransportStats(report));\n                break;\n        }\n        return map;\n    }, new Map());\n    if (activeCandidatePairId) {\n        var activeTransportId = transportIds.get(activeCandidatePairId);\n        if (activeTransportId) {\n            statsMap.get(activeTransportId).dtlsState = 'connected';\n        }\n    }\n    return new MockRTCStatsReport(statsMap);\n};\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCTransportStats}\n */\nfunction createRTCTransportStats(report) {\n    return {\n        type: 'transport',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        bytesSent: undefined,\n        bytesReceived: undefined,\n        rtcpTransportStatsId: undefined,\n        dtlsState: undefined,\n        selectedCandidatePairId: report.stat('selectedCandidatePairId'),\n        localCertificateId: report.stat('localCertificateId'),\n        remoteCertificateId: report.stat('remoteCertificateId')\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCCodecStats}\n */\nfunction createRTCCodecStats(report) {\n    return {\n        type: 'codec',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        payloadType: undefined,\n        mimeType: report.stat('mediaType') + \"/\" + report.stat('googCodecName'),\n        clockRate: undefined,\n        channels: undefined,\n        sdpFmtpLine: undefined,\n        implementation: undefined\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCMediaStreamTrackStats}\n */\nfunction createRTCMediaStreamTrackStats(report) {\n    return {\n        type: 'track',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        trackIdentifier: report.stat('googTrackId'),\n        remoteSource: undefined,\n        ended: undefined,\n        kind: report.stat('mediaType'),\n        detached: undefined,\n        ssrcIds: undefined,\n        frameWidth: isPresent(report, 'googFrameWidthReceived')\n            ? getInt(report, 'googFrameWidthReceived')\n            : getInt(report, 'googFrameWidthSent'),\n        frameHeight: isPresent(report, 'googFrameHeightReceived')\n            ? getInt(report, 'googFrameHeightReceived')\n            : getInt(report, 'googFrameHeightSent'),\n        framesPerSecond: undefined,\n        framesSent: getInt(report, 'framesEncoded'),\n        framesReceived: undefined,\n        framesDecoded: getInt(report, 'framesDecoded'),\n        framesDropped: undefined,\n        framesCorrupted: undefined,\n        partialFramesLost: undefined,\n        fullFramesLost: undefined,\n        audioLevel: isPresent(report, 'audioOutputLevel')\n            ? getInt(report, 'audioOutputLevel') / OLD_MAX_VOLUME\n            : (getInt(report, 'audioInputLevel') || 0) / OLD_MAX_VOLUME,\n        echoReturnLoss: getFloat(report, 'googEchoCancellationReturnLoss'),\n        echoReturnLossEnhancement: getFloat(report, 'googEchoCancellationReturnLossEnhancement')\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @param {boolean} isInbound - Whether to create an inbound stats object, or outbound.\n * @returns {RTCRTPStreamStats}\n */\nfunction createRTCRTPStreamStats(report, isInbound) {\n    return {\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        ssrc: report.stat('ssrc'),\n        associateStatsId: undefined,\n        isRemote: undefined,\n        mediaType: report.stat('mediaType'),\n        trackId: \"track-\" + report.id,\n        transportId: report.stat('transportId'),\n        codecId: \"codec-\" + report.id,\n        firCount: isInbound\n            ? getInt(report, 'googFirsSent')\n            : undefined,\n        pliCount: isInbound\n            ? getInt(report, 'googPlisSent')\n            : getInt(report, 'googPlisReceived'),\n        nackCount: isInbound\n            ? getInt(report, 'googNacksSent')\n            : getInt(report, 'googNacksReceived'),\n        sliCount: undefined,\n        qpSum: getInt(report, 'qpSum')\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCInboundRTPStreamStats}\n */\nfunction createRTCInboundRTPStreamStats(report) {\n    var rtp = createRTCRTPStreamStats(report, true);\n    Object.assign(rtp, {\n        type: 'inbound-rtp',\n        packetsReceived: getInt(report, 'packetsReceived'),\n        bytesReceived: getInt(report, 'bytesReceived'),\n        packetsLost: getInt(report, 'packetsLost'),\n        jitter: convertMsToSeconds(report.stat('googJitterReceived')),\n        fractionLost: undefined,\n        roundTripTime: convertMsToSeconds(report.stat('googRtt')),\n        packetsDiscarded: undefined,\n        packetsRepaired: undefined,\n        burstPacketsLost: undefined,\n        burstPacketsDiscarded: undefined,\n        burstLossCount: undefined,\n        burstDiscardCount: undefined,\n        burstLossRate: undefined,\n        burstDiscardRate: undefined,\n        gapLossRate: undefined,\n        gapDiscardRate: undefined,\n        framesDecoded: getInt(report, 'framesDecoded')\n    });\n    return rtp;\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCOutboundRTPStreamStats}\n */\nfunction createRTCOutboundRTPStreamStats(report) {\n    var rtp = createRTCRTPStreamStats(report, false);\n    Object.assign(rtp, {\n        type: 'outbound-rtp',\n        remoteTimestamp: undefined,\n        packetsSent: getInt(report, 'packetsSent'),\n        bytesSent: getInt(report, 'bytesSent'),\n        targetBitrate: undefined,\n        framesEncoded: getInt(report, 'framesEncoded')\n    });\n    return rtp;\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @param {boolean} isRemote - Whether to create for a remote candidate, or local candidate.\n * @returns {RTCIceCandidateStats}\n */\nfunction createRTCIceCandidateStats(report, isRemote) {\n    return {\n        type: isRemote\n            ? 'remote-candidate'\n            : 'local-candidate',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        transportId: undefined,\n        isRemote: isRemote,\n        ip: report.stat('ipAddress'),\n        port: getInt(report, 'portNumber'),\n        protocol: report.stat('transport'),\n        candidateType: translateCandidateType(report.stat('candidateType')),\n        priority: getFloat(report, 'priority'),\n        url: undefined,\n        relayProtocol: undefined,\n        deleted: undefined\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCIceCandidatePairStats}\n */\nfunction createRTCIceCandidatePairStats(report) {\n    return {\n        type: 'candidate-pair',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        transportId: report.stat('googChannelId'),\n        localCandidateId: report.stat('localCandidateId'),\n        remoteCandidateId: report.stat('remoteCandidateId'),\n        state: undefined,\n        priority: undefined,\n        nominated: undefined,\n        writable: getBoolean(report, 'googWritable'),\n        readable: undefined,\n        bytesSent: getInt(report, 'bytesSent'),\n        bytesReceived: getInt(report, 'bytesReceived'),\n        lastPacketSentTimestamp: undefined,\n        lastPacketReceivedTimestamp: undefined,\n        totalRoundTripTime: undefined,\n        currentRoundTripTime: convertMsToSeconds(report.stat('googRtt')),\n        availableOutgoingBitrate: undefined,\n        availableIncomingBitrate: undefined,\n        requestsReceived: getInt(report, 'requestsReceived'),\n        requestsSent: getInt(report, 'requestsSent'),\n        responsesReceived: getInt(report, 'responsesReceived'),\n        responsesSent: getInt(report, 'responsesSent'),\n        retransmissionsReceived: undefined,\n        retransmissionsSent: undefined,\n        consentRequestsSent: getInt(report, 'consentRequestsSent')\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCIceCertificateStats}\n */\nfunction createRTCCertificateStats(report) {\n    return {\n        type: 'certificate',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        fingerprint: report.stat('googFingerprint'),\n        fingerprintAlgorithm: report.stat('googFingerprintAlgorithm'),\n        base64Certificate: report.stat('googDerBase64'),\n        issuerCertificateId: report.stat('googIssuerId')\n    };\n}\n/**\n * @param {RTCLegacyStatsReport} report\n * @returns {RTCDataChannelStats}\n */\nfunction createRTCDataChannelStats(report) {\n    return {\n        type: 'data-channel',\n        id: report.id,\n        timestamp: Date.parse(report.timestamp),\n        label: report.stat('label'),\n        protocol: report.stat('protocol'),\n        datachannelid: report.stat('datachannelid'),\n        transportId: report.stat('transportId'),\n        state: report.stat('state'),\n        messagesSent: undefined,\n        bytesSent: undefined,\n        messagesReceived: undefined,\n        bytesReceived: undefined\n    };\n}\n/**\n * @param {number} inMs - A time in milliseconds\n * @returns {number} The time in seconds\n */\nfunction convertMsToSeconds(inMs) {\n    return isNaN(inMs) || inMs === ''\n        ? undefined\n        : parseInt(inMs, 10) / 1000;\n}\n/**\n * @param {string} type - A type in the legacy format\n * @returns {string} The type adjusted to new standards for known naming changes\n */\nfunction translateCandidateType(type) {\n    switch (type) {\n        case 'peerreflexive':\n            return 'prflx';\n        case 'serverreflexive':\n            return 'srflx';\n        case 'host':\n        case 'relay':\n        default:\n            return type;\n    }\n}\nfunction getInt(report, statName) {\n    var stat = report.stat(statName);\n    return isPresent(report, statName)\n        ? parseInt(stat, 10)\n        : undefined;\n}\nfunction getFloat(report, statName) {\n    var stat = report.stat(statName);\n    return isPresent(report, statName)\n        ? parseFloat(stat)\n        : undefined;\n}\nfunction getBoolean(report, statName) {\n    var stat = report.stat(statName);\n    return isPresent(report, statName)\n        ? (stat === 'true' || stat === true)\n        : undefined;\n}\nfunction isPresent(report, statName) {\n    var stat = report.stat(statName);\n    return typeof stat !== 'undefined' && stat !== '';\n}\nmodule.exports = MockRTCStatsReport;\n//# sourceMappingURL=mockrtcstatsreport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9tb2NrcnRjc3RhdHNyZXBvcnQuanM/MThhMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9ydGMvbW9ja3J0Y3N0YXRzcmVwb3J0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGlzIGZpbGUgd2FzIGltcG9ydGVkIGZyb20gYW5vdGhlciBwcm9qZWN0LiBJZiBtYWtpbmcgY2hhbmdlcyB0byB0aGlzIGZpbGUsIHBsZWFzZSBkb24ndFxuICogbWFrZSB0aGVtIGhlcmUuIE1ha2UgdGhlbSBvbiB0aGUgbGlua2VkIHJlcG8gYmVsb3csIHRoZW4gY29weSBiYWNrOlxuICogaHR0cHM6Ly9jb2RlLmhxLnR3aWxpby5jb20vY2xpZW50L01vY2tSVENTdGF0c1JlcG9ydFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cbi8vIFRoZSBsZWdhY3kgbWF4IHZvbHVtZSwgd2hpY2ggaXMgdGhlIHBvc2l0aXZlIGhhbGYgb2YgYSBzaWduZWQgc2hvcnQgaW50ZWdlci5cbnZhciBPTERfTUFYX1ZPTFVNRSA9IDMyNzY3O1xudmFyIE5hdGl2ZVJUQ1N0YXRzUmVwb3J0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvdy5SVENTdGF0c1JlcG9ydCA6IHVuZGVmaW5lZDtcbi8qKlxuICogQ3JlYXRlIGEgTW9ja1JUQ1N0YXRzUmVwb3J0IHdyYXBwZXIgYXJvdW5kIGEgTWFwIG9mIFJUQ1N0YXRzIG9iamVjdHMuIElmIFJUQ1N0YXRzUmVwb3J0IGlzIGF2YWlsYWJsZVxuICogICBuYXRpdmVseSwgaXQgd2lsbCBiZSBpbmhlcml0ZWQgc28gdGhhdCBpbnN0YW5jZW9mIGNoZWNrcyBwYXNzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSVENTdGF0c1JlcG9ydFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBSVENTdGF0cz59IHN0YXRzTWFwIC0gQSBNYXAgb2YgUlRDU3RhdHMgb2JqZWN0cyB0byB3cmFwXG4gKiAgIHdpdGggYSBNb2NrUlRDU3RhdHNSZXBvcnQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBNb2NrUlRDU3RhdHNSZXBvcnQoc3RhdHNNYXApIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9ja1JUQ1N0YXRzUmVwb3J0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vY2tSVENTdGF0c1JlcG9ydChzdGF0c01hcCk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fbWFwLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9tYXA6IHsgdmFsdWU6IHN0YXRzTWFwIH1cbiAgICB9KTtcbiAgICB0aGlzW1N5bWJvbC5pdGVyYXRvcl0gPSBzdGF0c01hcFtTeW1ib2wuaXRlcmF0b3JdO1xufVxuLy8gSWYgUlRDU3RhdHNSZXBvcnQgaXMgYXZhaWxhYmxlIG5hdGl2ZWx5LCBpbmhlcml0IGl0LiBLZWVwIG91ciBjb25zdHJ1Y3Rvci5cbmlmIChOYXRpdmVSVENTdGF0c1JlcG9ydCkge1xuICAgIE1vY2tSVENTdGF0c1JlcG9ydC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE5hdGl2ZVJUQ1N0YXRzUmVwb3J0LnByb3RvdHlwZSk7XG4gICAgTW9ja1JUQ1N0YXRzUmVwb3J0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vY2tSVENTdGF0c1JlcG9ydDtcbn1cbi8vIE1hcCB0aGUgTWFwLWxpa2UgcmVhZCBtZXRob2RzIHRvIHRoZSB1bmRlcmx5aW5nIE1hcFxuWydlbnRyaWVzJywgJ2ZvckVhY2gnLCAnZ2V0JywgJ2hhcycsICdrZXlzJywgJ3ZhbHVlcyddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIE1vY2tSVENTdGF0c1JlcG9ydC5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9tYXApW2tleV0uYXBwbHkoX2EsIGFyZ3MpO1xuICAgIH07XG59KTtcbi8qKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBSVENTdGF0cyBvYmplY3RzIGludG8gYSBtb2NrIFJUQ1N0YXRzUmVwb3J0IG9iamVjdC5cbiAqIEBwYXJhbSB7QXJyYXk8UlRDU3RhdHM+fVxuICogQHJldHVybiB7TW9ja1JUQ1N0YXRzUmVwb3J0fVxuICovXG5Nb2NrUlRDU3RhdHNSZXBvcnQuZnJvbUFycmF5ID0gZnVuY3Rpb24gZnJvbUFycmF5KGFycmF5KSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrUlRDU3RhdHNSZXBvcnQoYXJyYXkucmVkdWNlKGZ1bmN0aW9uIChtYXAsIHJ0Y1N0YXRzKSB7XG4gICAgICAgIG1hcC5zZXQocnRjU3RhdHMuaWQsIHJ0Y1N0YXRzKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBuZXcgTWFwKCkpKTtcbn07XG4vKipcbiAqIENvbnZlcnQgYSBsZWdhY3kgUlRDU3RhdHNSZXNwb25zZSBvYmplY3QgaW50byBhIG1vY2sgUlRDU3RhdHNSZXBvcnQgb2JqZWN0LlxuICogQHBhcmFtIHtSVENTdGF0c1Jlc3BvbnNlfSBzdGF0c1Jlc3BvbnNlIC0gQW4gUlRDU3RhdHNSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgdGhlXG4gKiAgIGxlZ2FjeSBnZXRTdGF0cyhjYWxsYmFjaykgbWV0aG9kIGluIENocm9tZS5cbiAqIEByZXR1cm4ge01vY2tSVENTdGF0c1JlcG9ydH0gQSBtb2NrIFJUQ1N0YXRzUmVwb3J0IG9iamVjdC5cbiAqL1xuTW9ja1JUQ1N0YXRzUmVwb3J0LmZyb21SVENTdGF0c1Jlc3BvbnNlID0gZnVuY3Rpb24gZnJvbVJUQ1N0YXRzUmVzcG9uc2Uoc3RhdHNSZXNwb25zZSkge1xuICAgIHZhciBhY3RpdmVDYW5kaWRhdGVQYWlySWQ7XG4gICAgdmFyIHRyYW5zcG9ydElkcyA9IG5ldyBNYXAoKTtcbiAgICB2YXIgc3RhdHNNYXAgPSBzdGF0c1Jlc3BvbnNlLnJlc3VsdCgpLnJlZHVjZShmdW5jdGlvbiAobWFwLCByZXBvcnQpIHtcbiAgICAgICAgdmFyIGlkID0gcmVwb3J0LmlkO1xuICAgICAgICBzd2l0Y2ggKHJlcG9ydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdnb29nQ2VydGlmaWNhdGUnOlxuICAgICAgICAgICAgICAgIG1hcC5zZXQoaWQsIGNyZWF0ZVJUQ0NlcnRpZmljYXRlU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXRhY2hhbm5lbCc6XG4gICAgICAgICAgICAgICAgbWFwLnNldChpZCwgY3JlYXRlUlRDRGF0YUNoYW5uZWxTdGF0cyhyZXBvcnQpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2dvb2dDYW5kaWRhdGVQYWlyJzpcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Qm9vbGVhbihyZXBvcnQsICdnb29nQWN0aXZlQ29ubmVjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNhbmRpZGF0ZVBhaXJJZCA9IGlkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXAuc2V0KGlkLCBjcmVhdGVSVENJY2VDYW5kaWRhdGVQYWlyU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhbGNhbmRpZGF0ZSc6XG4gICAgICAgICAgICAgICAgbWFwLnNldChpZCwgY3JlYXRlUlRDSWNlQ2FuZGlkYXRlU3RhdHMocmVwb3J0LCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmVtb3RlY2FuZGlkYXRlJzpcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGlkLCBjcmVhdGVSVENJY2VDYW5kaWRhdGVTdGF0cyhyZXBvcnQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NzcmMnOlxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocmVwb3J0LCAncGFja2V0c1JlY2VpdmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLnNldChcInJ0cC1cIiArIGlkLCBjcmVhdGVSVENJbmJvdW5kUlRQU3RyZWFtU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0KFwicnRwLVwiICsgaWQsIGNyZWF0ZVJUQ091dGJvdW5kUlRQU3RyZWFtU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoXCJ0cmFjay1cIiArIGlkLCBjcmVhdGVSVENNZWRpYVN0cmVhbVRyYWNrU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgbWFwLnNldChcImNvZGVjLVwiICsgaWQsIGNyZWF0ZVJUQ0NvZGVjU3RhdHMocmVwb3J0KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnb29nQ29tcG9uZW50JzpcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0UmVwb3J0ID0gY3JlYXRlUlRDVHJhbnNwb3J0U3RhdHMocmVwb3J0KTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRJZHMuc2V0KHRyYW5zcG9ydFJlcG9ydC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCwgaWQpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoaWQsIGNyZWF0ZVJUQ1RyYW5zcG9ydFN0YXRzKHJlcG9ydCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgbmV3IE1hcCgpKTtcbiAgICBpZiAoYWN0aXZlQ2FuZGlkYXRlUGFpcklkKSB7XG4gICAgICAgIHZhciBhY3RpdmVUcmFuc3BvcnRJZCA9IHRyYW5zcG9ydElkcy5nZXQoYWN0aXZlQ2FuZGlkYXRlUGFpcklkKTtcbiAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydElkKSB7XG4gICAgICAgICAgICBzdGF0c01hcC5nZXQoYWN0aXZlVHJhbnNwb3J0SWQpLmR0bHNTdGF0ZSA9ICdjb25uZWN0ZWQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTW9ja1JUQ1N0YXRzUmVwb3J0KHN0YXRzTWFwKTtcbn07XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ1RyYW5zcG9ydFN0YXRzfVxuICovXG5mdW5jdGlvbiBjcmVhdGVSVENUcmFuc3BvcnRTdGF0cyhyZXBvcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndHJhbnNwb3J0JyxcbiAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKHJlcG9ydC50aW1lc3RhbXApLFxuICAgICAgICBieXRlc1NlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgYnl0ZXNSZWNlaXZlZDogdW5kZWZpbmVkLFxuICAgICAgICBydGNwVHJhbnNwb3J0U3RhdHNJZDogdW5kZWZpbmVkLFxuICAgICAgICBkdGxzU3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQ6IHJlcG9ydC5zdGF0KCdzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCcpLFxuICAgICAgICBsb2NhbENlcnRpZmljYXRlSWQ6IHJlcG9ydC5zdGF0KCdsb2NhbENlcnRpZmljYXRlSWQnKSxcbiAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGVJZDogcmVwb3J0LnN0YXQoJ3JlbW90ZUNlcnRpZmljYXRlSWQnKVxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ0NvZGVjU3RhdHN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJUQ0NvZGVjU3RhdHMocmVwb3J0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NvZGVjJyxcbiAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKHJlcG9ydC50aW1lc3RhbXApLFxuICAgICAgICBwYXlsb2FkVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICBtaW1lVHlwZTogcmVwb3J0LnN0YXQoJ21lZGlhVHlwZScpICsgXCIvXCIgKyByZXBvcnQuc3RhdCgnZ29vZ0NvZGVjTmFtZScpLFxuICAgICAgICBjbG9ja1JhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hhbm5lbHM6IHVuZGVmaW5lZCxcbiAgICAgICAgc2RwRm10cExpbmU6IHVuZGVmaW5lZCxcbiAgICAgICAgaW1wbGVtZW50YXRpb246IHVuZGVmaW5lZFxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ01lZGlhU3RyZWFtVHJhY2tTdGF0c31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlRDTWVkaWFTdHJlYW1UcmFja1N0YXRzKHJlcG9ydCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICd0cmFjaycsXG4gICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZShyZXBvcnQudGltZXN0YW1wKSxcbiAgICAgICAgdHJhY2tJZGVudGlmaWVyOiByZXBvcnQuc3RhdCgnZ29vZ1RyYWNrSWQnKSxcbiAgICAgICAgcmVtb3RlU291cmNlOiB1bmRlZmluZWQsXG4gICAgICAgIGVuZGVkOiB1bmRlZmluZWQsXG4gICAgICAgIGtpbmQ6IHJlcG9ydC5zdGF0KCdtZWRpYVR5cGUnKSxcbiAgICAgICAgZGV0YWNoZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgc3NyY0lkczogdW5kZWZpbmVkLFxuICAgICAgICBmcmFtZVdpZHRoOiBpc1ByZXNlbnQocmVwb3J0LCAnZ29vZ0ZyYW1lV2lkdGhSZWNlaXZlZCcpXG4gICAgICAgICAgICA/IGdldEludChyZXBvcnQsICdnb29nRnJhbWVXaWR0aFJlY2VpdmVkJylcbiAgICAgICAgICAgIDogZ2V0SW50KHJlcG9ydCwgJ2dvb2dGcmFtZVdpZHRoU2VudCcpLFxuICAgICAgICBmcmFtZUhlaWdodDogaXNQcmVzZW50KHJlcG9ydCwgJ2dvb2dGcmFtZUhlaWdodFJlY2VpdmVkJylcbiAgICAgICAgICAgID8gZ2V0SW50KHJlcG9ydCwgJ2dvb2dGcmFtZUhlaWdodFJlY2VpdmVkJylcbiAgICAgICAgICAgIDogZ2V0SW50KHJlcG9ydCwgJ2dvb2dGcmFtZUhlaWdodFNlbnQnKSxcbiAgICAgICAgZnJhbWVzUGVyU2Vjb25kOiB1bmRlZmluZWQsXG4gICAgICAgIGZyYW1lc1NlbnQ6IGdldEludChyZXBvcnQsICdmcmFtZXNFbmNvZGVkJyksXG4gICAgICAgIGZyYW1lc1JlY2VpdmVkOiB1bmRlZmluZWQsXG4gICAgICAgIGZyYW1lc0RlY29kZWQ6IGdldEludChyZXBvcnQsICdmcmFtZXNEZWNvZGVkJyksXG4gICAgICAgIGZyYW1lc0Ryb3BwZWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZnJhbWVzQ29ycnVwdGVkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhcnRpYWxGcmFtZXNMb3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGZ1bGxGcmFtZXNMb3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGF1ZGlvTGV2ZWw6IGlzUHJlc2VudChyZXBvcnQsICdhdWRpb091dHB1dExldmVsJylcbiAgICAgICAgICAgID8gZ2V0SW50KHJlcG9ydCwgJ2F1ZGlvT3V0cHV0TGV2ZWwnKSAvIE9MRF9NQVhfVk9MVU1FXG4gICAgICAgICAgICA6IChnZXRJbnQocmVwb3J0LCAnYXVkaW9JbnB1dExldmVsJykgfHwgMCkgLyBPTERfTUFYX1ZPTFVNRSxcbiAgICAgICAgZWNob1JldHVybkxvc3M6IGdldEZsb2F0KHJlcG9ydCwgJ2dvb2dFY2hvQ2FuY2VsbGF0aW9uUmV0dXJuTG9zcycpLFxuICAgICAgICBlY2hvUmV0dXJuTG9zc0VuaGFuY2VtZW50OiBnZXRGbG9hdChyZXBvcnQsICdnb29nRWNob0NhbmNlbGxhdGlvblJldHVybkxvc3NFbmhhbmNlbWVudCcpXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtSVENMZWdhY3lTdGF0c1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5ib3VuZCAtIFdoZXRoZXIgdG8gY3JlYXRlIGFuIGluYm91bmQgc3RhdHMgb2JqZWN0LCBvciBvdXRib3VuZC5cbiAqIEByZXR1cm5zIHtSVENSVFBTdHJlYW1TdGF0c31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlRDUlRQU3RyZWFtU3RhdHMocmVwb3J0LCBpc0luYm91bmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UocmVwb3J0LnRpbWVzdGFtcCksXG4gICAgICAgIHNzcmM6IHJlcG9ydC5zdGF0KCdzc3JjJyksXG4gICAgICAgIGFzc29jaWF0ZVN0YXRzSWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNSZW1vdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVkaWFUeXBlOiByZXBvcnQuc3RhdCgnbWVkaWFUeXBlJyksXG4gICAgICAgIHRyYWNrSWQ6IFwidHJhY2stXCIgKyByZXBvcnQuaWQsXG4gICAgICAgIHRyYW5zcG9ydElkOiByZXBvcnQuc3RhdCgndHJhbnNwb3J0SWQnKSxcbiAgICAgICAgY29kZWNJZDogXCJjb2RlYy1cIiArIHJlcG9ydC5pZCxcbiAgICAgICAgZmlyQ291bnQ6IGlzSW5ib3VuZFxuICAgICAgICAgICAgPyBnZXRJbnQocmVwb3J0LCAnZ29vZ0ZpcnNTZW50JylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBwbGlDb3VudDogaXNJbmJvdW5kXG4gICAgICAgICAgICA/IGdldEludChyZXBvcnQsICdnb29nUGxpc1NlbnQnKVxuICAgICAgICAgICAgOiBnZXRJbnQocmVwb3J0LCAnZ29vZ1BsaXNSZWNlaXZlZCcpLFxuICAgICAgICBuYWNrQ291bnQ6IGlzSW5ib3VuZFxuICAgICAgICAgICAgPyBnZXRJbnQocmVwb3J0LCAnZ29vZ05hY2tzU2VudCcpXG4gICAgICAgICAgICA6IGdldEludChyZXBvcnQsICdnb29nTmFja3NSZWNlaXZlZCcpLFxuICAgICAgICBzbGlDb3VudDogdW5kZWZpbmVkLFxuICAgICAgICBxcFN1bTogZ2V0SW50KHJlcG9ydCwgJ3FwU3VtJylcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge1JUQ0xlZ2FjeVN0YXRzUmVwb3J0fSByZXBvcnRcbiAqIEByZXR1cm5zIHtSVENJbmJvdW5kUlRQU3RyZWFtU3RhdHN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJUQ0luYm91bmRSVFBTdHJlYW1TdGF0cyhyZXBvcnQpIHtcbiAgICB2YXIgcnRwID0gY3JlYXRlUlRDUlRQU3RyZWFtU3RhdHMocmVwb3J0LCB0cnVlKTtcbiAgICBPYmplY3QuYXNzaWduKHJ0cCwge1xuICAgICAgICB0eXBlOiAnaW5ib3VuZC1ydHAnLFxuICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IGdldEludChyZXBvcnQsICdwYWNrZXRzUmVjZWl2ZWQnKSxcbiAgICAgICAgYnl0ZXNSZWNlaXZlZDogZ2V0SW50KHJlcG9ydCwgJ2J5dGVzUmVjZWl2ZWQnKSxcbiAgICAgICAgcGFja2V0c0xvc3Q6IGdldEludChyZXBvcnQsICdwYWNrZXRzTG9zdCcpLFxuICAgICAgICBqaXR0ZXI6IGNvbnZlcnRNc1RvU2Vjb25kcyhyZXBvcnQuc3RhdCgnZ29vZ0ppdHRlclJlY2VpdmVkJykpLFxuICAgICAgICBmcmFjdGlvbkxvc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgcm91bmRUcmlwVGltZTogY29udmVydE1zVG9TZWNvbmRzKHJlcG9ydC5zdGF0KCdnb29nUnR0JykpLFxuICAgICAgICBwYWNrZXRzRGlzY2FyZGVkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhY2tldHNSZXBhaXJlZDogdW5kZWZpbmVkLFxuICAgICAgICBidXJzdFBhY2tldHNMb3N0OiB1bmRlZmluZWQsXG4gICAgICAgIGJ1cnN0UGFja2V0c0Rpc2NhcmRlZDogdW5kZWZpbmVkLFxuICAgICAgICBidXJzdExvc3NDb3VudDogdW5kZWZpbmVkLFxuICAgICAgICBidXJzdERpc2NhcmRDb3VudDogdW5kZWZpbmVkLFxuICAgICAgICBidXJzdExvc3NSYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIGJ1cnN0RGlzY2FyZFJhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2FwTG9zc1JhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2FwRGlzY2FyZFJhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgZnJhbWVzRGVjb2RlZDogZ2V0SW50KHJlcG9ydCwgJ2ZyYW1lc0RlY29kZWQnKVxuICAgIH0pO1xuICAgIHJldHVybiBydHA7XG59XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ091dGJvdW5kUlRQU3RyZWFtU3RhdHN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJUQ091dGJvdW5kUlRQU3RyZWFtU3RhdHMocmVwb3J0KSB7XG4gICAgdmFyIHJ0cCA9IGNyZWF0ZVJUQ1JUUFN0cmVhbVN0YXRzKHJlcG9ydCwgZmFsc2UpO1xuICAgIE9iamVjdC5hc3NpZ24ocnRwLCB7XG4gICAgICAgIHR5cGU6ICdvdXRib3VuZC1ydHAnLFxuICAgICAgICByZW1vdGVUaW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFja2V0c1NlbnQ6IGdldEludChyZXBvcnQsICdwYWNrZXRzU2VudCcpLFxuICAgICAgICBieXRlc1NlbnQ6IGdldEludChyZXBvcnQsICdieXRlc1NlbnQnKSxcbiAgICAgICAgdGFyZ2V0Qml0cmF0ZTogdW5kZWZpbmVkLFxuICAgICAgICBmcmFtZXNFbmNvZGVkOiBnZXRJbnQocmVwb3J0LCAnZnJhbWVzRW5jb2RlZCcpXG4gICAgfSk7XG4gICAgcmV0dXJuIHJ0cDtcbn1cbi8qKlxuICogQHBhcmFtIHtSVENMZWdhY3lTdGF0c1JlcG9ydH0gcmVwb3J0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzUmVtb3RlIC0gV2hldGhlciB0byBjcmVhdGUgZm9yIGEgcmVtb3RlIGNhbmRpZGF0ZSwgb3IgbG9jYWwgY2FuZGlkYXRlLlxuICogQHJldHVybnMge1JUQ0ljZUNhbmRpZGF0ZVN0YXRzfVxuICovXG5mdW5jdGlvbiBjcmVhdGVSVENJY2VDYW5kaWRhdGVTdGF0cyhyZXBvcnQsIGlzUmVtb3RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogaXNSZW1vdGVcbiAgICAgICAgICAgID8gJ3JlbW90ZS1jYW5kaWRhdGUnXG4gICAgICAgICAgICA6ICdsb2NhbC1jYW5kaWRhdGUnLFxuICAgICAgICBpZDogcmVwb3J0LmlkLFxuICAgICAgICB0aW1lc3RhbXA6IERhdGUucGFyc2UocmVwb3J0LnRpbWVzdGFtcCksXG4gICAgICAgIHRyYW5zcG9ydElkOiB1bmRlZmluZWQsXG4gICAgICAgIGlzUmVtb3RlOiBpc1JlbW90ZSxcbiAgICAgICAgaXA6IHJlcG9ydC5zdGF0KCdpcEFkZHJlc3MnKSxcbiAgICAgICAgcG9ydDogZ2V0SW50KHJlcG9ydCwgJ3BvcnROdW1iZXInKSxcbiAgICAgICAgcHJvdG9jb2w6IHJlcG9ydC5zdGF0KCd0cmFuc3BvcnQnKSxcbiAgICAgICAgY2FuZGlkYXRlVHlwZTogdHJhbnNsYXRlQ2FuZGlkYXRlVHlwZShyZXBvcnQuc3RhdCgnY2FuZGlkYXRlVHlwZScpKSxcbiAgICAgICAgcHJpb3JpdHk6IGdldEZsb2F0KHJlcG9ydCwgJ3ByaW9yaXR5JyksXG4gICAgICAgIHVybDogdW5kZWZpbmVkLFxuICAgICAgICByZWxheVByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgICAgIGRlbGV0ZWQ6IHVuZGVmaW5lZFxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ0ljZUNhbmRpZGF0ZVBhaXJTdGF0c31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlRDSWNlQ2FuZGlkYXRlUGFpclN0YXRzKHJlcG9ydCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjYW5kaWRhdGUtcGFpcicsXG4gICAgICAgIGlkOiByZXBvcnQuaWQsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZShyZXBvcnQudGltZXN0YW1wKSxcbiAgICAgICAgdHJhbnNwb3J0SWQ6IHJlcG9ydC5zdGF0KCdnb29nQ2hhbm5lbElkJyksXG4gICAgICAgIGxvY2FsQ2FuZGlkYXRlSWQ6IHJlcG9ydC5zdGF0KCdsb2NhbENhbmRpZGF0ZUlkJyksXG4gICAgICAgIHJlbW90ZUNhbmRpZGF0ZUlkOiByZXBvcnQuc3RhdCgncmVtb3RlQ2FuZGlkYXRlSWQnKSxcbiAgICAgICAgc3RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgcHJpb3JpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgbm9taW5hdGVkOiB1bmRlZmluZWQsXG4gICAgICAgIHdyaXRhYmxlOiBnZXRCb29sZWFuKHJlcG9ydCwgJ2dvb2dXcml0YWJsZScpLFxuICAgICAgICByZWFkYWJsZTogdW5kZWZpbmVkLFxuICAgICAgICBieXRlc1NlbnQ6IGdldEludChyZXBvcnQsICdieXRlc1NlbnQnKSxcbiAgICAgICAgYnl0ZXNSZWNlaXZlZDogZ2V0SW50KHJlcG9ydCwgJ2J5dGVzUmVjZWl2ZWQnKSxcbiAgICAgICAgbGFzdFBhY2tldFNlbnRUaW1lc3RhbXA6IHVuZGVmaW5lZCxcbiAgICAgICAgbGFzdFBhY2tldFJlY2VpdmVkVGltZXN0YW1wOiB1bmRlZmluZWQsXG4gICAgICAgIHRvdGFsUm91bmRUcmlwVGltZTogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50Um91bmRUcmlwVGltZTogY29udmVydE1zVG9TZWNvbmRzKHJlcG9ydC5zdGF0KCdnb29nUnR0JykpLFxuICAgICAgICBhdmFpbGFibGVPdXRnb2luZ0JpdHJhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgYXZhaWxhYmxlSW5jb21pbmdCaXRyYXRlOiB1bmRlZmluZWQsXG4gICAgICAgIHJlcXVlc3RzUmVjZWl2ZWQ6IGdldEludChyZXBvcnQsICdyZXF1ZXN0c1JlY2VpdmVkJyksXG4gICAgICAgIHJlcXVlc3RzU2VudDogZ2V0SW50KHJlcG9ydCwgJ3JlcXVlc3RzU2VudCcpLFxuICAgICAgICByZXNwb25zZXNSZWNlaXZlZDogZ2V0SW50KHJlcG9ydCwgJ3Jlc3BvbnNlc1JlY2VpdmVkJyksXG4gICAgICAgIHJlc3BvbnNlc1NlbnQ6IGdldEludChyZXBvcnQsICdyZXNwb25zZXNTZW50JyksXG4gICAgICAgIHJldHJhbnNtaXNzaW9uc1JlY2VpdmVkOiB1bmRlZmluZWQsXG4gICAgICAgIHJldHJhbnNtaXNzaW9uc1NlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29uc2VudFJlcXVlc3RzU2VudDogZ2V0SW50KHJlcG9ydCwgJ2NvbnNlbnRSZXF1ZXN0c1NlbnQnKVxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSB7UlRDTGVnYWN5U3RhdHNSZXBvcnR9IHJlcG9ydFxuICogQHJldHVybnMge1JUQ0ljZUNlcnRpZmljYXRlU3RhdHN9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJUQ0NlcnRpZmljYXRlU3RhdHMocmVwb3J0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2NlcnRpZmljYXRlJyxcbiAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKHJlcG9ydC50aW1lc3RhbXApLFxuICAgICAgICBmaW5nZXJwcmludDogcmVwb3J0LnN0YXQoJ2dvb2dGaW5nZXJwcmludCcpLFxuICAgICAgICBmaW5nZXJwcmludEFsZ29yaXRobTogcmVwb3J0LnN0YXQoJ2dvb2dGaW5nZXJwcmludEFsZ29yaXRobScpLFxuICAgICAgICBiYXNlNjRDZXJ0aWZpY2F0ZTogcmVwb3J0LnN0YXQoJ2dvb2dEZXJCYXNlNjQnKSxcbiAgICAgICAgaXNzdWVyQ2VydGlmaWNhdGVJZDogcmVwb3J0LnN0YXQoJ2dvb2dJc3N1ZXJJZCcpXG4gICAgfTtcbn1cbi8qKlxuICogQHBhcmFtIHtSVENMZWdhY3lTdGF0c1JlcG9ydH0gcmVwb3J0XG4gKiBAcmV0dXJucyB7UlRDRGF0YUNoYW5uZWxTdGF0c31cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUlRDRGF0YUNoYW5uZWxTdGF0cyhyZXBvcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZGF0YS1jaGFubmVsJyxcbiAgICAgICAgaWQ6IHJlcG9ydC5pZCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLnBhcnNlKHJlcG9ydC50aW1lc3RhbXApLFxuICAgICAgICBsYWJlbDogcmVwb3J0LnN0YXQoJ2xhYmVsJyksXG4gICAgICAgIHByb3RvY29sOiByZXBvcnQuc3RhdCgncHJvdG9jb2wnKSxcbiAgICAgICAgZGF0YWNoYW5uZWxpZDogcmVwb3J0LnN0YXQoJ2RhdGFjaGFubmVsaWQnKSxcbiAgICAgICAgdHJhbnNwb3J0SWQ6IHJlcG9ydC5zdGF0KCd0cmFuc3BvcnRJZCcpLFxuICAgICAgICBzdGF0ZTogcmVwb3J0LnN0YXQoJ3N0YXRlJyksXG4gICAgICAgIG1lc3NhZ2VzU2VudDogdW5kZWZpbmVkLFxuICAgICAgICBieXRlc1NlbnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdW5kZWZpbmVkLFxuICAgICAgICBieXRlc1JlY2VpdmVkOiB1bmRlZmluZWRcbiAgICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5NcyAtIEEgdGltZSBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0aW1lIGluIHNlY29uZHNcbiAqL1xuZnVuY3Rpb24gY29udmVydE1zVG9TZWNvbmRzKGluTXMpIHtcbiAgICByZXR1cm4gaXNOYU4oaW5NcykgfHwgaW5NcyA9PT0gJydcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBwYXJzZUludChpbk1zLCAxMCkgLyAxMDAwO1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgdHlwZSBpbiB0aGUgbGVnYWN5IGZvcm1hdFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIHR5cGUgYWRqdXN0ZWQgdG8gbmV3IHN0YW5kYXJkcyBmb3Iga25vd24gbmFtaW5nIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlQ2FuZGlkYXRlVHlwZSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3BlZXJyZWZsZXhpdmUnOlxuICAgICAgICAgICAgcmV0dXJuICdwcmZseCc7XG4gICAgICAgIGNhc2UgJ3NlcnZlcnJlZmxleGl2ZSc6XG4gICAgICAgICAgICByZXR1cm4gJ3NyZmx4JztcbiAgICAgICAgY2FzZSAnaG9zdCc6XG4gICAgICAgIGNhc2UgJ3JlbGF5JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEludChyZXBvcnQsIHN0YXROYW1lKSB7XG4gICAgdmFyIHN0YXQgPSByZXBvcnQuc3RhdChzdGF0TmFtZSk7XG4gICAgcmV0dXJuIGlzUHJlc2VudChyZXBvcnQsIHN0YXROYW1lKVxuICAgICAgICA/IHBhcnNlSW50KHN0YXQsIDEwKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEZsb2F0KHJlcG9ydCwgc3RhdE5hbWUpIHtcbiAgICB2YXIgc3RhdCA9IHJlcG9ydC5zdGF0KHN0YXROYW1lKTtcbiAgICByZXR1cm4gaXNQcmVzZW50KHJlcG9ydCwgc3RhdE5hbWUpXG4gICAgICAgID8gcGFyc2VGbG9hdChzdGF0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldEJvb2xlYW4ocmVwb3J0LCBzdGF0TmFtZSkge1xuICAgIHZhciBzdGF0ID0gcmVwb3J0LnN0YXQoc3RhdE5hbWUpO1xuICAgIHJldHVybiBpc1ByZXNlbnQocmVwb3J0LCBzdGF0TmFtZSlcbiAgICAgICAgPyAoc3RhdCA9PT0gJ3RydWUnIHx8IHN0YXQgPT09IHRydWUpXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNQcmVzZW50KHJlcG9ydCwgc3RhdE5hbWUpIHtcbiAgICB2YXIgc3RhdCA9IHJlcG9ydC5zdGF0KHN0YXROYW1lKTtcbiAgICByZXR1cm4gdHlwZW9mIHN0YXQgIT09ICd1bmRlZmluZWQnICYmIHN0YXQgIT09ICcnO1xufVxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUlRDU3RhdHNSZXBvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2NrcnRjc3RhdHNyZXBvcnQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/mockrtcstatsreport.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/mos.js":module=>{"use strict";eval("\n\nvar rfactorConstants = {\n  r0: 94.768,\n  is: 1.42611\n};\n\n/**\n * Calculate the mos score of a stats object\n * @param {number} rtt\n * @param {number} jitter\n * @param {number} fractionLost - The fraction of packets that have been lost\n     Calculated by packetsLost / totalPackets\n * @return {number} mos - Calculated MOS, 1.0 through roughly 4.5\n */\nfunction calcMos(rtt, jitter, fractionLost) {\n  if (!isPositiveNumber(rtt) || !isPositiveNumber(jitter) || !isPositiveNumber(fractionLost)) {\n    return null;\n  }\n\n  var rFactor = calculateRFactor(rtt, jitter, fractionLost);\n\n  var mos = 1 + 0.035 * rFactor + 0.000007 * rFactor * (rFactor - 60) * (100 - rFactor);\n\n  // Make sure MOS is in range\n  var isValid = mos >= 1.0 && mos < 4.6;\n  return isValid ? mos : null;\n}\n\nfunction calculateRFactor(rtt, jitter, fractionLost) {\n  var effectiveLatency = rtt + jitter * 2 + 10;\n  var rFactor = 0;\n\n  switch (true) {\n    case effectiveLatency < 160:\n      rFactor = rfactorConstants.r0 - effectiveLatency / 40;\n      break;\n    case effectiveLatency < 1000:\n      rFactor = rfactorConstants.r0 - (effectiveLatency - 120) / 10;\n      break;\n    case effectiveLatency >= 1000:\n      rFactor = rfactorConstants.r0 - effectiveLatency / 100;\n      break;\n  }\n\n  var multiplier = .01;\n  switch (true) {\n    case fractionLost === -1:\n      multiplier = 0;\n      rFactor = 0;\n      break;\n    case fractionLost <= rFactor / 2.5:\n      multiplier = 2.5;\n      break;\n    case fractionLost > rFactor / 2.5 && fractionLost < 100:\n      multiplier = .25;\n      break;\n  }\n\n  rFactor -= fractionLost * multiplier;\n  return rFactor;\n}\n\nfunction isPositiveNumber(n) {\n  return typeof n === 'number' && !isNaN(n) && isFinite(n) && n >= 0;\n}\n\nmodule.exports = {\n  calculate: calcMos\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9tb3MuanM/YzYwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcnRjL21vcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHJmYWN0b3JDb25zdGFudHMgPSB7XG4gIHIwOiA5NC43NjgsXG4gIGlzOiAxLjQyNjExXG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbW9zIHNjb3JlIG9mIGEgc3RhdHMgb2JqZWN0XG4gKiBAcGFyYW0ge251bWJlcn0gcnR0XG4gKiBAcGFyYW0ge251bWJlcn0gaml0dGVyXG4gKiBAcGFyYW0ge251bWJlcn0gZnJhY3Rpb25Mb3N0IC0gVGhlIGZyYWN0aW9uIG9mIHBhY2tldHMgdGhhdCBoYXZlIGJlZW4gbG9zdFxuICAgICBDYWxjdWxhdGVkIGJ5IHBhY2tldHNMb3N0IC8gdG90YWxQYWNrZXRzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IG1vcyAtIENhbGN1bGF0ZWQgTU9TLCAxLjAgdGhyb3VnaCByb3VnaGx5IDQuNVxuICovXG5mdW5jdGlvbiBjYWxjTW9zKHJ0dCwgaml0dGVyLCBmcmFjdGlvbkxvc3QpIHtcbiAgaWYgKCFpc1Bvc2l0aXZlTnVtYmVyKHJ0dCkgfHwgIWlzUG9zaXRpdmVOdW1iZXIoaml0dGVyKSB8fCAhaXNQb3NpdGl2ZU51bWJlcihmcmFjdGlvbkxvc3QpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgckZhY3RvciA9IGNhbGN1bGF0ZVJGYWN0b3IocnR0LCBqaXR0ZXIsIGZyYWN0aW9uTG9zdCk7XG5cbiAgdmFyIG1vcyA9IDEgKyAwLjAzNSAqIHJGYWN0b3IgKyAwLjAwMDAwNyAqIHJGYWN0b3IgKiAockZhY3RvciAtIDYwKSAqICgxMDAgLSByRmFjdG9yKTtcblxuICAvLyBNYWtlIHN1cmUgTU9TIGlzIGluIHJhbmdlXG4gIHZhciBpc1ZhbGlkID0gbW9zID49IDEuMCAmJiBtb3MgPCA0LjY7XG4gIHJldHVybiBpc1ZhbGlkID8gbW9zIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUkZhY3RvcihydHQsIGppdHRlciwgZnJhY3Rpb25Mb3N0KSB7XG4gIHZhciBlZmZlY3RpdmVMYXRlbmN5ID0gcnR0ICsgaml0dGVyICogMiArIDEwO1xuICB2YXIgckZhY3RvciA9IDA7XG5cbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBlZmZlY3RpdmVMYXRlbmN5IDwgMTYwOlxuICAgICAgckZhY3RvciA9IHJmYWN0b3JDb25zdGFudHMucjAgLSBlZmZlY3RpdmVMYXRlbmN5IC8gNDA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGVmZmVjdGl2ZUxhdGVuY3kgPCAxMDAwOlxuICAgICAgckZhY3RvciA9IHJmYWN0b3JDb25zdGFudHMucjAgLSAoZWZmZWN0aXZlTGF0ZW5jeSAtIDEyMCkgLyAxMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZWZmZWN0aXZlTGF0ZW5jeSA+PSAxMDAwOlxuICAgICAgckZhY3RvciA9IHJmYWN0b3JDb25zdGFudHMucjAgLSBlZmZlY3RpdmVMYXRlbmN5IC8gMTAwO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgbXVsdGlwbGllciA9IC4wMTtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBmcmFjdGlvbkxvc3QgPT09IC0xOlxuICAgICAgbXVsdGlwbGllciA9IDA7XG4gICAgICByRmFjdG9yID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgZnJhY3Rpb25Mb3N0IDw9IHJGYWN0b3IgLyAyLjU6XG4gICAgICBtdWx0aXBsaWVyID0gMi41O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBmcmFjdGlvbkxvc3QgPiByRmFjdG9yIC8gMi41ICYmIGZyYWN0aW9uTG9zdCA8IDEwMDpcbiAgICAgIG11bHRpcGxpZXIgPSAuMjU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJGYWN0b3IgLT0gZnJhY3Rpb25Mb3N0ICogbXVsdGlwbGllcjtcbiAgcmV0dXJuIHJGYWN0b3I7XG59XG5cbmZ1bmN0aW9uIGlzUG9zaXRpdmVOdW1iZXIobikge1xuICByZXR1cm4gdHlwZW9mIG4gPT09ICdudW1iZXInICYmICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKSAmJiBuID49IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWxjdWxhdGU6IGNhbGNNb3Ncbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/mos.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/peerconnection.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _require = __webpack_require__(/*! ../errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\"),\n    InvalidArgumentError = _require.InvalidArgumentError,\n    MediaErrors = _require.MediaErrors,\n    NotSupportedError = _require.NotSupportedError,\n    SignalingErrors = _require.SignalingErrors;\n\nvar Log = __webpack_require__(/*! ../log */ \"./node_modules/twilio-client/es5/twilio/log.js\").default;\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\nvar RTCPC = __webpack_require__(/*! ./rtcpc */ \"./node_modules/twilio-client/es5/twilio/rtc/rtcpc.js\");\n\nvar _require2 = __webpack_require__(/*! ./sdp */ \"./node_modules/twilio-client/es5/twilio/rtc/sdp.js\"),\n    setIceAggressiveNomination = _require2.setIceAggressiveNomination;\n\nvar ICE_GATHERING_TIMEOUT = 15000;\nvar ICE_GATHERING_FAIL_NONE = 'none';\nvar ICE_GATHERING_FAIL_TIMEOUT = 'timeout';\nvar INITIAL_ICE_CONNECTION_STATE = 'new';\nvar VOLUME_INTERVAL_MS = 50;\n\n/**\n * @typedef {Object} PeerConnection\n * @param audioHelper\n * @param pstream\n * @param options\n * @return {PeerConnection}\n * @constructor\n */\nfunction PeerConnection(audioHelper, pstream, getUserMedia, options) {\n  if (!audioHelper || !pstream || !getUserMedia) {\n    throw new InvalidArgumentError('Audiohelper, pstream and getUserMedia are required arguments');\n  }\n\n  if (!(this instanceof PeerConnection)) {\n    return new PeerConnection(audioHelper, pstream, getUserMedia, options);\n  }\n\n  function noop() {}\n  this.onopen = noop;\n  this.onerror = noop;\n  this.onclose = noop;\n  this.ondisconnected = noop;\n  this.onfailed = noop;\n  this.onconnected = noop;\n  this.onreconnected = noop;\n  this.onsignalingstatechange = noop;\n  this.ondtlstransportstatechange = noop;\n  this.onicegatheringfailure = noop;\n  this.onicegatheringstatechange = noop;\n  this.oniceconnectionstatechange = noop;\n  this.onpcconnectionstatechange = noop;\n  this.onicecandidate = noop;\n  this.onselectedcandidatepairchange = noop;\n  this.onvolume = noop;\n  this.version = null;\n  this.pstream = pstream;\n  this.stream = null;\n  this.sinkIds = new Set(['default']);\n  this.outputs = new Map();\n  this.status = 'connecting';\n  this.callSid = null;\n  this.isMuted = false;\n  this.getUserMedia = getUserMedia;\n\n  var AudioContext = typeof window !== 'undefined' && (window.AudioContext || window.webkitAudioContext);\n  this._isSinkSupported = !!AudioContext && typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId;\n  // NOTE(mmalavalli): Since each Connection creates its own AudioContext,\n  // after 6 instances an exception is thrown. Refer https://www.w3.org/2011/audio/track/issues/3.\n  // In order to get around it, we are re-using the Device's AudioContext.\n  this._audioContext = AudioContext && audioHelper._audioContext;\n  this._hasIceCandidates = false;\n  this._hasIceGatheringFailures = false;\n  this._iceGatheringTimeoutId = null;\n  this._masterAudio = null;\n  this._masterAudioDeviceId = null;\n  this._mediaStreamSource = null;\n  this._dtmfSender = null;\n  this._dtmfSenderUnsupported = false;\n  this._callEvents = [];\n  this._nextTimeToPublish = Date.now();\n  this._onAnswerOrRinging = noop;\n  this._onHangup = noop;\n  this._remoteStream = null;\n  this._shouldManageStream = true;\n  this._iceState = INITIAL_ICE_CONNECTION_STATE;\n  this._isUnifiedPlan = options.isUnifiedPlan;\n\n  this.options = options = options || {};\n  this.navigator = options.navigator || (typeof navigator !== 'undefined' ? navigator : null);\n  this.util = options.util || util;\n  this.codecPreferences = options.codecPreferences;\n\n  this._log = Log.getInstance();\n\n  return this;\n}\n\nPeerConnection.prototype.uri = function () {\n  return this._uri;\n};\n\n/**\n * Open the underlying RTCPeerConnection with a MediaStream obtained by\n *   passed constraints. The resulting MediaStream is created internally\n *   and will therefore be managed and destroyed internally.\n * @param {MediaStreamConstraints} constraints\n */\nPeerConnection.prototype.openWithConstraints = function (constraints) {\n  return this.getUserMedia({ audio: constraints }).then(this._setInputTracksFromStream.bind(this, false));\n};\n\n/**\n * Replace the existing input audio tracks with the audio tracks from the\n *   passed input audio stream. We re-use the existing stream because\n *   the AnalyzerNode is bound to the stream.\n * @param {MediaStream} stream\n */\nPeerConnection.prototype.setInputTracksFromStream = function (stream) {\n  var self = this;\n  return this._setInputTracksFromStream(true, stream).then(function () {\n    self._shouldManageStream = false;\n  });\n};\n\nPeerConnection.prototype._createAnalyser = function (audioContext, options) {\n  options = Object.assign({\n    fftSize: 32,\n    smoothingTimeConstant: 0.3\n  }, options);\n\n  var analyser = audioContext.createAnalyser();\n  for (var field in options) {\n    analyser[field] = options[field];\n  }\n\n  return analyser;\n};\n\nPeerConnection.prototype._setVolumeHandler = function (handler) {\n  this.onvolume = handler;\n};\nPeerConnection.prototype._startPollingVolume = function () {\n  if (!this._audioContext || !this.stream || !this._remoteStream) {\n    return;\n  }\n\n  var audioContext = this._audioContext;\n\n  var inputAnalyser = this._inputAnalyser = this._createAnalyser(audioContext);\n  var inputBufferLength = inputAnalyser.frequencyBinCount;\n  var inputDataArray = new Uint8Array(inputBufferLength);\n  this._inputAnalyser2 = this._createAnalyser(audioContext, {\n    minDecibels: -127,\n    maxDecibels: 0,\n    smoothingTimeConstant: 0\n  });\n\n  var outputAnalyser = this._outputAnalyser = this._createAnalyser(audioContext);\n  var outputBufferLength = outputAnalyser.frequencyBinCount;\n  var outputDataArray = new Uint8Array(outputBufferLength);\n  this._outputAnalyser2 = this._createAnalyser(audioContext, {\n    minDecibels: -127,\n    maxDecibels: 0,\n    smoothingTimeConstant: 0\n  });\n\n  this._updateInputStreamSource(this.stream);\n  this._updateOutputStreamSource(this._remoteStream);\n\n  var self = this;\n  setTimeout(function emitVolume() {\n    if (!self._audioContext) {\n      return;\n    } else if (self.status === 'closed') {\n      self._inputAnalyser.disconnect();\n      self._outputAnalyser.disconnect();\n      self._inputAnalyser2.disconnect();\n      self._outputAnalyser2.disconnect();\n      return;\n    }\n\n    self._inputAnalyser.getByteFrequencyData(inputDataArray);\n    var inputVolume = self.util.average(inputDataArray);\n\n    self._inputAnalyser2.getByteFrequencyData(inputDataArray);\n    var inputVolume2 = self.util.average(inputDataArray);\n\n    self._outputAnalyser.getByteFrequencyData(outputDataArray);\n    var outputVolume = self.util.average(outputDataArray);\n\n    self._outputAnalyser2.getByteFrequencyData(outputDataArray);\n    var outputVolume2 = self.util.average(outputDataArray);\n    self.onvolume(inputVolume / 255, outputVolume / 255, inputVolume2, outputVolume2);\n\n    setTimeout(emitVolume, VOLUME_INTERVAL_MS);\n  }, VOLUME_INTERVAL_MS);\n};\n\nPeerConnection.prototype._stopStream = function _stopStream(stream) {\n  // We shouldn't stop the tracks if they were not created inside\n  //   this PeerConnection.\n  if (!this._shouldManageStream) {\n    return;\n  }\n\n  if (typeof MediaStreamTrack.prototype.stop === 'function') {\n    var audioTracks = typeof stream.getAudioTracks === 'function' ? stream.getAudioTracks() : stream.audioTracks;\n    audioTracks.forEach(function (track) {\n      track.stop();\n    });\n  }\n  // NOTE(mroberts): This is just a fallback to any ancient browsers that may\n  // not implement MediaStreamTrack.stop.\n  else {\n      stream.stop();\n    }\n};\n\n/**\n * Update the stream source with the new input audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateInputStreamSource = function (stream) {\n  if (this._inputStreamSource) {\n    this._inputStreamSource.disconnect();\n  }\n\n  this._inputStreamSource = this._audioContext.createMediaStreamSource(stream);\n  this._inputStreamSource.connect(this._inputAnalyser);\n  this._inputStreamSource.connect(this._inputAnalyser2);\n};\n\n/**\n * Update the stream source with the new ouput audio stream.\n * @param {MediaStream} stream\n * @private\n */\nPeerConnection.prototype._updateOutputStreamSource = function (stream) {\n  if (this._outputStreamSource) {\n    this._outputStreamSource.disconnect();\n  }\n\n  this._outputStreamSource = this._audioContext.createMediaStreamSource(stream);\n  this._outputStreamSource.connect(this._outputAnalyser);\n  this._outputStreamSource.connect(this._outputAnalyser2);\n};\n\n/**\n * Replace the tracks of the current stream with new tracks. We do this rather than replacing the\n *   whole stream because AnalyzerNodes are bound to a stream.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksFromStream = function (shouldClone, newStream) {\n  return this._isUnifiedPlan ? this._setInputTracksForUnifiedPlan(shouldClone, newStream) : this._setInputTracksForPlanB(shouldClone, newStream);\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'plan-b' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForPlanB = function (shouldClone, newStream) {\n  var _this = this;\n\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  var localStream = this.stream;\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    this._stopStream(localStream);\n\n    removeStream(this.version.pc, localStream);\n    localStream.getAudioTracks().forEach(localStream.removeTrack, localStream);\n    newStream.getAudioTracks().forEach(localStream.addTrack, localStream);\n    addStream(this.version.pc, newStream);\n\n    this._updateInputStreamSource(this.stream);\n  }\n\n  // Apply mute settings to new input track\n  this.mute(this.isMuted);\n\n  if (!this.version) {\n    return Promise.resolve(this.stream);\n  }\n\n  return new Promise(function (resolve, reject) {\n    _this.version.createOffer(_this.options.maxAverageBitrate, _this.codecPreferences, { audio: true }, function () {\n      _this.version.processAnswer(_this.codecPreferences, _this._answerSdp, function () {\n        resolve(_this.stream);\n      }, reject);\n    }, reject);\n  });\n};\n\n/**\n * Replace the tracks of the current stream with new tracks using the 'unified-plan' method.\n * @param {Boolean} shouldClone - Whether the stream should be cloned if it is the first\n *   stream, or set directly. As a rule of thumb, streams that are passed in externally may have\n *   their lifecycle managed externally, and should be cloned so that we do not tear it or its tracks\n *   down when the call ends. Streams that we create internally (inside PeerConnection) should be set\n *   directly so that when the call ends it is disposed of.\n * @param {MediaStream} newStream - The new stream to copy the tracks over from.\n * @private\n */\nPeerConnection.prototype._setInputTracksForUnifiedPlan = function (shouldClone, newStream) {\n  var _this2 = this;\n\n  if (!newStream) {\n    return Promise.reject(new InvalidArgumentError('Can not set input stream to null while in a call'));\n  }\n\n  if (!newStream.getAudioTracks().length) {\n    return Promise.reject(new InvalidArgumentError('Supplied input stream has no audio tracks'));\n  }\n\n  var localStream = this.stream;\n  var getStreamPromise = function getStreamPromise() {\n    // Apply mute settings to new input track\n    _this2.mute(_this2.isMuted);\n    return Promise.resolve(_this2.stream);\n  };\n\n  if (!localStream) {\n    // We can't use MediaStream.clone() here because it stopped copying over tracks\n    //   as of Chrome 61. https://bugs.chromium.org/p/chromium/issues/detail?id=770908\n    this.stream = shouldClone ? cloneStream(newStream) : newStream;\n  } else {\n    // If the call was started with gUM, and we are now replacing that track with an\n    // external stream's tracks, we should stop the old managed track.\n    if (this._shouldManageStream) {\n      this._stopStream(localStream);\n    }\n\n    if (!this._sender) {\n      this._sender = this.version.pc.getSenders()[0];\n    }\n\n    return this._sender.replaceTrack(newStream.getAudioTracks()[0]).then(function () {\n      _this2._updateInputStreamSource(newStream);\n      return getStreamPromise();\n    });\n  }\n\n  return getStreamPromise();\n};\n\nPeerConnection.prototype._onInputDevicesChanged = function () {\n  if (!this.stream) {\n    return;\n  }\n\n  // If all of our active tracks are ended, then our active input was lost\n  var activeInputWasLost = this.stream.getAudioTracks().every(function (track) {\n    return track.readyState === 'ended';\n  });\n\n  // We only want to act if we manage the stream in PeerConnection (It was created\n  // here, rather than passed in.)\n  if (activeInputWasLost && this._shouldManageStream) {\n    this.openWithConstraints(true);\n  }\n};\n\nPeerConnection.prototype._onIceGatheringFailure = function (type) {\n  this._hasIceGatheringFailures = true;\n  this.onicegatheringfailure(type);\n};\n\nPeerConnection.prototype._onMediaConnectionStateChange = function (newState) {\n  var previousState = this._iceState;\n\n  if (previousState === newState || newState !== 'connected' && newState !== 'disconnected' && newState !== 'failed') {\n    return;\n  }\n  this._iceState = newState;\n\n  var message = void 0;\n  switch (newState) {\n    case 'connected':\n      if (previousState === 'disconnected' || previousState === 'failed') {\n        message = 'ICE liveliness check succeeded. Connection with Twilio restored';\n        this._log.info(message);\n        this.onreconnected(message);\n      } else {\n        message = 'Media connection established.';\n        this._log.info(message);\n        this.onconnected(message);\n      }\n      this._stopIceGatheringTimeout();\n      this._hasIceGatheringFailures = false;\n      break;\n    case 'disconnected':\n      message = 'ICE liveliness check failed. May be having trouble connecting to Twilio';\n      this._log.info(message);\n      this.ondisconnected(message);\n      break;\n    case 'failed':\n      message = 'Connection with Twilio was interrupted.';\n      this._log.info(message);\n      this.onfailed(message);\n      break;\n  }\n};\n\nPeerConnection.prototype._setSinkIds = function (sinkIds) {\n  if (!this._isSinkSupported) {\n    return Promise.reject(new NotSupportedError('Audio output selection is not supported by this browser'));\n  }\n\n  this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);\n  return this.version ? this._updateAudioOutputs() : Promise.resolve();\n};\n\n/**\n * Start timeout for ICE Gathering\n */\nPeerConnection.prototype._startIceGatheringTimeout = function startIceGatheringTimeout() {\n  var _this3 = this;\n\n  this._stopIceGatheringTimeout();\n  this._iceGatheringTimeoutId = setTimeout(function () {\n    _this3._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);\n  }, ICE_GATHERING_TIMEOUT);\n};\n\n/**\n * Stop timeout for ICE Gathering\n */\nPeerConnection.prototype._stopIceGatheringTimeout = function stopIceGatheringTimeout() {\n  clearInterval(this._iceGatheringTimeoutId);\n};\n\nPeerConnection.prototype._updateAudioOutputs = function updateAudioOutputs() {\n  var addedOutputIds = Array.from(this.sinkIds).filter(function (id) {\n    return !this.outputs.has(id);\n  }, this);\n\n  var removedOutputIds = Array.from(this.outputs.keys()).filter(function (id) {\n    return !this.sinkIds.has(id);\n  }, this);\n\n  var self = this;\n  var createOutputPromises = addedOutputIds.map(this._createAudioOutput, this);\n  return Promise.all(createOutputPromises).then(function () {\n    return Promise.all(removedOutputIds.map(self._removeAudioOutput, self));\n  });\n};\n\nPeerConnection.prototype._createAudio = function createAudio(arr) {\n  return new Audio(arr);\n};\n\nPeerConnection.prototype._createAudioOutput = function createAudioOutput(id) {\n  var dest = this._audioContext.createMediaStreamDestination();\n  this._mediaStreamSource.connect(dest);\n\n  var audio = this._createAudio();\n  setAudioSource(audio, dest.stream);\n\n  var self = this;\n  return audio.setSinkId(id).then(function () {\n    return audio.play();\n  }).then(function () {\n    self.outputs.set(id, {\n      audio: audio,\n      dest: dest\n    });\n  });\n};\n\nPeerConnection.prototype._removeAudioOutputs = function removeAudioOutputs() {\n  if (this._masterAudio && typeof this._masterAudioDeviceId !== 'undefined') {\n    this._disableOutput(this, this._masterAudioDeviceId);\n    this.outputs.delete(this._masterAudioDeviceId);\n    this._masterAudioDeviceId = null;\n\n    // Release the audio resources before deleting the audio\n    if (!this._masterAudio.paused) {\n      this._masterAudio.pause();\n    }\n    if (typeof this._masterAudio.srcObject !== 'undefined') {\n      this._masterAudio.srcObject = null;\n    } else {\n      this._masterAudio.src = '';\n    }\n    this._masterAudio = null;\n  }\n\n  return Array.from(this.outputs.keys()).map(this._removeAudioOutput, this);\n};\n\nPeerConnection.prototype._disableOutput = function disableOutput(pc, id) {\n  var output = pc.outputs.get(id);\n  if (!output) {\n    return;\n  }\n\n  if (output.audio) {\n    output.audio.pause();\n    output.audio.src = '';\n  }\n\n  if (output.dest) {\n    output.dest.disconnect();\n  }\n};\n\n/**\n * Disable a non-master output, and update the master output to assume its state. This\n *   is called when the device ID assigned to the master output has been removed from\n *   active devices. We can not simply remove the master audio output, so we must\n *   instead reassign it.\n * @private\n * @param {PeerConnection} pc\n * @param {string} masterId - The current device ID assigned to the master audio element.\n */\nPeerConnection.prototype._reassignMasterOutput = function reassignMasterOutput(pc, masterId) {\n  var masterOutput = pc.outputs.get(masterId);\n  pc.outputs.delete(masterId);\n\n  var self = this;\n  var idToReplace = Array.from(pc.outputs.keys())[0] || 'default';\n  return masterOutput.audio.setSinkId(idToReplace).then(function () {\n    self._disableOutput(pc, idToReplace);\n\n    pc.outputs.set(idToReplace, masterOutput);\n    pc._masterAudioDeviceId = idToReplace;\n  }).catch(function rollback() {\n    pc.outputs.set(masterId, masterOutput);\n    self._log.info('Could not reassign master output. Attempted to roll back.');\n  });\n};\n\nPeerConnection.prototype._removeAudioOutput = function removeAudioOutput(id) {\n  if (this._masterAudioDeviceId === id) {\n    return this._reassignMasterOutput(this, id);\n  }\n\n  this._disableOutput(this, id);\n  this.outputs.delete(id);\n\n  return Promise.resolve();\n};\n\n/**\n * Use an AudioContext to potentially split our audio output stream to multiple\n *   audio devices. This is only available to browsers with AudioContext and\n *   HTMLAudioElement.setSinkId() available. We save the source stream in\n *   _masterAudio, and use it for one of the active audio devices. We keep\n *   track of its ID because we must replace it if we lose its initial device.\n */\nPeerConnection.prototype._onAddTrack = function onAddTrack(pc, stream) {\n  var audio = pc._masterAudio = this._createAudio();\n  setAudioSource(audio, stream);\n  audio.play();\n\n  // Assign the initial master audio element to a random active output device\n  var deviceId = Array.from(pc.outputs.keys())[0] || 'default';\n  pc._masterAudioDeviceId = deviceId;\n  pc.outputs.set(deviceId, {\n    audio: audio\n  });\n\n  pc._mediaStreamSource = pc._audioContext.createMediaStreamSource(stream);\n\n  pc.pcStream = stream;\n  pc._updateAudioOutputs();\n};\n\n/**\n * Use a single audio element to play the audio output stream. This does not\n *   support multiple output devices, and is a fallback for when AudioContext\n *   and/or HTMLAudioElement.setSinkId() is not available to the client.\n */\nPeerConnection.prototype._fallbackOnAddTrack = function fallbackOnAddTrack(pc, stream) {\n  var audio = document && document.createElement('audio');\n  audio.autoplay = true;\n\n  if (!setAudioSource(audio, stream)) {\n    pc._log.info('Error attaching stream to element.');\n  }\n\n  pc.outputs.set('default', {\n    audio: audio\n  });\n};\n\nPeerConnection.prototype._setEncodingParameters = function (enableDscp) {\n  if (!enableDscp || !this._sender || typeof this._sender.getParameters !== 'function' || typeof this._sender.setParameters !== 'function') {\n    return;\n  }\n\n  var params = this._sender.getParameters();\n  if (!params.priority && !(params.encodings && params.encodings.length)) {\n    return;\n  }\n\n  // This is how MDN's RTPSenderParameters defines priority\n  params.priority = 'high';\n\n  // And this is how it's currently implemented in Chrome M72+\n  if (params.encodings && params.encodings.length) {\n    params.encodings.forEach(function (encoding) {\n      encoding.priority = 'high';\n      encoding.networkPriority = 'high';\n    });\n  }\n\n  this._sender.setParameters(params);\n};\n\nPeerConnection.prototype._setupPeerConnection = function (rtcConstraints, rtcConfiguration) {\n  var _this4 = this;\n\n  var self = this;\n  var version = new (this.options.rtcpcFactory || RTCPC)();\n  version.create(rtcConstraints, rtcConfiguration);\n  addStream(version.pc, this.stream);\n\n  var eventName = 'ontrack' in version.pc ? 'ontrack' : 'onaddstream';\n\n  version.pc[eventName] = function (event) {\n    var stream = self._remoteStream = event.stream || event.streams[0];\n\n    if (typeof version.pc.getSenders === 'function') {\n      _this4._sender = version.pc.getSenders()[0];\n    }\n\n    if (self._isSinkSupported) {\n      self._onAddTrack(self, stream);\n    } else {\n      self._fallbackOnAddTrack(self, stream);\n    }\n\n    self._startPollingVolume();\n  };\n  return version;\n};\n\nPeerConnection.prototype._maybeSetIceAggressiveNomination = function (sdp) {\n  return this.options.forceAggressiveIceNomination ? setIceAggressiveNomination(sdp) : sdp;\n};\n\nPeerConnection.prototype._setupChannel = function () {\n  var _this5 = this;\n\n  var pc = this.version.pc;\n\n  // Chrome 25 supports onopen\n  this.version.pc.onopen = function () {\n    _this5.status = 'open';\n    _this5.onopen();\n  };\n\n  // Chrome 26 doesn't support onopen so must detect state change\n  this.version.pc.onstatechange = function () {\n    if (_this5.version.pc && _this5.version.pc.readyState === 'stable') {\n      _this5.status = 'open';\n      _this5.onopen();\n    }\n  };\n\n  // Chrome 27 changed onstatechange to onsignalingstatechange\n  this.version.pc.onsignalingstatechange = function () {\n    var state = pc.signalingState;\n    _this5._log.info('signalingState is \"' + state + '\"');\n\n    if (_this5.version.pc && _this5.version.pc.signalingState === 'stable') {\n      _this5.status = 'open';\n      _this5.onopen();\n    }\n\n    _this5.onsignalingstatechange(pc.signalingState);\n  };\n\n  // Chrome 72+\n  pc.onconnectionstatechange = function () {\n    _this5._log.info('pc.connectionState is \"' + pc.connectionState + '\"');\n    _this5.onpcconnectionstatechange(pc.connectionState);\n    _this5._onMediaConnectionStateChange(pc.connectionState);\n  };\n\n  pc.onicecandidate = function (event) {\n    var candidate = event.candidate;\n\n    if (candidate) {\n      _this5._hasIceCandidates = true;\n      _this5.onicecandidate(candidate);\n      _this5._setupRTCIceTransportListener();\n    }\n\n    _this5._log.info('ICE Candidate: ' + JSON.stringify(candidate));\n  };\n\n  pc.onicegatheringstatechange = function () {\n    var state = pc.iceGatheringState;\n    if (state === 'gathering') {\n      _this5._startIceGatheringTimeout();\n    } else if (state === 'complete') {\n      _this5._stopIceGatheringTimeout();\n\n      // Fail if no candidates found\n      if (!_this5._hasIceCandidates) {\n        _this5._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);\n      }\n\n      // There was a failure mid-gathering phase. We want to start our timer and issue\n      // an ice restart if we don't get connected after our timeout\n      if (_this5._hasIceCandidates && _this5._hasIceGatheringFailures) {\n        _this5._startIceGatheringTimeout();\n      }\n    }\n\n    _this5._log.info('pc.iceGatheringState is \"' + pc.iceGatheringState + '\"');\n    _this5.onicegatheringstatechange(state);\n  };\n\n  pc.oniceconnectionstatechange = function () {\n    _this5._log.info('pc.iceConnectionState is \"' + pc.iceConnectionState + '\"');\n    _this5.oniceconnectionstatechange(pc.iceConnectionState);\n    _this5._onMediaConnectionStateChange(pc.iceConnectionState);\n  };\n};\nPeerConnection.prototype._initializeMediaStream = function (rtcConstraints, rtcConfiguration) {\n  // if mediastream already open then do nothing\n  if (this.status === 'open') {\n    return false;\n  }\n  if (this.pstream.status === 'disconnected') {\n    this.onerror({ info: {\n        code: 31000,\n        message: 'Cannot establish connection. Client is disconnected',\n        twilioError: new SignalingErrors.ConnectionDisconnected()\n      } });\n    this.close();\n    return false;\n  }\n  this.version = this._setupPeerConnection(rtcConstraints, rtcConfiguration);\n  this._setupChannel();\n  return true;\n};\n\n/**\n * Remove reconnection-related listeners\n * @private\n */\nPeerConnection.prototype._removeReconnectionListeners = function () {\n  if (this.pstream) {\n    this.pstream.removeListener('answer', this._onAnswerOrRinging);\n    this.pstream.removeListener('hangup', this._onHangup);\n  }\n};\n\n/**\n * Setup a listener for RTCDtlsTransport to capture state changes events\n * @private\n */\nPeerConnection.prototype._setupRTCDtlsTransportListener = function () {\n  var _this6 = this;\n\n  var dtlsTransport = this.getRTCDtlsTransport();\n\n  if (!dtlsTransport || dtlsTransport.onstatechange) {\n    return;\n  }\n\n  var handler = function handler() {\n    _this6._log.info('dtlsTransportState is \"' + dtlsTransport.state + '\"');\n    _this6.ondtlstransportstatechange(dtlsTransport.state);\n  };\n\n  // Publish initial state\n  handler();\n  dtlsTransport.onstatechange = handler;\n};\n\n/**\n * Setup a listener for RTCIceTransport to capture selected candidate pair changes\n * @private\n */\nPeerConnection.prototype._setupRTCIceTransportListener = function () {\n  var _this7 = this;\n\n  var iceTransport = this._getRTCIceTransport();\n\n  if (!iceTransport || iceTransport.onselectedcandidatepairchange) {\n    return;\n  }\n\n  iceTransport.onselectedcandidatepairchange = function () {\n    return _this7.onselectedcandidatepairchange(iceTransport.getSelectedCandidatePair());\n  };\n};\n\n/**\n * Restarts ICE for the current connection\n * ICE Restart failures are ignored. Retries are managed in Connection\n * @private\n */\nPeerConnection.prototype.iceRestart = function () {\n  var _this8 = this;\n\n  if (!this.options.enableIceRestart) {\n    return;\n  }\n  this._log.info('Attempting to restart ICE...');\n  this._hasIceCandidates = false;\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { iceRestart: true }).then(function () {\n    _this8._removeReconnectionListeners();\n\n    _this8._onAnswerOrRinging = function (payload) {\n      _this8._removeReconnectionListeners();\n\n      if (!payload.sdp || _this8.version.pc.signalingState !== 'have-local-offer') {\n        var message = 'Invalid state or param during ICE Restart:' + ('hasSdp:' + !!payload.sdp + ', signalingState:' + _this8.version.pc.signalingState);\n        _this8._log.info(message);\n        return;\n      }\n\n      var sdp = _this8._maybeSetIceAggressiveNomination(payload.sdp);\n      _this8._answerSdp = sdp;\n      if (_this8.status !== 'closed') {\n        _this8.version.processAnswer(_this8.codecPreferences, sdp, null, function (err) {\n          var message = err && err.message ? err.message : err;\n          _this8._log.info('Failed to process answer during ICE Restart. Error: ' + message);\n        });\n      }\n    };\n\n    _this8._onHangup = function () {\n      _this8._log.info('Received hangup during ICE Restart');\n      _this8._removeReconnectionListeners();\n    };\n\n    _this8.pstream.on('answer', _this8._onAnswerOrRinging);\n    _this8.pstream.on('hangup', _this8._onHangup);\n    _this8.pstream.reinvite(_this8.version.getSDP(), _this8.callSid);\n  }).catch(function (err) {\n    var message = err && err.message ? err.message : err;\n    _this8._log.info('Failed to createOffer during ICE Restart. Error: ' + message);\n    // CreateOffer failures doesn't transition ice state to failed\n    // We need trigger it so it can be picked up by retries\n    _this8.onfailed(message);\n  });\n};\n\nPeerConnection.prototype.makeOutgoingCall = function (token, params, callsid, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  var _this9 = this;\n\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n\n  var self = this;\n  this.callSid = callsid;\n  function onAnswerSuccess() {\n    if (self.options) {\n      self._setEncodingParameters(self.options.dscp);\n    }\n    onMediaStarted(self.version.pc);\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({ info: {\n        code: 31000,\n        message: 'Error processing answer: ' + errMsg,\n        twilioError: new MediaErrors.ClientRemoteDescFailed()\n      } });\n  }\n  this._onAnswerOrRinging = function (payload) {\n    if (!payload.sdp) {\n      return;\n    }\n\n    var sdp = _this9._maybeSetIceAggressiveNomination(payload.sdp);\n    self._answerSdp = sdp;\n    if (self.status !== 'closed') {\n      self.version.processAnswer(_this9.codecPreferences, sdp, onAnswerSuccess, onAnswerError);\n    }\n    self.pstream.removeListener('answer', self._onAnswerOrRinging);\n    self.pstream.removeListener('ringing', self._onAnswerOrRinging);\n  };\n  this.pstream.on('answer', this._onAnswerOrRinging);\n  this.pstream.on('ringing', this._onAnswerOrRinging);\n\n  function onOfferSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.invite(self.version.getSDP(), self.callSid, self.options.preflight, params);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n\n  function onOfferError(err) {\n    var errMsg = err.message || err;\n    self.onerror({ info: {\n        code: 31000,\n        message: 'Error creating the offer: ' + errMsg,\n        twilioError: new MediaErrors.ClientLocalDescFailed()\n      } });\n  }\n\n  this.version.createOffer(this.options.maxAverageBitrate, this.codecPreferences, { audio: true }, onOfferSuccess, onOfferError);\n};\nPeerConnection.prototype.answerIncomingCall = function (callSid, sdp, rtcConstraints, rtcConfiguration, onMediaStarted) {\n  if (!this._initializeMediaStream(rtcConstraints, rtcConfiguration)) {\n    return;\n  }\n  sdp = this._maybeSetIceAggressiveNomination(sdp);\n  this._answerSdp = sdp.replace(/^a=setup:actpass$/gm, 'a=setup:passive');\n  this.callSid = callSid;\n  var self = this;\n  function onAnswerSuccess() {\n    if (self.status !== 'closed') {\n      self.pstream.answer(self.version.getSDP(), callSid);\n      if (self.options) {\n        self._setEncodingParameters(self.options.dscp);\n      }\n      onMediaStarted(self.version.pc);\n      self._setupRTCDtlsTransportListener();\n    }\n  }\n  function onAnswerError(err) {\n    var errMsg = err.message || err;\n    self.onerror({ info: {\n        code: 31000,\n        message: 'Error creating the answer: ' + errMsg,\n        twilioError: new MediaErrors.ClientRemoteDescFailed()\n      } });\n  }\n  this.version.processSDP(this.options.maxAverageBitrate, this.codecPreferences, sdp, { audio: true }, onAnswerSuccess, onAnswerError);\n};\nPeerConnection.prototype.close = function () {\n  if (this.version && this.version.pc) {\n    if (this.version.pc.signalingState !== 'closed') {\n      this.version.pc.close();\n    }\n\n    this.version.pc = null;\n  }\n  if (this.stream) {\n    this.mute(false);\n    this._stopStream(this.stream);\n  }\n  this.stream = null;\n  this._removeReconnectionListeners();\n  this._stopIceGatheringTimeout();\n\n  Promise.all(this._removeAudioOutputs()).catch(function () {\n    // We don't need to alert about failures here.\n  });\n  if (this._mediaStreamSource) {\n    this._mediaStreamSource.disconnect();\n  }\n  if (this._inputAnalyser) {\n    this._inputAnalyser.disconnect();\n  }\n  if (this._outputAnalyser) {\n    this._outputAnalyser.disconnect();\n  }\n  if (this._inputAnalyser2) {\n    this._inputAnalyser2.disconnect();\n  }\n  if (this._outputAnalyser2) {\n    this._outputAnalyser2.disconnect();\n  }\n  this.status = 'closed';\n  this.onclose();\n};\nPeerConnection.prototype.reject = function (callSid) {\n  this.callSid = callSid;\n};\nPeerConnection.prototype.ignore = function (callSid) {\n  this.callSid = callSid;\n};\n/**\n * Mute or unmute input audio. If the stream is not yet present, the setting\n *   is saved and applied to future streams/tracks.\n * @params {boolean} shouldMute - Whether the input audio should\n *   be muted or unmuted.\n */\nPeerConnection.prototype.mute = function (shouldMute) {\n  this.isMuted = shouldMute;\n  if (!this.stream) {\n    return;\n  }\n\n  if (this._sender && this._sender.track) {\n    this._sender.track.enabled = !shouldMute;\n  } else {\n    var audioTracks = typeof this.stream.getAudioTracks === 'function' ? this.stream.getAudioTracks() : this.stream.audioTracks;\n\n    audioTracks.forEach(function (track) {\n      track.enabled = !shouldMute;\n    });\n  }\n};\n/**\n * Get or create an RTCDTMFSender for the first local audio MediaStreamTrack\n * we can get from the RTCPeerConnection. Return null if unsupported.\n * @instance\n * @returns ?RTCDTMFSender\n */\nPeerConnection.prototype.getOrCreateDTMFSender = function getOrCreateDTMFSender() {\n  if (this._dtmfSender || this._dtmfSenderUnsupported) {\n    return this._dtmfSender || null;\n  }\n\n  var self = this;\n  var pc = this.version.pc;\n  if (!pc) {\n    this._log.info('No RTCPeerConnection available to call createDTMFSender on');\n    return null;\n  }\n\n  if (typeof pc.getSenders === 'function' && (typeof RTCDTMFSender === 'function' || typeof RTCDtmfSender === 'function')) {\n    var chosenSender = pc.getSenders().find(function (sender) {\n      return sender.dtmf;\n    });\n    if (chosenSender) {\n      this._log.info('Using RTCRtpSender#dtmf');\n      this._dtmfSender = chosenSender.dtmf;\n      return this._dtmfSender;\n    }\n  }\n\n  if (typeof pc.createDTMFSender === 'function' && typeof pc.getLocalStreams === 'function') {\n    var track = pc.getLocalStreams().map(function (stream) {\n      var tracks = self._getAudioTracks(stream);\n      return tracks && tracks[0];\n    })[0];\n\n    if (!track) {\n      this._log.info('No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender');\n      return null;\n    }\n\n    this._log.info('Creating RTCDTMFSender');\n    this._dtmfSender = pc.createDTMFSender(track);\n    return this._dtmfSender;\n  }\n\n  this._log.info('RTCPeerConnection does not support RTCDTMFSender');\n  this._dtmfSenderUnsupported = true;\n  return null;\n};\n\n/**\n * Get the RTCDtlTransport object from the PeerConnection\n * @returns RTCDtlTransport\n */\nPeerConnection.prototype.getRTCDtlsTransport = function getRTCDtlsTransport() {\n  var sender = this.version && this.version.pc && typeof this.version.pc.getSenders === 'function' && this.version.pc.getSenders()[0];\n  return sender && sender.transport || null;\n};\n\nPeerConnection.prototype._canStopMediaStreamTrack = function () {\n  return typeof MediaStreamTrack.prototype.stop === 'function';\n};\n\nPeerConnection.prototype._getAudioTracks = function (stream) {\n  return typeof stream.getAudioTracks === 'function' ? stream.getAudioTracks() : stream.audioTracks;\n};\n\n/**\n * Get the RTCIceTransport object from the PeerConnection\n * @returns RTCIceTransport\n */\nPeerConnection.prototype._getRTCIceTransport = function _getRTCIceTransport() {\n  var dtlsTransport = this.getRTCDtlsTransport();\n  return dtlsTransport && dtlsTransport.iceTransport || null;\n};\n\n// Is PeerConnection.protocol used outside of our SDK? We should remove this if not.\nPeerConnection.protocol = function () {\n  return RTCPC.test() ? new RTCPC() : null;\n}();\n\nfunction addStream(pc, stream) {\n  if (typeof pc.addTrack === 'function') {\n    stream.getAudioTracks().forEach(function (track) {\n      // The second parameters, stream, should not be necessary per the latest editor's\n      //   draft, but FF requires it. https://bugzilla.mozilla.org/show_bug.cgi?id=1231414\n      pc.addTrack(track, stream);\n    });\n  } else {\n    pc.addStream(stream);\n  }\n}\n\nfunction cloneStream(oldStream) {\n  var newStream = typeof MediaStream !== 'undefined' ? new MediaStream()\n  // eslint-disable-next-line\n  : new webkitMediaStream();\n\n  oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);\n  return newStream;\n}\n\nfunction removeStream(pc, stream) {\n  if (typeof pc.removeTrack === 'function') {\n    pc.getSenders().forEach(function (sender) {\n      pc.removeTrack(sender);\n    });\n  } else {\n    pc.removeStream(stream);\n  }\n}\n\n/**\n * Set the source of an HTMLAudioElement to the specified MediaStream\n * @param {HTMLAudioElement} audio\n * @param {MediaStream} stream\n * @returns {boolean} Whether the audio source was set successfully\n */\nfunction setAudioSource(audio, stream) {\n  if (typeof audio.srcObject !== 'undefined') {\n    audio.srcObject = stream;\n  } else if (typeof audio.mozSrcObject !== 'undefined') {\n    audio.mozSrcObject = stream;\n  } else if (typeof audio.src !== 'undefined') {\n    var _window = audio.options.window || window;\n    audio.src = (_window.URL || _window.webkitURL).createObjectURL(stream);\n  } else {\n    return false;\n  }\n\n  return true;\n}\n\nPeerConnection.enabled = RTCPC.test();\n\nmodule.exports = PeerConnection;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9wZWVyY29ubmVjdGlvbi5qcz9iZjE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQywwRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLDJGQUF5QjtBQUNuQyxXQUFXLG1CQUFPLENBQUMsZ0VBQVM7QUFDNUIsWUFBWSxtQkFBTyxDQUFDLHFFQUFTOztBQUU3QixnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBTztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdGQUF3RixjQUFjO0FBQ3RHO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixtQkFBbUI7QUFDdEc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFO0FBQ1Q7O0FBRUEsbUZBQW1GLGNBQWM7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sRUFBRTtBQUNUO0FBQ0EsdUZBQXVGLGNBQWM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFlBQVk7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9ydGMvcGVlcmNvbm5lY3Rpb24uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLFxuICAgIEludmFsaWRBcmd1bWVudEVycm9yID0gX3JlcXVpcmUuSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gICAgTWVkaWFFcnJvcnMgPSBfcmVxdWlyZS5NZWRpYUVycm9ycyxcbiAgICBOb3RTdXBwb3J0ZWRFcnJvciA9IF9yZXF1aXJlLk5vdFN1cHBvcnRlZEVycm9yLFxuICAgIFNpZ25hbGluZ0Vycm9ycyA9IF9yZXF1aXJlLlNpZ25hbGluZ0Vycm9ycztcblxudmFyIExvZyA9IHJlcXVpcmUoJy4uL2xvZycpLmRlZmF1bHQ7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBSVENQQyA9IHJlcXVpcmUoJy4vcnRjcGMnKTtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJy4vc2RwJyksXG4gICAgc2V0SWNlQWdncmVzc2l2ZU5vbWluYXRpb24gPSBfcmVxdWlyZTIuc2V0SWNlQWdncmVzc2l2ZU5vbWluYXRpb247XG5cbnZhciBJQ0VfR0FUSEVSSU5HX1RJTUVPVVQgPSAxNTAwMDtcbnZhciBJQ0VfR0FUSEVSSU5HX0ZBSUxfTk9ORSA9ICdub25lJztcbnZhciBJQ0VfR0FUSEVSSU5HX0ZBSUxfVElNRU9VVCA9ICd0aW1lb3V0JztcbnZhciBJTklUSUFMX0lDRV9DT05ORUNUSU9OX1NUQVRFID0gJ25ldyc7XG52YXIgVk9MVU1FX0lOVEVSVkFMX01TID0gNTA7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUGVlckNvbm5lY3Rpb25cbiAqIEBwYXJhbSBhdWRpb0hlbHBlclxuICogQHBhcmFtIHBzdHJlYW1cbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJuIHtQZWVyQ29ubmVjdGlvbn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQZWVyQ29ubmVjdGlvbihhdWRpb0hlbHBlciwgcHN0cmVhbSwgZ2V0VXNlck1lZGlhLCBvcHRpb25zKSB7XG4gIGlmICghYXVkaW9IZWxwZXIgfHwgIXBzdHJlYW0gfHwgIWdldFVzZXJNZWRpYSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXVkaW9oZWxwZXIsIHBzdHJlYW0gYW5kIGdldFVzZXJNZWRpYSBhcmUgcmVxdWlyZWQgYXJndW1lbnRzJyk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuIG5ldyBQZWVyQ29ubmVjdGlvbihhdWRpb0hlbHBlciwgcHN0cmVhbSwgZ2V0VXNlck1lZGlhLCBvcHRpb25zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vb3AoKSB7fVxuICB0aGlzLm9ub3BlbiA9IG5vb3A7XG4gIHRoaXMub25lcnJvciA9IG5vb3A7XG4gIHRoaXMub25jbG9zZSA9IG5vb3A7XG4gIHRoaXMub25kaXNjb25uZWN0ZWQgPSBub29wO1xuICB0aGlzLm9uZmFpbGVkID0gbm9vcDtcbiAgdGhpcy5vbmNvbm5lY3RlZCA9IG5vb3A7XG4gIHRoaXMub25yZWNvbm5lY3RlZCA9IG5vb3A7XG4gIHRoaXMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IG5vb3A7XG4gIHRoaXMub25kdGxzdHJhbnNwb3J0c3RhdGVjaGFuZ2UgPSBub29wO1xuICB0aGlzLm9uaWNlZ2F0aGVyaW5nZmFpbHVyZSA9IG5vb3A7XG4gIHRoaXMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IG5vb3A7XG4gIHRoaXMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBub29wO1xuICB0aGlzLm9ucGNjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBub29wO1xuICB0aGlzLm9uaWNlY2FuZGlkYXRlID0gbm9vcDtcbiAgdGhpcy5vbnNlbGVjdGVkY2FuZGlkYXRlcGFpcmNoYW5nZSA9IG5vb3A7XG4gIHRoaXMub252b2x1bWUgPSBub29wO1xuICB0aGlzLnZlcnNpb24gPSBudWxsO1xuICB0aGlzLnBzdHJlYW0gPSBwc3RyZWFtO1xuICB0aGlzLnN0cmVhbSA9IG51bGw7XG4gIHRoaXMuc2lua0lkcyA9IG5ldyBTZXQoWydkZWZhdWx0J10pO1xuICB0aGlzLm91dHB1dHMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuc3RhdHVzID0gJ2Nvbm5lY3RpbmcnO1xuICB0aGlzLmNhbGxTaWQgPSBudWxsO1xuICB0aGlzLmlzTXV0ZWQgPSBmYWxzZTtcbiAgdGhpcy5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWE7XG5cbiAgdmFyIEF1ZGlvQ29udGV4dCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpO1xuICB0aGlzLl9pc1NpbmtTdXBwb3J0ZWQgPSAhIUF1ZGlvQ29udGV4dCAmJiB0eXBlb2YgSFRNTEF1ZGlvRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgSFRNTEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2V0U2lua0lkO1xuICAvLyBOT1RFKG1tYWxhdmFsbGkpOiBTaW5jZSBlYWNoIENvbm5lY3Rpb24gY3JlYXRlcyBpdHMgb3duIEF1ZGlvQ29udGV4dCxcbiAgLy8gYWZ0ZXIgNiBpbnN0YW5jZXMgYW4gZXhjZXB0aW9uIGlzIHRocm93bi4gUmVmZXIgaHR0cHM6Ly93d3cudzMub3JnLzIwMTEvYXVkaW8vdHJhY2svaXNzdWVzLzMuXG4gIC8vIEluIG9yZGVyIHRvIGdldCBhcm91bmQgaXQsIHdlIGFyZSByZS11c2luZyB0aGUgRGV2aWNlJ3MgQXVkaW9Db250ZXh0LlxuICB0aGlzLl9hdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHQgJiYgYXVkaW9IZWxwZXIuX2F1ZGlvQ29udGV4dDtcbiAgdGhpcy5faGFzSWNlQ2FuZGlkYXRlcyA9IGZhbHNlO1xuICB0aGlzLl9oYXNJY2VHYXRoZXJpbmdGYWlsdXJlcyA9IGZhbHNlO1xuICB0aGlzLl9pY2VHYXRoZXJpbmdUaW1lb3V0SWQgPSBudWxsO1xuICB0aGlzLl9tYXN0ZXJBdWRpbyA9IG51bGw7XG4gIHRoaXMuX21hc3RlckF1ZGlvRGV2aWNlSWQgPSBudWxsO1xuICB0aGlzLl9tZWRpYVN0cmVhbVNvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2R0bWZTZW5kZXIgPSBudWxsO1xuICB0aGlzLl9kdG1mU2VuZGVyVW5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdGhpcy5fY2FsbEV2ZW50cyA9IFtdO1xuICB0aGlzLl9uZXh0VGltZVRvUHVibGlzaCA9IERhdGUubm93KCk7XG4gIHRoaXMuX29uQW5zd2VyT3JSaW5naW5nID0gbm9vcDtcbiAgdGhpcy5fb25IYW5ndXAgPSBub29wO1xuICB0aGlzLl9yZW1vdGVTdHJlYW0gPSBudWxsO1xuICB0aGlzLl9zaG91bGRNYW5hZ2VTdHJlYW0gPSB0cnVlO1xuICB0aGlzLl9pY2VTdGF0ZSA9IElOSVRJQUxfSUNFX0NPTk5FQ1RJT05fU1RBVEU7XG4gIHRoaXMuX2lzVW5pZmllZFBsYW4gPSBvcHRpb25zLmlzVW5pZmllZFBsYW47XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMubmF2aWdhdG9yID0gb3B0aW9ucy5uYXZpZ2F0b3IgfHwgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gbmF2aWdhdG9yIDogbnVsbCk7XG4gIHRoaXMudXRpbCA9IG9wdGlvbnMudXRpbCB8fCB1dGlsO1xuICB0aGlzLmNvZGVjUHJlZmVyZW5jZXMgPSBvcHRpb25zLmNvZGVjUHJlZmVyZW5jZXM7XG5cbiAgdGhpcy5fbG9nID0gTG9nLmdldEluc3RhbmNlKCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl91cmk7XG59O1xuXG4vKipcbiAqIE9wZW4gdGhlIHVuZGVybHlpbmcgUlRDUGVlckNvbm5lY3Rpb24gd2l0aCBhIE1lZGlhU3RyZWFtIG9idGFpbmVkIGJ5XG4gKiAgIHBhc3NlZCBjb25zdHJhaW50cy4gVGhlIHJlc3VsdGluZyBNZWRpYVN0cmVhbSBpcyBjcmVhdGVkIGludGVybmFsbHlcbiAqICAgYW5kIHdpbGwgdGhlcmVmb3JlIGJlIG1hbmFnZWQgYW5kIGRlc3Ryb3llZCBpbnRlcm5hbGx5LlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbUNvbnN0cmFpbnRzfSBjb25zdHJhaW50c1xuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUub3BlbldpdGhDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xuICByZXR1cm4gdGhpcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzogY29uc3RyYWludHMgfSkudGhlbih0aGlzLl9zZXRJbnB1dFRyYWNrc0Zyb21TdHJlYW0uYmluZCh0aGlzLCBmYWxzZSkpO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBleGlzdGluZyBpbnB1dCBhdWRpbyB0cmFja3Mgd2l0aCB0aGUgYXVkaW8gdHJhY2tzIGZyb20gdGhlXG4gKiAgIHBhc3NlZCBpbnB1dCBhdWRpbyBzdHJlYW0uIFdlIHJlLXVzZSB0aGUgZXhpc3Rpbmcgc3RyZWFtIGJlY2F1c2VcbiAqICAgdGhlIEFuYWx5emVyTm9kZSBpcyBib3VuZCB0byB0aGUgc3RyZWFtLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gKi9cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRJbnB1dFRyYWNrc0Zyb21TdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIHRoaXMuX3NldElucHV0VHJhY2tzRnJvbVN0cmVhbSh0cnVlLCBzdHJlYW0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3Nob3VsZE1hbmFnZVN0cmVhbSA9IGZhbHNlO1xuICB9KTtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlQW5hbHlzZXIgPSBmdW5jdGlvbiAoYXVkaW9Db250ZXh0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBmZnRTaXplOiAzMixcbiAgICBzbW9vdGhpbmdUaW1lQ29uc3RhbnQ6IDAuM1xuICB9LCBvcHRpb25zKTtcblxuICB2YXIgYW5hbHlzZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcbiAgZm9yICh2YXIgZmllbGQgaW4gb3B0aW9ucykge1xuICAgIGFuYWx5c2VyW2ZpZWxkXSA9IG9wdGlvbnNbZmllbGRdO1xuICB9XG5cbiAgcmV0dXJuIGFuYWx5c2VyO1xufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZXRWb2x1bWVIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgdGhpcy5vbnZvbHVtZSA9IGhhbmRsZXI7XG59O1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9zdGFydFBvbGxpbmdWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5fYXVkaW9Db250ZXh0IHx8ICF0aGlzLnN0cmVhbSB8fCAhdGhpcy5fcmVtb3RlU3RyZWFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuX2F1ZGlvQ29udGV4dDtcblxuICB2YXIgaW5wdXRBbmFseXNlciA9IHRoaXMuX2lucHV0QW5hbHlzZXIgPSB0aGlzLl9jcmVhdGVBbmFseXNlcihhdWRpb0NvbnRleHQpO1xuICB2YXIgaW5wdXRCdWZmZXJMZW5ndGggPSBpbnB1dEFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICB2YXIgaW5wdXREYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShpbnB1dEJ1ZmZlckxlbmd0aCk7XG4gIHRoaXMuX2lucHV0QW5hbHlzZXIyID0gdGhpcy5fY3JlYXRlQW5hbHlzZXIoYXVkaW9Db250ZXh0LCB7XG4gICAgbWluRGVjaWJlbHM6IC0xMjcsXG4gICAgbWF4RGVjaWJlbHM6IDAsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwXG4gIH0pO1xuXG4gIHZhciBvdXRwdXRBbmFseXNlciA9IHRoaXMuX291dHB1dEFuYWx5c2VyID0gdGhpcy5fY3JlYXRlQW5hbHlzZXIoYXVkaW9Db250ZXh0KTtcbiAgdmFyIG91dHB1dEJ1ZmZlckxlbmd0aCA9IG91dHB1dEFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICB2YXIgb3V0cHV0RGF0YUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkob3V0cHV0QnVmZmVyTGVuZ3RoKTtcbiAgdGhpcy5fb3V0cHV0QW5hbHlzZXIyID0gdGhpcy5fY3JlYXRlQW5hbHlzZXIoYXVkaW9Db250ZXh0LCB7XG4gICAgbWluRGVjaWJlbHM6IC0xMjcsXG4gICAgbWF4RGVjaWJlbHM6IDAsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwXG4gIH0pO1xuXG4gIHRoaXMuX3VwZGF0ZUlucHV0U3RyZWFtU291cmNlKHRoaXMuc3RyZWFtKTtcbiAgdGhpcy5fdXBkYXRlT3V0cHV0U3RyZWFtU291cmNlKHRoaXMuX3JlbW90ZVN0cmVhbSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uIGVtaXRWb2x1bWUoKSB7XG4gICAgaWYgKCFzZWxmLl9hdWRpb0NvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHNlbGYuc3RhdHVzID09PSAnY2xvc2VkJykge1xuICAgICAgc2VsZi5faW5wdXRBbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICBzZWxmLl9vdXRwdXRBbmFseXNlci5kaXNjb25uZWN0KCk7XG4gICAgICBzZWxmLl9pbnB1dEFuYWx5c2VyMi5kaXNjb25uZWN0KCk7XG4gICAgICBzZWxmLl9vdXRwdXRBbmFseXNlcjIuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNlbGYuX2lucHV0QW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoaW5wdXREYXRhQXJyYXkpO1xuICAgIHZhciBpbnB1dFZvbHVtZSA9IHNlbGYudXRpbC5hdmVyYWdlKGlucHV0RGF0YUFycmF5KTtcblxuICAgIHNlbGYuX2lucHV0QW5hbHlzZXIyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKGlucHV0RGF0YUFycmF5KTtcbiAgICB2YXIgaW5wdXRWb2x1bWUyID0gc2VsZi51dGlsLmF2ZXJhZ2UoaW5wdXREYXRhQXJyYXkpO1xuXG4gICAgc2VsZi5fb3V0cHV0QW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEob3V0cHV0RGF0YUFycmF5KTtcbiAgICB2YXIgb3V0cHV0Vm9sdW1lID0gc2VsZi51dGlsLmF2ZXJhZ2Uob3V0cHV0RGF0YUFycmF5KTtcblxuICAgIHNlbGYuX291dHB1dEFuYWx5c2VyMi5nZXRCeXRlRnJlcXVlbmN5RGF0YShvdXRwdXREYXRhQXJyYXkpO1xuICAgIHZhciBvdXRwdXRWb2x1bWUyID0gc2VsZi51dGlsLmF2ZXJhZ2Uob3V0cHV0RGF0YUFycmF5KTtcbiAgICBzZWxmLm9udm9sdW1lKGlucHV0Vm9sdW1lIC8gMjU1LCBvdXRwdXRWb2x1bWUgLyAyNTUsIGlucHV0Vm9sdW1lMiwgb3V0cHV0Vm9sdW1lMik7XG5cbiAgICBzZXRUaW1lb3V0KGVtaXRWb2x1bWUsIFZPTFVNRV9JTlRFUlZBTF9NUyk7XG4gIH0sIFZPTFVNRV9JTlRFUlZBTF9NUyk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3N0b3BTdHJlYW0gPSBmdW5jdGlvbiBfc3RvcFN0cmVhbShzdHJlYW0pIHtcbiAgLy8gV2Ugc2hvdWxkbid0IHN0b3AgdGhlIHRyYWNrcyBpZiB0aGV5IHdlcmUgbm90IGNyZWF0ZWQgaW5zaWRlXG4gIC8vICAgdGhpcyBQZWVyQ29ubmVjdGlvbi5cbiAgaWYgKCF0aGlzLl9zaG91bGRNYW5hZ2VTdHJlYW0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAodHlwZW9mIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLnN0b3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYXVkaW9UcmFja3MgPSB0eXBlb2Ygc3RyZWFtLmdldEF1ZGlvVHJhY2tzID09PSAnZnVuY3Rpb24nID8gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkgOiBzdHJlYW0uYXVkaW9UcmFja3M7XG4gICAgYXVkaW9UcmFja3MuZm9yRWFjaChmdW5jdGlvbiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBOT1RFKG1yb2JlcnRzKTogVGhpcyBpcyBqdXN0IGEgZmFsbGJhY2sgdG8gYW55IGFuY2llbnQgYnJvd3NlcnMgdGhhdCBtYXlcbiAgLy8gbm90IGltcGxlbWVudCBNZWRpYVN0cmVhbVRyYWNrLnN0b3AuXG4gIGVsc2Uge1xuICAgICAgc3RyZWFtLnN0b3AoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgc3RyZWFtIHNvdXJjZSB3aXRoIHRoZSBuZXcgaW5wdXQgYXVkaW8gc3RyZWFtLlxuICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gc3RyZWFtXG4gKiBAcHJpdmF0ZVxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZUlucHV0U3RyZWFtU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICBpZiAodGhpcy5faW5wdXRTdHJlYW1Tb3VyY2UpIHtcbiAgICB0aGlzLl9pbnB1dFN0cmVhbVNvdXJjZS5kaXNjb25uZWN0KCk7XG4gIH1cblxuICB0aGlzLl9pbnB1dFN0cmVhbVNvdXJjZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICB0aGlzLl9pbnB1dFN0cmVhbVNvdXJjZS5jb25uZWN0KHRoaXMuX2lucHV0QW5hbHlzZXIpO1xuICB0aGlzLl9pbnB1dFN0cmVhbVNvdXJjZS5jb25uZWN0KHRoaXMuX2lucHV0QW5hbHlzZXIyKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzdHJlYW0gc291cmNlIHdpdGggdGhlIG5ldyBvdXB1dCBhdWRpbyBzdHJlYW0uXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fdXBkYXRlT3V0cHV0U3RyZWFtU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtU291cmNlKSB7XG4gICAgdGhpcy5fb3V0cHV0U3RyZWFtU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHRoaXMuX291dHB1dFN0cmVhbVNvdXJjZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuICB0aGlzLl9vdXRwdXRTdHJlYW1Tb3VyY2UuY29ubmVjdCh0aGlzLl9vdXRwdXRBbmFseXNlcik7XG4gIHRoaXMuX291dHB1dFN0cmVhbVNvdXJjZS5jb25uZWN0KHRoaXMuX291dHB1dEFuYWx5c2VyMik7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHRyYWNrcyBvZiB0aGUgY3VycmVudCBzdHJlYW0gd2l0aCBuZXcgdHJhY2tzLiBXZSBkbyB0aGlzIHJhdGhlciB0aGFuIHJlcGxhY2luZyB0aGVcbiAqICAgd2hvbGUgc3RyZWFtIGJlY2F1c2UgQW5hbHl6ZXJOb2RlcyBhcmUgYm91bmQgdG8gYSBzdHJlYW0uXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lIC0gV2hldGhlciB0aGUgc3RyZWFtIHNob3VsZCBiZSBjbG9uZWQgaWYgaXQgaXMgdGhlIGZpcnN0XG4gKiAgIHN0cmVhbSwgb3Igc2V0IGRpcmVjdGx5LiBBcyBhIHJ1bGUgb2YgdGh1bWIsIHN0cmVhbXMgdGhhdCBhcmUgcGFzc2VkIGluIGV4dGVybmFsbHkgbWF5IGhhdmVcbiAqICAgdGhlaXIgbGlmZWN5Y2xlIG1hbmFnZWQgZXh0ZXJuYWxseSwgYW5kIHNob3VsZCBiZSBjbG9uZWQgc28gdGhhdCB3ZSBkbyBub3QgdGVhciBpdCBvciBpdHMgdHJhY2tzXG4gKiAgIGRvd24gd2hlbiB0aGUgY2FsbCBlbmRzLiBTdHJlYW1zIHRoYXQgd2UgY3JlYXRlIGludGVybmFsbHkgKGluc2lkZSBQZWVyQ29ubmVjdGlvbikgc2hvdWxkIGJlIHNldFxuICogICBkaXJlY3RseSBzbyB0aGF0IHdoZW4gdGhlIGNhbGwgZW5kcyBpdCBpcyBkaXNwb3NlZCBvZi5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG5ld1N0cmVhbSAtIFRoZSBuZXcgc3RyZWFtIHRvIGNvcHkgdGhlIHRyYWNrcyBvdmVyIGZyb20uXG4gKiBAcHJpdmF0ZVxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldElucHV0VHJhY2tzRnJvbVN0cmVhbSA9IGZ1bmN0aW9uIChzaG91bGRDbG9uZSwgbmV3U3RyZWFtKSB7XG4gIHJldHVybiB0aGlzLl9pc1VuaWZpZWRQbGFuID8gdGhpcy5fc2V0SW5wdXRUcmFja3NGb3JVbmlmaWVkUGxhbihzaG91bGRDbG9uZSwgbmV3U3RyZWFtKSA6IHRoaXMuX3NldElucHV0VHJhY2tzRm9yUGxhbkIoc2hvdWxkQ2xvbmUsIG5ld1N0cmVhbSk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHRyYWNrcyBvZiB0aGUgY3VycmVudCBzdHJlYW0gd2l0aCBuZXcgdHJhY2tzIHVzaW5nIHRoZSAncGxhbi1iJyBtZXRob2QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lIC0gV2hldGhlciB0aGUgc3RyZWFtIHNob3VsZCBiZSBjbG9uZWQgaWYgaXQgaXMgdGhlIGZpcnN0XG4gKiAgIHN0cmVhbSwgb3Igc2V0IGRpcmVjdGx5LiBBcyBhIHJ1bGUgb2YgdGh1bWIsIHN0cmVhbXMgdGhhdCBhcmUgcGFzc2VkIGluIGV4dGVybmFsbHkgbWF5IGhhdmVcbiAqICAgdGhlaXIgbGlmZWN5Y2xlIG1hbmFnZWQgZXh0ZXJuYWxseSwgYW5kIHNob3VsZCBiZSBjbG9uZWQgc28gdGhhdCB3ZSBkbyBub3QgdGVhciBpdCBvciBpdHMgdHJhY2tzXG4gKiAgIGRvd24gd2hlbiB0aGUgY2FsbCBlbmRzLiBTdHJlYW1zIHRoYXQgd2UgY3JlYXRlIGludGVybmFsbHkgKGluc2lkZSBQZWVyQ29ubmVjdGlvbikgc2hvdWxkIGJlIHNldFxuICogICBkaXJlY3RseSBzbyB0aGF0IHdoZW4gdGhlIGNhbGwgZW5kcyBpdCBpcyBkaXNwb3NlZCBvZi5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG5ld1N0cmVhbSAtIFRoZSBuZXcgc3RyZWFtIHRvIGNvcHkgdGhlIHRyYWNrcyBvdmVyIGZyb20uXG4gKiBAcHJpdmF0ZVxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldElucHV0VHJhY2tzRm9yUGxhbkIgPSBmdW5jdGlvbiAoc2hvdWxkQ2xvbmUsIG5ld1N0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICghbmV3U3RyZWFtKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQ2FuIG5vdCBzZXQgaW5wdXQgc3RyZWFtIHRvIG51bGwgd2hpbGUgaW4gYSBjYWxsJykpO1xuICB9XG5cbiAgaWYgKCFuZXdTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdTdXBwbGllZCBpbnB1dCBzdHJlYW0gaGFzIG5vIGF1ZGlvIHRyYWNrcycpKTtcbiAgfVxuXG4gIHZhciBsb2NhbFN0cmVhbSA9IHRoaXMuc3RyZWFtO1xuXG4gIGlmICghbG9jYWxTdHJlYW0pIHtcbiAgICAvLyBXZSBjYW4ndCB1c2UgTWVkaWFTdHJlYW0uY2xvbmUoKSBoZXJlIGJlY2F1c2UgaXQgc3RvcHBlZCBjb3B5aW5nIG92ZXIgdHJhY2tzXG4gICAgLy8gICBhcyBvZiBDaHJvbWUgNjEuIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTc3MDkwOFxuICAgIHRoaXMuc3RyZWFtID0gc2hvdWxkQ2xvbmUgPyBjbG9uZVN0cmVhbShuZXdTdHJlYW0pIDogbmV3U3RyZWFtO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3N0b3BTdHJlYW0obG9jYWxTdHJlYW0pO1xuXG4gICAgcmVtb3ZlU3RyZWFtKHRoaXMudmVyc2lvbi5wYywgbG9jYWxTdHJlYW0pO1xuICAgIGxvY2FsU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChsb2NhbFN0cmVhbS5yZW1vdmVUcmFjaywgbG9jYWxTdHJlYW0pO1xuICAgIG5ld1N0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2gobG9jYWxTdHJlYW0uYWRkVHJhY2ssIGxvY2FsU3RyZWFtKTtcbiAgICBhZGRTdHJlYW0odGhpcy52ZXJzaW9uLnBjLCBuZXdTdHJlYW0pO1xuXG4gICAgdGhpcy5fdXBkYXRlSW5wdXRTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW0pO1xuICB9XG5cbiAgLy8gQXBwbHkgbXV0ZSBzZXR0aW5ncyB0byBuZXcgaW5wdXQgdHJhY2tcbiAgdGhpcy5tdXRlKHRoaXMuaXNNdXRlZCk7XG5cbiAgaWYgKCF0aGlzLnZlcnNpb24pIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3RyZWFtKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgX3RoaXMudmVyc2lvbi5jcmVhdGVPZmZlcihfdGhpcy5vcHRpb25zLm1heEF2ZXJhZ2VCaXRyYXRlLCBfdGhpcy5jb2RlY1ByZWZlcmVuY2VzLCB7IGF1ZGlvOiB0cnVlIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnZlcnNpb24ucHJvY2Vzc0Fuc3dlcihfdGhpcy5jb2RlY1ByZWZlcmVuY2VzLCBfdGhpcy5fYW5zd2VyU2RwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUoX3RoaXMuc3RyZWFtKTtcbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHRyYWNrcyBvZiB0aGUgY3VycmVudCBzdHJlYW0gd2l0aCBuZXcgdHJhY2tzIHVzaW5nIHRoZSAndW5pZmllZC1wbGFuJyBtZXRob2QuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZENsb25lIC0gV2hldGhlciB0aGUgc3RyZWFtIHNob3VsZCBiZSBjbG9uZWQgaWYgaXQgaXMgdGhlIGZpcnN0XG4gKiAgIHN0cmVhbSwgb3Igc2V0IGRpcmVjdGx5LiBBcyBhIHJ1bGUgb2YgdGh1bWIsIHN0cmVhbXMgdGhhdCBhcmUgcGFzc2VkIGluIGV4dGVybmFsbHkgbWF5IGhhdmVcbiAqICAgdGhlaXIgbGlmZWN5Y2xlIG1hbmFnZWQgZXh0ZXJuYWxseSwgYW5kIHNob3VsZCBiZSBjbG9uZWQgc28gdGhhdCB3ZSBkbyBub3QgdGVhciBpdCBvciBpdHMgdHJhY2tzXG4gKiAgIGRvd24gd2hlbiB0aGUgY2FsbCBlbmRzLiBTdHJlYW1zIHRoYXQgd2UgY3JlYXRlIGludGVybmFsbHkgKGluc2lkZSBQZWVyQ29ubmVjdGlvbikgc2hvdWxkIGJlIHNldFxuICogICBkaXJlY3RseSBzbyB0aGF0IHdoZW4gdGhlIGNhbGwgZW5kcyBpdCBpcyBkaXNwb3NlZCBvZi5cbiAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IG5ld1N0cmVhbSAtIFRoZSBuZXcgc3RyZWFtIHRvIGNvcHkgdGhlIHRyYWNrcyBvdmVyIGZyb20uXG4gKiBAcHJpdmF0ZVxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldElucHV0VHJhY2tzRm9yVW5pZmllZFBsYW4gPSBmdW5jdGlvbiAoc2hvdWxkQ2xvbmUsIG5ld1N0cmVhbSkge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBpZiAoIW5ld1N0cmVhbSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0NhbiBub3Qgc2V0IGlucHV0IHN0cmVhbSB0byBudWxsIHdoaWxlIGluIGEgY2FsbCcpKTtcbiAgfVxuXG4gIGlmICghbmV3U3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignU3VwcGxpZWQgaW5wdXQgc3RyZWFtIGhhcyBubyBhdWRpbyB0cmFja3MnKSk7XG4gIH1cblxuICB2YXIgbG9jYWxTdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgdmFyIGdldFN0cmVhbVByb21pc2UgPSBmdW5jdGlvbiBnZXRTdHJlYW1Qcm9taXNlKCkge1xuICAgIC8vIEFwcGx5IG11dGUgc2V0dGluZ3MgdG8gbmV3IGlucHV0IHRyYWNrXG4gICAgX3RoaXMyLm11dGUoX3RoaXMyLmlzTXV0ZWQpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoX3RoaXMyLnN0cmVhbSk7XG4gIH07XG5cbiAgaWYgKCFsb2NhbFN0cmVhbSkge1xuICAgIC8vIFdlIGNhbid0IHVzZSBNZWRpYVN0cmVhbS5jbG9uZSgpIGhlcmUgYmVjYXVzZSBpdCBzdG9wcGVkIGNvcHlpbmcgb3ZlciB0cmFja3NcbiAgICAvLyAgIGFzIG9mIENocm9tZSA2MS4gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NzcwOTA4XG4gICAgdGhpcy5zdHJlYW0gPSBzaG91bGRDbG9uZSA/IGNsb25lU3RyZWFtKG5ld1N0cmVhbSkgOiBuZXdTdHJlYW07XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGNhbGwgd2FzIHN0YXJ0ZWQgd2l0aCBnVU0sIGFuZCB3ZSBhcmUgbm93IHJlcGxhY2luZyB0aGF0IHRyYWNrIHdpdGggYW5cbiAgICAvLyBleHRlcm5hbCBzdHJlYW0ncyB0cmFja3MsIHdlIHNob3VsZCBzdG9wIHRoZSBvbGQgbWFuYWdlZCB0cmFjay5cbiAgICBpZiAodGhpcy5fc2hvdWxkTWFuYWdlU3RyZWFtKSB7XG4gICAgICB0aGlzLl9zdG9wU3RyZWFtKGxvY2FsU3RyZWFtKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3NlbmRlcikge1xuICAgICAgdGhpcy5fc2VuZGVyID0gdGhpcy52ZXJzaW9uLnBjLmdldFNlbmRlcnMoKVswXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyLnJlcGxhY2VUcmFjayhuZXdTdHJlYW0uZ2V0QXVkaW9UcmFja3MoKVswXSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpczIuX3VwZGF0ZUlucHV0U3RyZWFtU291cmNlKG5ld1N0cmVhbSk7XG4gICAgICByZXR1cm4gZ2V0U3RyZWFtUHJvbWlzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGdldFN0cmVhbVByb21pc2UoKTtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fb25JbnB1dERldmljZXNDaGFuZ2VkID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuc3RyZWFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgYWxsIG9mIG91ciBhY3RpdmUgdHJhY2tzIGFyZSBlbmRlZCwgdGhlbiBvdXIgYWN0aXZlIGlucHV0IHdhcyBsb3N0XG4gIHZhciBhY3RpdmVJbnB1dFdhc0xvc3QgPSB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmV2ZXJ5KGZ1bmN0aW9uICh0cmFjaykge1xuICAgIHJldHVybiB0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnO1xuICB9KTtcblxuICAvLyBXZSBvbmx5IHdhbnQgdG8gYWN0IGlmIHdlIG1hbmFnZSB0aGUgc3RyZWFtIGluIFBlZXJDb25uZWN0aW9uIChJdCB3YXMgY3JlYXRlZFxuICAvLyBoZXJlLCByYXRoZXIgdGhhbiBwYXNzZWQgaW4uKVxuICBpZiAoYWN0aXZlSW5wdXRXYXNMb3N0ICYmIHRoaXMuX3Nob3VsZE1hbmFnZVN0cmVhbSkge1xuICAgIHRoaXMub3BlbldpdGhDb25zdHJhaW50cyh0cnVlKTtcbiAgfVxufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9vbkljZUdhdGhlcmluZ0ZhaWx1cmUgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLl9oYXNJY2VHYXRoZXJpbmdGYWlsdXJlcyA9IHRydWU7XG4gIHRoaXMub25pY2VnYXRoZXJpbmdmYWlsdXJlKHR5cGUpO1xufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9vbk1lZGlhQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5faWNlU3RhdGU7XG5cbiAgaWYgKHByZXZpb3VzU3RhdGUgPT09IG5ld1N0YXRlIHx8IG5ld1N0YXRlICE9PSAnY29ubmVjdGVkJyAmJiBuZXdTdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgbmV3U3RhdGUgIT09ICdmYWlsZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2ljZVN0YXRlID0gbmV3U3RhdGU7XG5cbiAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgaWYgKHByZXZpb3VzU3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHByZXZpb3VzU3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgIG1lc3NhZ2UgPSAnSUNFIGxpdmVsaW5lc3MgY2hlY2sgc3VjY2VlZGVkLiBDb25uZWN0aW9uIHdpdGggVHdpbGlvIHJlc3RvcmVkJztcbiAgICAgICAgdGhpcy5fbG9nLmluZm8obWVzc2FnZSk7XG4gICAgICAgIHRoaXMub25yZWNvbm5lY3RlZChtZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSAnTWVkaWEgY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4nO1xuICAgICAgICB0aGlzLl9sb2cuaW5mbyhtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5vbmNvbm5lY3RlZChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3BJY2VHYXRoZXJpbmdUaW1lb3V0KCk7XG4gICAgICB0aGlzLl9oYXNJY2VHYXRoZXJpbmdGYWlsdXJlcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgIG1lc3NhZ2UgPSAnSUNFIGxpdmVsaW5lc3MgY2hlY2sgZmFpbGVkLiBNYXkgYmUgaGF2aW5nIHRyb3VibGUgY29ubmVjdGluZyB0byBUd2lsaW8nO1xuICAgICAgdGhpcy5fbG9nLmluZm8obWVzc2FnZSk7XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdGVkKG1lc3NhZ2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgIG1lc3NhZ2UgPSAnQ29ubmVjdGlvbiB3aXRoIFR3aWxpbyB3YXMgaW50ZXJydXB0ZWQuJztcbiAgICAgIHRoaXMuX2xvZy5pbmZvKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5vbmZhaWxlZChtZXNzYWdlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldFNpbmtJZHMgPSBmdW5jdGlvbiAoc2lua0lkcykge1xuICBpZiAoIXRoaXMuX2lzU2lua1N1cHBvcnRlZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTm90U3VwcG9ydGVkRXJyb3IoJ0F1ZGlvIG91dHB1dCBzZWxlY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGJyb3dzZXInKSk7XG4gIH1cblxuICB0aGlzLnNpbmtJZHMgPSBuZXcgU2V0KHNpbmtJZHMuZm9yRWFjaCA/IHNpbmtJZHMgOiBbc2lua0lkc10pO1xuICByZXR1cm4gdGhpcy52ZXJzaW9uID8gdGhpcy5fdXBkYXRlQXVkaW9PdXRwdXRzKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbn07XG5cbi8qKlxuICogU3RhcnQgdGltZW91dCBmb3IgSUNFIEdhdGhlcmluZ1xuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3N0YXJ0SWNlR2F0aGVyaW5nVGltZW91dCA9IGZ1bmN0aW9uIHN0YXJ0SWNlR2F0aGVyaW5nVGltZW91dCgpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgdGhpcy5fc3RvcEljZUdhdGhlcmluZ1RpbWVvdXQoKTtcbiAgdGhpcy5faWNlR2F0aGVyaW5nVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMzLl9vbkljZUdhdGhlcmluZ0ZhaWx1cmUoSUNFX0dBVEhFUklOR19GQUlMX1RJTUVPVVQpO1xuICB9LCBJQ0VfR0FUSEVSSU5HX1RJTUVPVVQpO1xufTtcblxuLyoqXG4gKiBTdG9wIHRpbWVvdXQgZm9yIElDRSBHYXRoZXJpbmdcbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9zdG9wSWNlR2F0aGVyaW5nVGltZW91dCA9IGZ1bmN0aW9uIHN0b3BJY2VHYXRoZXJpbmdUaW1lb3V0KCkge1xuICBjbGVhckludGVydmFsKHRoaXMuX2ljZUdhdGhlcmluZ1RpbWVvdXRJZCk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZGF0ZUF1ZGlvT3V0cHV0cyA9IGZ1bmN0aW9uIHVwZGF0ZUF1ZGlvT3V0cHV0cygpIHtcbiAgdmFyIGFkZGVkT3V0cHV0SWRzID0gQXJyYXkuZnJvbSh0aGlzLnNpbmtJZHMpLmZpbHRlcihmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gIXRoaXMub3V0cHV0cy5oYXMoaWQpO1xuICB9LCB0aGlzKTtcblxuICB2YXIgcmVtb3ZlZE91dHB1dElkcyA9IEFycmF5LmZyb20odGhpcy5vdXRwdXRzLmtleXMoKSkuZmlsdGVyKGZ1bmN0aW9uIChpZCkge1xuICAgIHJldHVybiAhdGhpcy5zaW5rSWRzLmhhcyhpZCk7XG4gIH0sIHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGNyZWF0ZU91dHB1dFByb21pc2VzID0gYWRkZWRPdXRwdXRJZHMubWFwKHRoaXMuX2NyZWF0ZUF1ZGlvT3V0cHV0LCB0aGlzKTtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGNyZWF0ZU91dHB1dFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVtb3ZlZE91dHB1dElkcy5tYXAoc2VsZi5fcmVtb3ZlQXVkaW9PdXRwdXQsIHNlbGYpKTtcbiAgfSk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2NyZWF0ZUF1ZGlvID0gZnVuY3Rpb24gY3JlYXRlQXVkaW8oYXJyKSB7XG4gIHJldHVybiBuZXcgQXVkaW8oYXJyKTtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fY3JlYXRlQXVkaW9PdXRwdXQgPSBmdW5jdGlvbiBjcmVhdGVBdWRpb091dHB1dChpZCkge1xuICB2YXIgZGVzdCA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gIHRoaXMuX21lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoZGVzdCk7XG5cbiAgdmFyIGF1ZGlvID0gdGhpcy5fY3JlYXRlQXVkaW8oKTtcbiAgc2V0QXVkaW9Tb3VyY2UoYXVkaW8sIGRlc3Quc3RyZWFtKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBhdWRpby5zZXRTaW5rSWQoaWQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhdWRpby5wbGF5KCk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHNlbGYub3V0cHV0cy5zZXQoaWQsIHtcbiAgICAgIGF1ZGlvOiBhdWRpbyxcbiAgICAgIGRlc3Q6IGRlc3RcbiAgICB9KTtcbiAgfSk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JlbW92ZUF1ZGlvT3V0cHV0cyA9IGZ1bmN0aW9uIHJlbW92ZUF1ZGlvT3V0cHV0cygpIHtcbiAgaWYgKHRoaXMuX21hc3RlckF1ZGlvICYmIHR5cGVvZiB0aGlzLl9tYXN0ZXJBdWRpb0RldmljZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMuX2Rpc2FibGVPdXRwdXQodGhpcywgdGhpcy5fbWFzdGVyQXVkaW9EZXZpY2VJZCk7XG4gICAgdGhpcy5vdXRwdXRzLmRlbGV0ZSh0aGlzLl9tYXN0ZXJBdWRpb0RldmljZUlkKTtcbiAgICB0aGlzLl9tYXN0ZXJBdWRpb0RldmljZUlkID0gbnVsbDtcblxuICAgIC8vIFJlbGVhc2UgdGhlIGF1ZGlvIHJlc291cmNlcyBiZWZvcmUgZGVsZXRpbmcgdGhlIGF1ZGlvXG4gICAgaWYgKCF0aGlzLl9tYXN0ZXJBdWRpby5wYXVzZWQpIHtcbiAgICAgIHRoaXMuX21hc3RlckF1ZGlvLnBhdXNlKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy5fbWFzdGVyQXVkaW8uc3JjT2JqZWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fbWFzdGVyQXVkaW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFzdGVyQXVkaW8uc3JjID0gJyc7XG4gICAgfVxuICAgIHRoaXMuX21hc3RlckF1ZGlvID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBBcnJheS5mcm9tKHRoaXMub3V0cHV0cy5rZXlzKCkpLm1hcCh0aGlzLl9yZW1vdmVBdWRpb091dHB1dCwgdGhpcyk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Rpc2FibGVPdXRwdXQgPSBmdW5jdGlvbiBkaXNhYmxlT3V0cHV0KHBjLCBpZCkge1xuICB2YXIgb3V0cHV0ID0gcGMub3V0cHV0cy5nZXQoaWQpO1xuICBpZiAoIW91dHB1dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvdXRwdXQuYXVkaW8pIHtcbiAgICBvdXRwdXQuYXVkaW8ucGF1c2UoKTtcbiAgICBvdXRwdXQuYXVkaW8uc3JjID0gJyc7XG4gIH1cblxuICBpZiAob3V0cHV0LmRlc3QpIHtcbiAgICBvdXRwdXQuZGVzdC5kaXNjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogRGlzYWJsZSBhIG5vbi1tYXN0ZXIgb3V0cHV0LCBhbmQgdXBkYXRlIHRoZSBtYXN0ZXIgb3V0cHV0IHRvIGFzc3VtZSBpdHMgc3RhdGUuIFRoaXNcbiAqICAgaXMgY2FsbGVkIHdoZW4gdGhlIGRldmljZSBJRCBhc3NpZ25lZCB0byB0aGUgbWFzdGVyIG91dHB1dCBoYXMgYmVlbiByZW1vdmVkIGZyb21cbiAqICAgYWN0aXZlIGRldmljZXMuIFdlIGNhbiBub3Qgc2ltcGx5IHJlbW92ZSB0aGUgbWFzdGVyIGF1ZGlvIG91dHB1dCwgc28gd2UgbXVzdFxuICogICBpbnN0ZWFkIHJlYXNzaWduIGl0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UGVlckNvbm5lY3Rpb259IHBjXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFzdGVySWQgLSBUaGUgY3VycmVudCBkZXZpY2UgSUQgYXNzaWduZWQgdG8gdGhlIG1hc3RlciBhdWRpbyBlbGVtZW50LlxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JlYXNzaWduTWFzdGVyT3V0cHV0ID0gZnVuY3Rpb24gcmVhc3NpZ25NYXN0ZXJPdXRwdXQocGMsIG1hc3RlcklkKSB7XG4gIHZhciBtYXN0ZXJPdXRwdXQgPSBwYy5vdXRwdXRzLmdldChtYXN0ZXJJZCk7XG4gIHBjLm91dHB1dHMuZGVsZXRlKG1hc3RlcklkKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBpZFRvUmVwbGFjZSA9IEFycmF5LmZyb20ocGMub3V0cHV0cy5rZXlzKCkpWzBdIHx8ICdkZWZhdWx0JztcbiAgcmV0dXJuIG1hc3Rlck91dHB1dC5hdWRpby5zZXRTaW5rSWQoaWRUb1JlcGxhY2UpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX2Rpc2FibGVPdXRwdXQocGMsIGlkVG9SZXBsYWNlKTtcblxuICAgIHBjLm91dHB1dHMuc2V0KGlkVG9SZXBsYWNlLCBtYXN0ZXJPdXRwdXQpO1xuICAgIHBjLl9tYXN0ZXJBdWRpb0RldmljZUlkID0gaWRUb1JlcGxhY2U7XG4gIH0pLmNhdGNoKGZ1bmN0aW9uIHJvbGxiYWNrKCkge1xuICAgIHBjLm91dHB1dHMuc2V0KG1hc3RlcklkLCBtYXN0ZXJPdXRwdXQpO1xuICAgIHNlbGYuX2xvZy5pbmZvKCdDb3VsZCBub3QgcmVhc3NpZ24gbWFzdGVyIG91dHB1dC4gQXR0ZW1wdGVkIHRvIHJvbGwgYmFjay4nKTtcbiAgfSk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3JlbW92ZUF1ZGlvT3V0cHV0ID0gZnVuY3Rpb24gcmVtb3ZlQXVkaW9PdXRwdXQoaWQpIHtcbiAgaWYgKHRoaXMuX21hc3RlckF1ZGlvRGV2aWNlSWQgPT09IGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYXNzaWduTWFzdGVyT3V0cHV0KHRoaXMsIGlkKTtcbiAgfVxuXG4gIHRoaXMuX2Rpc2FibGVPdXRwdXQodGhpcywgaWQpO1xuICB0aGlzLm91dHB1dHMuZGVsZXRlKGlkKTtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG59O1xuXG4vKipcbiAqIFVzZSBhbiBBdWRpb0NvbnRleHQgdG8gcG90ZW50aWFsbHkgc3BsaXQgb3VyIGF1ZGlvIG91dHB1dCBzdHJlYW0gdG8gbXVsdGlwbGVcbiAqICAgYXVkaW8gZGV2aWNlcy4gVGhpcyBpcyBvbmx5IGF2YWlsYWJsZSB0byBicm93c2VycyB3aXRoIEF1ZGlvQ29udGV4dCBhbmRcbiAqICAgSFRNTEF1ZGlvRWxlbWVudC5zZXRTaW5rSWQoKSBhdmFpbGFibGUuIFdlIHNhdmUgdGhlIHNvdXJjZSBzdHJlYW0gaW5cbiAqICAgX21hc3RlckF1ZGlvLCBhbmQgdXNlIGl0IGZvciBvbmUgb2YgdGhlIGFjdGl2ZSBhdWRpbyBkZXZpY2VzLiBXZSBrZWVwXG4gKiAgIHRyYWNrIG9mIGl0cyBJRCBiZWNhdXNlIHdlIG11c3QgcmVwbGFjZSBpdCBpZiB3ZSBsb3NlIGl0cyBpbml0aWFsIGRldmljZS5cbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9vbkFkZFRyYWNrID0gZnVuY3Rpb24gb25BZGRUcmFjayhwYywgc3RyZWFtKSB7XG4gIHZhciBhdWRpbyA9IHBjLl9tYXN0ZXJBdWRpbyA9IHRoaXMuX2NyZWF0ZUF1ZGlvKCk7XG4gIHNldEF1ZGlvU291cmNlKGF1ZGlvLCBzdHJlYW0pO1xuICBhdWRpby5wbGF5KCk7XG5cbiAgLy8gQXNzaWduIHRoZSBpbml0aWFsIG1hc3RlciBhdWRpbyBlbGVtZW50IHRvIGEgcmFuZG9tIGFjdGl2ZSBvdXRwdXQgZGV2aWNlXG4gIHZhciBkZXZpY2VJZCA9IEFycmF5LmZyb20ocGMub3V0cHV0cy5rZXlzKCkpWzBdIHx8ICdkZWZhdWx0JztcbiAgcGMuX21hc3RlckF1ZGlvRGV2aWNlSWQgPSBkZXZpY2VJZDtcbiAgcGMub3V0cHV0cy5zZXQoZGV2aWNlSWQsIHtcbiAgICBhdWRpbzogYXVkaW9cbiAgfSk7XG5cbiAgcGMuX21lZGlhU3RyZWFtU291cmNlID0gcGMuX2F1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShzdHJlYW0pO1xuXG4gIHBjLnBjU3RyZWFtID0gc3RyZWFtO1xuICBwYy5fdXBkYXRlQXVkaW9PdXRwdXRzKCk7XG59O1xuXG4vKipcbiAqIFVzZSBhIHNpbmdsZSBhdWRpbyBlbGVtZW50IHRvIHBsYXkgdGhlIGF1ZGlvIG91dHB1dCBzdHJlYW0uIFRoaXMgZG9lcyBub3RcbiAqICAgc3VwcG9ydCBtdWx0aXBsZSBvdXRwdXQgZGV2aWNlcywgYW5kIGlzIGEgZmFsbGJhY2sgZm9yIHdoZW4gQXVkaW9Db250ZXh0XG4gKiAgIGFuZC9vciBIVE1MQXVkaW9FbGVtZW50LnNldFNpbmtJZCgpIGlzIG5vdCBhdmFpbGFibGUgdG8gdGhlIGNsaWVudC5cbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9mYWxsYmFja09uQWRkVHJhY2sgPSBmdW5jdGlvbiBmYWxsYmFja09uQWRkVHJhY2socGMsIHN0cmVhbSkge1xuICB2YXIgYXVkaW8gPSBkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICBhdWRpby5hdXRvcGxheSA9IHRydWU7XG5cbiAgaWYgKCFzZXRBdWRpb1NvdXJjZShhdWRpbywgc3RyZWFtKSkge1xuICAgIHBjLl9sb2cuaW5mbygnRXJyb3IgYXR0YWNoaW5nIHN0cmVhbSB0byBlbGVtZW50LicpO1xuICB9XG5cbiAgcGMub3V0cHV0cy5zZXQoJ2RlZmF1bHQnLCB7XG4gICAgYXVkaW86IGF1ZGlvXG4gIH0pO1xufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9zZXRFbmNvZGluZ1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAoZW5hYmxlRHNjcCkge1xuICBpZiAoIWVuYWJsZURzY3AgfHwgIXRoaXMuX3NlbmRlciB8fCB0eXBlb2YgdGhpcy5fc2VuZGVyLmdldFBhcmFtZXRlcnMgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHRoaXMuX3NlbmRlci5zZXRQYXJhbWV0ZXJzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmFtcyA9IHRoaXMuX3NlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gIGlmICghcGFyYW1zLnByaW9yaXR5ICYmICEocGFyYW1zLmVuY29kaW5ncyAmJiBwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUaGlzIGlzIGhvdyBNRE4ncyBSVFBTZW5kZXJQYXJhbWV0ZXJzIGRlZmluZXMgcHJpb3JpdHlcbiAgcGFyYW1zLnByaW9yaXR5ID0gJ2hpZ2gnO1xuXG4gIC8vIEFuZCB0aGlzIGlzIGhvdyBpdCdzIGN1cnJlbnRseSBpbXBsZW1lbnRlZCBpbiBDaHJvbWUgTTcyK1xuICBpZiAocGFyYW1zLmVuY29kaW5ncyAmJiBwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCkge1xuICAgIHBhcmFtcy5lbmNvZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgICAgIGVuY29kaW5nLnByaW9yaXR5ID0gJ2hpZ2gnO1xuICAgICAgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID0gJ2hpZ2gnO1xuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5fc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0dXBQZWVyQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChydGNDb25zdHJhaW50cywgcnRjQ29uZmlndXJhdGlvbikge1xuICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB2ZXJzaW9uID0gbmV3ICh0aGlzLm9wdGlvbnMucnRjcGNGYWN0b3J5IHx8IFJUQ1BDKSgpO1xuICB2ZXJzaW9uLmNyZWF0ZShydGNDb25zdHJhaW50cywgcnRjQ29uZmlndXJhdGlvbik7XG4gIGFkZFN0cmVhbSh2ZXJzaW9uLnBjLCB0aGlzLnN0cmVhbSk7XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbnRyYWNrJyBpbiB2ZXJzaW9uLnBjID8gJ29udHJhY2snIDogJ29uYWRkc3RyZWFtJztcblxuICB2ZXJzaW9uLnBjW2V2ZW50TmFtZV0gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgc3RyZWFtID0gc2VsZi5fcmVtb3RlU3RyZWFtID0gZXZlbnQuc3RyZWFtIHx8IGV2ZW50LnN0cmVhbXNbMF07XG5cbiAgICBpZiAodHlwZW9mIHZlcnNpb24ucGMuZ2V0U2VuZGVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgX3RoaXM0Ll9zZW5kZXIgPSB2ZXJzaW9uLnBjLmdldFNlbmRlcnMoKVswXTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5faXNTaW5rU3VwcG9ydGVkKSB7XG4gICAgICBzZWxmLl9vbkFkZFRyYWNrKHNlbGYsIHN0cmVhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX2ZhbGxiYWNrT25BZGRUcmFjayhzZWxmLCBzdHJlYW0pO1xuICAgIH1cblxuICAgIHNlbGYuX3N0YXJ0UG9sbGluZ1ZvbHVtZSgpO1xuICB9O1xuICByZXR1cm4gdmVyc2lvbjtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fbWF5YmVTZXRJY2VBZ2dyZXNzaXZlTm9taW5hdGlvbiA9IGZ1bmN0aW9uIChzZHApIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy5mb3JjZUFnZ3Jlc3NpdmVJY2VOb21pbmF0aW9uID8gc2V0SWNlQWdncmVzc2l2ZU5vbWluYXRpb24oc2RwKSA6IHNkcDtcbn07XG5cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0dXBDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICB2YXIgcGMgPSB0aGlzLnZlcnNpb24ucGM7XG5cbiAgLy8gQ2hyb21lIDI1IHN1cHBvcnRzIG9ub3BlblxuICB0aGlzLnZlcnNpb24ucGMub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgIF90aGlzNS5zdGF0dXMgPSAnb3Blbic7XG4gICAgX3RoaXM1Lm9ub3BlbigpO1xuICB9O1xuXG4gIC8vIENocm9tZSAyNiBkb2Vzbid0IHN1cHBvcnQgb25vcGVuIHNvIG11c3QgZGV0ZWN0IHN0YXRlIGNoYW5nZVxuICB0aGlzLnZlcnNpb24ucGMub25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX3RoaXM1LnZlcnNpb24ucGMgJiYgX3RoaXM1LnZlcnNpb24ucGMucmVhZHlTdGF0ZSA9PT0gJ3N0YWJsZScpIHtcbiAgICAgIF90aGlzNS5zdGF0dXMgPSAnb3Blbic7XG4gICAgICBfdGhpczUub25vcGVuKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENocm9tZSAyNyBjaGFuZ2VkIG9uc3RhdGVjaGFuZ2UgdG8gb25zaWduYWxpbmdzdGF0ZWNoYW5nZVxuICB0aGlzLnZlcnNpb24ucGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBwYy5zaWduYWxpbmdTdGF0ZTtcbiAgICBfdGhpczUuX2xvZy5pbmZvKCdzaWduYWxpbmdTdGF0ZSBpcyBcIicgKyBzdGF0ZSArICdcIicpO1xuXG4gICAgaWYgKF90aGlzNS52ZXJzaW9uLnBjICYmIF90aGlzNS52ZXJzaW9uLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJykge1xuICAgICAgX3RoaXM1LnN0YXR1cyA9ICdvcGVuJztcbiAgICAgIF90aGlzNS5vbm9wZW4oKTtcbiAgICB9XG5cbiAgICBfdGhpczUub25zaWduYWxpbmdzdGF0ZWNoYW5nZShwYy5zaWduYWxpbmdTdGF0ZSk7XG4gIH07XG5cbiAgLy8gQ2hyb21lIDcyK1xuICBwYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczUuX2xvZy5pbmZvKCdwYy5jb25uZWN0aW9uU3RhdGUgaXMgXCInICsgcGMuY29ubmVjdGlvblN0YXRlICsgJ1wiJyk7XG4gICAgX3RoaXM1Lm9ucGNjb25uZWN0aW9uc3RhdGVjaGFuZ2UocGMuY29ubmVjdGlvblN0YXRlKTtcbiAgICBfdGhpczUuX29uTWVkaWFDb25uZWN0aW9uU3RhdGVDaGFuZ2UocGMuY29ubmVjdGlvblN0YXRlKTtcbiAgfTtcblxuICBwYy5vbmljZWNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBjYW5kaWRhdGUgPSBldmVudC5jYW5kaWRhdGU7XG5cbiAgICBpZiAoY2FuZGlkYXRlKSB7XG4gICAgICBfdGhpczUuX2hhc0ljZUNhbmRpZGF0ZXMgPSB0cnVlO1xuICAgICAgX3RoaXM1Lm9uaWNlY2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICBfdGhpczUuX3NldHVwUlRDSWNlVHJhbnNwb3J0TGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICBfdGhpczUuX2xvZy5pbmZvKCdJQ0UgQ2FuZGlkYXRlOiAnICsgSlNPTi5zdHJpbmdpZnkoY2FuZGlkYXRlKSk7XG4gIH07XG5cbiAgcGMub25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBwYy5pY2VHYXRoZXJpbmdTdGF0ZTtcbiAgICBpZiAoc3RhdGUgPT09ICdnYXRoZXJpbmcnKSB7XG4gICAgICBfdGhpczUuX3N0YXJ0SWNlR2F0aGVyaW5nVGltZW91dCgpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIF90aGlzNS5fc3RvcEljZUdhdGhlcmluZ1RpbWVvdXQoKTtcblxuICAgICAgLy8gRmFpbCBpZiBubyBjYW5kaWRhdGVzIGZvdW5kXG4gICAgICBpZiAoIV90aGlzNS5faGFzSWNlQ2FuZGlkYXRlcykge1xuICAgICAgICBfdGhpczUuX29uSWNlR2F0aGVyaW5nRmFpbHVyZShJQ0VfR0FUSEVSSU5HX0ZBSUxfTk9ORSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZXJlIHdhcyBhIGZhaWx1cmUgbWlkLWdhdGhlcmluZyBwaGFzZS4gV2Ugd2FudCB0byBzdGFydCBvdXIgdGltZXIgYW5kIGlzc3VlXG4gICAgICAvLyBhbiBpY2UgcmVzdGFydCBpZiB3ZSBkb24ndCBnZXQgY29ubmVjdGVkIGFmdGVyIG91ciB0aW1lb3V0XG4gICAgICBpZiAoX3RoaXM1Ll9oYXNJY2VDYW5kaWRhdGVzICYmIF90aGlzNS5faGFzSWNlR2F0aGVyaW5nRmFpbHVyZXMpIHtcbiAgICAgICAgX3RoaXM1Ll9zdGFydEljZUdhdGhlcmluZ1RpbWVvdXQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpczUuX2xvZy5pbmZvKCdwYy5pY2VHYXRoZXJpbmdTdGF0ZSBpcyBcIicgKyBwYy5pY2VHYXRoZXJpbmdTdGF0ZSArICdcIicpO1xuICAgIF90aGlzNS5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlKHN0YXRlKTtcbiAgfTtcblxuICBwYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczUuX2xvZy5pbmZvKCdwYy5pY2VDb25uZWN0aW9uU3RhdGUgaXMgXCInICsgcGMuaWNlQ29ubmVjdGlvblN0YXRlICsgJ1wiJyk7XG4gICAgX3RoaXM1Lm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgX3RoaXM1Ll9vbk1lZGlhQ29ubmVjdGlvblN0YXRlQ2hhbmdlKHBjLmljZUNvbm5lY3Rpb25TdGF0ZSk7XG4gIH07XG59O1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9pbml0aWFsaXplTWVkaWFTdHJlYW0gPSBmdW5jdGlvbiAocnRjQ29uc3RyYWludHMsIHJ0Y0NvbmZpZ3VyYXRpb24pIHtcbiAgLy8gaWYgbWVkaWFzdHJlYW0gYWxyZWFkeSBvcGVuIHRoZW4gZG8gbm90aGluZ1xuICBpZiAodGhpcy5zdGF0dXMgPT09ICdvcGVuJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodGhpcy5wc3RyZWFtLnN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICB0aGlzLm9uZXJyb3IoeyBpbmZvOiB7XG4gICAgICAgIGNvZGU6IDMxMDAwLFxuICAgICAgICBtZXNzYWdlOiAnQ2Fubm90IGVzdGFibGlzaCBjb25uZWN0aW9uLiBDbGllbnQgaXMgZGlzY29ubmVjdGVkJyxcbiAgICAgICAgdHdpbGlvRXJyb3I6IG5ldyBTaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCgpXG4gICAgICB9IH0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdGhpcy52ZXJzaW9uID0gdGhpcy5fc2V0dXBQZWVyQ29ubmVjdGlvbihydGNDb25zdHJhaW50cywgcnRjQ29uZmlndXJhdGlvbik7XG4gIHRoaXMuX3NldHVwQ2hhbm5lbCgpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHJlY29ubmVjdGlvbi1yZWxhdGVkIGxpc3RlbmVyc1xuICogQHByaXZhdGVcbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9yZW1vdmVSZWNvbm5lY3Rpb25MaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBzdHJlYW0pIHtcbiAgICB0aGlzLnBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fuc3dlcicsIHRoaXMuX29uQW5zd2VyT3JSaW5naW5nKTtcbiAgICB0aGlzLnBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2hhbmd1cCcsIHRoaXMuX29uSGFuZ3VwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXR1cCBhIGxpc3RlbmVyIGZvciBSVENEdGxzVHJhbnNwb3J0IHRvIGNhcHR1cmUgc3RhdGUgY2hhbmdlcyBldmVudHNcbiAqIEBwcml2YXRlXG4gKi9cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fc2V0dXBSVENEdGxzVHJhbnNwb3J0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gIHZhciBkdGxzVHJhbnNwb3J0ID0gdGhpcy5nZXRSVENEdGxzVHJhbnNwb3J0KCk7XG5cbiAgaWYgKCFkdGxzVHJhbnNwb3J0IHx8IGR0bHNUcmFuc3BvcnQub25zdGF0ZWNoYW5nZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICBfdGhpczYuX2xvZy5pbmZvKCdkdGxzVHJhbnNwb3J0U3RhdGUgaXMgXCInICsgZHRsc1RyYW5zcG9ydC5zdGF0ZSArICdcIicpO1xuICAgIF90aGlzNi5vbmR0bHN0cmFuc3BvcnRzdGF0ZWNoYW5nZShkdGxzVHJhbnNwb3J0LnN0YXRlKTtcbiAgfTtcblxuICAvLyBQdWJsaXNoIGluaXRpYWwgc3RhdGVcbiAgaGFuZGxlcigpO1xuICBkdGxzVHJhbnNwb3J0Lm9uc3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xufTtcblxuLyoqXG4gKiBTZXR1cCBhIGxpc3RlbmVyIGZvciBSVENJY2VUcmFuc3BvcnQgdG8gY2FwdHVyZSBzZWxlY3RlZCBjYW5kaWRhdGUgcGFpciBjaGFuZ2VzXG4gKiBAcHJpdmF0ZVxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldHVwUlRDSWNlVHJhbnNwb3J0TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gIHZhciBpY2VUcmFuc3BvcnQgPSB0aGlzLl9nZXRSVENJY2VUcmFuc3BvcnQoKTtcblxuICBpZiAoIWljZVRyYW5zcG9ydCB8fCBpY2VUcmFuc3BvcnQub25zZWxlY3RlZGNhbmRpZGF0ZXBhaXJjaGFuZ2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpY2VUcmFuc3BvcnQub25zZWxlY3RlZGNhbmRpZGF0ZXBhaXJjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNy5vbnNlbGVjdGVkY2FuZGlkYXRlcGFpcmNoYW5nZShpY2VUcmFuc3BvcnQuZ2V0U2VsZWN0ZWRDYW5kaWRhdGVQYWlyKCkpO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXN0YXJ0cyBJQ0UgZm9yIHRoZSBjdXJyZW50IGNvbm5lY3Rpb25cbiAqIElDRSBSZXN0YXJ0IGZhaWx1cmVzIGFyZSBpZ25vcmVkLiBSZXRyaWVzIGFyZSBtYW5hZ2VkIGluIENvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5pY2VSZXN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXM4ID0gdGhpcztcblxuICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVJY2VSZXN0YXJ0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2xvZy5pbmZvKCdBdHRlbXB0aW5nIHRvIHJlc3RhcnQgSUNFLi4uJyk7XG4gIHRoaXMuX2hhc0ljZUNhbmRpZGF0ZXMgPSBmYWxzZTtcbiAgdGhpcy52ZXJzaW9uLmNyZWF0ZU9mZmVyKHRoaXMub3B0aW9ucy5tYXhBdmVyYWdlQml0cmF0ZSwgdGhpcy5jb2RlY1ByZWZlcmVuY2VzLCB7IGljZVJlc3RhcnQ6IHRydWUgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXM4Ll9yZW1vdmVSZWNvbm5lY3Rpb25MaXN0ZW5lcnMoKTtcblxuICAgIF90aGlzOC5fb25BbnN3ZXJPclJpbmdpbmcgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgX3RoaXM4Ll9yZW1vdmVSZWNvbm5lY3Rpb25MaXN0ZW5lcnMoKTtcblxuICAgICAgaWYgKCFwYXlsb2FkLnNkcCB8fCBfdGhpczgudmVyc2lvbi5wYy5zaWduYWxpbmdTdGF0ZSAhPT0gJ2hhdmUtbG9jYWwtb2ZmZXInKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ0ludmFsaWQgc3RhdGUgb3IgcGFyYW0gZHVyaW5nIElDRSBSZXN0YXJ0OicgKyAoJ2hhc1NkcDonICsgISFwYXlsb2FkLnNkcCArICcsIHNpZ25hbGluZ1N0YXRlOicgKyBfdGhpczgudmVyc2lvbi5wYy5zaWduYWxpbmdTdGF0ZSk7XG4gICAgICAgIF90aGlzOC5fbG9nLmluZm8obWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNkcCA9IF90aGlzOC5fbWF5YmVTZXRJY2VBZ2dyZXNzaXZlTm9taW5hdGlvbihwYXlsb2FkLnNkcCk7XG4gICAgICBfdGhpczguX2Fuc3dlclNkcCA9IHNkcDtcbiAgICAgIGlmIChfdGhpczguc3RhdHVzICE9PSAnY2xvc2VkJykge1xuICAgICAgICBfdGhpczgudmVyc2lvbi5wcm9jZXNzQW5zd2VyKF90aGlzOC5jb2RlY1ByZWZlcmVuY2VzLCBzZHAsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyO1xuICAgICAgICAgIF90aGlzOC5fbG9nLmluZm8oJ0ZhaWxlZCB0byBwcm9jZXNzIGFuc3dlciBkdXJpbmcgSUNFIFJlc3RhcnQuIEVycm9yOiAnICsgbWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpczguX29uSGFuZ3VwID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXM4Ll9sb2cuaW5mbygnUmVjZWl2ZWQgaGFuZ3VwIGR1cmluZyBJQ0UgUmVzdGFydCcpO1xuICAgICAgX3RoaXM4Ll9yZW1vdmVSZWNvbm5lY3Rpb25MaXN0ZW5lcnMoKTtcbiAgICB9O1xuXG4gICAgX3RoaXM4LnBzdHJlYW0ub24oJ2Fuc3dlcicsIF90aGlzOC5fb25BbnN3ZXJPclJpbmdpbmcpO1xuICAgIF90aGlzOC5wc3RyZWFtLm9uKCdoYW5ndXAnLCBfdGhpczguX29uSGFuZ3VwKTtcbiAgICBfdGhpczgucHN0cmVhbS5yZWludml0ZShfdGhpczgudmVyc2lvbi5nZXRTRFAoKSwgX3RoaXM4LmNhbGxTaWQpO1xuICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2UgPyBlcnIubWVzc2FnZSA6IGVycjtcbiAgICBfdGhpczguX2xvZy5pbmZvKCdGYWlsZWQgdG8gY3JlYXRlT2ZmZXIgZHVyaW5nIElDRSBSZXN0YXJ0LiBFcnJvcjogJyArIG1lc3NhZ2UpO1xuICAgIC8vIENyZWF0ZU9mZmVyIGZhaWx1cmVzIGRvZXNuJ3QgdHJhbnNpdGlvbiBpY2Ugc3RhdGUgdG8gZmFpbGVkXG4gICAgLy8gV2UgbmVlZCB0cmlnZ2VyIGl0IHNvIGl0IGNhbiBiZSBwaWNrZWQgdXAgYnkgcmV0cmllc1xuICAgIF90aGlzOC5vbmZhaWxlZChtZXNzYWdlKTtcbiAgfSk7XG59O1xuXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUubWFrZU91dGdvaW5nQ2FsbCA9IGZ1bmN0aW9uICh0b2tlbiwgcGFyYW1zLCBjYWxsc2lkLCBydGNDb25zdHJhaW50cywgcnRjQ29uZmlndXJhdGlvbiwgb25NZWRpYVN0YXJ0ZWQpIHtcbiAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLl9pbml0aWFsaXplTWVkaWFTdHJlYW0ocnRjQ29uc3RyYWludHMsIHJ0Y0NvbmZpZ3VyYXRpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmNhbGxTaWQgPSBjYWxsc2lkO1xuICBmdW5jdGlvbiBvbkFuc3dlclN1Y2Nlc3MoKSB7XG4gICAgaWYgKHNlbGYub3B0aW9ucykge1xuICAgICAgc2VsZi5fc2V0RW5jb2RpbmdQYXJhbWV0ZXJzKHNlbGYub3B0aW9ucy5kc2NwKTtcbiAgICB9XG4gICAgb25NZWRpYVN0YXJ0ZWQoc2VsZi52ZXJzaW9uLnBjKTtcbiAgfVxuICBmdW5jdGlvbiBvbkFuc3dlckVycm9yKGVycikge1xuICAgIHZhciBlcnJNc2cgPSBlcnIubWVzc2FnZSB8fCBlcnI7XG4gICAgc2VsZi5vbmVycm9yKHsgaW5mbzoge1xuICAgICAgICBjb2RlOiAzMTAwMCxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIHByb2Nlc3NpbmcgYW5zd2VyOiAnICsgZXJyTXNnLFxuICAgICAgICB0d2lsaW9FcnJvcjogbmV3IE1lZGlhRXJyb3JzLkNsaWVudFJlbW90ZURlc2NGYWlsZWQoKVxuICAgICAgfSB9KTtcbiAgfVxuICB0aGlzLl9vbkFuc3dlck9yUmluZ2luZyA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnNkcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzZHAgPSBfdGhpczkuX21heWJlU2V0SWNlQWdncmVzc2l2ZU5vbWluYXRpb24ocGF5bG9hZC5zZHApO1xuICAgIHNlbGYuX2Fuc3dlclNkcCA9IHNkcDtcbiAgICBpZiAoc2VsZi5zdGF0dXMgIT09ICdjbG9zZWQnKSB7XG4gICAgICBzZWxmLnZlcnNpb24ucHJvY2Vzc0Fuc3dlcihfdGhpczkuY29kZWNQcmVmZXJlbmNlcywgc2RwLCBvbkFuc3dlclN1Y2Nlc3MsIG9uQW5zd2VyRXJyb3IpO1xuICAgIH1cbiAgICBzZWxmLnBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fuc3dlcicsIHNlbGYuX29uQW5zd2VyT3JSaW5naW5nKTtcbiAgICBzZWxmLnBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JpbmdpbmcnLCBzZWxmLl9vbkFuc3dlck9yUmluZ2luZyk7XG4gIH07XG4gIHRoaXMucHN0cmVhbS5vbignYW5zd2VyJywgdGhpcy5fb25BbnN3ZXJPclJpbmdpbmcpO1xuICB0aGlzLnBzdHJlYW0ub24oJ3JpbmdpbmcnLCB0aGlzLl9vbkFuc3dlck9yUmluZ2luZyk7XG5cbiAgZnVuY3Rpb24gb25PZmZlclN1Y2Nlc3MoKSB7XG4gICAgaWYgKHNlbGYuc3RhdHVzICE9PSAnY2xvc2VkJykge1xuICAgICAgc2VsZi5wc3RyZWFtLmludml0ZShzZWxmLnZlcnNpb24uZ2V0U0RQKCksIHNlbGYuY2FsbFNpZCwgc2VsZi5vcHRpb25zLnByZWZsaWdodCwgcGFyYW1zKTtcbiAgICAgIHNlbGYuX3NldHVwUlRDRHRsc1RyYW5zcG9ydExpc3RlbmVyKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25PZmZlckVycm9yKGVycikge1xuICAgIHZhciBlcnJNc2cgPSBlcnIubWVzc2FnZSB8fCBlcnI7XG4gICAgc2VsZi5vbmVycm9yKHsgaW5mbzoge1xuICAgICAgICBjb2RlOiAzMTAwMCxcbiAgICAgICAgbWVzc2FnZTogJ0Vycm9yIGNyZWF0aW5nIHRoZSBvZmZlcjogJyArIGVyck1zZyxcbiAgICAgICAgdHdpbGlvRXJyb3I6IG5ldyBNZWRpYUVycm9ycy5DbGllbnRMb2NhbERlc2NGYWlsZWQoKVxuICAgICAgfSB9KTtcbiAgfVxuXG4gIHRoaXMudmVyc2lvbi5jcmVhdGVPZmZlcih0aGlzLm9wdGlvbnMubWF4QXZlcmFnZUJpdHJhdGUsIHRoaXMuY29kZWNQcmVmZXJlbmNlcywgeyBhdWRpbzogdHJ1ZSB9LCBvbk9mZmVyU3VjY2Vzcywgb25PZmZlckVycm9yKTtcbn07XG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYW5zd2VySW5jb21pbmdDYWxsID0gZnVuY3Rpb24gKGNhbGxTaWQsIHNkcCwgcnRjQ29uc3RyYWludHMsIHJ0Y0NvbmZpZ3VyYXRpb24sIG9uTWVkaWFTdGFydGVkKSB7XG4gIGlmICghdGhpcy5faW5pdGlhbGl6ZU1lZGlhU3RyZWFtKHJ0Y0NvbnN0cmFpbnRzLCBydGNDb25maWd1cmF0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzZHAgPSB0aGlzLl9tYXliZVNldEljZUFnZ3Jlc3NpdmVOb21pbmF0aW9uKHNkcCk7XG4gIHRoaXMuX2Fuc3dlclNkcCA9IHNkcC5yZXBsYWNlKC9eYT1zZXR1cDphY3RwYXNzJC9nbSwgJ2E9c2V0dXA6cGFzc2l2ZScpO1xuICB0aGlzLmNhbGxTaWQgPSBjYWxsU2lkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIG9uQW5zd2VyU3VjY2VzcygpIHtcbiAgICBpZiAoc2VsZi5zdGF0dXMgIT09ICdjbG9zZWQnKSB7XG4gICAgICBzZWxmLnBzdHJlYW0uYW5zd2VyKHNlbGYudmVyc2lvbi5nZXRTRFAoKSwgY2FsbFNpZCk7XG4gICAgICBpZiAoc2VsZi5vcHRpb25zKSB7XG4gICAgICAgIHNlbGYuX3NldEVuY29kaW5nUGFyYW1ldGVycyhzZWxmLm9wdGlvbnMuZHNjcCk7XG4gICAgICB9XG4gICAgICBvbk1lZGlhU3RhcnRlZChzZWxmLnZlcnNpb24ucGMpO1xuICAgICAgc2VsZi5fc2V0dXBSVENEdGxzVHJhbnNwb3J0TGlzdGVuZXIoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25BbnN3ZXJFcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyTXNnID0gZXJyLm1lc3NhZ2UgfHwgZXJyO1xuICAgIHNlbGYub25lcnJvcih7IGluZm86IHtcbiAgICAgICAgY29kZTogMzEwMDAsXG4gICAgICAgIG1lc3NhZ2U6ICdFcnJvciBjcmVhdGluZyB0aGUgYW5zd2VyOiAnICsgZXJyTXNnLFxuICAgICAgICB0d2lsaW9FcnJvcjogbmV3IE1lZGlhRXJyb3JzLkNsaWVudFJlbW90ZURlc2NGYWlsZWQoKVxuICAgICAgfSB9KTtcbiAgfVxuICB0aGlzLnZlcnNpb24ucHJvY2Vzc1NEUCh0aGlzLm9wdGlvbnMubWF4QXZlcmFnZUJpdHJhdGUsIHRoaXMuY29kZWNQcmVmZXJlbmNlcywgc2RwLCB7IGF1ZGlvOiB0cnVlIH0sIG9uQW5zd2VyU3VjY2Vzcywgb25BbnN3ZXJFcnJvcik7XG59O1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy52ZXJzaW9uICYmIHRoaXMudmVyc2lvbi5wYykge1xuICAgIGlmICh0aGlzLnZlcnNpb24ucGMuc2lnbmFsaW5nU3RhdGUgIT09ICdjbG9zZWQnKSB7XG4gICAgICB0aGlzLnZlcnNpb24ucGMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnZlcnNpb24ucGMgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnN0cmVhbSkge1xuICAgIHRoaXMubXV0ZShmYWxzZSk7XG4gICAgdGhpcy5fc3RvcFN0cmVhbSh0aGlzLnN0cmVhbSk7XG4gIH1cbiAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICB0aGlzLl9yZW1vdmVSZWNvbm5lY3Rpb25MaXN0ZW5lcnMoKTtcbiAgdGhpcy5fc3RvcEljZUdhdGhlcmluZ1RpbWVvdXQoKTtcblxuICBQcm9taXNlLmFsbCh0aGlzLl9yZW1vdmVBdWRpb091dHB1dHMoKSkuY2F0Y2goZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gYWxlcnQgYWJvdXQgZmFpbHVyZXMgaGVyZS5cbiAgfSk7XG4gIGlmICh0aGlzLl9tZWRpYVN0cmVhbVNvdXJjZSkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodGhpcy5faW5wdXRBbmFseXNlcikge1xuICAgIHRoaXMuX2lucHV0QW5hbHlzZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0aGlzLl9vdXRwdXRBbmFseXNlcikge1xuICAgIHRoaXMuX291dHB1dEFuYWx5c2VyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBpZiAodGhpcy5faW5wdXRBbmFseXNlcjIpIHtcbiAgICB0aGlzLl9pbnB1dEFuYWx5c2VyMi5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHRoaXMuX291dHB1dEFuYWx5c2VyMikge1xuICAgIHRoaXMuX291dHB1dEFuYWx5c2VyMi5kaXNjb25uZWN0KCk7XG4gIH1cbiAgdGhpcy5zdGF0dXMgPSAnY2xvc2VkJztcbiAgdGhpcy5vbmNsb3NlKCk7XG59O1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uIChjYWxsU2lkKSB7XG4gIHRoaXMuY2FsbFNpZCA9IGNhbGxTaWQ7XG59O1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmlnbm9yZSA9IGZ1bmN0aW9uIChjYWxsU2lkKSB7XG4gIHRoaXMuY2FsbFNpZCA9IGNhbGxTaWQ7XG59O1xuLyoqXG4gKiBNdXRlIG9yIHVubXV0ZSBpbnB1dCBhdWRpby4gSWYgdGhlIHN0cmVhbSBpcyBub3QgeWV0IHByZXNlbnQsIHRoZSBzZXR0aW5nXG4gKiAgIGlzIHNhdmVkIGFuZCBhcHBsaWVkIHRvIGZ1dHVyZSBzdHJlYW1zL3RyYWNrcy5cbiAqIEBwYXJhbXMge2Jvb2xlYW59IHNob3VsZE11dGUgLSBXaGV0aGVyIHRoZSBpbnB1dCBhdWRpbyBzaG91bGRcbiAqICAgYmUgbXV0ZWQgb3IgdW5tdXRlZC5cbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAoc2hvdWxkTXV0ZSkge1xuICB0aGlzLmlzTXV0ZWQgPSBzaG91bGRNdXRlO1xuICBpZiAoIXRoaXMuc3RyZWFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX3NlbmRlciAmJiB0aGlzLl9zZW5kZXIudHJhY2spIHtcbiAgICB0aGlzLl9zZW5kZXIudHJhY2suZW5hYmxlZCA9ICFzaG91bGRNdXRlO1xuICB9IGVsc2Uge1xuICAgIHZhciBhdWRpb1RyYWNrcyA9IHR5cGVvZiB0aGlzLnN0cmVhbS5nZXRBdWRpb1RyYWNrcyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkgOiB0aGlzLnN0cmVhbS5hdWRpb1RyYWNrcztcblxuICAgIGF1ZGlvVHJhY2tzLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICB0cmFjay5lbmFibGVkID0gIXNob3VsZE11dGU7XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEdldCBvciBjcmVhdGUgYW4gUlRDRFRNRlNlbmRlciBmb3IgdGhlIGZpcnN0IGxvY2FsIGF1ZGlvIE1lZGlhU3RyZWFtVHJhY2tcbiAqIHdlIGNhbiBnZXQgZnJvbSB0aGUgUlRDUGVlckNvbm5lY3Rpb24uIFJldHVybiBudWxsIGlmIHVuc3VwcG9ydGVkLlxuICogQGluc3RhbmNlXG4gKiBAcmV0dXJucyA/UlRDRFRNRlNlbmRlclxuICovXG5QZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0T3JDcmVhdGVEVE1GU2VuZGVyID0gZnVuY3Rpb24gZ2V0T3JDcmVhdGVEVE1GU2VuZGVyKCkge1xuICBpZiAodGhpcy5fZHRtZlNlbmRlciB8fCB0aGlzLl9kdG1mU2VuZGVyVW5zdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZHRtZlNlbmRlciB8fCBudWxsO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcGMgPSB0aGlzLnZlcnNpb24ucGM7XG4gIGlmICghcGMpIHtcbiAgICB0aGlzLl9sb2cuaW5mbygnTm8gUlRDUGVlckNvbm5lY3Rpb24gYXZhaWxhYmxlIHRvIGNhbGwgY3JlYXRlRFRNRlNlbmRlciBvbicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYy5nZXRTZW5kZXJzID09PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgUlRDRFRNRlNlbmRlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgUlRDRHRtZlNlbmRlciA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB2YXIgY2hvc2VuU2VuZGVyID0gcGMuZ2V0U2VuZGVycygpLmZpbmQoZnVuY3Rpb24gKHNlbmRlcikge1xuICAgICAgcmV0dXJuIHNlbmRlci5kdG1mO1xuICAgIH0pO1xuICAgIGlmIChjaG9zZW5TZW5kZXIpIHtcbiAgICAgIHRoaXMuX2xvZy5pbmZvKCdVc2luZyBSVENSdHBTZW5kZXIjZHRtZicpO1xuICAgICAgdGhpcy5fZHRtZlNlbmRlciA9IGNob3NlblNlbmRlci5kdG1mO1xuICAgICAgcmV0dXJuIHRoaXMuX2R0bWZTZW5kZXI7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYy5jcmVhdGVEVE1GU2VuZGVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwYy5nZXRMb2NhbFN0cmVhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdHJhY2sgPSBwYy5nZXRMb2NhbFN0cmVhbXMoKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgdmFyIHRyYWNrcyA9IHNlbGYuX2dldEF1ZGlvVHJhY2tzKHN0cmVhbSk7XG4gICAgICByZXR1cm4gdHJhY2tzICYmIHRyYWNrc1swXTtcbiAgICB9KVswXTtcblxuICAgIGlmICghdHJhY2spIHtcbiAgICAgIHRoaXMuX2xvZy5pbmZvKCdObyBsb2NhbCBhdWRpbyBNZWRpYVN0cmVhbVRyYWNrIGF2YWlsYWJsZSBvbiB0aGUgUlRDUGVlckNvbm5lY3Rpb24gdG8gcGFzcyB0byBjcmVhdGVEVE1GU2VuZGVyJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2cuaW5mbygnQ3JlYXRpbmcgUlRDRFRNRlNlbmRlcicpO1xuICAgIHRoaXMuX2R0bWZTZW5kZXIgPSBwYy5jcmVhdGVEVE1GU2VuZGVyKHRyYWNrKTtcbiAgICByZXR1cm4gdGhpcy5fZHRtZlNlbmRlcjtcbiAgfVxuXG4gIHRoaXMuX2xvZy5pbmZvKCdSVENQZWVyQ29ubmVjdGlvbiBkb2VzIG5vdCBzdXBwb3J0IFJUQ0RUTUZTZW5kZXInKTtcbiAgdGhpcy5fZHRtZlNlbmRlclVuc3VwcG9ydGVkID0gdHJ1ZTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgUlRDRHRsVHJhbnNwb3J0IG9iamVjdCBmcm9tIHRoZSBQZWVyQ29ubmVjdGlvblxuICogQHJldHVybnMgUlRDRHRsVHJhbnNwb3J0XG4gKi9cblBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSVENEdGxzVHJhbnNwb3J0ID0gZnVuY3Rpb24gZ2V0UlRDRHRsc1RyYW5zcG9ydCgpIHtcbiAgdmFyIHNlbmRlciA9IHRoaXMudmVyc2lvbiAmJiB0aGlzLnZlcnNpb24ucGMgJiYgdHlwZW9mIHRoaXMudmVyc2lvbi5wYy5nZXRTZW5kZXJzID09PSAnZnVuY3Rpb24nICYmIHRoaXMudmVyc2lvbi5wYy5nZXRTZW5kZXJzKClbMF07XG4gIHJldHVybiBzZW5kZXIgJiYgc2VuZGVyLnRyYW5zcG9ydCB8fCBudWxsO1xufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jYW5TdG9wTWVkaWFTdHJlYW1UcmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5zdG9wID09PSAnZnVuY3Rpb24nO1xufTtcblxuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9nZXRBdWRpb1RyYWNrcyA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHJlYW0uZ2V0QXVkaW9UcmFja3MgPT09ICdmdW5jdGlvbicgPyBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKSA6IHN0cmVhbS5hdWRpb1RyYWNrcztcbn07XG5cbi8qKlxuICogR2V0IHRoZSBSVENJY2VUcmFuc3BvcnQgb2JqZWN0IGZyb20gdGhlIFBlZXJDb25uZWN0aW9uXG4gKiBAcmV0dXJucyBSVENJY2VUcmFuc3BvcnRcbiAqL1xuUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9nZXRSVENJY2VUcmFuc3BvcnQgPSBmdW5jdGlvbiBfZ2V0UlRDSWNlVHJhbnNwb3J0KCkge1xuICB2YXIgZHRsc1RyYW5zcG9ydCA9IHRoaXMuZ2V0UlRDRHRsc1RyYW5zcG9ydCgpO1xuICByZXR1cm4gZHRsc1RyYW5zcG9ydCAmJiBkdGxzVHJhbnNwb3J0LmljZVRyYW5zcG9ydCB8fCBudWxsO1xufTtcblxuLy8gSXMgUGVlckNvbm5lY3Rpb24ucHJvdG9jb2wgdXNlZCBvdXRzaWRlIG9mIG91ciBTREs/IFdlIHNob3VsZCByZW1vdmUgdGhpcyBpZiBub3QuXG5QZWVyQ29ubmVjdGlvbi5wcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJUQ1BDLnRlc3QoKSA/IG5ldyBSVENQQygpIDogbnVsbDtcbn0oKTtcblxuZnVuY3Rpb24gYWRkU3RyZWFtKHBjLCBzdHJlYW0pIHtcbiAgaWYgKHR5cGVvZiBwYy5hZGRUcmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2goZnVuY3Rpb24gKHRyYWNrKSB7XG4gICAgICAvLyBUaGUgc2Vjb25kIHBhcmFtZXRlcnMsIHN0cmVhbSwgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgcGVyIHRoZSBsYXRlc3QgZWRpdG9yJ3NcbiAgICAgIC8vICAgZHJhZnQsIGJ1dCBGRiByZXF1aXJlcyBpdC4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTIzMTQxNFxuICAgICAgcGMuYWRkVHJhY2sodHJhY2ssIHN0cmVhbSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcGMuYWRkU3RyZWFtKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVTdHJlYW0ob2xkU3RyZWFtKSB7XG4gIHZhciBuZXdTdHJlYW0gPSB0eXBlb2YgTWVkaWFTdHJlYW0gIT09ICd1bmRlZmluZWQnID8gbmV3IE1lZGlhU3RyZWFtKClcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIDogbmV3IHdlYmtpdE1lZGlhU3RyZWFtKCk7XG5cbiAgb2xkU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkuZm9yRWFjaChuZXdTdHJlYW0uYWRkVHJhY2ssIG5ld1N0cmVhbSk7XG4gIHJldHVybiBuZXdTdHJlYW07XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0cmVhbShwYywgc3RyZWFtKSB7XG4gIGlmICh0eXBlb2YgcGMucmVtb3ZlVHJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICBwYy5nZXRTZW5kZXJzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VuZGVyKSB7XG4gICAgICBwYy5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHBjLnJlbW92ZVN0cmVhbShzdHJlYW0pO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2Ugb2YgYW4gSFRNTEF1ZGlvRWxlbWVudCB0byB0aGUgc3BlY2lmaWVkIE1lZGlhU3RyZWFtXG4gKiBAcGFyYW0ge0hUTUxBdWRpb0VsZW1lbnR9IGF1ZGlvXG4gKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBzdHJlYW1cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBhdWRpbyBzb3VyY2Ugd2FzIHNldCBzdWNjZXNzZnVsbHlcbiAqL1xuZnVuY3Rpb24gc2V0QXVkaW9Tb3VyY2UoYXVkaW8sIHN0cmVhbSkge1xuICBpZiAodHlwZW9mIGF1ZGlvLnNyY09iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhdWRpby5zcmNPYmplY3QgPSBzdHJlYW07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1ZGlvLm1velNyY09iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhdWRpby5tb3pTcmNPYmplY3QgPSBzdHJlYW07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGF1ZGlvLnNyYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgX3dpbmRvdyA9IGF1ZGlvLm9wdGlvbnMud2luZG93IHx8IHdpbmRvdztcbiAgICBhdWRpby5zcmMgPSAoX3dpbmRvdy5VUkwgfHwgX3dpbmRvdy53ZWJraXRVUkwpLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5QZWVyQ29ubmVjdGlvbi5lbmFibGVkID0gUlRDUEMudGVzdCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXJDb25uZWN0aW9uOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/peerconnection.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/rtcpc.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global webkitRTCPeerConnection, mozRTCPeerConnection, mozRTCSessionDescription, mozRTCIceCandidate */\nvar RTCPeerConnectionShim = __webpack_require__(/*! rtcpeerconnection-shim */ \"./node_modules/rtcpeerconnection-shim/rtcpeerconnection.js\");\nvar Log = __webpack_require__(/*! ../log */ \"./node_modules/twilio-client/es5/twilio/log.js\").default;\n\nvar _require = __webpack_require__(/*! ./sdp */ \"./node_modules/twilio-client/es5/twilio/rtc/sdp.js\"),\n    setCodecPreferences = _require.setCodecPreferences,\n    setMaxAverageBitrate = _require.setMaxAverageBitrate;\n\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\n\nfunction RTCPC() {\n  if (typeof window === 'undefined') {\n    this.log.info('No RTCPeerConnection implementation available. The window object was not found.');\n    return;\n  }\n\n  if (util.isLegacyEdge()) {\n    this.RTCPeerConnection = new RTCPeerConnectionShim(typeof window !== 'undefined' ? window : __webpack_require__.g);\n  } else if (typeof window.RTCPeerConnection === 'function') {\n    this.RTCPeerConnection = window.RTCPeerConnection;\n  } else if (typeof window.webkitRTCPeerConnection === 'function') {\n    this.RTCPeerConnection = webkitRTCPeerConnection;\n  } else if (typeof window.mozRTCPeerConnection === 'function') {\n    this.RTCPeerConnection = mozRTCPeerConnection;\n    window.RTCSessionDescription = mozRTCSessionDescription;\n    window.RTCIceCandidate = mozRTCIceCandidate;\n  } else {\n    this.log.info('No RTCPeerConnection implementation available');\n  }\n}\n\nRTCPC.prototype.create = function (rtcConstraints, rtcConfiguration) {\n  this.log = Log.getInstance();\n  this.pc = new this.RTCPeerConnection(rtcConfiguration, rtcConstraints);\n};\nRTCPC.prototype.createModernConstraints = function (c) {\n  // createOffer differs between Chrome 23 and Chrome 24+.\n  // See https://groups.google.com/forum/?fromgroups=#!topic/discuss-webrtc/JBDZtrMumyU\n  // Unfortunately I haven't figured out a way to detect which format\n  // is required ahead of time, so we'll first try the old way, and\n  // if we get an exception, then we'll try the new way.\n  if (typeof c === 'undefined') {\n    return null;\n  }\n  // NOTE(mroberts): As of Chrome 38, Chrome still appears to expect\n  // constraints under the 'mandatory' key, and with the first letter of each\n  // constraint capitalized. Firefox, on the other hand, has deprecated the\n  // 'mandatory' key and does not expect the first letter of each constraint\n  // capitalized.\n  var nc = Object.assign({}, c);\n  if (typeof webkitRTCPeerConnection !== 'undefined' && !util.isLegacyEdge()) {\n    nc.mandatory = {};\n    if (typeof c.audio !== 'undefined') {\n      nc.mandatory.OfferToReceiveAudio = c.audio;\n    }\n    if (typeof c.video !== 'undefined') {\n      nc.mandatory.OfferToReceiveVideo = c.video;\n    }\n  } else {\n    if (typeof c.audio !== 'undefined') {\n      nc.offerToReceiveAudio = c.audio;\n    }\n    if (typeof c.video !== 'undefined') {\n      nc.offerToReceiveVideo = c.video;\n    }\n  }\n\n  delete nc.audio;\n  delete nc.video;\n\n  return nc;\n};\nRTCPC.prototype.createOffer = function (maxAverageBitrate, codecPreferences, constraints, onSuccess, onError) {\n  var _this = this;\n\n  constraints = this.createModernConstraints(constraints);\n  return promisifyCreate(this.pc.createOffer, this.pc)(constraints).then(function (offer) {\n    if (!_this.pc) {\n      return Promise.resolve();\n    }\n\n    var sdp = setMaxAverageBitrate(offer.sdp, maxAverageBitrate);\n\n    return promisifySet(_this.pc.setLocalDescription, _this.pc)(new RTCSessionDescription({\n      type: 'offer',\n      sdp: setCodecPreferences(sdp, codecPreferences)\n    }));\n  }).then(onSuccess, onError);\n};\nRTCPC.prototype.createAnswer = function (maxAverageBitrate, codecPreferences, constraints, onSuccess, onError) {\n  var _this2 = this;\n\n  constraints = this.createModernConstraints(constraints);\n  return promisifyCreate(this.pc.createAnswer, this.pc)(constraints).then(function (answer) {\n    if (!_this2.pc) {\n      return Promise.resolve();\n    }\n    var sdp = setMaxAverageBitrate(answer.sdp, maxAverageBitrate);\n\n    return promisifySet(_this2.pc.setLocalDescription, _this2.pc)(new RTCSessionDescription({\n      type: 'answer',\n      sdp: setCodecPreferences(sdp, codecPreferences)\n    }));\n  }).then(onSuccess, onError);\n};\nRTCPC.prototype.processSDP = function (maxAverageBitrate, codecPreferences, sdp, constraints, onSuccess, onError) {\n  var _this3 = this;\n\n  sdp = setCodecPreferences(sdp, codecPreferences);\n  var desc = new RTCSessionDescription({ sdp: sdp, type: 'offer' });\n  return promisifySet(this.pc.setRemoteDescription, this.pc)(desc).then(function () {\n    _this3.createAnswer(maxAverageBitrate, codecPreferences, constraints, onSuccess, onError);\n  });\n};\nRTCPC.prototype.getSDP = function () {\n  return this.pc.localDescription.sdp;\n};\nRTCPC.prototype.processAnswer = function (codecPreferences, sdp, onSuccess, onError) {\n  if (!this.pc) {\n    return Promise.resolve();\n  }\n  sdp = setCodecPreferences(sdp, codecPreferences);\n\n  return promisifySet(this.pc.setRemoteDescription, this.pc)(new RTCSessionDescription({ sdp: sdp, type: 'answer' })).then(onSuccess, onError);\n};\n/* NOTE(mroberts): Firefox 18 through 21 include a `mozRTCPeerConnection`\n   object, but attempting to instantiate it will throw the error\n\n       Error: PeerConnection not enabled (did you set the pref?)\n\n   unless the `media.peerconnection.enabled` pref is enabled. So we need to test\n   if we can actually instantiate `mozRTCPeerConnection`; however, if the user\n   *has* enabled `media.peerconnection.enabled`, we need to perform the same\n   test that we use to detect Firefox 24 and above, namely:\n\n       typeof (new mozRTCPeerConnection()).getLocalStreams === 'function'\n\n\n    NOTE(rrowland): We no longer support Legacy Edge as of Sep 1, 2020.\n*/\nRTCPC.test = function () {\n  if ((typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === 'object') {\n    var getUserMedia = navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.getUserMedia;\n\n    if (util.isLegacyEdge(navigator)) {\n      return false;\n    }\n\n    if (getUserMedia && typeof window.RTCPeerConnection === 'function') {\n      return true;\n    } else if (getUserMedia && typeof window.webkitRTCPeerConnection === 'function') {\n      return true;\n    } else if (getUserMedia && typeof window.mozRTCPeerConnection === 'function') {\n      try {\n        // eslint-disable-next-line babel/new-cap\n        var test = new window.mozRTCPeerConnection();\n        if (typeof test.getLocalStreams !== 'function') return false;\n      } catch (e) {\n        return false;\n      }\n      return true;\n    } else if (typeof RTCIceGatherer !== 'undefined') {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nfunction promisify(fn, ctx, areCallbacksFirst) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    return new Promise(function (resolve) {\n      resolve(fn.apply(ctx, args));\n    }).catch(function () {\n      return new Promise(function (resolve, reject) {\n        fn.apply(ctx, areCallbacksFirst ? [resolve, reject].concat(args) : args.concat([resolve, reject]));\n      });\n    });\n  };\n}\n\nfunction promisifyCreate(fn, ctx) {\n  return promisify(fn, ctx, true);\n}\n\nfunction promisifySet(fn, ctx) {\n  return promisify(fn, ctx, false);\n}\n\nmodule.exports = RTCPC;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9ydGNwYy5qcz82N2U2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUTtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLDBGQUF3QjtBQUM1RCxVQUFVLDJGQUF5Qjs7QUFFbkMsZUFBZSxtQkFBTyxDQUFDLGlFQUFPO0FBQzlCO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGdFQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0dBQWdHLHFCQUFNO0FBQ3RHLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsMEJBQTBCO0FBQ2xFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdGQUF3RiwyQkFBMkI7QUFDbkg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vcnRjL3J0Y3BjLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbi8qIGdsb2JhbCB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiwgbW96UlRDUGVlckNvbm5lY3Rpb24sIG1velJUQ1Nlc3Npb25EZXNjcmlwdGlvbiwgbW96UlRDSWNlQ2FuZGlkYXRlICovXG52YXIgUlRDUGVlckNvbm5lY3Rpb25TaGltID0gcmVxdWlyZSgncnRjcGVlcmNvbm5lY3Rpb24tc2hpbScpO1xudmFyIExvZyA9IHJlcXVpcmUoJy4uL2xvZycpLmRlZmF1bHQ7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vc2RwJyksXG4gICAgc2V0Q29kZWNQcmVmZXJlbmNlcyA9IF9yZXF1aXJlLnNldENvZGVjUHJlZmVyZW5jZXMsXG4gICAgc2V0TWF4QXZlcmFnZUJpdHJhdGUgPSBfcmVxdWlyZS5zZXRNYXhBdmVyYWdlQml0cmF0ZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmZ1bmN0aW9uIFJUQ1BDKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmxvZy5pbmZvKCdObyBSVENQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUuIFRoZSB3aW5kb3cgb2JqZWN0IHdhcyBub3QgZm91bmQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHV0aWwuaXNMZWdhY3lFZGdlKCkpIHtcbiAgICB0aGlzLlJUQ1BlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uU2hpbSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuUlRDUGVlckNvbm5lY3Rpb24gPSB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5SVENQZWVyQ29ubmVjdGlvbiA9IG1velJUQ1BlZXJDb25uZWN0aW9uO1xuICAgIHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24gPSBtb3pSVENTZXNzaW9uRGVzY3JpcHRpb247XG4gICAgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA9IG1velJUQ0ljZUNhbmRpZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxvZy5pbmZvKCdObyBSVENQZWVyQ29ubmVjdGlvbiBpbXBsZW1lbnRhdGlvbiBhdmFpbGFibGUnKTtcbiAgfVxufVxuXG5SVENQQy5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKHJ0Y0NvbnN0cmFpbnRzLCBydGNDb25maWd1cmF0aW9uKSB7XG4gIHRoaXMubG9nID0gTG9nLmdldEluc3RhbmNlKCk7XG4gIHRoaXMucGMgPSBuZXcgdGhpcy5SVENQZWVyQ29ubmVjdGlvbihydGNDb25maWd1cmF0aW9uLCBydGNDb25zdHJhaW50cyk7XG59O1xuUlRDUEMucHJvdG90eXBlLmNyZWF0ZU1vZGVybkNvbnN0cmFpbnRzID0gZnVuY3Rpb24gKGMpIHtcbiAgLy8gY3JlYXRlT2ZmZXIgZGlmZmVycyBiZXR3ZWVuIENocm9tZSAyMyBhbmQgQ2hyb21lIDI0Ky5cbiAgLy8gU2VlIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vP2Zyb21ncm91cHM9IyF0b3BpYy9kaXNjdXNzLXdlYnJ0Yy9KQkRadHJNdW15VVxuICAvLyBVbmZvcnR1bmF0ZWx5IEkgaGF2ZW4ndCBmaWd1cmVkIG91dCBhIHdheSB0byBkZXRlY3Qgd2hpY2ggZm9ybWF0XG4gIC8vIGlzIHJlcXVpcmVkIGFoZWFkIG9mIHRpbWUsIHNvIHdlJ2xsIGZpcnN0IHRyeSB0aGUgb2xkIHdheSwgYW5kXG4gIC8vIGlmIHdlIGdldCBhbiBleGNlcHRpb24sIHRoZW4gd2UnbGwgdHJ5IHRoZSBuZXcgd2F5LlxuICBpZiAodHlwZW9mIGMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gTk9URShtcm9iZXJ0cyk6IEFzIG9mIENocm9tZSAzOCwgQ2hyb21lIHN0aWxsIGFwcGVhcnMgdG8gZXhwZWN0XG4gIC8vIGNvbnN0cmFpbnRzIHVuZGVyIHRoZSAnbWFuZGF0b3J5JyBrZXksIGFuZCB3aXRoIHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaFxuICAvLyBjb25zdHJhaW50IGNhcGl0YWxpemVkLiBGaXJlZm94LCBvbiB0aGUgb3RoZXIgaGFuZCwgaGFzIGRlcHJlY2F0ZWQgdGhlXG4gIC8vICdtYW5kYXRvcnknIGtleSBhbmQgZG9lcyBub3QgZXhwZWN0IHRoZSBmaXJzdCBsZXR0ZXIgb2YgZWFjaCBjb25zdHJhaW50XG4gIC8vIGNhcGl0YWxpemVkLlxuICB2YXIgbmMgPSBPYmplY3QuYXNzaWduKHt9LCBjKTtcbiAgaWYgKHR5cGVvZiB3ZWJraXRSVENQZWVyQ29ubmVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgIXV0aWwuaXNMZWdhY3lFZGdlKCkpIHtcbiAgICBuYy5tYW5kYXRvcnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIGMuYXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBuYy5tYW5kYXRvcnkuT2ZmZXJUb1JlY2VpdmVBdWRpbyA9IGMuYXVkaW87XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYy52aWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5jLm1hbmRhdG9yeS5PZmZlclRvUmVjZWl2ZVZpZGVvID0gYy52aWRlbztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBjLmF1ZGlvICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbmMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9IGMuYXVkaW87XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYy52aWRlbyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG5jLm9mZmVyVG9SZWNlaXZlVmlkZW8gPSBjLnZpZGVvO1xuICAgIH1cbiAgfVxuXG4gIGRlbGV0ZSBuYy5hdWRpbztcbiAgZGVsZXRlIG5jLnZpZGVvO1xuXG4gIHJldHVybiBuYztcbn07XG5SVENQQy5wcm90b3R5cGUuY3JlYXRlT2ZmZXIgPSBmdW5jdGlvbiAobWF4QXZlcmFnZUJpdHJhdGUsIGNvZGVjUHJlZmVyZW5jZXMsIGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBjb25zdHJhaW50cyA9IHRoaXMuY3JlYXRlTW9kZXJuQ29uc3RyYWludHMoY29uc3RyYWludHMpO1xuICByZXR1cm4gcHJvbWlzaWZ5Q3JlYXRlKHRoaXMucGMuY3JlYXRlT2ZmZXIsIHRoaXMucGMpKGNvbnN0cmFpbnRzKS50aGVuKGZ1bmN0aW9uIChvZmZlcikge1xuICAgIGlmICghX3RoaXMucGMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2RwID0gc2V0TWF4QXZlcmFnZUJpdHJhdGUob2ZmZXIuc2RwLCBtYXhBdmVyYWdlQml0cmF0ZSk7XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5U2V0KF90aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24sIF90aGlzLnBjKShuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6ICdvZmZlcicsXG4gICAgICBzZHA6IHNldENvZGVjUHJlZmVyZW5jZXMoc2RwLCBjb2RlY1ByZWZlcmVuY2VzKVxuICAgIH0pKTtcbiAgfSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xufTtcblJUQ1BDLnByb3RvdHlwZS5jcmVhdGVBbnN3ZXIgPSBmdW5jdGlvbiAobWF4QXZlcmFnZUJpdHJhdGUsIGNvZGVjUHJlZmVyZW5jZXMsIGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgY29uc3RyYWludHMgPSB0aGlzLmNyZWF0ZU1vZGVybkNvbnN0cmFpbnRzKGNvbnN0cmFpbnRzKTtcbiAgcmV0dXJuIHByb21pc2lmeUNyZWF0ZSh0aGlzLnBjLmNyZWF0ZUFuc3dlciwgdGhpcy5wYykoY29uc3RyYWludHMpLnRoZW4oZnVuY3Rpb24gKGFuc3dlcikge1xuICAgIGlmICghX3RoaXMyLnBjKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHZhciBzZHAgPSBzZXRNYXhBdmVyYWdlQml0cmF0ZShhbnN3ZXIuc2RwLCBtYXhBdmVyYWdlQml0cmF0ZSk7XG5cbiAgICByZXR1cm4gcHJvbWlzaWZ5U2V0KF90aGlzMi5wYy5zZXRMb2NhbERlc2NyaXB0aW9uLCBfdGhpczIucGMpKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogJ2Fuc3dlcicsXG4gICAgICBzZHA6IHNldENvZGVjUHJlZmVyZW5jZXMoc2RwLCBjb2RlY1ByZWZlcmVuY2VzKVxuICAgIH0pKTtcbiAgfSkudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xufTtcblJUQ1BDLnByb3RvdHlwZS5wcm9jZXNzU0RQID0gZnVuY3Rpb24gKG1heEF2ZXJhZ2VCaXRyYXRlLCBjb2RlY1ByZWZlcmVuY2VzLCBzZHAsIGNvbnN0cmFpbnRzLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgc2RwID0gc2V0Q29kZWNQcmVmZXJlbmNlcyhzZHAsIGNvZGVjUHJlZmVyZW5jZXMpO1xuICB2YXIgZGVzYyA9IG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oeyBzZHA6IHNkcCwgdHlwZTogJ29mZmVyJyB9KTtcbiAgcmV0dXJuIHByb21pc2lmeVNldCh0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uLCB0aGlzLnBjKShkZXNjKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBfdGhpczMuY3JlYXRlQW5zd2VyKG1heEF2ZXJhZ2VCaXRyYXRlLCBjb2RlY1ByZWZlcmVuY2VzLCBjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfSk7XG59O1xuUlRDUEMucHJvdG90eXBlLmdldFNEUCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGMubG9jYWxEZXNjcmlwdGlvbi5zZHA7XG59O1xuUlRDUEMucHJvdG90eXBlLnByb2Nlc3NBbnN3ZXIgPSBmdW5jdGlvbiAoY29kZWNQcmVmZXJlbmNlcywgc2RwLCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgaWYgKCF0aGlzLnBjKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG4gIHNkcCA9IHNldENvZGVjUHJlZmVyZW5jZXMoc2RwLCBjb2RlY1ByZWZlcmVuY2VzKTtcblxuICByZXR1cm4gcHJvbWlzaWZ5U2V0KHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24sIHRoaXMucGMpKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oeyBzZHA6IHNkcCwgdHlwZTogJ2Fuc3dlcicgfSkpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKTtcbn07XG4vKiBOT1RFKG1yb2JlcnRzKTogRmlyZWZveCAxOCB0aHJvdWdoIDIxIGluY2x1ZGUgYSBgbW96UlRDUGVlckNvbm5lY3Rpb25gXG4gICBvYmplY3QsIGJ1dCBhdHRlbXB0aW5nIHRvIGluc3RhbnRpYXRlIGl0IHdpbGwgdGhyb3cgdGhlIGVycm9yXG5cbiAgICAgICBFcnJvcjogUGVlckNvbm5lY3Rpb24gbm90IGVuYWJsZWQgKGRpZCB5b3Ugc2V0IHRoZSBwcmVmPylcblxuICAgdW5sZXNzIHRoZSBgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZGAgcHJlZiBpcyBlbmFibGVkLiBTbyB3ZSBuZWVkIHRvIHRlc3RcbiAgIGlmIHdlIGNhbiBhY3R1YWxseSBpbnN0YW50aWF0ZSBgbW96UlRDUGVlckNvbm5lY3Rpb25gOyBob3dldmVyLCBpZiB0aGUgdXNlclxuICAgKmhhcyogZW5hYmxlZCBgbWVkaWEucGVlcmNvbm5lY3Rpb24uZW5hYmxlZGAsIHdlIG5lZWQgdG8gcGVyZm9ybSB0aGUgc2FtZVxuICAgdGVzdCB0aGF0IHdlIHVzZSB0byBkZXRlY3QgRmlyZWZveCAyNCBhbmQgYWJvdmUsIG5hbWVseTpcblxuICAgICAgIHR5cGVvZiAobmV3IG1velJUQ1BlZXJDb25uZWN0aW9uKCkpLmdldExvY2FsU3RyZWFtcyA9PT0gJ2Z1bmN0aW9uJ1xuXG5cbiAgICBOT1RFKHJyb3dsYW5kKTogV2Ugbm8gbG9uZ2VyIHN1cHBvcnQgTGVnYWN5IEVkZ2UgYXMgb2YgU2VwIDEsIDIwMjAuXG4qL1xuUlRDUEMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihuYXZpZ2F0b3IpKSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgZ2V0VXNlck1lZGlhID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLmdldFVzZXJNZWRpYTtcblxuICAgIGlmICh1dGlsLmlzTGVnYWN5RWRnZShuYXZpZ2F0b3IpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGdldFVzZXJNZWRpYSAmJiB0eXBlb2Ygd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdldFVzZXJNZWRpYSAmJiB0eXBlb2Ygd2luZG93LndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdldFVzZXJNZWRpYSAmJiB0eXBlb2Ygd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFiZWwvbmV3LWNhcFxuICAgICAgICB2YXIgdGVzdCA9IG5ldyB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24oKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXN0LmdldExvY2FsU3RyZWFtcyAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBSVENJY2VHYXRoZXJlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHByb21pc2lmeShmbiwgY3R4LCBhcmVDYWxsYmFja3NGaXJzdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgcmVzb2x2ZShmbi5hcHBseShjdHgsIGFyZ3MpKTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmbi5hcHBseShjdHgsIGFyZUNhbGxiYWNrc0ZpcnN0ID8gW3Jlc29sdmUsIHJlamVjdF0uY29uY2F0KGFyZ3MpIDogYXJncy5jb25jYXQoW3Jlc29sdmUsIHJlamVjdF0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnlDcmVhdGUoZm4sIGN0eCkge1xuICByZXR1cm4gcHJvbWlzaWZ5KGZuLCBjdHgsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBwcm9taXNpZnlTZXQoZm4sIGN0eCkge1xuICByZXR1cm4gcHJvbWlzaWZ5KGZuLCBjdHgsIGZhbHNlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSVENQQzsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/rtcpc.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/sdp.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar util = __webpack_require__(/*! ../util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\n\nvar ptToFixedBitrateAudioCodecName = {\n  0: 'PCMU',\n  8: 'PCMA'\n};\n\nvar defaultOpusId = 111;\nvar BITRATE_MAX = 510000;\nvar BITRATE_MIN = 6000;\n\nfunction getPreferredCodecInfo(sdp) {\n  var _ref = /a=rtpmap:(\\d+) (\\S+)/m.exec(sdp) || [null, '', ''],\n      _ref2 = _slicedToArray(_ref, 3),\n      codecId = _ref2[1],\n      codecName = _ref2[2];\n\n  var regex = new RegExp('a=fmtp:' + codecId + ' (\\\\S+)', 'm');\n\n  var _ref3 = regex.exec(sdp) || [null, ''],\n      _ref4 = _slicedToArray(_ref3, 2),\n      codecParams = _ref4[1];\n\n  return { codecName: codecName, codecParams: codecParams };\n}\n\nfunction setIceAggressiveNomination(sdp) {\n  // This only works on Chrome. We don't want any side effects on other browsers\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=1024096\n  // https://issues.corp.twilio.com/browse/CLIENT-6911\n  if (!util.isChrome(window, window.navigator)) {\n    return sdp;\n  }\n\n  return sdp.split('\\n').filter(function (line) {\n    return line.indexOf('a=ice-lite') === -1;\n  }).join('\\n');\n}\n\nfunction setMaxAverageBitrate(sdp, maxAverageBitrate) {\n  if (typeof maxAverageBitrate !== 'number' || maxAverageBitrate < BITRATE_MIN || maxAverageBitrate > BITRATE_MAX) {\n    return sdp;\n  }\n\n  var matches = /a=rtpmap:(\\d+) opus/m.exec(sdp);\n  var opusId = matches && matches.length ? matches[1] : defaultOpusId;\n  var regex = new RegExp('a=fmtp:' + opusId);\n  var lines = sdp.split('\\n').map(function (line) {\n    return regex.test(line) ? line + (';maxaveragebitrate=' + maxAverageBitrate) : line;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Return a new SDP string with the re-ordered codec preferences.\n * @param {string} sdp\n * @param {Array<AudioCodec>} preferredCodecs - If empty, the existing order\n *   of audio codecs is preserved\n * @returns {string} Updated SDP string\n */\nfunction setCodecPreferences(sdp, preferredCodecs) {\n  var mediaSections = getMediaSections(sdp);\n  var session = sdp.split('\\r\\nm=')[0];\n  return [session].concat(mediaSections.map(function (section) {\n    // Codec preferences should not be applied to m=application sections.\n    if (!/^m=(audio|video)/.test(section)) {\n      return section;\n    }\n    var kind = section.match(/^m=(audio|video)/)[1];\n    var codecMap = createCodecMapForMediaSection(section);\n    var payloadTypes = getReorderedPayloadTypes(codecMap, preferredCodecs);\n    var newSection = setPayloadTypesInMediaSection(payloadTypes, section);\n\n    var pcmaPayloadTypes = codecMap.get('pcma') || [];\n    var pcmuPayloadTypes = codecMap.get('pcmu') || [];\n    var fixedBitratePayloadTypes = kind === 'audio' ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes)) : new Set();\n\n    return fixedBitratePayloadTypes.has(payloadTypes[0]) ? newSection.replace(/\\r\\nb=(AS|TIAS):([0-9]+)/g, '') : newSection;\n  })).join('\\r\\n');\n}\n\n/**\n * Get the m= sections of a particular kind and direction from an sdp.\n * @param {string} sdp - SDP string\n * @param {string} [kind] - Pattern for matching kind\n * @param {string} [direction] - Pattern for matching direction\n * @returns {Array<string>} mediaSections\n */\nfunction getMediaSections(sdp, kind, direction) {\n  return sdp.replace(/\\r\\n\\r\\n$/, '\\r\\n').split('\\r\\nm=').slice(1).map(function (mediaSection) {\n    return 'm=' + mediaSection;\n  }).filter(function (mediaSection) {\n    var kindPattern = new RegExp('m=' + (kind || '.*'), 'gm');\n    var directionPattern = new RegExp('a=' + (direction || '.*'), 'gm');\n    return kindPattern.test(mediaSection) && directionPattern.test(mediaSection);\n  });\n}\n\n/**\n * Create a Codec Map for the given m= section.\n * @param {string} section - The given m= section\n * @returns {Map<Codec, Array<PT>>}\n */\nfunction createCodecMapForMediaSection(section) {\n  return Array.from(createPtToCodecName(section)).reduce(function (codecMap, pair) {\n    var pt = pair[0];\n    var codecName = pair[1];\n    var pts = codecMap.get(codecName) || [];\n    return codecMap.set(codecName, pts.concat(pt));\n  }, new Map());\n}\n\n/**\n * Create the reordered Codec Payload Types based on the preferred Codec Names.\n * @param {Map<Codec, Array<PT>>} codecMap - Codec Map\n * @param {Array<Codec>} preferredCodecs - Preferred Codec Names\n * @returns {Array<PT>} Reordered Payload Types\n */\nfunction getReorderedPayloadTypes(codecMap, preferredCodecs) {\n  preferredCodecs = preferredCodecs.map(function (codecName) {\n    return codecName.toLowerCase();\n  });\n\n  var preferredPayloadTypes = util.flatMap(preferredCodecs, function (codecName) {\n    return codecMap.get(codecName) || [];\n  });\n\n  var remainingCodecs = util.difference(Array.from(codecMap.keys()), preferredCodecs);\n  var remainingPayloadTypes = util.flatMap(remainingCodecs, function (codecName) {\n    return codecMap.get(codecName);\n  });\n\n  return preferredPayloadTypes.concat(remainingPayloadTypes);\n}\n\n/**\n * Set the given Codec Payload Types in the first line of the given m= section.\n * @param {Array<PT>} payloadTypes - Payload Types\n * @param {string} section - Given m= section\n * @returns {string} - Updated m= section\n */\nfunction setPayloadTypesInMediaSection(payloadTypes, section) {\n  var lines = section.split('\\r\\n');\n  var mLine = lines[0];\n  var otherLines = lines.slice(1);\n  mLine = mLine.replace(/([0-9]+\\s?)+$/, payloadTypes.join(' '));\n  return [mLine].concat(otherLines).join('\\r\\n');\n}\n\n/**\n * Create a Map from PTs to codec names for the given m= section.\n * @param {string} mediaSection - The given m= section.\n * @returns {Map<PT, Codec>} ptToCodecName\n */\nfunction createPtToCodecName(mediaSection) {\n  return getPayloadTypesInMediaSection(mediaSection).reduce(function (ptToCodecName, pt) {\n    var rtpmapPattern = new RegExp('a=rtpmap:' + pt + ' ([^/]+)');\n    var matches = mediaSection.match(rtpmapPattern);\n    var codecName = matches ? matches[1].toLowerCase() : ptToFixedBitrateAudioCodecName[pt] ? ptToFixedBitrateAudioCodecName[pt].toLowerCase() : '';\n    return ptToCodecName.set(pt, codecName);\n  }, new Map());\n}\n\n/**\n * Get the Codec Payload Types present in the first line of the given m= section\n * @param {string} section - The m= section\n * @returns {Array<PT>} Payload Types\n */\nfunction getPayloadTypesInMediaSection(section) {\n  var mLine = section.split('\\r\\n')[0];\n\n  // In \"m=<kind> <port> <proto> <payload_type_1> <payload_type_2> ... <payload_type_n>\",\n  // the regex matches <port> and the PayloadTypes.\n  var matches = mLine.match(/([0-9]+)/g);\n\n  // This should not happen, but in case there are no PayloadTypes in\n  // the m= line, return an empty array.\n  if (!matches) {\n    return [];\n  }\n\n  // Since only the PayloadTypes are needed, we discard the <port>.\n  return matches.slice(1).map(function (match) {\n    return parseInt(match, 10);\n  });\n}\n\nmodule.exports = {\n  getPreferredCodecInfo: getPreferredCodecInfo,\n  setCodecPreferences: setCodecPreferences,\n  setIceAggressiveNomination: setIceAggressiveNomination,\n  setMaxAverageBitrate: setMaxAverageBitrate\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9zZHAuanM/YWU0MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixrQ0FBa0MsaUNBQWlDLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLHlDQUF5QyxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLDBCQUEwQixZQUFZLEVBQUUsMkNBQTJDLDhCQUE4QixFQUFFLE9BQU8sNkVBQTZFLEVBQUUsR0FBRyxFQUFFOztBQUVycEIsV0FBVyxtQkFBTyxDQUFDLGdFQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGFBQWE7QUFDeEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9zZHAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBwdFRvRml4ZWRCaXRyYXRlQXVkaW9Db2RlY05hbWUgPSB7XG4gIDA6ICdQQ01VJyxcbiAgODogJ1BDTUEnXG59O1xuXG52YXIgZGVmYXVsdE9wdXNJZCA9IDExMTtcbnZhciBCSVRSQVRFX01BWCA9IDUxMDAwMDtcbnZhciBCSVRSQVRFX01JTiA9IDYwMDA7XG5cbmZ1bmN0aW9uIGdldFByZWZlcnJlZENvZGVjSW5mbyhzZHApIHtcbiAgdmFyIF9yZWYgPSAvYT1ydHBtYXA6KFxcZCspIChcXFMrKS9tLmV4ZWMoc2RwKSB8fCBbbnVsbCwgJycsICcnXSxcbiAgICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMyksXG4gICAgICBjb2RlY0lkID0gX3JlZjJbMV0sXG4gICAgICBjb2RlY05hbWUgPSBfcmVmMlsyXTtcblxuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdhPWZtdHA6JyArIGNvZGVjSWQgKyAnIChcXFxcUyspJywgJ20nKTtcblxuICB2YXIgX3JlZjMgPSByZWdleC5leGVjKHNkcCkgfHwgW251bGwsICcnXSxcbiAgICAgIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDIpLFxuICAgICAgY29kZWNQYXJhbXMgPSBfcmVmNFsxXTtcblxuICByZXR1cm4geyBjb2RlY05hbWU6IGNvZGVjTmFtZSwgY29kZWNQYXJhbXM6IGNvZGVjUGFyYW1zIH07XG59XG5cbmZ1bmN0aW9uIHNldEljZUFnZ3Jlc3NpdmVOb21pbmF0aW9uKHNkcCkge1xuICAvLyBUaGlzIG9ubHkgd29ya3Mgb24gQ2hyb21lLiBXZSBkb24ndCB3YW50IGFueSBzaWRlIGVmZmVjdHMgb24gb3RoZXIgYnJvd3NlcnNcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTAyNDA5NlxuICAvLyBodHRwczovL2lzc3Vlcy5jb3JwLnR3aWxpby5jb20vYnJvd3NlL0NMSUVOVC02OTExXG4gIGlmICghdXRpbC5pc0Nocm9tZSh3aW5kb3csIHdpbmRvdy5uYXZpZ2F0b3IpKSB7XG4gICAgcmV0dXJuIHNkcDtcbiAgfVxuXG4gIHJldHVybiBzZHAuc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiBsaW5lLmluZGV4T2YoJ2E9aWNlLWxpdGUnKSA9PT0gLTE7XG4gIH0pLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXhBdmVyYWdlQml0cmF0ZShzZHAsIG1heEF2ZXJhZ2VCaXRyYXRlKSB7XG4gIGlmICh0eXBlb2YgbWF4QXZlcmFnZUJpdHJhdGUgIT09ICdudW1iZXInIHx8IG1heEF2ZXJhZ2VCaXRyYXRlIDwgQklUUkFURV9NSU4gfHwgbWF4QXZlcmFnZUJpdHJhdGUgPiBCSVRSQVRFX01BWCkge1xuICAgIHJldHVybiBzZHA7XG4gIH1cblxuICB2YXIgbWF0Y2hlcyA9IC9hPXJ0cG1hcDooXFxkKykgb3B1cy9tLmV4ZWMoc2RwKTtcbiAgdmFyIG9wdXNJZCA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPyBtYXRjaGVzWzFdIDogZGVmYXVsdE9wdXNJZDtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnYT1mbXRwOicgKyBvcHVzSWQpO1xuICB2YXIgbGluZXMgPSBzZHAuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgIHJldHVybiByZWdleC50ZXN0KGxpbmUpID8gbGluZSArICgnO21heGF2ZXJhZ2ViaXRyYXRlPScgKyBtYXhBdmVyYWdlQml0cmF0ZSkgOiBsaW5lO1xuICB9KTtcblxuICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbmV3IFNEUCBzdHJpbmcgd2l0aCB0aGUgcmUtb3JkZXJlZCBjb2RlYyBwcmVmZXJlbmNlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHBcbiAqIEBwYXJhbSB7QXJyYXk8QXVkaW9Db2RlYz59IHByZWZlcnJlZENvZGVjcyAtIElmIGVtcHR5LCB0aGUgZXhpc3Rpbmcgb3JkZXJcbiAqICAgb2YgYXVkaW8gY29kZWNzIGlzIHByZXNlcnZlZFxuICogQHJldHVybnMge3N0cmluZ30gVXBkYXRlZCBTRFAgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHNldENvZGVjUHJlZmVyZW5jZXMoc2RwLCBwcmVmZXJyZWRDb2RlY3MpIHtcbiAgdmFyIG1lZGlhU2VjdGlvbnMgPSBnZXRNZWRpYVNlY3Rpb25zKHNkcCk7XG4gIHZhciBzZXNzaW9uID0gc2RwLnNwbGl0KCdcXHJcXG5tPScpWzBdO1xuICByZXR1cm4gW3Nlc3Npb25dLmNvbmNhdChtZWRpYVNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgIC8vIENvZGVjIHByZWZlcmVuY2VzIHNob3VsZCBub3QgYmUgYXBwbGllZCB0byBtPWFwcGxpY2F0aW9uIHNlY3Rpb25zLlxuICAgIGlmICghL15tPShhdWRpb3x2aWRlbykvLnRlc3Qoc2VjdGlvbikpIHtcbiAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgIH1cbiAgICB2YXIga2luZCA9IHNlY3Rpb24ubWF0Y2goL15tPShhdWRpb3x2aWRlbykvKVsxXTtcbiAgICB2YXIgY29kZWNNYXAgPSBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKTtcbiAgICB2YXIgcGF5bG9hZFR5cGVzID0gZ2V0UmVvcmRlcmVkUGF5bG9hZFR5cGVzKGNvZGVjTWFwLCBwcmVmZXJyZWRDb2RlY3MpO1xuICAgIHZhciBuZXdTZWN0aW9uID0gc2V0UGF5bG9hZFR5cGVzSW5NZWRpYVNlY3Rpb24ocGF5bG9hZFR5cGVzLCBzZWN0aW9uKTtcblxuICAgIHZhciBwY21hUGF5bG9hZFR5cGVzID0gY29kZWNNYXAuZ2V0KCdwY21hJykgfHwgW107XG4gICAgdmFyIHBjbXVQYXlsb2FkVHlwZXMgPSBjb2RlY01hcC5nZXQoJ3BjbXUnKSB8fCBbXTtcbiAgICB2YXIgZml4ZWRCaXRyYXRlUGF5bG9hZFR5cGVzID0ga2luZCA9PT0gJ2F1ZGlvJyA/IG5ldyBTZXQocGNtYVBheWxvYWRUeXBlcy5jb25jYXQocGNtdVBheWxvYWRUeXBlcykpIDogbmV3IFNldCgpO1xuXG4gICAgcmV0dXJuIGZpeGVkQml0cmF0ZVBheWxvYWRUeXBlcy5oYXMocGF5bG9hZFR5cGVzWzBdKSA/IG5ld1NlY3Rpb24ucmVwbGFjZSgvXFxyXFxuYj0oQVN8VElBUyk6KFswLTldKykvZywgJycpIDogbmV3U2VjdGlvbjtcbiAgfSkpLmpvaW4oJ1xcclxcbicpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbT0gc2VjdGlvbnMgb2YgYSBwYXJ0aWN1bGFyIGtpbmQgYW5kIGRpcmVjdGlvbiBmcm9tIGFuIHNkcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzZHAgLSBTRFAgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tpbmRdIC0gUGF0dGVybiBmb3IgbWF0Y2hpbmcga2luZFxuICogQHBhcmFtIHtzdHJpbmd9IFtkaXJlY3Rpb25dIC0gUGF0dGVybiBmb3IgbWF0Y2hpbmcgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gbWVkaWFTZWN0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRNZWRpYVNlY3Rpb25zKHNkcCwga2luZCwgZGlyZWN0aW9uKSB7XG4gIHJldHVybiBzZHAucmVwbGFjZSgvXFxyXFxuXFxyXFxuJC8sICdcXHJcXG4nKS5zcGxpdCgnXFxyXFxubT0nKS5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIHJldHVybiAnbT0nICsgbWVkaWFTZWN0aW9uO1xuICB9KS5maWx0ZXIoZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgIHZhciBraW5kUGF0dGVybiA9IG5ldyBSZWdFeHAoJ209JyArIChraW5kIHx8ICcuKicpLCAnZ20nKTtcbiAgICB2YXIgZGlyZWN0aW9uUGF0dGVybiA9IG5ldyBSZWdFeHAoJ2E9JyArIChkaXJlY3Rpb24gfHwgJy4qJyksICdnbScpO1xuICAgIHJldHVybiBraW5kUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbikgJiYgZGlyZWN0aW9uUGF0dGVybi50ZXN0KG1lZGlhU2VjdGlvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIENvZGVjIE1hcCBmb3IgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIFRoZSBnaXZlbiBtPSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7TWFwPENvZGVjLCBBcnJheTxQVD4+fVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb2RlY01hcEZvck1lZGlhU2VjdGlvbihzZWN0aW9uKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGNyZWF0ZVB0VG9Db2RlY05hbWUoc2VjdGlvbikpLnJlZHVjZShmdW5jdGlvbiAoY29kZWNNYXAsIHBhaXIpIHtcbiAgICB2YXIgcHQgPSBwYWlyWzBdO1xuICAgIHZhciBjb2RlY05hbWUgPSBwYWlyWzFdO1xuICAgIHZhciBwdHMgPSBjb2RlY01hcC5nZXQoY29kZWNOYW1lKSB8fCBbXTtcbiAgICByZXR1cm4gY29kZWNNYXAuc2V0KGNvZGVjTmFtZSwgcHRzLmNvbmNhdChwdCkpO1xuICB9LCBuZXcgTWFwKCkpO1xufVxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVvcmRlcmVkIENvZGVjIFBheWxvYWQgVHlwZXMgYmFzZWQgb24gdGhlIHByZWZlcnJlZCBDb2RlYyBOYW1lcy5cbiAqIEBwYXJhbSB7TWFwPENvZGVjLCBBcnJheTxQVD4+fSBjb2RlY01hcCAtIENvZGVjIE1hcFxuICogQHBhcmFtIHtBcnJheTxDb2RlYz59IHByZWZlcnJlZENvZGVjcyAtIFByZWZlcnJlZCBDb2RlYyBOYW1lc1xuICogQHJldHVybnMge0FycmF5PFBUPn0gUmVvcmRlcmVkIFBheWxvYWQgVHlwZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UmVvcmRlcmVkUGF5bG9hZFR5cGVzKGNvZGVjTWFwLCBwcmVmZXJyZWRDb2RlY3MpIHtcbiAgcHJlZmVycmVkQ29kZWNzID0gcHJlZmVycmVkQ29kZWNzLm1hcChmdW5jdGlvbiAoY29kZWNOYW1lKSB7XG4gICAgcmV0dXJuIGNvZGVjTmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcblxuICB2YXIgcHJlZmVycmVkUGF5bG9hZFR5cGVzID0gdXRpbC5mbGF0TWFwKHByZWZlcnJlZENvZGVjcywgZnVuY3Rpb24gKGNvZGVjTmFtZSkge1xuICAgIHJldHVybiBjb2RlY01hcC5nZXQoY29kZWNOYW1lKSB8fCBbXTtcbiAgfSk7XG5cbiAgdmFyIHJlbWFpbmluZ0NvZGVjcyA9IHV0aWwuZGlmZmVyZW5jZShBcnJheS5mcm9tKGNvZGVjTWFwLmtleXMoKSksIHByZWZlcnJlZENvZGVjcyk7XG4gIHZhciByZW1haW5pbmdQYXlsb2FkVHlwZXMgPSB1dGlsLmZsYXRNYXAocmVtYWluaW5nQ29kZWNzLCBmdW5jdGlvbiAoY29kZWNOYW1lKSB7XG4gICAgcmV0dXJuIGNvZGVjTWFwLmdldChjb2RlY05hbWUpO1xuICB9KTtcblxuICByZXR1cm4gcHJlZmVycmVkUGF5bG9hZFR5cGVzLmNvbmNhdChyZW1haW5pbmdQYXlsb2FkVHlwZXMpO1xufVxuXG4vKipcbiAqIFNldCB0aGUgZ2l2ZW4gQ29kZWMgUGF5bG9hZCBUeXBlcyBpbiB0aGUgZmlyc3QgbGluZSBvZiB0aGUgZ2l2ZW4gbT0gc2VjdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXk8UFQ+fSBwYXlsb2FkVHlwZXMgLSBQYXlsb2FkIFR5cGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIEdpdmVuIG09IHNlY3Rpb25cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBtPSBzZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIHNldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHBheWxvYWRUeXBlcywgc2VjdGlvbikge1xuICB2YXIgbGluZXMgPSBzZWN0aW9uLnNwbGl0KCdcXHJcXG4nKTtcbiAgdmFyIG1MaW5lID0gbGluZXNbMF07XG4gIHZhciBvdGhlckxpbmVzID0gbGluZXMuc2xpY2UoMSk7XG4gIG1MaW5lID0gbUxpbmUucmVwbGFjZSgvKFswLTldK1xccz8pKyQvLCBwYXlsb2FkVHlwZXMuam9pbignICcpKTtcbiAgcmV0dXJuIFttTGluZV0uY29uY2F0KG90aGVyTGluZXMpLmpvaW4oJ1xcclxcbicpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIE1hcCBmcm9tIFBUcyB0byBjb2RlYyBuYW1lcyBmb3IgdGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVkaWFTZWN0aW9uIC0gVGhlIGdpdmVuIG09IHNlY3Rpb24uXG4gKiBAcmV0dXJucyB7TWFwPFBULCBDb2RlYz59IHB0VG9Db2RlY05hbWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUHRUb0NvZGVjTmFtZShtZWRpYVNlY3Rpb24pIHtcbiAgcmV0dXJuIGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbikucmVkdWNlKGZ1bmN0aW9uIChwdFRvQ29kZWNOYW1lLCBwdCkge1xuICAgIHZhciBydHBtYXBQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnYT1ydHBtYXA6JyArIHB0ICsgJyAoW14vXSspJyk7XG4gICAgdmFyIG1hdGNoZXMgPSBtZWRpYVNlY3Rpb24ubWF0Y2gocnRwbWFwUGF0dGVybik7XG4gICAgdmFyIGNvZGVjTmFtZSA9IG1hdGNoZXMgPyBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCkgOiBwdFRvRml4ZWRCaXRyYXRlQXVkaW9Db2RlY05hbWVbcHRdID8gcHRUb0ZpeGVkQml0cmF0ZUF1ZGlvQ29kZWNOYW1lW3B0XS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gICAgcmV0dXJuIHB0VG9Db2RlY05hbWUuc2V0KHB0LCBjb2RlY05hbWUpO1xuICB9LCBuZXcgTWFwKCkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgQ29kZWMgUGF5bG9hZCBUeXBlcyBwcmVzZW50IGluIHRoZSBmaXJzdCBsaW5lIG9mIHRoZSBnaXZlbiBtPSBzZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VjdGlvbiAtIFRoZSBtPSBzZWN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXk8UFQ+fSBQYXlsb2FkIFR5cGVzXG4gKi9cbmZ1bmN0aW9uIGdldFBheWxvYWRUeXBlc0luTWVkaWFTZWN0aW9uKHNlY3Rpb24pIHtcbiAgdmFyIG1MaW5lID0gc2VjdGlvbi5zcGxpdCgnXFxyXFxuJylbMF07XG5cbiAgLy8gSW4gXCJtPTxraW5kPiA8cG9ydD4gPHByb3RvPiA8cGF5bG9hZF90eXBlXzE+IDxwYXlsb2FkX3R5cGVfMj4gLi4uIDxwYXlsb2FkX3R5cGVfbj5cIixcbiAgLy8gdGhlIHJlZ2V4IG1hdGNoZXMgPHBvcnQ+IGFuZCB0aGUgUGF5bG9hZFR5cGVzLlxuICB2YXIgbWF0Y2hlcyA9IG1MaW5lLm1hdGNoKC8oWzAtOV0rKS9nKTtcblxuICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgaW4gY2FzZSB0aGVyZSBhcmUgbm8gUGF5bG9hZFR5cGVzIGluXG4gIC8vIHRoZSBtPSBsaW5lLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIFNpbmNlIG9ubHkgdGhlIFBheWxvYWRUeXBlcyBhcmUgbmVlZGVkLCB3ZSBkaXNjYXJkIHRoZSA8cG9ydD4uXG4gIHJldHVybiBtYXRjaGVzLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2gsIDEwKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRQcmVmZXJyZWRDb2RlY0luZm86IGdldFByZWZlcnJlZENvZGVjSW5mbyxcbiAgc2V0Q29kZWNQcmVmZXJlbmNlczogc2V0Q29kZWNQcmVmZXJlbmNlcyxcbiAgc2V0SWNlQWdncmVzc2l2ZU5vbWluYXRpb246IHNldEljZUFnZ3Jlc3NpdmVOb21pbmF0aW9uLFxuICBzZXRNYXhBdmVyYWdlQml0cmF0ZTogc2V0TWF4QXZlcmFnZUJpdHJhdGVcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/sdp.js\n")},"./node_modules/twilio-client/es5/twilio/rtc/stats.js":function(module,__unused_webpack_exports,__webpack_require__){eval("var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n/* eslint-disable no-fallthrough */\nvar _a = __webpack_require__(/*! ../errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\"), NotSupportedError = _a.NotSupportedError, InvalidArgumentError = _a.InvalidArgumentError;\nvar MockRTCStatsReport = __webpack_require__(/*! ./mockrtcstatsreport */ \"./node_modules/twilio-client/es5/twilio/rtc/mockrtcstatsreport.js\");\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n    if (!peerConnection) {\n        return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n    }\n    if (typeof peerConnection.getStats !== 'function') {\n        return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n    }\n    var promise;\n    try {\n        promise = peerConnection.getStats();\n    }\n    catch (e) {\n        promise = new Promise(function (resolve) { return peerConnection.getStats(resolve); }).then(MockRTCStatsReport.fromRTCStatsResponse);\n    }\n    return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n    options = Object.assign({\n        createRTCSample: createRTCSample\n    }, options);\n    return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n    return getRTCStatsReport(peerConnection).then(function (report) {\n        // Find the relevant information needed to determine selected candidates later\n        var _a = Array.from(report.values()).reduce(function (rval, stat) {\n            ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n                if (!rval[prop]) {\n                    rval[prop] = [];\n                }\n            });\n            switch (stat.type) {\n                case 'candidate-pair':\n                    rval.candidatePairs.push(stat);\n                    break;\n                case 'local-candidate':\n                    rval.localCandidates.push(stat);\n                    break;\n                case 'remote-candidate':\n                    rval.remoteCandidates.push(stat);\n                    break;\n                case 'transport':\n                    // This transport is the one being used if selectedCandidatePairId is populated\n                    if (stat.selectedCandidatePairId) {\n                        rval.transport = stat;\n                    }\n                    break;\n            }\n            return rval;\n        }, {}), candidatePairs = _a.candidatePairs, localCandidates = _a.localCandidates, remoteCandidates = _a.remoteCandidates, transport = _a.transport;\n        // This is a report containing information about the selected candidates, such as IDs\n        // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n        var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n            // Firefox\n            return pair.selected ||\n                // Spec-compliant way\n                (transport && pair.id === transport.selectedCandidatePairId);\n        });\n        var selectedIceCandidatePairStats;\n        if (selectedCandidatePairReport) {\n            selectedIceCandidatePairStats = {\n                localCandidate: localCandidates.find(function (candidate) { return candidate.id === selectedCandidatePairReport.localCandidateId; }),\n                remoteCandidate: remoteCandidates.find(function (candidate) { return candidate.id === selectedCandidatePairReport.remoteCandidateId; }),\n            };\n        }\n        // Build the return object\n        return {\n            iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n            selectedIceCandidatePairStats: selectedIceCandidatePairStats,\n        };\n    });\n}\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() { }\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n    var activeTransportId = null;\n    var sample = new RTCSample();\n    var fallbackTimestamp;\n    Array.from(statsReport.values()).forEach(function (stats) {\n        // Skip isRemote tracks which will be phased out completely and break in FF66.\n        if (stats.isRemote) {\n            return;\n        }\n        // Firefox hack -- Older firefox doesn't have dashes in type names\n        var type = stats.type.replace('-', '');\n        fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n        // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n        // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n        // the appropriate place to look is cleared up.\n        if (stats.remoteId) {\n            var remote = statsReport.get(stats.remoteId);\n            if (remote && remote.roundTripTime) {\n                sample.rtt = remote.roundTripTime * 1000;\n            }\n        }\n        switch (type) {\n            case 'inboundrtp':\n                sample.timestamp = sample.timestamp || stats.timestamp;\n                sample.jitter = stats.jitter * 1000;\n                sample.packetsLost = stats.packetsLost;\n                sample.packetsReceived = stats.packetsReceived;\n                sample.bytesReceived = stats.bytesReceived;\n                break;\n            case 'outboundrtp':\n                sample.timestamp = stats.timestamp;\n                sample.packetsSent = stats.packetsSent;\n                sample.bytesSent = stats.bytesSent;\n                if (stats.codecId) {\n                    var codec = statsReport.get(stats.codecId);\n                    sample.codecName = codec\n                        ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2]\n                        : stats.codecId;\n                }\n                break;\n            case 'transport':\n                activeTransportId = stats.id;\n                break;\n        }\n    });\n    if (!sample.timestamp) {\n        sample.timestamp = fallbackTimestamp;\n    }\n    var activeTransport = statsReport.get(activeTransportId);\n    if (!activeTransport) {\n        return sample;\n    }\n    var selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n    if (!selectedCandidatePair) {\n        return sample;\n    }\n    var localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n    var remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n    if (!sample.rtt) {\n        sample.rtt = selectedCandidatePair &&\n            (selectedCandidatePair.currentRoundTripTime * 1000);\n    }\n    Object.assign(sample, {\n        localAddress: localCandidate && localCandidate.ip,\n        remoteAddress: remoteCandidate && remoteCandidate.ip,\n    });\n    return sample;\n}\nmodule.exports = {\n    getRTCStats: getRTCStats,\n    getRTCIceCandidateStatsReport: getRTCIceCandidateStatsReport,\n};\n//# sourceMappingURL=stats.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9zdGF0cy5qcz83MjM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQsd0NBQXdDLFFBQVE7QUFDaEQsd0RBQXdELFFBQVE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1CQUFPLENBQUMsMEVBQVc7QUFDNUIseUJBQXlCLG1CQUFPLENBQUMsK0ZBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCxXQUFXLGVBQWU7QUFDMUIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUNBQXlDLEVBQUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxhQUFhO0FBQ3hCLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRyxXQUFXLGVBQWU7QUFDMUIsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxzRUFBc0UsRUFBRTtBQUNuSiw2RUFBNkUsdUVBQXVFLEVBQUU7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3J0Yy9zdGF0cy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbnZhciBfYSA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLCBOb3RTdXBwb3J0ZWRFcnJvciA9IF9hLk5vdFN1cHBvcnRlZEVycm9yLCBJbnZhbGlkQXJndW1lbnRFcnJvciA9IF9hLkludmFsaWRBcmd1bWVudEVycm9yO1xudmFyIE1vY2tSVENTdGF0c1JlcG9ydCA9IHJlcXVpcmUoJy4vbW9ja3J0Y3N0YXRzcmVwb3J0Jyk7XG52YXIgRVJST1JfUEVFUl9DT05ORUNUSU9OX05VTEwgPSAnUGVlckNvbm5lY3Rpb24gaXMgbnVsbCc7XG52YXIgRVJST1JfV0VCX1JUQ19VTlNVUFBPUlRFRCA9ICdXZWJSVEMgc3RhdGlzdGljcyBhcmUgdW5zdXBwb3J0ZWQnO1xuLyoqXG4gKiBHZW5lcmF0ZSBXZWJSVEMgc3RhdGlzdGljcyByZXBvcnQgZm9yIHRoZSBnaXZlbiB7QGxpbmsgUGVlckNvbm5lY3Rpb259XG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvbiAtIFRhcmdldCBjb25uZWN0aW9uLlxuICogQHJldHVybiB7UHJvbWlzZTxSVENTdGF0c1JlcG9ydD59IFdlYlJUQyBSVENTdGF0c1JlcG9ydCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UlRDU3RhdHNSZXBvcnQocGVlckNvbm5lY3Rpb24pIHtcbiAgICBpZiAoIXBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoRVJST1JfUEVFUl9DT05ORUNUSU9OX05VTEwpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwZWVyQ29ubmVjdGlvbi5nZXRTdGF0cyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5vdFN1cHBvcnRlZEVycm9yKEVSUk9SX1dFQl9SVENfVU5TVVBQT1JURUQpKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJvbWlzZSA9IHBlZXJDb25uZWN0aW9uLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcGVlckNvbm5lY3Rpb24uZ2V0U3RhdHMocmVzb2x2ZSk7IH0pLnRoZW4oTW9ja1JUQ1N0YXRzUmVwb3J0LmZyb21SVENTdGF0c1Jlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YXRzT3B0aW9uc1xuICogVXNlZCBmb3IgdGVzdGluZyB0byBpbmplY3QgYW5kIGV4dHJhY3QgbWV0aG9kcy5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtjcmVhdGVSVENTYW1wbGVdIC0gTWV0aG9kIGZvciBwYXJzaW5nIGFuIFJUQ1N0YXRzUmVwb3J0XG4gKi9cbi8qKlxuICogQ29sbGVjdHMgYW55IFdlYlJUQyBzdGF0aXN0aWNzIGZvciB0aGUgZ2l2ZW4ge0BsaW5rIFBlZXJDb25uZWN0aW9ufVxuICogQHBhcmFtIHtQZWVyQ29ubmVjdGlvbn0gcGVlckNvbm5lY3Rpb24gLSBUYXJnZXQgY29ubmVjdGlvbi5cbiAqIEBwYXJhbSB7U3RhdHNPcHRpb25zfSBvcHRpb25zIC0gTGlzdCBvZiBjdXN0b20gb3B0aW9ucy5cbiAqIEByZXR1cm4ge1Byb21pc2U8UlRDU2FtcGxlPn0gVW5pdmVyc2FsbHktZm9ybWF0dGVkIHZlcnNpb24gb2YgUlRDIHN0YXRzLlxuICovXG5mdW5jdGlvbiBnZXRSVENTdGF0cyhwZWVyQ29ubmVjdGlvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgY3JlYXRlUlRDU2FtcGxlOiBjcmVhdGVSVENTYW1wbGVcbiAgICB9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZ2V0UlRDU3RhdHNSZXBvcnQocGVlckNvbm5lY3Rpb24pLnRoZW4ob3B0aW9ucy5jcmVhdGVSVENTYW1wbGUpO1xufVxuLyoqXG4gKiBHZW5lcmF0ZSBXZWJSVEMgc3RhdHMgcmVwb3J0IGNvbnRhaW5pbmcgcmVsZXZhbnQgaW5mb3JtYXRpb24gYWJvdXQgSUNFIGNhbmRpZGF0ZXMgZm9yIHRoZSBnaXZlbiB7QGxpbmsgUGVlckNvbm5lY3Rpb259XG4gKiBAcGFyYW0ge1BlZXJDb25uZWN0aW9ufSBwZWVyQ29ubmVjdGlvbiAtIFRhcmdldCBjb25uZWN0aW9uLlxuICogQHJldHVybiB7UHJvbWlzZTxSVENJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydD59IFJUQ0ljZUNhbmRpZGF0ZVN0YXRzUmVwb3J0IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRSVENJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydChwZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybiBnZXRSVENTdGF0c1JlcG9ydChwZWVyQ29ubmVjdGlvbikudGhlbihmdW5jdGlvbiAocmVwb3J0KSB7XG4gICAgICAgIC8vIEZpbmQgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIG5lZWRlZCB0byBkZXRlcm1pbmUgc2VsZWN0ZWQgY2FuZGlkYXRlcyBsYXRlclxuICAgICAgICB2YXIgX2EgPSBBcnJheS5mcm9tKHJlcG9ydC52YWx1ZXMoKSkucmVkdWNlKGZ1bmN0aW9uIChydmFsLCBzdGF0KSB7XG4gICAgICAgICAgICBbJ2NhbmRpZGF0ZVBhaXJzJywgJ2xvY2FsQ2FuZGlkYXRlcycsICdyZW1vdGVDYW5kaWRhdGVzJ10uZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIGlmICghcnZhbFtwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICBydmFsW3Byb3BdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NhbmRpZGF0ZS1wYWlyJzpcbiAgICAgICAgICAgICAgICAgICAgcnZhbC5jYW5kaWRhdGVQYWlycy5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsb2NhbC1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgICAgICAgICBydmFsLmxvY2FsQ2FuZGlkYXRlcy5wdXNoKHN0YXQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZW1vdGUtY2FuZGlkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcnZhbC5yZW1vdGVDYW5kaWRhdGVzLnB1c2goc3RhdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RyYW5zcG9ydCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNwb3J0IGlzIHRoZSBvbmUgYmVpbmcgdXNlZCBpZiBzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCBpcyBwb3B1bGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXQuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ2YWwudHJhbnNwb3J0ID0gc3RhdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydmFsO1xuICAgICAgICB9LCB7fSksIGNhbmRpZGF0ZVBhaXJzID0gX2EuY2FuZGlkYXRlUGFpcnMsIGxvY2FsQ2FuZGlkYXRlcyA9IF9hLmxvY2FsQ2FuZGlkYXRlcywgcmVtb3RlQ2FuZGlkYXRlcyA9IF9hLnJlbW90ZUNhbmRpZGF0ZXMsIHRyYW5zcG9ydCA9IF9hLnRyYW5zcG9ydDtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlcG9ydCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzZWxlY3RlZCBjYW5kaWRhdGVzLCBzdWNoIGFzIElEc1xuICAgICAgICAvLyBUaGlzIGlzIGNvbWluZyBmcm9tIFdlYlJUQyBzdGF0cyBkaXJlY3RseSBhbmQgZG9lc24ndCBjb250YWluIHRoZSBhY3R1YWwgSUNFIENhbmRpZGF0ZXMgaW5mb1xuICAgICAgICB2YXIgc2VsZWN0ZWRDYW5kaWRhdGVQYWlyUmVwb3J0ID0gY2FuZGlkYXRlUGFpcnMuZmluZChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgLy8gRmlyZWZveFxuICAgICAgICAgICAgcmV0dXJuIHBhaXIuc2VsZWN0ZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTcGVjLWNvbXBsaWFudCB3YXlcbiAgICAgICAgICAgICAgICAodHJhbnNwb3J0ICYmIHBhaXIuaWQgPT09IHRyYW5zcG9ydC5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2VsZWN0ZWRJY2VDYW5kaWRhdGVQYWlyU3RhdHM7XG4gICAgICAgIGlmIChzZWxlY3RlZENhbmRpZGF0ZVBhaXJSZXBvcnQpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzID0ge1xuICAgICAgICAgICAgICAgIGxvY2FsQ2FuZGlkYXRlOiBsb2NhbENhbmRpZGF0ZXMuZmluZChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7IHJldHVybiBjYW5kaWRhdGUuaWQgPT09IHNlbGVjdGVkQ2FuZGlkYXRlUGFpclJlcG9ydC5sb2NhbENhbmRpZGF0ZUlkOyB9KSxcbiAgICAgICAgICAgICAgICByZW1vdGVDYW5kaWRhdGU6IHJlbW90ZUNhbmRpZGF0ZXMuZmluZChmdW5jdGlvbiAoY2FuZGlkYXRlKSB7IHJldHVybiBjYW5kaWRhdGUuaWQgPT09IHNlbGVjdGVkQ2FuZGlkYXRlUGFpclJlcG9ydC5yZW1vdGVDYW5kaWRhdGVJZDsgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSByZXR1cm4gb2JqZWN0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVTdGF0czogX19zcHJlYWRBcnJheXMobG9jYWxDYW5kaWRhdGVzLCByZW1vdGVDYW5kaWRhdGVzKSxcbiAgICAgICAgICAgIHNlbGVjdGVkSWNlQ2FuZGlkYXRlUGFpclN0YXRzOiBzZWxlY3RlZEljZUNhbmRpZGF0ZVBhaXJTdGF0cyxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUlRDU2FtcGxlIC0gQSBzYW1wbGUgY29udGFpbmluZyByZWxldmFudCBXZWJSVEMgc3RhdHMgaW5mb3JtYXRpb24uXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3RpbWVzdGFtcF1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29kZWNOYW1lXSAtIE1pbWVUeXBlIG5hbWUgb2YgdGhlIGNvZGVjIGJlaW5nIHVzZWQgYnkgdGhlIG91dGJvdW5kIGF1ZGlvIHN0cmVhbVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtydHRdIC0gUm91bmQgdHJpcCB0aW1lXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2ppdHRlcl1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFja2V0c1NlbnRdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW3BhY2tldHNMb3N0XVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWNrZXRzUmVjZWl2ZWRdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2J5dGVzUmVjZWl2ZWRdXG4gKiBAcHJvcGVydHkge051bWJlcn0gW2J5dGVzU2VudF1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbG9jYWxBZGRyZXNzXVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyZW1vdGVBZGRyZXNzXVxuICovXG5mdW5jdGlvbiBSVENTYW1wbGUoKSB7IH1cbi8qKlxuICogQ3JlYXRlIGFuIFJUQ1NhbXBsZSBvYmplY3QgZnJvbSBhbiBSVENTdGF0c1JlcG9ydFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UlRDU3RhdHNSZXBvcnR9IHN0YXRzUmVwb3J0XG4gKiBAcmV0dXJucyB7UlRDU2FtcGxlfVxuICovXG5mdW5jdGlvbiBjcmVhdGVSVENTYW1wbGUoc3RhdHNSZXBvcnQpIHtcbiAgICB2YXIgYWN0aXZlVHJhbnNwb3J0SWQgPSBudWxsO1xuICAgIHZhciBzYW1wbGUgPSBuZXcgUlRDU2FtcGxlKCk7XG4gICAgdmFyIGZhbGxiYWNrVGltZXN0YW1wO1xuICAgIEFycmF5LmZyb20oc3RhdHNSZXBvcnQudmFsdWVzKCkpLmZvckVhY2goZnVuY3Rpb24gKHN0YXRzKSB7XG4gICAgICAgIC8vIFNraXAgaXNSZW1vdGUgdHJhY2tzIHdoaWNoIHdpbGwgYmUgcGhhc2VkIG91dCBjb21wbGV0ZWx5IGFuZCBicmVhayBpbiBGRjY2LlxuICAgICAgICBpZiAoc3RhdHMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaXJlZm94IGhhY2sgLS0gT2xkZXIgZmlyZWZveCBkb2Vzbid0IGhhdmUgZGFzaGVzIGluIHR5cGUgbmFtZXNcbiAgICAgICAgdmFyIHR5cGUgPSBzdGF0cy50eXBlLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIGZhbGxiYWNrVGltZXN0YW1wID0gZmFsbGJhY2tUaW1lc3RhbXAgfHwgc3RhdHMudGltZXN0YW1wO1xuICAgICAgICAvLyAocnJvd2xhbmQpIEFzIEkgdW5kZXJzdGFuZCBpdCwgdGhpcyBpcyBzdXBwb3NlZCB0byBjb21lIGluIG9uIHJlbW90ZS1pbmJvdW5kLXJ0cCBidXQgaXQnc1xuICAgICAgICAvLyBjdXJyZW50bHkgY29taW5nIGluIG9uIHJlbW90ZS1vdXRib3VuZC1ydHAsIHNvIEknbSBsZWF2aW5nIHRoaXMgb3V0c2lkZSB0aGUgc3dpdGNoIHVudGlsXG4gICAgICAgIC8vIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSB0byBsb29rIGlzIGNsZWFyZWQgdXAuXG4gICAgICAgIGlmIChzdGF0cy5yZW1vdGVJZCkge1xuICAgICAgICAgICAgdmFyIHJlbW90ZSA9IHN0YXRzUmVwb3J0LmdldChzdGF0cy5yZW1vdGVJZCk7XG4gICAgICAgICAgICBpZiAocmVtb3RlICYmIHJlbW90ZS5yb3VuZFRyaXBUaW1lKSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlLnJ0dCA9IHJlbW90ZS5yb3VuZFRyaXBUaW1lICogMTAwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luYm91bmRydHAnOlxuICAgICAgICAgICAgICAgIHNhbXBsZS50aW1lc3RhbXAgPSBzYW1wbGUudGltZXN0YW1wIHx8IHN0YXRzLnRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICBzYW1wbGUuaml0dGVyID0gc3RhdHMuaml0dGVyICogMTAwMDtcbiAgICAgICAgICAgICAgICBzYW1wbGUucGFja2V0c0xvc3QgPSBzdGF0cy5wYWNrZXRzTG9zdDtcbiAgICAgICAgICAgICAgICBzYW1wbGUucGFja2V0c1JlY2VpdmVkID0gc3RhdHMucGFja2V0c1JlY2VpdmVkO1xuICAgICAgICAgICAgICAgIHNhbXBsZS5ieXRlc1JlY2VpdmVkID0gc3RhdHMuYnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ291dGJvdW5kcnRwJzpcbiAgICAgICAgICAgICAgICBzYW1wbGUudGltZXN0YW1wID0gc3RhdHMudGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIHNhbXBsZS5wYWNrZXRzU2VudCA9IHN0YXRzLnBhY2tldHNTZW50O1xuICAgICAgICAgICAgICAgIHNhbXBsZS5ieXRlc1NlbnQgPSBzdGF0cy5ieXRlc1NlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRzLmNvZGVjSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGVjID0gc3RhdHNSZXBvcnQuZ2V0KHN0YXRzLmNvZGVjSWQpO1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUuY29kZWNOYW1lID0gY29kZWNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY29kZWMubWltZVR5cGUgJiYgY29kZWMubWltZVR5cGUubWF0Y2goLyguKlxcLyk/KC4qKS8pWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHN0YXRzLmNvZGVjSWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNwb3J0JzpcbiAgICAgICAgICAgICAgICBhY3RpdmVUcmFuc3BvcnRJZCA9IHN0YXRzLmlkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzYW1wbGUudGltZXN0YW1wKSB7XG4gICAgICAgIHNhbXBsZS50aW1lc3RhbXAgPSBmYWxsYmFja1RpbWVzdGFtcDtcbiAgICB9XG4gICAgdmFyIGFjdGl2ZVRyYW5zcG9ydCA9IHN0YXRzUmVwb3J0LmdldChhY3RpdmVUcmFuc3BvcnRJZCk7XG4gICAgaWYgKCFhY3RpdmVUcmFuc3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIHNhbXBsZTtcbiAgICB9XG4gICAgdmFyIHNlbGVjdGVkQ2FuZGlkYXRlUGFpciA9IHN0YXRzUmVwb3J0LmdldChhY3RpdmVUcmFuc3BvcnQuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQpO1xuICAgIGlmICghc2VsZWN0ZWRDYW5kaWRhdGVQYWlyKSB7XG4gICAgICAgIHJldHVybiBzYW1wbGU7XG4gICAgfVxuICAgIHZhciBsb2NhbENhbmRpZGF0ZSA9IHN0YXRzUmVwb3J0LmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXIubG9jYWxDYW5kaWRhdGVJZCk7XG4gICAgdmFyIHJlbW90ZUNhbmRpZGF0ZSA9IHN0YXRzUmVwb3J0LmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXIucmVtb3RlQ2FuZGlkYXRlSWQpO1xuICAgIGlmICghc2FtcGxlLnJ0dCkge1xuICAgICAgICBzYW1wbGUucnR0ID0gc2VsZWN0ZWRDYW5kaWRhdGVQYWlyICYmXG4gICAgICAgICAgICAoc2VsZWN0ZWRDYW5kaWRhdGVQYWlyLmN1cnJlbnRSb3VuZFRyaXBUaW1lICogMTAwMCk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oc2FtcGxlLCB7XG4gICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxDYW5kaWRhdGUgJiYgbG9jYWxDYW5kaWRhdGUuaXAsXG4gICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUNhbmRpZGF0ZSAmJiByZW1vdGVDYW5kaWRhdGUuaXAsXG4gICAgfSk7XG4gICAgcmV0dXJuIHNhbXBsZTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldFJUQ1N0YXRzOiBnZXRSVENTdGF0cyxcbiAgICBnZXRSVENJY2VDYW5kaWRhdGVTdGF0c1JlcG9ydDogZ2V0UlRDSWNlQ2FuZGlkYXRlU3RhdHNSZXBvcnQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/rtc/stats.js\n")},"./node_modules/twilio-client/es5/twilio/shims/eventtarget.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nfunction EventTarget() {\n    Object.defineProperties(this, {\n        _eventEmitter: {\n            value: new EventEmitter()\n        },\n        _handlers: {\n            value: {}\n        },\n    });\n}\nEventTarget.prototype.dispatchEvent = function dispatchEvent(event) {\n    return this._eventEmitter.emit(event.type, event);\n};\nEventTarget.prototype.addEventListener = function addEventListener() {\n    var _a;\n    return (_a = this._eventEmitter).addListener.apply(_a, arguments);\n};\nEventTarget.prototype.removeEventListener = function removeEventListener() {\n    var _a;\n    return (_a = this._eventEmitter).removeListener.apply(_a, arguments);\n};\nEventTarget.prototype._defineEventHandler = function _defineEventHandler(eventName) {\n    var self = this;\n    Object.defineProperty(this, \"on\" + eventName, {\n        get: function () {\n            return self._handlers[eventName];\n        },\n        set: function (newHandler) {\n            var oldHandler = self._handlers[eventName];\n            if (oldHandler\n                && (typeof newHandler === 'function'\n                    || typeof newHandler === 'undefined'\n                    || newHandler === null)) {\n                self._handlers[eventName] = null;\n                self.removeEventListener(eventName, oldHandler);\n            }\n            if (typeof newHandler === 'function') {\n                self._handlers[eventName] = newHandler;\n                self.addEventListener(eventName, newHandler);\n            }\n        }\n    });\n};\nmodule.exports = EventTarget;\n//# sourceMappingURL=eventtarget.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3NoaW1zL2V2ZW50dGFyZ2V0LmpzP2U2ZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsbUJBQW1CLGlGQUE4QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9zaGltcy9ldmVudHRhcmdldC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIF9ldmVudEVtaXR0ZXI6IHtcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRXZlbnRFbWl0dGVyKClcbiAgICAgICAgfSxcbiAgICAgICAgX2hhbmRsZXJzOiB7XG4gICAgICAgICAgICB2YWx1ZToge31cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgIHJldHVybiB0aGlzLl9ldmVudEVtaXR0ZXIuZW1pdChldmVudC50eXBlLCBldmVudCk7XG59O1xuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fZXZlbnRFbWl0dGVyKS5hZGRMaXN0ZW5lci5hcHBseShfYSwgYXJndW1lbnRzKTtcbn07XG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLl9ldmVudEVtaXR0ZXIpLnJlbW92ZUxpc3RlbmVyLmFwcGx5KF9hLCBhcmd1bWVudHMpO1xufTtcbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5fZGVmaW5lRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24gX2RlZmluZUV2ZW50SGFuZGxlcihldmVudE5hbWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib25cIiArIGV2ZW50TmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9oYW5kbGVyc1tldmVudE5hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdIYW5kbGVyKSB7XG4gICAgICAgICAgICB2YXIgb2xkSGFuZGxlciA9IHNlbGYuX2hhbmRsZXJzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAob2xkSGFuZGxlclxuICAgICAgICAgICAgICAgICYmICh0eXBlb2YgbmV3SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgbmV3SGFuZGxlciA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICAgICAgfHwgbmV3SGFuZGxlciA9PT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9oYW5kbGVyc1tldmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBvbGRIYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3SGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNlbGYuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBuZXdIYW5kbGVyO1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIG5ld0hhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50dGFyZ2V0LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/shims/eventtarget.js\n")},"./node_modules/twilio-client/es5/twilio/shims/mediadeviceinfo.js":module=>{"use strict";eval('\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar MediaDeviceInfoShim = function MediaDeviceInfoShim(options) {\n  _classCallCheck(this, MediaDeviceInfoShim);\n\n  Object.defineProperties(this, {\n    deviceId: {\n      get: function get() {\n        return options.deviceId;\n      }\n    },\n    groupId: {\n      get: function get() {\n        return options.groupId;\n      }\n    },\n    kind: {\n      get: function get() {\n        return options.kind;\n      }\n    },\n    label: {\n      get: function get() {\n        return options.label;\n      }\n    }\n  });\n};\n\nmodule.exports = MediaDeviceInfoShim;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3NoaW1zL21lZGlhZGV2aWNlaW5mby5qcz9kODI3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby9zaGltcy9tZWRpYWRldmljZWluZm8uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE1lZGlhRGV2aWNlSW5mb1NoaW0gPSBmdW5jdGlvbiBNZWRpYURldmljZUluZm9TaGltKG9wdGlvbnMpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lZGlhRGV2aWNlSW5mb1NoaW0pO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBkZXZpY2VJZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRldmljZUlkO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ3JvdXBJZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmdyb3VwSWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBraW5kOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMua2luZDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMubGFiZWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWVkaWFEZXZpY2VJbmZvU2hpbTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/shims/mediadeviceinfo.js\n')},"./node_modules/twilio-client/es5/twilio/shims/mediadevices.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("var EventTarget = __webpack_require__(/*! ./eventtarget */ \"./node_modules/twilio-client/es5/twilio/shims/eventtarget.js\");\nvar inherits = __webpack_require__(/*! util */ \"./node_modules/util/util.js\").inherits;\nvar POLL_INTERVAL_MS = 500;\nvar nativeMediaDevices = typeof navigator !== 'undefined' && navigator.mediaDevices;\n/**\n * Make a custom MediaDevices object, and proxy through existing functionality. If\n *   devicechange is present, we simply reemit the event. If not, we will do the\n *   detection ourselves and fire the event when necessary. The same logic exists\n *   for deviceinfochange for consistency, however deviceinfochange is our own event\n *   so it is unlikely that it will ever be native. The w3c spec for devicechange\n *   is unclear as to whether MediaDeviceInfo changes (such as label) will\n *   trigger the devicechange event. We have an open question on this here:\n *   https://bugs.chromium.org/p/chromium/issues/detail?id=585096\n */\nfunction MediaDevicesShim() {\n    EventTarget.call(this);\n    this._defineEventHandler('devicechange');\n    this._defineEventHandler('deviceinfochange');\n    var knownDevices = [];\n    Object.defineProperties(this, {\n        _deviceChangeIsNative: {\n            value: reemitNativeEvent(this, 'devicechange')\n        },\n        _deviceInfoChangeIsNative: {\n            value: reemitNativeEvent(this, 'deviceinfochange')\n        },\n        _knownDevices: {\n            value: knownDevices\n        },\n        _pollInterval: {\n            value: null,\n            writable: true\n        }\n    });\n    if (typeof nativeMediaDevices.enumerateDevices === 'function') {\n        nativeMediaDevices.enumerateDevices().then(function (devices) {\n            devices.sort(sortDevicesById).forEach([].push, knownDevices);\n        });\n    }\n    this._eventEmitter.on('newListener', function maybeStartPolling(eventName) {\n        if (eventName !== 'devicechange' && eventName !== 'deviceinfochange') {\n            return;\n        }\n        this._pollInterval = this._pollInterval\n            || setInterval(sampleDevices.bind(null, this), POLL_INTERVAL_MS);\n    }.bind(this));\n    this._eventEmitter.on('removeListener', function maybeStopPolling() {\n        if (this._pollInterval && !hasChangeListeners(this)) {\n            clearInterval(this._pollInterval);\n            this._pollInterval = null;\n        }\n    }.bind(this));\n}\ninherits(MediaDevicesShim, EventTarget);\nif (nativeMediaDevices && typeof nativeMediaDevices.enumerateDevices === 'function') {\n    MediaDevicesShim.prototype.enumerateDevices = function enumerateDevices() {\n        return nativeMediaDevices.enumerateDevices.apply(nativeMediaDevices, arguments);\n    };\n}\nMediaDevicesShim.prototype.getUserMedia = function getUserMedia() {\n    return nativeMediaDevices.getUserMedia.apply(nativeMediaDevices, arguments);\n};\nfunction deviceInfosHaveChanged(newDevices, oldDevices) {\n    var oldLabels = oldDevices.reduce(function (map, device) { return map.set(device.deviceId, device.label || null); }, new Map());\n    return newDevices.some(function (newDevice) {\n        var oldLabel = oldLabels.get(newDevice.deviceId);\n        return typeof oldLabel !== 'undefined' && oldLabel !== newDevice.label;\n    });\n}\nfunction devicesHaveChanged(newDevices, oldDevices) {\n    return newDevices.length !== oldDevices.length\n        || propertyHasChanged('deviceId', newDevices, oldDevices);\n}\nfunction hasChangeListeners(mediaDevices) {\n    return ['devicechange', 'deviceinfochange'].reduce(function (count, event) { return count + mediaDevices._eventEmitter.listenerCount(event); }, 0) > 0;\n}\n/**\n * Sample the current set of devices and emit devicechange event if a device has been\n *   added or removed, and deviceinfochange if a device's label has changed.\n * @param {MediaDevicesShim} mediaDevices\n * @private\n */\nfunction sampleDevices(mediaDevices) {\n    nativeMediaDevices.enumerateDevices().then(function (newDevices) {\n        var knownDevices = mediaDevices._knownDevices;\n        var oldDevices = knownDevices.slice();\n        // Replace known devices in-place\n        [].splice.apply(knownDevices, [0, knownDevices.length]\n            .concat(newDevices.sort(sortDevicesById)));\n        if (!mediaDevices._deviceChangeIsNative\n            && devicesHaveChanged(knownDevices, oldDevices)) {\n            mediaDevices.dispatchEvent(new Event('devicechange'));\n        }\n        if (!mediaDevices._deviceInfoChangeIsNative\n            && deviceInfosHaveChanged(knownDevices, oldDevices)) {\n            mediaDevices.dispatchEvent(new Event('deviceinfochange'));\n        }\n    });\n}\n/**\n * Accepts two sorted arrays and the name of a property to compare on objects from each.\n *   Arrays should also be of the same length.\n * @param {string} propertyName - Name of the property to compare on each object\n * @param {Array<Object>} as - The left-side array of objects to compare.\n * @param {Array<Object>} bs - The right-side array of objects to compare.\n * @private\n * @returns {boolean} True if the property of any object in array A is different than\n *   the same property of its corresponding object in array B.\n */\nfunction propertyHasChanged(propertyName, as, bs) {\n    return as.some(function (a, i) { return a[propertyName] !== bs[i][propertyName]; });\n}\n/**\n * Re-emit the native event, if the native mediaDevices has the corresponding property.\n * @param {MediaDevicesShim} mediaDevices\n * @param {string} eventName - Name of the event\n * @private\n * @returns {boolean} Whether the native mediaDevice had the corresponding property\n */\nfunction reemitNativeEvent(mediaDevices, eventName) {\n    var methodName = \"on\" + eventName;\n    function dispatchEvent(event) {\n        mediaDevices.dispatchEvent(event);\n    }\n    if (methodName in nativeMediaDevices) {\n        // Use addEventListener if it's available so we don't stomp on any other listeners\n        // for this event. Currently, navigator.mediaDevices.addEventListener does not exist in Safari.\n        if ('addEventListener' in nativeMediaDevices) {\n            nativeMediaDevices.addEventListener(eventName, dispatchEvent);\n        }\n        else {\n            nativeMediaDevices[methodName] = dispatchEvent;\n        }\n        return true;\n    }\n    return false;\n}\nfunction sortDevicesById(a, b) {\n    return a.deviceId < b.deviceId;\n}\nmodule.exports = (function shimMediaDevices() {\n    return nativeMediaDevices ? new MediaDevicesShim() : null;\n})();\n//# sourceMappingURL=mediadevices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3NoaW1zL21lZGlhZGV2aWNlcy5qcz8wNjhlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFlO0FBQ3pDLGVBQWUsdUVBQXdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsdURBQXVELEVBQUU7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixnRUFBZ0UsRUFBRTtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsY0FBYztBQUN6QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0RBQWdELEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vc2hpbXMvbWVkaWFkZXZpY2VzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xudmFyIFBPTExfSU5URVJWQUxfTVMgPSA1MDA7XG52YXIgbmF0aXZlTWVkaWFEZXZpY2VzID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcztcbi8qKlxuICogTWFrZSBhIGN1c3RvbSBNZWRpYURldmljZXMgb2JqZWN0LCBhbmQgcHJveHkgdGhyb3VnaCBleGlzdGluZyBmdW5jdGlvbmFsaXR5LiBJZlxuICogICBkZXZpY2VjaGFuZ2UgaXMgcHJlc2VudCwgd2Ugc2ltcGx5IHJlZW1pdCB0aGUgZXZlbnQuIElmIG5vdCwgd2Ugd2lsbCBkbyB0aGVcbiAqICAgZGV0ZWN0aW9uIG91cnNlbHZlcyBhbmQgZmlyZSB0aGUgZXZlbnQgd2hlbiBuZWNlc3NhcnkuIFRoZSBzYW1lIGxvZ2ljIGV4aXN0c1xuICogICBmb3IgZGV2aWNlaW5mb2NoYW5nZSBmb3IgY29uc2lzdGVuY3ksIGhvd2V2ZXIgZGV2aWNlaW5mb2NoYW5nZSBpcyBvdXIgb3duIGV2ZW50XG4gKiAgIHNvIGl0IGlzIHVubGlrZWx5IHRoYXQgaXQgd2lsbCBldmVyIGJlIG5hdGl2ZS4gVGhlIHczYyBzcGVjIGZvciBkZXZpY2VjaGFuZ2VcbiAqICAgaXMgdW5jbGVhciBhcyB0byB3aGV0aGVyIE1lZGlhRGV2aWNlSW5mbyBjaGFuZ2VzIChzdWNoIGFzIGxhYmVsKSB3aWxsXG4gKiAgIHRyaWdnZXIgdGhlIGRldmljZWNoYW5nZSBldmVudC4gV2UgaGF2ZSBhbiBvcGVuIHF1ZXN0aW9uIG9uIHRoaXMgaGVyZTpcbiAqICAgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg1MDk2XG4gKi9cbmZ1bmN0aW9uIE1lZGlhRGV2aWNlc1NoaW0oKSB7XG4gICAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9kZWZpbmVFdmVudEhhbmRsZXIoJ2RldmljZWNoYW5nZScpO1xuICAgIHRoaXMuX2RlZmluZUV2ZW50SGFuZGxlcignZGV2aWNlaW5mb2NoYW5nZScpO1xuICAgIHZhciBrbm93bkRldmljZXMgPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgIF9kZXZpY2VDaGFuZ2VJc05hdGl2ZToge1xuICAgICAgICAgICAgdmFsdWU6IHJlZW1pdE5hdGl2ZUV2ZW50KHRoaXMsICdkZXZpY2VjaGFuZ2UnKVxuICAgICAgICB9LFxuICAgICAgICBfZGV2aWNlSW5mb0NoYW5nZUlzTmF0aXZlOiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVlbWl0TmF0aXZlRXZlbnQodGhpcywgJ2RldmljZWluZm9jaGFuZ2UnKVxuICAgICAgICB9LFxuICAgICAgICBfa25vd25EZXZpY2VzOiB7XG4gICAgICAgICAgICB2YWx1ZToga25vd25EZXZpY2VzXG4gICAgICAgIH0sXG4gICAgICAgIF9wb2xsSW50ZXJ2YWw6IHtcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlTWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbmF0aXZlTWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKS50aGVuKGZ1bmN0aW9uIChkZXZpY2VzKSB7XG4gICAgICAgICAgICBkZXZpY2VzLnNvcnQoc29ydERldmljZXNCeUlkKS5mb3JFYWNoKFtdLnB1c2gsIGtub3duRGV2aWNlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9ldmVudEVtaXR0ZXIub24oJ25ld0xpc3RlbmVyJywgZnVuY3Rpb24gbWF5YmVTdGFydFBvbGxpbmcoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUgIT09ICdkZXZpY2VjaGFuZ2UnICYmIGV2ZW50TmFtZSAhPT0gJ2RldmljZWluZm9jaGFuZ2UnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbEludGVydmFsID0gdGhpcy5fcG9sbEludGVydmFsXG4gICAgICAgICAgICB8fCBzZXRJbnRlcnZhbChzYW1wbGVEZXZpY2VzLmJpbmQobnVsbCwgdGhpcyksIFBPTExfSU5URVJWQUxfTVMpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fZXZlbnRFbWl0dGVyLm9uKCdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uIG1heWJlU3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsSW50ZXJ2YWwgJiYgIWhhc0NoYW5nZUxpc3RlbmVycyh0aGlzKSkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbEludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG59XG5pbmhlcml0cyhNZWRpYURldmljZXNTaGltLCBFdmVudFRhcmdldCk7XG5pZiAobmF0aXZlTWVkaWFEZXZpY2VzICYmIHR5cGVvZiBuYXRpdmVNZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIE1lZGlhRGV2aWNlc1NoaW0ucHJvdG90eXBlLmVudW1lcmF0ZURldmljZXMgPSBmdW5jdGlvbiBlbnVtZXJhdGVEZXZpY2VzKCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlTWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuYXBwbHkobmF0aXZlTWVkaWFEZXZpY2VzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5NZWRpYURldmljZXNTaGltLnByb3RvdHlwZS5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoKSB7XG4gICAgcmV0dXJuIG5hdGl2ZU1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEuYXBwbHkobmF0aXZlTWVkaWFEZXZpY2VzLCBhcmd1bWVudHMpO1xufTtcbmZ1bmN0aW9uIGRldmljZUluZm9zSGF2ZUNoYW5nZWQobmV3RGV2aWNlcywgb2xkRGV2aWNlcykge1xuICAgIHZhciBvbGRMYWJlbHMgPSBvbGREZXZpY2VzLnJlZHVjZShmdW5jdGlvbiAobWFwLCBkZXZpY2UpIHsgcmV0dXJuIG1hcC5zZXQoZGV2aWNlLmRldmljZUlkLCBkZXZpY2UubGFiZWwgfHwgbnVsbCk7IH0sIG5ldyBNYXAoKSk7XG4gICAgcmV0dXJuIG5ld0RldmljZXMuc29tZShmdW5jdGlvbiAobmV3RGV2aWNlKSB7XG4gICAgICAgIHZhciBvbGRMYWJlbCA9IG9sZExhYmVscy5nZXQobmV3RGV2aWNlLmRldmljZUlkKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvbGRMYWJlbCAhPT0gJ3VuZGVmaW5lZCcgJiYgb2xkTGFiZWwgIT09IG5ld0RldmljZS5sYWJlbDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRldmljZXNIYXZlQ2hhbmdlZChuZXdEZXZpY2VzLCBvbGREZXZpY2VzKSB7XG4gICAgcmV0dXJuIG5ld0RldmljZXMubGVuZ3RoICE9PSBvbGREZXZpY2VzLmxlbmd0aFxuICAgICAgICB8fCBwcm9wZXJ0eUhhc0NoYW5nZWQoJ2RldmljZUlkJywgbmV3RGV2aWNlcywgb2xkRGV2aWNlcyk7XG59XG5mdW5jdGlvbiBoYXNDaGFuZ2VMaXN0ZW5lcnMobWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuIFsnZGV2aWNlY2hhbmdlJywgJ2RldmljZWluZm9jaGFuZ2UnXS5yZWR1Y2UoZnVuY3Rpb24gKGNvdW50LCBldmVudCkgeyByZXR1cm4gY291bnQgKyBtZWRpYURldmljZXMuX2V2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KGV2ZW50KTsgfSwgMCkgPiAwO1xufVxuLyoqXG4gKiBTYW1wbGUgdGhlIGN1cnJlbnQgc2V0IG9mIGRldmljZXMgYW5kIGVtaXQgZGV2aWNlY2hhbmdlIGV2ZW50IGlmIGEgZGV2aWNlIGhhcyBiZWVuXG4gKiAgIGFkZGVkIG9yIHJlbW92ZWQsIGFuZCBkZXZpY2VpbmZvY2hhbmdlIGlmIGEgZGV2aWNlJ3MgbGFiZWwgaGFzIGNoYW5nZWQuXG4gKiBAcGFyYW0ge01lZGlhRGV2aWNlc1NoaW19IG1lZGlhRGV2aWNlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2FtcGxlRGV2aWNlcyhtZWRpYURldmljZXMpIHtcbiAgICBuYXRpdmVNZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZnVuY3Rpb24gKG5ld0RldmljZXMpIHtcbiAgICAgICAgdmFyIGtub3duRGV2aWNlcyA9IG1lZGlhRGV2aWNlcy5fa25vd25EZXZpY2VzO1xuICAgICAgICB2YXIgb2xkRGV2aWNlcyA9IGtub3duRGV2aWNlcy5zbGljZSgpO1xuICAgICAgICAvLyBSZXBsYWNlIGtub3duIGRldmljZXMgaW4tcGxhY2VcbiAgICAgICAgW10uc3BsaWNlLmFwcGx5KGtub3duRGV2aWNlcywgWzAsIGtub3duRGV2aWNlcy5sZW5ndGhdXG4gICAgICAgICAgICAuY29uY2F0KG5ld0RldmljZXMuc29ydChzb3J0RGV2aWNlc0J5SWQpKSk7XG4gICAgICAgIGlmICghbWVkaWFEZXZpY2VzLl9kZXZpY2VDaGFuZ2VJc05hdGl2ZVxuICAgICAgICAgICAgJiYgZGV2aWNlc0hhdmVDaGFuZ2VkKGtub3duRGV2aWNlcywgb2xkRGV2aWNlcykpIHtcbiAgICAgICAgICAgIG1lZGlhRGV2aWNlcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZGV2aWNlY2hhbmdlJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWVkaWFEZXZpY2VzLl9kZXZpY2VJbmZvQ2hhbmdlSXNOYXRpdmVcbiAgICAgICAgICAgICYmIGRldmljZUluZm9zSGF2ZUNoYW5nZWQoa25vd25EZXZpY2VzLCBvbGREZXZpY2VzKSkge1xuICAgICAgICAgICAgbWVkaWFEZXZpY2VzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdkZXZpY2VpbmZvY2hhbmdlJykpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEFjY2VwdHMgdHdvIHNvcnRlZCBhcnJheXMgYW5kIHRoZSBuYW1lIG9mIGEgcHJvcGVydHkgdG8gY29tcGFyZSBvbiBvYmplY3RzIGZyb20gZWFjaC5cbiAqICAgQXJyYXlzIHNob3VsZCBhbHNvIGJlIG9mIHRoZSBzYW1lIGxlbmd0aC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb21wYXJlIG9uIGVhY2ggb2JqZWN0XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGFzIC0gVGhlIGxlZnQtc2lkZSBhcnJheSBvZiBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IGJzIC0gVGhlIHJpZ2h0LXNpZGUgYXJyYXkgb2Ygb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHByaXZhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm9wZXJ0eSBvZiBhbnkgb2JqZWN0IGluIGFycmF5IEEgaXMgZGlmZmVyZW50IHRoYW5cbiAqICAgdGhlIHNhbWUgcHJvcGVydHkgb2YgaXRzIGNvcnJlc3BvbmRpbmcgb2JqZWN0IGluIGFycmF5IEIuXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5SGFzQ2hhbmdlZChwcm9wZXJ0eU5hbWUsIGFzLCBicykge1xuICAgIHJldHVybiBhcy5zb21lKGZ1bmN0aW9uIChhLCBpKSB7IHJldHVybiBhW3Byb3BlcnR5TmFtZV0gIT09IGJzW2ldW3Byb3BlcnR5TmFtZV07IH0pO1xufVxuLyoqXG4gKiBSZS1lbWl0IHRoZSBuYXRpdmUgZXZlbnQsIGlmIHRoZSBuYXRpdmUgbWVkaWFEZXZpY2VzIGhhcyB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7TWVkaWFEZXZpY2VzU2hpbX0gbWVkaWFEZXZpY2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbmF0aXZlIG1lZGlhRGV2aWNlIGhhZCB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiByZWVtaXROYXRpdmVFdmVudChtZWRpYURldmljZXMsIGV2ZW50TmFtZSkge1xuICAgIHZhciBtZXRob2ROYW1lID0gXCJvblwiICsgZXZlbnROYW1lO1xuICAgIGZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgbWVkaWFEZXZpY2VzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAobWV0aG9kTmFtZSBpbiBuYXRpdmVNZWRpYURldmljZXMpIHtcbiAgICAgICAgLy8gVXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgaXQncyBhdmFpbGFibGUgc28gd2UgZG9uJ3Qgc3RvbXAgb24gYW55IG90aGVyIGxpc3RlbmVyc1xuICAgICAgICAvLyBmb3IgdGhpcyBldmVudC4gQ3VycmVudGx5LCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIgZG9lcyBub3QgZXhpc3QgaW4gU2FmYXJpLlxuICAgICAgICBpZiAoJ2FkZEV2ZW50TGlzdGVuZXInIGluIG5hdGl2ZU1lZGlhRGV2aWNlcykge1xuICAgICAgICAgICAgbmF0aXZlTWVkaWFEZXZpY2VzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBkaXNwYXRjaEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5hdGl2ZU1lZGlhRGV2aWNlc1ttZXRob2ROYW1lXSA9IGRpc3BhdGNoRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNvcnREZXZpY2VzQnlJZChhLCBiKSB7XG4gICAgcmV0dXJuIGEuZGV2aWNlSWQgPCBiLmRldmljZUlkO1xufVxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gc2hpbU1lZGlhRGV2aWNlcygpIHtcbiAgICByZXR1cm4gbmF0aXZlTWVkaWFEZXZpY2VzID8gbmV3IE1lZGlhRGV2aWNlc1NoaW0oKSA6IG51bGw7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFkZXZpY2VzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/shims/mediadevices.js\n")},"./node_modules/twilio-client/es5/twilio/sound.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar AsyncQueue = __webpack_require__(/*! ./asyncQueue */ \"./node_modules/twilio-client/es5/twilio/asyncQueue.js\").AsyncQueue;\nvar AudioPlayer = __webpack_require__(/*! @twilio/audioplayer */ \"./node_modules/@twilio/audioplayer/es5/index.js\");\nvar InvalidArgumentError = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\").InvalidArgumentError;\n\n/**\n * @class\n * @param {string} name - Name of the sound\n * @param {string} url - URL of the sound\n * @param {Sound#ConstructorOptions} options\n * @property {boolean} isPlaying - Whether the Sound is currently playing audio.\n * @property {string} name - Name of the sound\n * @property {string} url - URL of the sound\n * @property {AudioContext} audioContext - The AudioContext to use if available for AudioPlayer.\n */ /**\n    * @typedef {Object} Sound#ConstructorOptions\n    * @property {number} [maxDuration=0] - The maximum length of time to play the sound\n    *   before stopping it.\n    * @property {Boolean} [shouldLoop=false] - Whether the sound should be looped.\n    */\nfunction Sound(name, url, options) {\n  if (!(this instanceof Sound)) {\n    return new Sound(name, url, options);\n  }\n\n  if (!name || !url) {\n    throw new InvalidArgumentError('name and url are required arguments');\n  }\n\n  options = Object.assign({\n    AudioFactory: typeof Audio !== 'undefined' ? Audio : null,\n    maxDuration: 0,\n    shouldLoop: false\n  }, options);\n\n  options.AudioPlayer = options.audioContext ? AudioPlayer.bind(AudioPlayer, options.audioContext) : options.AudioFactory;\n\n  Object.defineProperties(this, {\n    _activeEls: {\n      value: new Map()\n    },\n    _Audio: {\n      value: options.AudioPlayer\n    },\n    _isSinkSupported: {\n      value: options.AudioFactory !== null && typeof options.AudioFactory.prototype.setSinkId === 'function'\n    },\n    _maxDuration: {\n      value: options.maxDuration\n    },\n    _maxDurationTimeout: {\n      value: null,\n      writable: true\n    },\n    _operations: {\n      value: new AsyncQueue()\n    },\n    _playPromise: {\n      value: null,\n      writable: true\n    },\n    _shouldLoop: {\n      value: options.shouldLoop\n    },\n    _sinkIds: {\n      value: ['default']\n    },\n    isPlaying: {\n      enumerable: true,\n      get: function get() {\n        return !!this._playPromise;\n      }\n    },\n    name: {\n      enumerable: true,\n      value: name\n    },\n    url: {\n      enumerable: true,\n      value: url\n    }\n  });\n\n  if (this._Audio) {\n    // Play it (muted and should not loop) as soon as possible so that it does not get incorrectly caught by Chrome's\n    // \"gesture requirement for media playback\" feature.\n    // https://plus.google.com/+FrancoisBeaufort/posts/6PiJQqJzGqX\n    this._play(true, false);\n  }\n}\n\nfunction destroyAudioElement(audioElement) {\n  if (audioElement) {\n    audioElement.pause();\n    audioElement.src = '';\n    audioElement.srcObject = null;\n    audioElement.load();\n  }\n}\n\n/**\n * Plays the audio element that was initialized using the speficied sinkId\n */\nSound.prototype._playAudioElement = function _playAudioElement(sinkId, isMuted, shouldLoop) {\n  var _this = this;\n\n  var audioElement = this._activeEls.get(sinkId);\n\n  if (!audioElement) {\n    throw new InvalidArgumentError('sinkId: \"' + sinkId + '\" doesn\\'t have an audio element');\n  }\n\n  audioElement.muted = !!isMuted;\n  audioElement.loop = !!shouldLoop;\n\n  return audioElement.play().then(function () {\n    return audioElement;\n  }).catch(function (reason) {\n    destroyAudioElement(audioElement);\n    _this._activeEls.delete(sinkId);\n    throw reason;\n  });\n};\n\n/**\n * Start playing the sound. Will stop the currently playing sound first.\n * If it exists, the audio element that was initialized for the sinkId will be used\n */\nSound.prototype._play = function _play(forceIsMuted, forceShouldLoop) {\n  if (this.isPlaying) {\n    this._stop();\n  }\n\n  if (this._maxDuration > 0) {\n    this._maxDurationTimeout = setTimeout(this._stop.bind(this), this._maxDuration);\n  }\n\n  forceShouldLoop = typeof forceShouldLoop === 'boolean' ? forceShouldLoop : this._shouldLoop;\n  var self = this;\n  var playPromise = this._playPromise = Promise.all(this._sinkIds.map(function createAudioElement(sinkId) {\n    if (!self._Audio) {\n      return Promise.resolve();\n    }\n\n    var audioElement = self._activeEls.get(sinkId);\n    if (audioElement) {\n      return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n    }\n\n    audioElement = new self._Audio(self.url);\n\n    // Make sure the browser always retrieves the resource using CORS.\n    // By default when using media tags, origin header is not sent to server\n    // which causes the server to not return CORS headers. When this caches\n    // on the CDN or browser, it causes issues to future requests that needs CORS,\n    // which is true when using AudioContext. Please note that we won't have to do this\n    // once we migrate to CloudFront.\n    if (typeof audioElement.setAttribute === 'function') {\n      audioElement.setAttribute('crossorigin', 'anonymous');\n    }\n\n    /**\n     * (rrowland) Bug in Chrome 53 & 54 prevents us from calling Audio.setSinkId without\n     *   crashing the tab. https://bugs.chromium.org/p/chromium/issues/detail?id=655342\n     */\n    return new Promise(function (resolve) {\n      audioElement.addEventListener('canplaythrough', resolve);\n    }).then(function () {\n      return (self._isSinkSupported ? audioElement.setSinkId(sinkId) : Promise.resolve()).then(function setSinkIdSuccess() {\n        self._activeEls.set(sinkId, audioElement);\n\n        // Stop has been called, bail out\n        if (!self._playPromise) {\n          return Promise.resolve();\n        }\n        return self._playAudioElement(sinkId, forceIsMuted, forceShouldLoop);\n      });\n    });\n  }));\n\n  return playPromise;\n};\n\n/**\n * Stop playing the sound.\n */\nSound.prototype._stop = function _stop() {\n  var _this2 = this;\n\n  this._activeEls.forEach(function (audioEl, sinkId) {\n    if (_this2._sinkIds.includes(sinkId)) {\n      audioEl.pause();\n      audioEl.currentTime = 0;\n    } else {\n      // Destroy the ones that are not used anymore\n      destroyAudioElement(audioEl);\n      _this2._activeEls.delete(sinkId);\n    }\n  });\n\n  clearTimeout(this._maxDurationTimeout);\n\n  this._playPromise = null;\n  this._maxDurationTimeout = null;\n};\n\n/**\n * Update the sinkIds of the audio output devices this sound should play through.\n */\nSound.prototype.setSinkIds = function setSinkIds(ids) {\n  if (!this._isSinkSupported) {\n    return;\n  }\n\n  ids = ids.forEach ? ids : [ids];\n  [].splice.apply(this._sinkIds, [0, this._sinkIds.length].concat(ids));\n};\n\n/**\n * Add a stop operation to the queue\n */\nSound.prototype.stop = function stop() {\n  var _this3 = this;\n\n  this._operations.enqueue(function () {\n    _this3._stop();\n    return Promise.resolve();\n  });\n};\n\n/**\n * Add a play operation to the queue\n */\nSound.prototype.play = function play() {\n  var _this4 = this;\n\n  return this._operations.enqueue(function () {\n    return _this4._play();\n  });\n};\n\nmodule.exports = Sound;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3NvdW5kLmpzPzRkNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaUJBQWlCLDJHQUFrQztBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBcUI7QUFDL0MsMkJBQTJCLG1IQUF3Qzs7QUFFbkU7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyx5QkFBeUI7QUFDcEMsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxhQUFhO0FBQzNCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vc291bmQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBBc3luY1F1ZXVlID0gcmVxdWlyZSgnLi9hc3luY1F1ZXVlJykuQXN5bmNRdWV1ZTtcbnZhciBBdWRpb1BsYXllciA9IHJlcXVpcmUoJ0B0d2lsaW8vYXVkaW9wbGF5ZXInKTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IHJlcXVpcmUoJy4vZXJyb3JzJykuSW52YWxpZEFyZ3VtZW50RXJyb3I7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHNvdW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIG9mIHRoZSBzb3VuZFxuICogQHBhcmFtIHtTb3VuZCNDb25zdHJ1Y3Rvck9wdGlvbnN9IG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNQbGF5aW5nIC0gV2hldGhlciB0aGUgU291bmQgaXMgY3VycmVudGx5IHBsYXlpbmcgYXVkaW8uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHNvdW5kXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gVVJMIG9mIHRoZSBzb3VuZFxuICogQHByb3BlcnR5IHtBdWRpb0NvbnRleHR9IGF1ZGlvQ29udGV4dCAtIFRoZSBBdWRpb0NvbnRleHQgdG8gdXNlIGlmIGF2YWlsYWJsZSBmb3IgQXVkaW9QbGF5ZXIuXG4gKi8gLyoqXG4gICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTb3VuZCNDb25zdHJ1Y3Rvck9wdGlvbnNcbiAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbWF4RHVyYXRpb249MF0gLSBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGltZSB0byBwbGF5IHRoZSBzb3VuZFxuICAgICogICBiZWZvcmUgc3RvcHBpbmcgaXQuXG4gICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzaG91bGRMb29wPWZhbHNlXSAtIFdoZXRoZXIgdGhlIHNvdW5kIHNob3VsZCBiZSBsb29wZWQuXG4gICAgKi9cbmZ1bmN0aW9uIFNvdW5kKG5hbWUsIHVybCwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU291bmQpKSB7XG4gICAgcmV0dXJuIG5ldyBTb3VuZChuYW1lLCB1cmwsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCFuYW1lIHx8ICF1cmwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ25hbWUgYW5kIHVybCBhcmUgcmVxdWlyZWQgYXJndW1lbnRzJyk7XG4gIH1cblxuICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgQXVkaW9GYWN0b3J5OiB0eXBlb2YgQXVkaW8gIT09ICd1bmRlZmluZWQnID8gQXVkaW8gOiBudWxsLFxuICAgIG1heER1cmF0aW9uOiAwLFxuICAgIHNob3VsZExvb3A6IGZhbHNlXG4gIH0sIG9wdGlvbnMpO1xuXG4gIG9wdGlvbnMuQXVkaW9QbGF5ZXIgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCA/IEF1ZGlvUGxheWVyLmJpbmQoQXVkaW9QbGF5ZXIsIG9wdGlvbnMuYXVkaW9Db250ZXh0KSA6IG9wdGlvbnMuQXVkaW9GYWN0b3J5O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICBfYWN0aXZlRWxzOiB7XG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSxcbiAgICBfQXVkaW86IHtcbiAgICAgIHZhbHVlOiBvcHRpb25zLkF1ZGlvUGxheWVyXG4gICAgfSxcbiAgICBfaXNTaW5rU3VwcG9ydGVkOiB7XG4gICAgICB2YWx1ZTogb3B0aW9ucy5BdWRpb0ZhY3RvcnkgIT09IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuQXVkaW9GYWN0b3J5LnByb3RvdHlwZS5zZXRTaW5rSWQgPT09ICdmdW5jdGlvbidcbiAgICB9LFxuICAgIF9tYXhEdXJhdGlvbjoge1xuICAgICAgdmFsdWU6IG9wdGlvbnMubWF4RHVyYXRpb25cbiAgICB9LFxuICAgIF9tYXhEdXJhdGlvblRpbWVvdXQ6IHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9LFxuICAgIF9vcGVyYXRpb25zOiB7XG4gICAgICB2YWx1ZTogbmV3IEFzeW5jUXVldWUoKVxuICAgIH0sXG4gICAgX3BsYXlQcm9taXNlOiB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBfc2hvdWxkTG9vcDoge1xuICAgICAgdmFsdWU6IG9wdGlvbnMuc2hvdWxkTG9vcFxuICAgIH0sXG4gICAgX3NpbmtJZHM6IHtcbiAgICAgIHZhbHVlOiBbJ2RlZmF1bHQnXVxuICAgIH0sXG4gICAgaXNQbGF5aW5nOiB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3BsYXlQcm9taXNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBuYW1lXG4gICAgfSxcbiAgICB1cmw6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdXJsXG4gICAgfVxuICB9KTtcblxuICBpZiAodGhpcy5fQXVkaW8pIHtcbiAgICAvLyBQbGF5IGl0IChtdXRlZCBhbmQgc2hvdWxkIG5vdCBsb29wKSBhcyBzb29uIGFzIHBvc3NpYmxlIHNvIHRoYXQgaXQgZG9lcyBub3QgZ2V0IGluY29ycmVjdGx5IGNhdWdodCBieSBDaHJvbWUnc1xuICAgIC8vIFwiZ2VzdHVyZSByZXF1aXJlbWVudCBmb3IgbWVkaWEgcGxheWJhY2tcIiBmZWF0dXJlLlxuICAgIC8vIGh0dHBzOi8vcGx1cy5nb29nbGUuY29tLytGcmFuY29pc0JlYXVmb3J0L3Bvc3RzLzZQaUpRcUp6R3FYXG4gICAgdGhpcy5fcGxheSh0cnVlLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveUF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQpIHtcbiAgaWYgKGF1ZGlvRWxlbWVudCkge1xuICAgIGF1ZGlvRWxlbWVudC5wYXVzZSgpO1xuICAgIGF1ZGlvRWxlbWVudC5zcmMgPSAnJztcbiAgICBhdWRpb0VsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICBhdWRpb0VsZW1lbnQubG9hZCgpO1xuICB9XG59XG5cbi8qKlxuICogUGxheXMgdGhlIGF1ZGlvIGVsZW1lbnQgdGhhdCB3YXMgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIHNwZWZpY2llZCBzaW5rSWRcbiAqL1xuU291bmQucHJvdG90eXBlLl9wbGF5QXVkaW9FbGVtZW50ID0gZnVuY3Rpb24gX3BsYXlBdWRpb0VsZW1lbnQoc2lua0lkLCBpc011dGVkLCBzaG91bGRMb29wKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIGF1ZGlvRWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVscy5nZXQoc2lua0lkKTtcblxuICBpZiAoIWF1ZGlvRWxlbWVudCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignc2lua0lkOiBcIicgKyBzaW5rSWQgKyAnXCIgZG9lc25cXCd0IGhhdmUgYW4gYXVkaW8gZWxlbWVudCcpO1xuICB9XG5cbiAgYXVkaW9FbGVtZW50Lm11dGVkID0gISFpc011dGVkO1xuICBhdWRpb0VsZW1lbnQubG9vcCA9ICEhc2hvdWxkTG9vcDtcblxuICByZXR1cm4gYXVkaW9FbGVtZW50LnBsYXkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXVkaW9FbGVtZW50O1xuICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgZGVzdHJveUF1ZGlvRWxlbWVudChhdWRpb0VsZW1lbnQpO1xuICAgIF90aGlzLl9hY3RpdmVFbHMuZGVsZXRlKHNpbmtJZCk7XG4gICAgdGhyb3cgcmVhc29uO1xuICB9KTtcbn07XG5cbi8qKlxuICogU3RhcnQgcGxheWluZyB0aGUgc291bmQuIFdpbGwgc3RvcCB0aGUgY3VycmVudGx5IHBsYXlpbmcgc291bmQgZmlyc3QuXG4gKiBJZiBpdCBleGlzdHMsIHRoZSBhdWRpbyBlbGVtZW50IHRoYXQgd2FzIGluaXRpYWxpemVkIGZvciB0aGUgc2lua0lkIHdpbGwgYmUgdXNlZFxuICovXG5Tb3VuZC5wcm90b3R5cGUuX3BsYXkgPSBmdW5jdGlvbiBfcGxheShmb3JjZUlzTXV0ZWQsIGZvcmNlU2hvdWxkTG9vcCkge1xuICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICB0aGlzLl9zdG9wKCk7XG4gIH1cblxuICBpZiAodGhpcy5fbWF4RHVyYXRpb24gPiAwKSB7XG4gICAgdGhpcy5fbWF4RHVyYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9zdG9wLmJpbmQodGhpcyksIHRoaXMuX21heER1cmF0aW9uKTtcbiAgfVxuXG4gIGZvcmNlU2hvdWxkTG9vcCA9IHR5cGVvZiBmb3JjZVNob3VsZExvb3AgPT09ICdib29sZWFuJyA/IGZvcmNlU2hvdWxkTG9vcCA6IHRoaXMuX3Nob3VsZExvb3A7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBsYXlQcm9taXNlID0gdGhpcy5fcGxheVByb21pc2UgPSBQcm9taXNlLmFsbCh0aGlzLl9zaW5rSWRzLm1hcChmdW5jdGlvbiBjcmVhdGVBdWRpb0VsZW1lbnQoc2lua0lkKSB7XG4gICAgaWYgKCFzZWxmLl9BdWRpbykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBhdWRpb0VsZW1lbnQgPSBzZWxmLl9hY3RpdmVFbHMuZ2V0KHNpbmtJZCk7XG4gICAgaWYgKGF1ZGlvRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHNlbGYuX3BsYXlBdWRpb0VsZW1lbnQoc2lua0lkLCBmb3JjZUlzTXV0ZWQsIGZvcmNlU2hvdWxkTG9vcCk7XG4gICAgfVxuXG4gICAgYXVkaW9FbGVtZW50ID0gbmV3IHNlbGYuX0F1ZGlvKHNlbGYudXJsKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYnJvd3NlciBhbHdheXMgcmV0cmlldmVzIHRoZSByZXNvdXJjZSB1c2luZyBDT1JTLlxuICAgIC8vIEJ5IGRlZmF1bHQgd2hlbiB1c2luZyBtZWRpYSB0YWdzLCBvcmlnaW4gaGVhZGVyIGlzIG5vdCBzZW50IHRvIHNlcnZlclxuICAgIC8vIHdoaWNoIGNhdXNlcyB0aGUgc2VydmVyIHRvIG5vdCByZXR1cm4gQ09SUyBoZWFkZXJzLiBXaGVuIHRoaXMgY2FjaGVzXG4gICAgLy8gb24gdGhlIENETiBvciBicm93c2VyLCBpdCBjYXVzZXMgaXNzdWVzIHRvIGZ1dHVyZSByZXF1ZXN0cyB0aGF0IG5lZWRzIENPUlMsXG4gICAgLy8gd2hpY2ggaXMgdHJ1ZSB3aGVuIHVzaW5nIEF1ZGlvQ29udGV4dC4gUGxlYXNlIG5vdGUgdGhhdCB3ZSB3b24ndCBoYXZlIHRvIGRvIHRoaXNcbiAgICAvLyBvbmNlIHdlIG1pZ3JhdGUgdG8gQ2xvdWRGcm9udC5cbiAgICBpZiAodHlwZW9mIGF1ZGlvRWxlbWVudC5zZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGF1ZGlvRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJywgJ2Fub255bW91cycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIChycm93bGFuZCkgQnVnIGluIENocm9tZSA1MyAmIDU0IHByZXZlbnRzIHVzIGZyb20gY2FsbGluZyBBdWRpby5zZXRTaW5rSWQgd2l0aG91dFxuICAgICAqICAgY3Jhc2hpbmcgdGhlIHRhYi4gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjU1MzQyXG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBhdWRpb0VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCByZXNvbHZlKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAoc2VsZi5faXNTaW5rU3VwcG9ydGVkID8gYXVkaW9FbGVtZW50LnNldFNpbmtJZChzaW5rSWQpIDogUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oZnVuY3Rpb24gc2V0U2lua0lkU3VjY2VzcygpIHtcbiAgICAgICAgc2VsZi5fYWN0aXZlRWxzLnNldChzaW5rSWQsIGF1ZGlvRWxlbWVudCk7XG5cbiAgICAgICAgLy8gU3RvcCBoYXMgYmVlbiBjYWxsZWQsIGJhaWwgb3V0XG4gICAgICAgIGlmICghc2VsZi5fcGxheVByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYuX3BsYXlBdWRpb0VsZW1lbnQoc2lua0lkLCBmb3JjZUlzTXV0ZWQsIGZvcmNlU2hvdWxkTG9vcCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSkpO1xuXG4gIHJldHVybiBwbGF5UHJvbWlzZTtcbn07XG5cbi8qKlxuICogU3RvcCBwbGF5aW5nIHRoZSBzb3VuZC5cbiAqL1xuU291bmQucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gX3N0b3AoKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIHRoaXMuX2FjdGl2ZUVscy5mb3JFYWNoKGZ1bmN0aW9uIChhdWRpb0VsLCBzaW5rSWQpIHtcbiAgICBpZiAoX3RoaXMyLl9zaW5rSWRzLmluY2x1ZGVzKHNpbmtJZCkpIHtcbiAgICAgIGF1ZGlvRWwucGF1c2UoKTtcbiAgICAgIGF1ZGlvRWwuY3VycmVudFRpbWUgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZXN0cm95IHRoZSBvbmVzIHRoYXQgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgIGRlc3Ryb3lBdWRpb0VsZW1lbnQoYXVkaW9FbCk7XG4gICAgICBfdGhpczIuX2FjdGl2ZUVscy5kZWxldGUoc2lua0lkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNsZWFyVGltZW91dCh0aGlzLl9tYXhEdXJhdGlvblRpbWVvdXQpO1xuXG4gIHRoaXMuX3BsYXlQcm9taXNlID0gbnVsbDtcbiAgdGhpcy5fbWF4RHVyYXRpb25UaW1lb3V0ID0gbnVsbDtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBzaW5rSWRzIG9mIHRoZSBhdWRpbyBvdXRwdXQgZGV2aWNlcyB0aGlzIHNvdW5kIHNob3VsZCBwbGF5IHRocm91Z2guXG4gKi9cblNvdW5kLnByb3RvdHlwZS5zZXRTaW5rSWRzID0gZnVuY3Rpb24gc2V0U2lua0lkcyhpZHMpIHtcbiAgaWYgKCF0aGlzLl9pc1NpbmtTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZHMgPSBpZHMuZm9yRWFjaCA/IGlkcyA6IFtpZHNdO1xuICBbXS5zcGxpY2UuYXBwbHkodGhpcy5fc2lua0lkcywgWzAsIHRoaXMuX3NpbmtJZHMubGVuZ3RoXS5jb25jYXQoaWRzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIHN0b3Agb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZVxuICovXG5Tb3VuZC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gIHRoaXMuX29wZXJhdGlvbnMuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMzLl9zdG9wKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQWRkIGEgcGxheSBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlXG4gKi9cblNvdW5kLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgcmV0dXJuIHRoaXMuX29wZXJhdGlvbnMuZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90aGlzNC5fcGxheSgpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU291bmQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/sound.js\n")},"./node_modules/twilio-client/es5/twilio/statsMonitor.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/twilio-client/es5/twilio/util.js\");\nvar getRTCStats = __webpack_require__(/*! ./rtc/stats */ \"./node_modules/twilio-client/es5/twilio/rtc/stats.js\").getRTCStats;\nvar Mos = __webpack_require__(/*! ./rtc/mos */ \"./node_modules/twilio-client/es5/twilio/rtc/mos.js\");\n// How many samples we use when testing metric thresholds\nvar SAMPLE_COUNT_METRICS = 5;\n// How many samples that need to cross the threshold to\n// raise or clear a warning.\nvar SAMPLE_COUNT_CLEAR = 0;\nvar SAMPLE_COUNT_RAISE = 3;\nvar SAMPLE_INTERVAL = 1000;\nvar WARNING_TIMEOUT = 5 * 1000;\nvar DEFAULT_THRESHOLDS = {\n    audioInputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n    audioOutputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n    bytesReceived: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n    bytesSent: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n    jitter: { max: 30 },\n    mos: { min: 3 },\n    packetsLostFraction: [{\n            max: 1,\n        }, {\n            clearValue: 1,\n            maxAverage: 3,\n            sampleCount: 7,\n        }],\n    rtt: { max: 400 },\n};\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countHigh(max, values) {\n    return values.reduce(function (highCount, value) { return highCount += (value > max) ? 1 : 0; }, 0);\n}\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countLow(min, values) {\n    return values.reduce(function (lowCount, value) { return lowCount += (value < min) ? 1 : 0; }, 0);\n}\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\nfunction calculateStandardDeviation(values) {\n    if (values.length <= 0) {\n        return null;\n    }\n    var valueAverage = values.reduce(function (partialSum, value) { return partialSum + value; }, 0) / values.length;\n    var diffSquared = values.map(function (value) { return Math.pow(value - valueAverage, 2); });\n    var stdDev = Math.sqrt(diffSquared.reduce(function (partialSum, value) { return partialSum + value; }, 0) / diffSquared.length);\n    return stdDev;\n}\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\nfunction flattenSamples(sampleSets) {\n    return sampleSets.reduce(function (flat, current) { return __spreadArrays(flat, current); }, []);\n}\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\nvar StatsMonitor = /** @class */ (function (_super) {\n    __extends(StatsMonitor, _super);\n    /**\n     * @constructor\n     * @param [options] - Optional settings\n     */\n    function StatsMonitor(options) {\n        var _this = _super.call(this) || this;\n        /**\n         * A map of warnings with their raised time\n         */\n        _this._activeWarnings = new Map();\n        /**\n         * A map of stats with the number of exceeded thresholds\n         */\n        _this._currentStreaks = new Map();\n        /**\n         * Keeps track of input volumes in the last second\n         */\n        _this._inputVolumes = [];\n        /**\n         * Keeps track of output volumes in the last second\n         */\n        _this._outputVolumes = [];\n        /**\n         * Sample buffer. Saves most recent samples\n         */\n        _this._sampleBuffer = [];\n        /**\n         * Keeps track of supplemental sample values.\n         *\n         * Currently used for constant audio detection. Contains an array of volume\n         * samples for each sample interval.\n         */\n        _this._supplementalSampleBuffers = {\n            audioInputLevel: [],\n            audioOutputLevel: [],\n        };\n        /**\n         * Whether warnings should be enabled\n         */\n        _this._warningsEnabled = true;\n        options = options || {};\n        _this._getRTCStats = options.getRTCStats || getRTCStats;\n        _this._mos = options.Mos || Mos;\n        _this._peerConnection = options.peerConnection;\n        _this._thresholds = __assign(__assign({}, DEFAULT_THRESHOLDS), options.thresholds);\n        var thresholdSampleCounts = Object.values(_this._thresholds)\n            .map(function (threshold) { return threshold.sampleCount; })\n            .filter(function (sampleCount) { return !!sampleCount; });\n        _this._maxSampleCount = Math.max.apply(Math, __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts));\n        if (_this._peerConnection) {\n            _this.enable(_this._peerConnection);\n        }\n        return _this;\n    }\n    /**\n     * Called when a volume sample is available\n     * @param inputVolume - Input volume level from 0 to 32767\n     * @param outputVolume - Output volume level from 0 to 32767\n     */\n    StatsMonitor.prototype.addVolumes = function (inputVolume, outputVolume) {\n        this._inputVolumes.push(inputVolume);\n        this._outputVolumes.push(outputVolume);\n    };\n    /**\n     * Stop sampling RTC statistics for this {@link StatsMonitor}.\n     * @returns The current {@link StatsMonitor}.\n     */\n    StatsMonitor.prototype.disable = function () {\n        clearInterval(this._sampleInterval);\n        delete this._sampleInterval;\n        return this;\n    };\n    /**\n     * Disable warnings for this {@link StatsMonitor}.\n     * @returns The current {@link StatsMonitor}.\n     */\n    StatsMonitor.prototype.disableWarnings = function () {\n        if (this._warningsEnabled) {\n            this._activeWarnings.clear();\n        }\n        this._warningsEnabled = false;\n        return this;\n    };\n    /**\n     * Start sampling RTC statistics for this {@link StatsMonitor}.\n     * @param peerConnection - A PeerConnection to monitor.\n     * @returns The current {@link StatsMonitor}.\n     */\n    StatsMonitor.prototype.enable = function (peerConnection) {\n        if (peerConnection) {\n            if (this._peerConnection && peerConnection !== this._peerConnection) {\n                throw new errors_1.InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n            }\n            this._peerConnection = peerConnection;\n        }\n        if (!this._peerConnection) {\n            throw new errors_1.InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n        }\n        this._sampleInterval = this._sampleInterval ||\n            setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n        return this;\n    };\n    /**\n     * Enable warnings for this {@link StatsMonitor}.\n     * @returns The current {@link StatsMonitor}.\n     */\n    StatsMonitor.prototype.enableWarnings = function () {\n        this._warningsEnabled = true;\n        return this;\n    };\n    /**\n     * Check if there is an active warning for a specific stat and threshold\n     * @param statName - The name of the stat to check\n     * @param thresholdName - The name of the threshold to check\n     * @returns Whether there is an active warning for a specific stat and threshold\n     */\n    StatsMonitor.prototype.hasActiveWarning = function (statName, thresholdName) {\n        var warningId = statName + \":\" + thresholdName;\n        return !!this._activeWarnings.get(warningId);\n    };\n    /**\n     * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n     * @param sample - Sample to add\n     */\n    StatsMonitor.prototype._addSample = function (sample) {\n        var samples = this._sampleBuffer;\n        samples.push(sample);\n        // We store 1 extra sample so that we always have (current, previous)\n        // available for all {sampleBufferSize} threshold validations.\n        if (samples.length > this._maxSampleCount) {\n            samples.splice(0, samples.length - this._maxSampleCount);\n        }\n    };\n    /**\n     * Clear an active warning.\n     * @param statName - The name of the stat to clear.\n     * @param thresholdName - The name of the threshold to clear\n     * @param [data] - Any relevant sample data.\n     */\n    StatsMonitor.prototype._clearWarning = function (statName, thresholdName, data) {\n        var warningId = statName + \":\" + thresholdName;\n        var activeWarning = this._activeWarnings.get(warningId);\n        if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {\n            return;\n        }\n        this._activeWarnings.delete(warningId);\n        this.emit('warning-cleared', __assign(__assign({}, data), { name: statName, threshold: {\n                name: thresholdName,\n                value: this._thresholds[statName][thresholdName],\n            } }));\n    };\n    /**\n     * Create a sample object from a stats object using the previous sample, if available.\n     * @param stats - Stats retrieved from getStatistics\n     * @param [previousSample=null] - The previous sample to use to calculate deltas.\n     * @returns A universally-formatted version of RTC stats.\n     */\n    StatsMonitor.prototype._createSample = function (stats, previousSample) {\n        var previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n        var previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n        var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n        var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n        var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n        var currentBytesSent = stats.bytesSent - previousBytesSent;\n        var currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n        var currentPacketsSent = stats.packetsSent - previousPacketsSent;\n        var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n        var currentPacketsLost = stats.packetsLost - previousPacketsLost;\n        var currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n        var currentPacketsLostFraction = (currentInboundPackets > 0) ?\n            (currentPacketsLost / currentInboundPackets) * 100 : 0;\n        var totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n        var totalPacketsLostFraction = (totalInboundPackets > 0) ?\n            (stats.packetsLost / totalInboundPackets) * 100 : 100;\n        var rttValue = (typeof stats.rtt === 'number' || !previousSample) ? stats.rtt : previousSample.rtt;\n        var audioInputLevelValues = this._inputVolumes.splice(0);\n        this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n        var audioOutputLevelValues = this._outputVolumes.splice(0);\n        this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n        return {\n            audioInputLevel: Math.round(util_1.average(audioInputLevelValues)),\n            audioOutputLevel: Math.round(util_1.average(audioOutputLevelValues)),\n            bytesReceived: currentBytesReceived,\n            bytesSent: currentBytesSent,\n            codecName: stats.codecName,\n            jitter: stats.jitter,\n            mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n            packetsLost: currentPacketsLost,\n            packetsLostFraction: currentPacketsLostFraction,\n            packetsReceived: currentPacketsReceived,\n            packetsSent: currentPacketsSent,\n            rtt: rttValue,\n            timestamp: stats.timestamp,\n            totals: {\n                bytesReceived: stats.bytesReceived,\n                bytesSent: stats.bytesSent,\n                packetsLost: stats.packetsLost,\n                packetsLostFraction: totalPacketsLostFraction,\n                packetsReceived: stats.packetsReceived,\n                packetsSent: stats.packetsSent,\n            },\n        };\n    };\n    /**\n     * Get stats from the PeerConnection and add it to our list of samples.\n     */\n    StatsMonitor.prototype._fetchSample = function () {\n        var _this = this;\n        this._getSample().then(function (sample) {\n            _this._addSample(sample);\n            _this._raiseWarnings();\n            _this.emit('sample', sample);\n        }).catch(function (error) {\n            _this.disable();\n            // We only bubble up any errors coming from pc.getStats()\n            // No need to attach a twilioError\n            _this.emit('error', error);\n        });\n    };\n    /**\n     * Get stats from the PeerConnection.\n     * @returns A universally-formatted version of RTC stats.\n     */\n    StatsMonitor.prototype._getSample = function () {\n        var _this = this;\n        return this._getRTCStats(this._peerConnection).then(function (stats) {\n            var previousSample = null;\n            if (_this._sampleBuffer.length) {\n                previousSample = _this._sampleBuffer[_this._sampleBuffer.length - 1];\n            }\n            return _this._createSample(stats, previousSample);\n        });\n    };\n    /**\n     * Raise a warning and log its raised time.\n     * @param statName - The name of the stat to raise.\n     * @param thresholdName - The name of the threshold to raise\n     * @param [data] - Any relevant sample data.\n     */\n    StatsMonitor.prototype._raiseWarning = function (statName, thresholdName, data) {\n        var warningId = statName + \":\" + thresholdName;\n        if (this._activeWarnings.has(warningId)) {\n            return;\n        }\n        this._activeWarnings.set(warningId, { timeRaised: Date.now() });\n        var thresholds = this._thresholds[statName];\n        var thresholdValue;\n        if (Array.isArray(thresholds)) {\n            var foundThreshold = thresholds.find(function (threshold) { return thresholdName in threshold; });\n            if (foundThreshold) {\n                thresholdValue = foundThreshold[thresholdName];\n            }\n        }\n        else {\n            thresholdValue = this._thresholds[statName][thresholdName];\n        }\n        this.emit('warning', __assign(__assign({}, data), { name: statName, threshold: {\n                name: thresholdName,\n                value: thresholdValue,\n            } }));\n    };\n    /**\n     * Apply our thresholds to our array of RTCStat samples.\n     */\n    StatsMonitor.prototype._raiseWarnings = function () {\n        var _this = this;\n        if (!this._warningsEnabled) {\n            return;\n        }\n        Object.keys(this._thresholds).forEach(function (name) { return _this._raiseWarningsForStat(name); });\n    };\n    /**\n     * Apply thresholds for a given stat name to our array of\n     * RTCStat samples and raise or clear any associated warnings.\n     * @param statName - Name of the stat to compare.\n     */\n    StatsMonitor.prototype._raiseWarningsForStat = function (statName) {\n        var _this = this;\n        var limits = Array.isArray(this._thresholds[statName])\n            ? this._thresholds[statName]\n            : [this._thresholds[statName]];\n        limits.forEach(function (limit) {\n            var samples = _this._sampleBuffer;\n            var clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n            var raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n            var sampleCount = limit.sampleCount || _this._maxSampleCount;\n            var relevantSamples = samples.slice(-sampleCount);\n            var values = relevantSamples.map(function (sample) { return sample[statName]; });\n            // (rrowland) If we have a bad or missing value in the set, we don't\n            // have enough information to throw or clear a warning. Bail out.\n            var containsNull = values.some(function (value) { return typeof value === 'undefined' || value === null; });\n            if (containsNull) {\n                return;\n            }\n            var count;\n            if (typeof limit.max === 'number') {\n                count = countHigh(limit.max, values);\n                if (count >= raiseCount) {\n                    _this._raiseWarning(statName, 'max', { values: values, samples: relevantSamples });\n                }\n                else if (count <= clearCount) {\n                    _this._clearWarning(statName, 'max', { values: values, samples: relevantSamples });\n                }\n            }\n            if (typeof limit.min === 'number') {\n                count = countLow(limit.min, values);\n                if (count >= raiseCount) {\n                    _this._raiseWarning(statName, 'min', { values: values, samples: relevantSamples });\n                }\n                else if (count <= clearCount) {\n                    _this._clearWarning(statName, 'min', { values: values, samples: relevantSamples });\n                }\n            }\n            if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n                relevantSamples = samples.slice(-2);\n                var prevValue = relevantSamples[0][statName];\n                var curValue = relevantSamples[1][statName];\n                var prevStreak = _this._currentStreaks.get(statName) || 0;\n                var streak = (prevValue === curValue) ? prevStreak + 1 : 0;\n                _this._currentStreaks.set(statName, streak);\n                if (streak >= limit.maxDuration) {\n                    _this._raiseWarning(statName, 'maxDuration', { value: streak });\n                }\n                else if (streak === 0) {\n                    _this._clearWarning(statName, 'maxDuration', { value: prevStreak });\n                }\n            }\n            if (typeof limit.minStandardDeviation === 'number') {\n                var sampleSets = _this._supplementalSampleBuffers[statName];\n                if (!sampleSets || sampleSets.length < limit.sampleCount) {\n                    return;\n                }\n                if (sampleSets.length > limit.sampleCount) {\n                    sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n                }\n                var flatSamples = flattenSamples(sampleSets.slice(-sampleCount));\n                var stdDev = calculateStandardDeviation(flatSamples);\n                if (typeof stdDev !== 'number') {\n                    return;\n                }\n                if (stdDev < limit.minStandardDeviation) {\n                    _this._raiseWarning(statName, 'minStandardDeviation', { value: stdDev });\n                }\n                else {\n                    _this._clearWarning(statName, 'minStandardDeviation', { value: stdDev });\n                }\n            }\n            [\n                ['maxAverage', function (x, y) { return x > y; }],\n                ['minAverage', function (x, y) { return x < y; }],\n            ].forEach(function (_a) {\n                var thresholdName = _a[0], comparator = _a[1];\n                if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n                    var avg = util_1.average(values);\n                    if (comparator(avg, limit[thresholdName])) {\n                        _this._raiseWarning(statName, thresholdName, { values: values, samples: relevantSamples });\n                    }\n                    else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n                        _this._clearWarning(statName, thresholdName, { values: values, samples: relevantSamples });\n                    }\n                }\n            });\n        });\n    };\n    return StatsMonitor;\n}(events_1.EventEmitter));\nexports.default = StatsMonitor;\n//# sourceMappingURL=statsMonitor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3N0YXRzTW9uaXRvci5qcz8zODRjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCx3Q0FBd0MsUUFBUTtBQUNoRCx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsQ0FBQyxjQUFjLEVBQUM7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLCtDQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyx5RUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsK0RBQVE7QUFDN0Isa0JBQWtCLDBHQUFrQztBQUNwRCxVQUFVLG1CQUFPLENBQUMscUVBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFnRDtBQUN0RSx1QkFBdUIsZ0RBQWdEO0FBQ3ZFLG9CQUFvQix1REFBdUQ7QUFDM0UsZ0JBQWdCLHVEQUF1RDtBQUN2RSxhQUFhLFVBQVU7QUFDdkIsVUFBVSxTQUFTO0FBQ25CO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsMkNBQTJDLEVBQUU7QUFDbkc7QUFDQTtB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ZGVfbW9kdWxlcy90d2lsaW8tY2xpZW50L2VzNS90d2lsaW8vc3RhdHNNb25pdG9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBWb2ljZVxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIGdldFJUQ1N0YXRzID0gcmVxdWlyZSgnLi9ydGMvc3RhdHMnKS5nZXRSVENTdGF0cztcbnZhciBNb3MgPSByZXF1aXJlKCcuL3J0Yy9tb3MnKTtcbi8vIEhvdyBtYW55IHNhbXBsZXMgd2UgdXNlIHdoZW4gdGVzdGluZyBtZXRyaWMgdGhyZXNob2xkc1xudmFyIFNBTVBMRV9DT1VOVF9NRVRSSUNTID0gNTtcbi8vIEhvdyBtYW55IHNhbXBsZXMgdGhhdCBuZWVkIHRvIGNyb3NzIHRoZSB0aHJlc2hvbGQgdG9cbi8vIHJhaXNlIG9yIGNsZWFyIGEgd2FybmluZy5cbnZhciBTQU1QTEVfQ09VTlRfQ0xFQVIgPSAwO1xudmFyIFNBTVBMRV9DT1VOVF9SQUlTRSA9IDM7XG52YXIgU0FNUExFX0lOVEVSVkFMID0gMTAwMDtcbnZhciBXQVJOSU5HX1RJTUVPVVQgPSA1ICogMTAwMDtcbnZhciBERUZBVUxUX1RIUkVTSE9MRFMgPSB7XG4gICAgYXVkaW9JbnB1dExldmVsOiB7IG1pblN0YW5kYXJkRGV2aWF0aW9uOiAzMjcuNjcsIHNhbXBsZUNvdW50OiAxMCB9LFxuICAgIGF1ZGlvT3V0cHV0TGV2ZWw6IHsgbWluU3RhbmRhcmREZXZpYXRpb246IDMyNy42Nywgc2FtcGxlQ291bnQ6IDEwIH0sXG4gICAgYnl0ZXNSZWNlaXZlZDogeyBjbGVhckNvdW50OiAyLCBtaW46IDEsIHJhaXNlQ291bnQ6IDMsIHNhbXBsZUNvdW50OiAzIH0sXG4gICAgYnl0ZXNTZW50OiB7IGNsZWFyQ291bnQ6IDIsIG1pbjogMSwgcmFpc2VDb3VudDogMywgc2FtcGxlQ291bnQ6IDMgfSxcbiAgICBqaXR0ZXI6IHsgbWF4OiAzMCB9LFxuICAgIG1vczogeyBtaW46IDMgfSxcbiAgICBwYWNrZXRzTG9zdEZyYWN0aW9uOiBbe1xuICAgICAgICAgICAgbWF4OiAxLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBjbGVhclZhbHVlOiAxLFxuICAgICAgICAgICAgbWF4QXZlcmFnZTogMyxcbiAgICAgICAgICAgIHNhbXBsZUNvdW50OiA3LFxuICAgICAgICB9XSxcbiAgICBydHQ6IHsgbWF4OiA0MDAgfSxcbn07XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgdmFsdWVzIHRoYXQgY3Jvc3MgdGhlIG1heCB0aHJlc2hvbGQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG1heCAtIFRoZSBtYXggYWxsb3dhYmxlIHZhbHVlLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB2YWx1ZXMgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB2YWx1ZXMgaW4gd2hpY2ggdGhlIHN0YXQgY3Jvc3NlZCB0aGUgdGhyZXNob2xkLlxuICovXG5mdW5jdGlvbiBjb3VudEhpZ2gobWF4LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoaGlnaENvdW50LCB2YWx1ZSkgeyByZXR1cm4gaGlnaENvdW50ICs9ICh2YWx1ZSA+IG1heCkgPyAxIDogMDsgfSwgMCk7XG59XG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgdmFsdWVzIHRoYXQgY3Jvc3MgdGhlIG1pbiB0aHJlc2hvbGQuXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIG1pbiAtIFRoZSBtaW5pbXVtIGFsbG93YWJsZSB2YWx1ZS5cbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdmFsdWVzIGluIHdoaWNoIHRoZSBzdGF0IGNyb3NzZWQgdGhlIHRocmVzaG9sZC5cbiAqL1xuZnVuY3Rpb24gY291bnRMb3cobWluLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAobG93Q291bnQsIHZhbHVlKSB7IHJldHVybiBsb3dDb3VudCArPSAodmFsdWUgPCBtaW4pID8gMSA6IDA7IH0sIDApO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBmcm9tIGEgbGlzdCBvZiBudW1iZXJzLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB2YWx1ZXMgVGhlIGxpc3Qgb2YgbnVtYmVycyB0byBjYWxjdWxhdGUgdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBmcm9tLlxuICogQHJldHVybnMgVGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhIGxpc3Qgb2YgbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3RhbmRhcmREZXZpYXRpb24odmFsdWVzKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlQXZlcmFnZSA9IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKHBhcnRpYWxTdW0sIHZhbHVlKSB7IHJldHVybiBwYXJ0aWFsU3VtICsgdmFsdWU7IH0sIDApIC8gdmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgZGlmZlNxdWFyZWQgPSB2YWx1ZXMubWFwKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTWF0aC5wb3codmFsdWUgLSB2YWx1ZUF2ZXJhZ2UsIDIpOyB9KTtcbiAgICB2YXIgc3RkRGV2ID0gTWF0aC5zcXJ0KGRpZmZTcXVhcmVkLnJlZHVjZShmdW5jdGlvbiAocGFydGlhbFN1bSwgdmFsdWUpIHsgcmV0dXJuIHBhcnRpYWxTdW0gKyB2YWx1ZTsgfSwgMCkgLyBkaWZmU3F1YXJlZC5sZW5ndGgpO1xuICAgIHJldHVybiBzdGREZXY7XG59XG4vKipcbiAqIEZsYXR0ZW4gYSBzZXQgb2YgbnVtZXJpY2FsIHNhbXBsZSBzZXRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2Ygc2FtcGxlcy5cbiAqIEBwYXJhbSBzYW1wbGVTZXRzXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5TYW1wbGVzKHNhbXBsZVNldHMpIHtcbiAgICByZXR1cm4gc2FtcGxlU2V0cy5yZWR1Y2UoZnVuY3Rpb24gKGZsYXQsIGN1cnJlbnQpIHsgcmV0dXJuIF9fc3ByZWFkQXJyYXlzKGZsYXQsIGN1cnJlbnQpOyB9LCBbXSk7XG59XG4vKipcbiAqIHtAbGluayBTdGF0c01vbml0b3J9IHBvbGxzIGEgcGVlckNvbm5lY3Rpb24gdmlhIFBlZXJDb25uZWN0aW9uLmdldFN0YXRzXG4gKiBhbmQgZW1pdHMgd2FybmluZ3Mgd2hlbiBzdGF0cyBjcm9zcyB0aGUgc3BlY2lmaWVkIHRocmVzaG9sZCB2YWx1ZXMuXG4gKi9cbnZhciBTdGF0c01vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YXRzTW9uaXRvciwgX3N1cGVyKTtcbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdIC0gT3B0aW9uYWwgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdGF0c01vbml0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2Ygd2FybmluZ3Mgd2l0aCB0aGVpciByYWlzZWQgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX2FjdGl2ZVdhcm5pbmdzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2Ygc3RhdHMgd2l0aCB0aGUgbnVtYmVyIG9mIGV4Y2VlZGVkIHRocmVzaG9sZHNcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9jdXJyZW50U3RyZWFrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIGlucHV0IHZvbHVtZXMgaW4gdGhlIGxhc3Qgc2Vjb25kXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5faW5wdXRWb2x1bWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiBvdXRwdXQgdm9sdW1lcyBpbiB0aGUgbGFzdCBzZWNvbmRcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vdXRwdXRWb2x1bWVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYW1wbGUgYnVmZmVyLiBTYXZlcyBtb3N0IHJlY2VudCBzYW1wbGVzXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fc2FtcGxlQnVmZmVyID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwcyB0cmFjayBvZiBzdXBwbGVtZW50YWwgc2FtcGxlIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ3VycmVudGx5IHVzZWQgZm9yIGNvbnN0YW50IGF1ZGlvIGRldGVjdGlvbi4gQ29udGFpbnMgYW4gYXJyYXkgb2Ygdm9sdW1lXG4gICAgICAgICAqIHNhbXBsZXMgZm9yIGVhY2ggc2FtcGxlIGludGVydmFsLlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX3N1cHBsZW1lbnRhbFNhbXBsZUJ1ZmZlcnMgPSB7XG4gICAgICAgICAgICBhdWRpb0lucHV0TGV2ZWw6IFtdLFxuICAgICAgICAgICAgYXVkaW9PdXRwdXRMZXZlbDogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHdhcm5pbmdzIHNob3VsZCBiZSBlbmFibGVkXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fd2FybmluZ3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIF90aGlzLl9nZXRSVENTdGF0cyA9IG9wdGlvbnMuZ2V0UlRDU3RhdHMgfHwgZ2V0UlRDU3RhdHM7XG4gICAgICAgIF90aGlzLl9tb3MgPSBvcHRpb25zLk1vcyB8fCBNb3M7XG4gICAgICAgIF90aGlzLl9wZWVyQ29ubmVjdGlvbiA9IG9wdGlvbnMucGVlckNvbm5lY3Rpb247XG4gICAgICAgIF90aGlzLl90aHJlc2hvbGRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIERFRkFVTFRfVEhSRVNIT0xEUyksIG9wdGlvbnMudGhyZXNob2xkcyk7XG4gICAgICAgIHZhciB0aHJlc2hvbGRTYW1wbGVDb3VudHMgPSBPYmplY3QudmFsdWVzKF90aGlzLl90aHJlc2hvbGRzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodGhyZXNob2xkKSB7IHJldHVybiB0aHJlc2hvbGQuc2FtcGxlQ291bnQ7IH0pXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzYW1wbGVDb3VudCkgeyByZXR1cm4gISFzYW1wbGVDb3VudDsgfSk7XG4gICAgICAgIF90aGlzLl9tYXhTYW1wbGVDb3VudCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF9fc3ByZWFkQXJyYXlzKFtTQU1QTEVfQ09VTlRfTUVUUklDU10sIHRocmVzaG9sZFNhbXBsZUNvdW50cykpO1xuICAgICAgICBpZiAoX3RoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5lbmFibGUoX3RoaXMuX3BlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdm9sdW1lIHNhbXBsZSBpcyBhdmFpbGFibGVcbiAgICAgKiBAcGFyYW0gaW5wdXRWb2x1bWUgLSBJbnB1dCB2b2x1bWUgbGV2ZWwgZnJvbSAwIHRvIDMyNzY3XG4gICAgICogQHBhcmFtIG91dHB1dFZvbHVtZSAtIE91dHB1dCB2b2x1bWUgbGV2ZWwgZnJvbSAwIHRvIDMyNzY3XG4gICAgICovXG4gICAgU3RhdHNNb25pdG9yLnByb3RvdHlwZS5hZGRWb2x1bWVzID0gZnVuY3Rpb24gKGlucHV0Vm9sdW1lLCBvdXRwdXRWb2x1bWUpIHtcbiAgICAgICAgdGhpcy5faW5wdXRWb2x1bWVzLnB1c2goaW5wdXRWb2x1bWUpO1xuICAgICAgICB0aGlzLl9vdXRwdXRWb2x1bWVzLnB1c2gob3V0cHV0Vm9sdW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3Agc2FtcGxpbmcgUlRDIHN0YXRpc3RpY3MgZm9yIHRoaXMge0BsaW5rIFN0YXRzTW9uaXRvcn0uXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQge0BsaW5rIFN0YXRzTW9uaXRvcn0uXG4gICAgICovXG4gICAgU3RhdHNNb25pdG9yLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3NhbXBsZUludGVydmFsKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NhbXBsZUludGVydmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc2FibGUgd2FybmluZ3MgZm9yIHRoaXMge0BsaW5rIFN0YXRzTW9uaXRvcn0uXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQge0BsaW5rIFN0YXRzTW9uaXRvcn0uXG4gICAgICovXG4gICAgU3RhdHNNb25pdG9yLnByb3RvdHlwZS5kaXNhYmxlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl93YXJuaW5nc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVdhcm5pbmdzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd2FybmluZ3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU3RhcnQgc2FtcGxpbmcgUlRDIHN0YXRpc3RpY3MgZm9yIHRoaXMge0BsaW5rIFN0YXRzTW9uaXRvcn0uXG4gICAgICogQHBhcmFtIHBlZXJDb25uZWN0aW9uIC0gQSBQZWVyQ29ubmVjdGlvbiB0byBtb25pdG9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHtAbGluayBTdGF0c01vbml0b3J9LlxuICAgICAqL1xuICAgIFN0YXRzTW9uaXRvci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlZXJDb25uZWN0aW9uICYmIHBlZXJDb25uZWN0aW9uICE9PSB0aGlzLl9wZWVyQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQXJndW1lbnRFcnJvcignQXR0ZW1wdGVkIHRvIHJlcGxhY2UgYW4gZXhpc3RpbmcgUGVlckNvbm5lY3Rpb24gaW4gU3RhdHNNb25pdG9yLmVuYWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSBwZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3BlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0NhbiBub3QgZW5hYmxlIFN0YXRzTW9uaXRvciB3aXRob3V0IGEgUGVlckNvbm5lY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zYW1wbGVJbnRlcnZhbCA9IHRoaXMuX3NhbXBsZUludGVydmFsIHx8XG4gICAgICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLl9mZXRjaFNhbXBsZS5iaW5kKHRoaXMpLCBTQU1QTEVfSU5URVJWQUwpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEVuYWJsZSB3YXJuaW5ncyBmb3IgdGhpcyB7QGxpbmsgU3RhdHNNb25pdG9yfS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCB7QGxpbmsgU3RhdHNNb25pdG9yfS5cbiAgICAgKi9cbiAgICBTdGF0c01vbml0b3IucHJvdG90eXBlLmVuYWJsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl93YXJuaW5nc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB3YXJuaW5nIGZvciBhIHNwZWNpZmljIHN0YXQgYW5kIHRocmVzaG9sZFxuICAgICAqIEBwYXJhbSBzdGF0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzdGF0IHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHRocmVzaG9sZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhyZXNob2xkIHRvIGNoZWNrXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGVyZSBpcyBhbiBhY3RpdmUgd2FybmluZyBmb3IgYSBzcGVjaWZpYyBzdGF0IGFuZCB0aHJlc2hvbGRcbiAgICAgKi9cbiAgICBTdGF0c01vbml0b3IucHJvdG90eXBlLmhhc0FjdGl2ZVdhcm5pbmcgPSBmdW5jdGlvbiAoc3RhdE5hbWUsIHRocmVzaG9sZE5hbWUpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdJZCA9IHN0YXROYW1lICsgXCI6XCIgKyB0aHJlc2hvbGROYW1lO1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hY3RpdmVXYXJuaW5ncy5nZXQod2FybmluZ0lkKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZCBhIHNhbXBsZSB0byBvdXIgc2FtcGxlIGJ1ZmZlciBhbmQgcmVtb3ZlIHRoZSBvbGRlc3QgaWYgd2UgYXJlIG92ZXIgdGhlIGxpbWl0LlxuICAgICAqIEBwYXJhbSBzYW1wbGUgLSBTYW1wbGUgdG8gYWRkXG4gICAgICovXG4gICAgU3RhdHNNb25pdG9yLnByb3RvdHlwZS5fYWRkU2FtcGxlID0gZnVuY3Rpb24gKHNhbXBsZSkge1xuICAgICAgICB2YXIgc2FtcGxlcyA9IHRoaXMuX3NhbXBsZUJ1ZmZlcjtcbiAgICAgICAgc2FtcGxlcy5wdXNoKHNhbXBsZSk7XG4gICAgICAgIC8vIFdlIHN0b3JlIDEgZXh0cmEgc2FtcGxlIHNvIHRoYXQgd2UgYWx3YXlzIGhhdmUgKGN1cnJlbnQsIHByZXZpb3VzKVxuICAgICAgICAvLyBhdmFpbGFibGUgZm9yIGFsbCB7c2FtcGxlQnVmZmVyU2l6ZX0gdGhyZXNob2xkIHZhbGlkYXRpb25zLlxuICAgICAgICBpZiAoc2FtcGxlcy5sZW5ndGggPiB0aGlzLl9tYXhTYW1wbGVDb3VudCkge1xuICAgICAgICAgICAgc2FtcGxlcy5zcGxpY2UoMCwgc2FtcGxlcy5sZW5ndGggLSB0aGlzLl9tYXhTYW1wbGVDb3VudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFuIGFjdGl2ZSB3YXJuaW5nLlxuICAgICAqIEBwYXJhbSBzdGF0TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBzdGF0IHRvIGNsZWFyLlxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRocmVzaG9sZCB0byBjbGVhclxuICAgICAqIEBwYXJhbSBbZGF0YV0gLSBBbnkgcmVsZXZhbnQgc2FtcGxlIGRhdGEuXG4gICAgICovXG4gICAgU3RhdHNNb25pdG9yLnByb3RvdHlwZS5fY2xlYXJXYXJuaW5nID0gZnVuY3Rpb24gKHN0YXROYW1lLCB0aHJlc2hvbGROYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciB3YXJuaW5nSWQgPSBzdGF0TmFtZSArIFwiOlwiICsgdGhyZXNob2xkTmFtZTtcbiAgICAgICAgdmFyIGFjdGl2ZVdhcm5pbmcgPSB0aGlzLl9hY3RpdmVXYXJuaW5ncy5nZXQod2FybmluZ0lkKTtcbiAgICAgICAgaWYgKCFhY3RpdmVXYXJuaW5nIHx8IERhdGUubm93KCkgLSBhY3RpdmVXYXJuaW5nLnRpbWVSYWlzZWQgPCBXQVJOSU5HX1RJTUVPVVQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmVXYXJuaW5ncy5kZWxldGUod2FybmluZ0lkKTtcbiAgICAgICAgdGhpcy5lbWl0KCd3YXJuaW5nLWNsZWFyZWQnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgbmFtZTogc3RhdE5hbWUsIHRocmVzaG9sZDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRocmVzaG9sZE5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX3RocmVzaG9sZHNbc3RhdE5hbWVdW3RocmVzaG9sZE5hbWVdLFxuICAgICAgICAgICAgfSB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzYW1wbGUgb2JqZWN0IGZyb20gYSBzdGF0cyBvYmplY3QgdXNpbmcgdGhlIHByZXZpb3VzIHNhbXBsZSwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBzdGF0cyAtIFN0YXRzIHJldHJpZXZlZCBmcm9tIGdldFN0YXRpc3RpY3NcbiAgICAgKiBAcGFyYW0gW3ByZXZpb3VzU2FtcGxlPW51bGxdIC0gVGhlIHByZXZpb3VzIHNhbXBsZSB0byB1c2UgdG8gY2FsY3VsYXRlIGRlbHRhcy5cbiAgICAgKiBAcmV0dXJucyBBIHVuaXZlcnNhbGx5LWZvcm1hdHRlZCB2ZXJzaW9uIG9mIFJUQyBzdGF0cy5cbiAgICAgKi9cbiAgICBTdGF0c01vbml0b3IucHJvdG90eXBlLl9jcmVhdGVTYW1wbGUgPSBmdW5jdGlvbiAoc3RhdHMsIHByZXZpb3VzU2FtcGxlKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0J5dGVzU2VudCA9IHByZXZpb3VzU2FtcGxlICYmIHByZXZpb3VzU2FtcGxlLnRvdGFscy5ieXRlc1NlbnQgfHwgMDtcbiAgICAgICAgdmFyIHByZXZpb3VzQnl0ZXNSZWNlaXZlZCA9IHByZXZpb3VzU2FtcGxlICYmIHByZXZpb3VzU2FtcGxlLnRvdGFscy5ieXRlc1JlY2VpdmVkIHx8IDA7XG4gICAgICAgIHZhciBwcmV2aW91c1BhY2tldHNTZW50ID0gcHJldmlvdXNTYW1wbGUgJiYgcHJldmlvdXNTYW1wbGUudG90YWxzLnBhY2tldHNTZW50IHx8IDA7XG4gICAgICAgIHZhciBwcmV2aW91c1BhY2tldHNSZWNlaXZlZCA9IHByZXZpb3VzU2FtcGxlICYmIHByZXZpb3VzU2FtcGxlLnRvdGFscy5wYWNrZXRzUmVjZWl2ZWQgfHwgMDtcbiAgICAgICAgdmFyIHByZXZpb3VzUGFja2V0c0xvc3QgPSBwcmV2aW91c1NhbXBsZSAmJiBwcmV2aW91c1NhbXBsZS50b3RhbHMucGFja2V0c0xvc3QgfHwgMDtcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlc1NlbnQgPSBzdGF0cy5ieXRlc1NlbnQgLSBwcmV2aW91c0J5dGVzU2VudDtcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlc1JlY2VpdmVkID0gc3RhdHMuYnl0ZXNSZWNlaXZlZCAtIHByZXZpb3VzQnl0ZXNSZWNlaXZlZDtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWNrZXRzU2VudCA9IHN0YXRzLnBhY2tldHNTZW50IC0gcHJldmlvdXNQYWNrZXRzU2VudDtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWNrZXRzUmVjZWl2ZWQgPSBzdGF0cy5wYWNrZXRzUmVjZWl2ZWQgLSBwcmV2aW91c1BhY2tldHNSZWNlaXZlZDtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWNrZXRzTG9zdCA9IHN0YXRzLnBhY2tldHNMb3N0IC0gcHJldmlvdXNQYWNrZXRzTG9zdDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmJvdW5kUGFja2V0cyA9IGN1cnJlbnRQYWNrZXRzUmVjZWl2ZWQgKyBjdXJyZW50UGFja2V0c0xvc3Q7XG4gICAgICAgIHZhciBjdXJyZW50UGFja2V0c0xvc3RGcmFjdGlvbiA9IChjdXJyZW50SW5ib3VuZFBhY2tldHMgPiAwKSA/XG4gICAgICAgICAgICAoY3VycmVudFBhY2tldHNMb3N0IC8gY3VycmVudEluYm91bmRQYWNrZXRzKSAqIDEwMCA6IDA7XG4gICAgICAgIHZhciB0b3RhbEluYm91bmRQYWNrZXRzID0gc3RhdHMucGFja2V0c1JlY2VpdmVkICsgc3RhdHMucGFja2V0c0xvc3Q7XG4gICAgICAgIHZhciB0b3RhbFBhY2tldHNMb3N0RnJhY3Rpb24gPSAodG90YWxJbmJvdW5kUGFja2V0cyA+IDApID9cbiAgICAgICAgICAgIChzdGF0cy5wYWNrZXRzTG9zdCAvIHRvdGFsSW5ib3VuZFBhY2tldHMpICogMTAwIDogMTAwO1xuICAgICAgICB2YXIgcnR0VmFsdWUgPSAodHlwZW9mIHN0YXRzLnJ0dCA9PT0gJ251bWJlcicgfHwgIXByZXZpb3VzU2FtcGxlKSA/IHN0YXRzLnJ0dCA6IHByZXZpb3VzU2FtcGxlLnJ0dDtcbiAgICAgICAgdmFyIGF1ZGlvSW5wdXRMZXZlbFZhbHVlcyA9IHRoaXMuX2lucHV0Vm9sdW1lcy5zcGxpY2UoMCk7XG4gICAgICAgIHRoaXMuX3N1cHBsZW1lbnRhbFNhbXBsZUJ1ZmZlcnMuYXVkaW9JbnB1dExldmVsLnB1c2goYXVkaW9JbnB1dExldmVsVmFsdWVzKTtcbiAgICAgICAgdmFyIGF1ZGlvT3V0cHV0TGV2ZWxWYWx1ZXMgPSB0aGlzLl9vdXRwdXRWb2x1bWVzLnNwbGljZSgwKTtcbiAgICAgICAgdGhpcy5fc3VwcGxlbWVudGFsU2FtcGxlQnVmZmVycy5hdWRpb091dHB1dExldmVsLnB1c2goYXVkaW9PdXRwdXRMZXZlbFZhbHVlcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdWRpb0lucHV0TGV2ZWw6IE1hdGgucm91bmQodXRpbF8xLmF2ZXJhZ2UoYXVkaW9JbnB1dExldmVsVmFsdWVzKSksXG4gICAgICAgICAgICBhdWRpb091dHB1dExldmVsOiBNYXRoLnJvdW5kKHV0aWxfMS5hdmVyYWdlKGF1ZGlvT3V0cHV0TGV2ZWxWYWx1ZXMpKSxcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IGN1cnJlbnRCeXRlc1JlY2VpdmVkLFxuICAgICAgICAgICAgYnl0ZXNTZW50OiBjdXJyZW50Qnl0ZXNTZW50LFxuICAgICAgICAgICAgY29kZWNOYW1lOiBzdGF0cy5jb2RlY05hbWUsXG4gICAgICAgICAgICBqaXR0ZXI6IHN0YXRzLmppdHRlcixcbiAgICAgICAgICAgIG1vczogdGhpcy5fbW9zLmNhbGN1bGF0ZShydHRWYWx1ZSwgc3RhdHMuaml0dGVyLCBwcmV2aW91c1NhbXBsZSAmJiBjdXJyZW50UGFja2V0c0xvc3RGcmFjdGlvbiksXG4gICAgICAgICAgICBwYWNrZXRzTG9zdDogY3VycmVudFBhY2tldHNMb3N0LFxuICAgICAgICAgICAgcGFja2V0c0xvc3RGcmFjdGlvbjogY3VycmVudFBhY2tldHNMb3N0RnJhY3Rpb24sXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IGN1cnJlbnRQYWNrZXRzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzU2VudDogY3VycmVudFBhY2tldHNTZW50LFxuICAgICAgICAgICAgcnR0OiBydHRWYWx1ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogc3RhdHMudGltZXN0YW1wLFxuICAgICAgICAgICAgdG90YWxzOiB7XG4gICAgICAgICAgICAgICAgYnl0ZXNSZWNlaXZlZDogc3RhdHMuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICBieXRlc1NlbnQ6IHN0YXRzLmJ5dGVzU2VudCxcbiAgICAgICAgICAgICAgICBwYWNrZXRzTG9zdDogc3RhdHMucGFja2V0c0xvc3QsXG4gICAgICAgICAgICAgICAgcGFja2V0c0xvc3RGcmFjdGlvbjogdG90YWxQYWNrZXRzTG9zdEZyYWN0aW9uLFxuICAgICAgICAgICAgICAgIHBhY2tldHNSZWNlaXZlZDogc3RhdHMucGFja2V0c1JlY2VpdmVkLFxuICAgICAgICAgICAgICAgIHBhY2tldHNTZW50OiBzdGF0cy5wYWNrZXRzU2VudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgc3RhdHMgZnJvbSB0aGUgUGVlckNvbm5lY3Rpb24gYW5kIGFkZCBpdCB0byBvdXIgbGlzdCBvZiBzYW1wbGVzLlxuICAgICAqL1xuICAgIFN0YXRzTW9uaXRvci5wcm90b3R5cGUuX2ZldGNoU2FtcGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9nZXRTYW1wbGUoKS50aGVuKGZ1bmN0aW9uIChzYW1wbGUpIHtcbiAgICAgICAgICAgIF90aGlzLl9hZGRTYW1wbGUoc2FtcGxlKTtcbiAgICAgICAgICAgIF90aGlzLl9yYWlzZVdhcm5pbmdzKCk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdzYW1wbGUnLCBzYW1wbGUpO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIF90aGlzLmRpc2FibGUoKTtcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgYnViYmxlIHVwIGFueSBlcnJvcnMgY29taW5nIGZyb20gcGMuZ2V0U3RhdHMoKVxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhdHRhY2ggYSB0d2lsaW9FcnJvclxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHN0YXRzIGZyb20gdGhlIFBlZXJDb25uZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgdW5pdmVyc2FsbHktZm9ybWF0dGVkIHZlcnNpb24gb2YgUlRDIHN0YXRzLlxuICAgICAqL1xuICAgIFN0YXRzTW9uaXRvci5wcm90b3R5cGUuX2dldFNhbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJUQ1N0YXRzKHRoaXMuX3BlZXJDb25uZWN0aW9uKS50aGVuKGZ1bmN0aW9uIChzdGF0cykge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2FtcGxlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fc2FtcGxlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU2FtcGxlID0gX3RoaXMuX3NhbXBsZUJ1ZmZlcltfdGhpcy5fc2FtcGxlQnVmZmVyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jcmVhdGVTYW1wbGUoc3RhdHMsIHByZXZpb3VzU2FtcGxlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSYWlzZSBhIHdhcm5pbmcgYW5kIGxvZyBpdHMgcmFpc2VkIHRpbWUuXG4gICAgICogQHBhcmFtIHN0YXROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0YXQgdG8gcmFpc2UuXG4gICAgICogQHBhcmFtIHRocmVzaG9sZE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdGhyZXNob2xkIHRvIHJhaXNlXG4gICAgICogQHBhcmFtIFtkYXRhXSAtIEFueSByZWxldmFudCBzYW1wbGUgZGF0YS5cbiAgICAgKi9cbiAgICBTdGF0c01vbml0b3IucHJvdG90eXBlLl9yYWlzZVdhcm5pbmcgPSBmdW5jdGlvbiAoc3RhdE5hbWUsIHRocmVzaG9sZE5hbWUsIGRhdGEpIHtcbiAgICAgICAgdmFyIHdhcm5pbmdJZCA9IHN0YXROYW1lICsgXCI6XCIgKyB0aHJlc2hvbGROYW1lO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlV2FybmluZ3MuaGFzKHdhcm5pbmdJZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY3RpdmVXYXJuaW5ncy5zZXQod2FybmluZ0lkLCB7IHRpbWVSYWlzZWQ6IERhdGUubm93KCkgfSk7XG4gICAgICAgIHZhciB0aHJlc2hvbGRzID0gdGhpcy5fdGhyZXNob2xkc1tzdGF0TmFtZV07XG4gICAgICAgIHZhciB0aHJlc2hvbGRWYWx1ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhyZXNob2xkcykpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZFRocmVzaG9sZCA9IHRocmVzaG9sZHMuZmluZChmdW5jdGlvbiAodGhyZXNob2xkKSB7IHJldHVybiB0aHJlc2hvbGROYW1lIGluIHRocmVzaG9sZDsgfSk7XG4gICAgICAgICAgICBpZiAoZm91bmRUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGRWYWx1ZSA9IGZvdW5kVGhyZXNob2xkW3RocmVzaG9sZE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyZXNob2xkVmFsdWUgPSB0aGlzLl90aHJlc2hvbGRzW3N0YXROYW1lXVt0aHJlc2hvbGROYW1lXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3dhcm5pbmcnLCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGF0YSksIHsgbmFtZTogc3RhdE5hbWUsIHRocmVzaG9sZDoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRocmVzaG9sZE5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRocmVzaG9sZFZhbHVlLFxuICAgICAgICAgICAgfSB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseSBvdXIgdGhyZXNob2xkcyB0byBvdXIgYXJyYXkgb2YgUlRDU3RhdCBzYW1wbGVzLlxuICAgICAqL1xuICAgIFN0YXRzTW9uaXRvci5wcm90b3R5cGUuX3JhaXNlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fd2FybmluZ3NFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fdGhyZXNob2xkcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuX3JhaXNlV2FybmluZ3NGb3JTdGF0KG5hbWUpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5IHRocmVzaG9sZHMgZm9yIGEgZ2l2ZW4gc3RhdCBuYW1lIHRvIG91ciBhcnJheSBvZlxuICAgICAqIFJUQ1N0YXQgc2FtcGxlcyBhbmQgcmFpc2Ugb3IgY2xlYXIgYW55IGFzc29jaWF0ZWQgd2FybmluZ3MuXG4gICAgICogQHBhcmFtIHN0YXROYW1lIC0gTmFtZSBvZiB0aGUgc3RhdCB0byBjb21wYXJlLlxuICAgICAqL1xuICAgIFN0YXRzTW9uaXRvci5wcm90b3R5cGUuX3JhaXNlV2FybmluZ3NGb3JTdGF0ID0gZnVuY3Rpb24gKHN0YXROYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsaW1pdHMgPSBBcnJheS5pc0FycmF5KHRoaXMuX3RocmVzaG9sZHNbc3RhdE5hbWVdKVxuICAgICAgICAgICAgPyB0aGlzLl90aHJlc2hvbGRzW3N0YXROYW1lXVxuICAgICAgICAgICAgOiBbdGhpcy5fdGhyZXNob2xkc1tzdGF0TmFtZV1dO1xuICAgICAgICBsaW1pdHMuZm9yRWFjaChmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzYW1wbGVzID0gX3RoaXMuX3NhbXBsZUJ1ZmZlcjtcbiAgICAgICAgICAgIHZhciBjbGVhckNvdW50ID0gbGltaXQuY2xlYXJDb3VudCB8fCBTQU1QTEVfQ09VTlRfQ0xFQVI7XG4gICAgICAgICAgICB2YXIgcmFpc2VDb3VudCA9IGxpbWl0LnJhaXNlQ291bnQgfHwgU0FNUExFX0NPVU5UX1JBSVNFO1xuICAgICAgICAgICAgdmFyIHNhbXBsZUNvdW50ID0gbGltaXQuc2FtcGxlQ291bnQgfHwgX3RoaXMuX21heFNhbXBsZUNvdW50O1xuICAgICAgICAgICAgdmFyIHJlbGV2YW50U2FtcGxlcyA9IHNhbXBsZXMuc2xpY2UoLXNhbXBsZUNvdW50KTtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSByZWxldmFudFNhbXBsZXMubWFwKGZ1bmN0aW9uIChzYW1wbGUpIHsgcmV0dXJuIHNhbXBsZVtzdGF0TmFtZV07IH0pO1xuICAgICAgICAgICAgLy8gKHJyb3dsYW5kKSBJZiB3ZSBoYXZlIGEgYmFkIG9yIG1pc3NpbmcgdmFsdWUgaW4gdGhlIHNldCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgZW5vdWdoIGluZm9ybWF0aW9uIHRvIHRocm93IG9yIGNsZWFyIGEgd2FybmluZy4gQmFpbCBvdXQuXG4gICAgICAgICAgICB2YXIgY29udGFpbnNOdWxsID0gdmFsdWVzLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHZhbHVlID09PSBudWxsOyB9KTtcbiAgICAgICAgICAgIGlmIChjb250YWluc051bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY291bnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbWl0Lm1heCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjb3VudCA9IGNvdW50SGlnaChsaW1pdC5tYXgsIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID49IHJhaXNlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3JhaXNlV2FybmluZyhzdGF0TmFtZSwgJ21heCcsIHsgdmFsdWVzOiB2YWx1ZXMsIHNhbXBsZXM6IHJlbGV2YW50U2FtcGxlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY291bnQgPD0gY2xlYXJDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJXYXJuaW5nKHN0YXROYW1lLCAnbWF4JywgeyB2YWx1ZXM6IHZhbHVlcywgc2FtcGxlczogcmVsZXZhbnRTYW1wbGVzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGltaXQubWluID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGNvdW50ID0gY291bnRMb3cobGltaXQubWluLCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudCA+PSByYWlzZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yYWlzZVdhcm5pbmcoc3RhdE5hbWUsICdtaW4nLCB7IHZhbHVlczogdmFsdWVzLCBzYW1wbGVzOiByZWxldmFudFNhbXBsZXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50IDw9IGNsZWFyQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2NsZWFyV2FybmluZyhzdGF0TmFtZSwgJ21pbicsIHsgdmFsdWVzOiB2YWx1ZXMsIHNhbXBsZXM6IHJlbGV2YW50U2FtcGxlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbWl0Lm1heER1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBzYW1wbGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICByZWxldmFudFNhbXBsZXMgPSBzYW1wbGVzLnNsaWNlKC0yKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gcmVsZXZhbnRTYW1wbGVzWzBdW3N0YXROYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyVmFsdWUgPSByZWxldmFudFNhbXBsZXNbMV1bc3RhdE5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2U3RyZWFrID0gX3RoaXMuX2N1cnJlbnRTdHJlYWtzLmdldChzdGF0TmFtZSkgfHwgMDtcbiAgICAgICAgICAgICAgICB2YXIgc3RyZWFrID0gKHByZXZWYWx1ZSA9PT0gY3VyVmFsdWUpID8gcHJldlN0cmVhayArIDEgOiAwO1xuICAgICAgICAgICAgICAgIF90aGlzLl9jdXJyZW50U3RyZWFrcy5zZXQoc3RhdE5hbWUsIHN0cmVhayk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhayA+PSBsaW1pdC5tYXhEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmFpc2VXYXJuaW5nKHN0YXROYW1lLCAnbWF4RHVyYXRpb24nLCB7IHZhbHVlOiBzdHJlYWsgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhayA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJXYXJuaW5nKHN0YXROYW1lLCAnbWF4RHVyYXRpb24nLCB7IHZhbHVlOiBwcmV2U3RyZWFrIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGltaXQubWluU3RhbmRhcmREZXZpYXRpb24gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNhbXBsZVNldHMgPSBfdGhpcy5fc3VwcGxlbWVudGFsU2FtcGxlQnVmZmVyc1tzdGF0TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKCFzYW1wbGVTZXRzIHx8IHNhbXBsZVNldHMubGVuZ3RoIDwgbGltaXQuc2FtcGxlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2FtcGxlU2V0cy5sZW5ndGggPiBsaW1pdC5zYW1wbGVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGVTZXRzLnNwbGljZSgwLCBzYW1wbGVTZXRzLmxlbmd0aCAtIGxpbWl0LnNhbXBsZUNvdW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZsYXRTYW1wbGVzID0gZmxhdHRlblNhbXBsZXMoc2FtcGxlU2V0cy5zbGljZSgtc2FtcGxlQ291bnQpKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RkRGV2ID0gY2FsY3VsYXRlU3RhbmRhcmREZXZpYXRpb24oZmxhdFNhbXBsZXMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RkRGV2ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGREZXYgPCBsaW1pdC5taW5TdGFuZGFyZERldmlhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmFpc2VXYXJuaW5nKHN0YXROYW1lLCAnbWluU3RhbmRhcmREZXZpYXRpb24nLCB7IHZhbHVlOiBzdGREZXYgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJXYXJuaW5nKHN0YXROYW1lLCAnbWluU3RhbmRhcmREZXZpYXRpb24nLCB7IHZhbHVlOiBzdGREZXYgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIFsnbWF4QXZlcmFnZScsIGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ID4geTsgfV0sXG4gICAgICAgICAgICAgICAgWydtaW5BdmVyYWdlJywgZnVuY3Rpb24gKHgsIHkpIHsgcmV0dXJuIHggPCB5OyB9XSxcbiAgICAgICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhyZXNob2xkTmFtZSA9IF9hWzBdLCBjb21wYXJhdG9yID0gX2FbMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsaW1pdFt0aHJlc2hvbGROYW1lXSA9PT0gJ251bWJlcicgJiYgdmFsdWVzLmxlbmd0aCA+PSBzYW1wbGVDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXZnID0gdXRpbF8xLmF2ZXJhZ2UodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IoYXZnLCBsaW1pdFt0aHJlc2hvbGROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9yYWlzZVdhcm5pbmcoc3RhdE5hbWUsIHRocmVzaG9sZE5hbWUsIHsgdmFsdWVzOiB2YWx1ZXMsIHNhbXBsZXM6IHJlbGV2YW50U2FtcGxlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghY29tcGFyYXRvcihhdmcsIGxpbWl0LmNsZWFyVmFsdWUgfHwgbGltaXRbdGhyZXNob2xkTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fY2xlYXJXYXJuaW5nKHN0YXROYW1lLCB0aHJlc2hvbGROYW1lLCB7IHZhbHVlczogdmFsdWVzLCBzYW1wbGVzOiByZWxldmFudFNhbXBsZXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdHNNb25pdG9yO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YXRzTW9uaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRzTW9uaXRvci5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/statsMonitor.js\n")},"./node_modules/twilio-client/es5/twilio/util.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("/**\n * Exception class.\n * @class\n * @name Exception\n * @exports Exception as Twilio.Exception\n * @memberOf Twilio\n * @param {string} message The exception message\n */\nfunction TwilioException(message) {\n    if (!(this instanceof TwilioException)) {\n        return new TwilioException(message);\n    }\n    this.message = message;\n}\n/**\n * Returns the exception message.\n *\n * @return {string} The exception message.\n */\nTwilioException.prototype.toString = function () {\n    return \"Twilio.Exception: \" + this.message;\n};\nfunction average(values) {\n    return values && values.length ? values.reduce(function (t, v) { return t + v; }) / values.length : 0;\n}\nfunction difference(lefts, rights, getKey) {\n    getKey = getKey || (function (a) { return a; });\n    var rightKeys = new Set(rights.map(getKey));\n    return lefts.filter(function (left) { return !rightKeys.has(getKey(left)); });\n}\nfunction isElectron(navigator) {\n    return !!navigator.userAgent.match('Electron');\n}\nfunction isChrome(window, navigator) {\n    var isCriOS = !!navigator.userAgent.match('CriOS');\n    var isHeadlessChrome = !!navigator.userAgent.match('HeadlessChrome');\n    var isGoogle = typeof window.chrome !== 'undefined'\n        && navigator.vendor === 'Google Inc.'\n        && navigator.userAgent.indexOf('OPR') === -1\n        && navigator.userAgent.indexOf('Edge') === -1;\n    return isCriOS || isElectron(navigator) || isGoogle || isHeadlessChrome;\n}\nfunction isFirefox(navigator) {\n    navigator = navigator || (typeof window === 'undefined'\n        ? __webpack_require__.g.navigator : window.navigator);\n    return !!(navigator) && typeof navigator.userAgent === 'string'\n        && /firefox|fxios/i.test(navigator.userAgent);\n}\nfunction isLegacyEdge(navigator) {\n    navigator = navigator || (typeof window === 'undefined'\n        ? __webpack_require__.g.navigator : window.navigator);\n    return !!(navigator) && typeof navigator.userAgent === 'string'\n        && /edge\\/\\d+/i.test(navigator.userAgent);\n}\nfunction isSafari(navigator) {\n    return !!(navigator.vendor) && navigator.vendor.indexOf('Apple') !== -1\n        && navigator.userAgent\n        && navigator.userAgent.indexOf('CriOS') === -1\n        && navigator.userAgent.indexOf('FxiOS') === -1;\n}\nfunction isUnifiedPlanDefault(window, navigator, PeerConnection, RtpTransceiver) {\n    if (typeof window === 'undefined'\n        || typeof navigator === 'undefined'\n        || typeof PeerConnection === 'undefined'\n        || typeof RtpTransceiver === 'undefined'\n        || typeof PeerConnection.prototype === 'undefined'\n        || typeof RtpTransceiver.prototype === 'undefined') {\n        return false;\n    }\n    if (isChrome(window, navigator) && PeerConnection.prototype.addTransceiver) {\n        var pc = new PeerConnection();\n        var isUnifiedPlan = true;\n        try {\n            pc.addTransceiver('audio');\n        }\n        catch (e) {\n            isUnifiedPlan = false;\n        }\n        pc.close();\n        return isUnifiedPlan;\n    }\n    else if (isFirefox(navigator)) {\n        return true;\n    }\n    else if (isSafari(navigator)) {\n        return 'currentDirection' in RtpTransceiver.prototype;\n    }\n    // Edge currently does not support unified plan.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17733189/\n    // https://wpdev.uservoice.com/forums/257854-microsoft-edge-developer/suggestions/34451998-sdp-unified-plan\n    return false;\n}\nfunction queryToJson(params) {\n    if (!params) {\n        return '';\n    }\n    return params.split('&').reduce(function (output, pair) {\n        var parts = pair.split('=');\n        var key = parts[0];\n        var value = decodeURIComponent((parts[1] || '').replace(/\\+/g, '%20'));\n        if (key) {\n            output[key] = value;\n        }\n        return output;\n    }, {});\n}\n/**\n * Map a list to an array of arrays, and return the flattened result.\n * @param {Array<*>|Set<*>|Map<*>} list\n * @param {function(*): Array<*>} [mapFn]\n * @returns Array<*>\n */\nfunction flatMap(list, mapFn) {\n    var listArray = list instanceof Map || list instanceof Set\n        ? Array.from(list.values())\n        : list;\n    mapFn = mapFn || (function (item) { return item; });\n    return listArray.reduce(function (flattened, item) {\n        var mapped = mapFn(item);\n        return flattened.concat(mapped);\n    }, []);\n}\nexports.Exception = TwilioException;\nexports.average = average;\nexports.difference = difference;\nexports.isElectron = isElectron;\nexports.isChrome = isChrome;\nexports.isFirefox = isFirefox;\nexports.isLegacyEdge = isLegacyEdge;\nexports.isSafari = isSafari;\nexports.isUnifiedPlanDefault = isUnifiedPlanDefault;\nexports.queryToJson = queryToJson;\nexports.flatMap = flatMap;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3V0aWwuanM/YTMxOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxjQUFjLEVBQUU7QUFDcEY7QUFDQTtBQUNBLHNDQUFzQyxVQUFVLEVBQUU7QUFDbEQ7QUFDQSx5Q0FBeUMscUNBQXFDLEVBQUU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxzQkFBc0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGFBQWEsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby91dGlsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFeGNlcHRpb24gY2xhc3MuXG4gKiBAY2xhc3NcbiAqIEBuYW1lIEV4Y2VwdGlvblxuICogQGV4cG9ydHMgRXhjZXB0aW9uIGFzIFR3aWxpby5FeGNlcHRpb25cbiAqIEBtZW1iZXJPZiBUd2lsaW9cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBleGNlcHRpb24gbWVzc2FnZVxuICovXG5mdW5jdGlvbiBUd2lsaW9FeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUd2lsaW9FeGNlcHRpb24pKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHdpbGlvRXhjZXB0aW9uKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleGNlcHRpb24gbWVzc2FnZS5cbiAqXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBleGNlcHRpb24gbWVzc2FnZS5cbiAqL1xuVHdpbGlvRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJUd2lsaW8uRXhjZXB0aW9uOiBcIiArIHRoaXMubWVzc2FnZTtcbn07XG5mdW5jdGlvbiBhdmVyYWdlKHZhbHVlcykge1xuICAgIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCA/IHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKHQsIHYpIHsgcmV0dXJuIHQgKyB2OyB9KSAvIHZhbHVlcy5sZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZGlmZmVyZW5jZShsZWZ0cywgcmlnaHRzLCBnZXRLZXkpIHtcbiAgICBnZXRLZXkgPSBnZXRLZXkgfHwgKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhOyB9KTtcbiAgICB2YXIgcmlnaHRLZXlzID0gbmV3IFNldChyaWdodHMubWFwKGdldEtleSkpO1xuICAgIHJldHVybiBsZWZ0cy5maWx0ZXIoZnVuY3Rpb24gKGxlZnQpIHsgcmV0dXJuICFyaWdodEtleXMuaGFzKGdldEtleShsZWZ0KSk7IH0pO1xufVxuZnVuY3Rpb24gaXNFbGVjdHJvbihuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gISFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCdFbGVjdHJvbicpO1xufVxuZnVuY3Rpb24gaXNDaHJvbWUod2luZG93LCBuYXZpZ2F0b3IpIHtcbiAgICB2YXIgaXNDcmlPUyA9ICEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnQ3JpT1MnKTtcbiAgICB2YXIgaXNIZWFkbGVzc0Nocm9tZSA9ICEhbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnSGVhZGxlc3NDaHJvbWUnKTtcbiAgICB2YXIgaXNHb29nbGUgPSB0eXBlb2Ygd2luZG93LmNocm9tZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgJiYgbmF2aWdhdG9yLnZlbmRvciA9PT0gJ0dvb2dsZSBJbmMuJ1xuICAgICAgICAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09QUicpID09PSAtMVxuICAgICAgICAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTE7XG4gICAgcmV0dXJuIGlzQ3JpT1MgfHwgaXNFbGVjdHJvbihuYXZpZ2F0b3IpIHx8IGlzR29vZ2xlIHx8IGlzSGVhZGxlc3NDaHJvbWU7XG59XG5mdW5jdGlvbiBpc0ZpcmVmb3gobmF2aWdhdG9yKSB7XG4gICAgbmF2aWdhdG9yID0gbmF2aWdhdG9yIHx8ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbC5uYXZpZ2F0b3IgOiB3aW5kb3cubmF2aWdhdG9yKTtcbiAgICByZXR1cm4gISEobmF2aWdhdG9yKSAmJiB0eXBlb2YgbmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgL2ZpcmVmb3h8Znhpb3MvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gaXNMZWdhY3lFZGdlKG5hdmlnYXRvcikge1xuICAgIG5hdmlnYXRvciA9IG5hdmlnYXRvciB8fCAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWwubmF2aWdhdG9yIDogd2luZG93Lm5hdmlnYXRvcik7XG4gICAgcmV0dXJuICEhKG5hdmlnYXRvcikgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICYmIC9lZGdlXFwvXFxkKy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiBpc1NhZmFyaShuYXZpZ2F0b3IpIHtcbiAgICByZXR1cm4gISEobmF2aWdhdG9yLnZlbmRvcikgJiYgbmF2aWdhdG9yLnZlbmRvci5pbmRleE9mKCdBcHBsZScpICE9PSAtMVxuICAgICAgICAmJiBuYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICAgICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ3JpT1MnKSA9PT0gLTFcbiAgICAgICAgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGeGlPUycpID09PSAtMTtcbn1cbmZ1bmN0aW9uIGlzVW5pZmllZFBsYW5EZWZhdWx0KHdpbmRvdywgbmF2aWdhdG9yLCBQZWVyQ29ubmVjdGlvbiwgUnRwVHJhbnNjZWl2ZXIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgfHwgdHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgfHwgdHlwZW9mIFBlZXJDb25uZWN0aW9uID09PSAndW5kZWZpbmVkJ1xuICAgICAgICB8fCB0eXBlb2YgUnRwVHJhbnNjZWl2ZXIgPT09ICd1bmRlZmluZWQnXG4gICAgICAgIHx8IHR5cGVvZiBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgPT09ICd1bmRlZmluZWQnXG4gICAgICAgIHx8IHR5cGVvZiBSdHBUcmFuc2NlaXZlci5wcm90b3R5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzQ2hyb21lKHdpbmRvdywgbmF2aWdhdG9yKSAmJiBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgdmFyIHBjID0gbmV3IFBlZXJDb25uZWN0aW9uKCk7XG4gICAgICAgIHZhciBpc1VuaWZpZWRQbGFuID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpc1VuaWZpZWRQbGFuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGlzVW5pZmllZFBsYW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRmlyZWZveChuYXZpZ2F0b3IpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NhZmFyaShuYXZpZ2F0b3IpKSB7XG4gICAgICAgIHJldHVybiAnY3VycmVudERpcmVjdGlvbicgaW4gUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlO1xuICAgIH1cbiAgICAvLyBFZGdlIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHVuaWZpZWQgcGxhbi5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xNzczMzE4OS9cbiAgICAvLyBodHRwczovL3dwZGV2LnVzZXJ2b2ljZS5jb20vZm9ydW1zLzI1Nzg1NC1taWNyb3NvZnQtZWRnZS1kZXZlbG9wZXIvc3VnZ2VzdGlvbnMvMzQ0NTE5OTgtc2RwLXVuaWZpZWQtcGxhblxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5VG9Kc29uKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcy5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAob3V0cHV0LCBwYWlyKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhaXIuc3BsaXQoJz0nKTtcbiAgICAgICAgdmFyIGtleSA9IHBhcnRzWzBdO1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoKHBhcnRzWzFdIHx8ICcnKS5yZXBsYWNlKC9cXCsvZywgJyUyMCcpKTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0sIHt9KTtcbn1cbi8qKlxuICogTWFwIGEgbGlzdCB0byBhbiBhcnJheSBvZiBhcnJheXMsIGFuZCByZXR1cm4gdGhlIGZsYXR0ZW5lZCByZXN1bHQuXG4gKiBAcGFyYW0ge0FycmF5PCo+fFNldDwqPnxNYXA8Kj59IGxpc3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6IEFycmF5PCo+fSBbbWFwRm5dXG4gKiBAcmV0dXJucyBBcnJheTwqPlxuICovXG5mdW5jdGlvbiBmbGF0TWFwKGxpc3QsIG1hcEZuKSB7XG4gICAgdmFyIGxpc3RBcnJheSA9IGxpc3QgaW5zdGFuY2VvZiBNYXAgfHwgbGlzdCBpbnN0YW5jZW9mIFNldFxuICAgICAgICA/IEFycmF5LmZyb20obGlzdC52YWx1ZXMoKSlcbiAgICAgICAgOiBsaXN0O1xuICAgIG1hcEZuID0gbWFwRm4gfHwgKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9KTtcbiAgICByZXR1cm4gbGlzdEFycmF5LnJlZHVjZShmdW5jdGlvbiAoZmxhdHRlbmVkLCBpdGVtKSB7XG4gICAgICAgIHZhciBtYXBwZWQgPSBtYXBGbihpdGVtKTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQobWFwcGVkKTtcbiAgICB9LCBbXSk7XG59XG5leHBvcnRzLkV4Y2VwdGlvbiA9IFR3aWxpb0V4Y2VwdGlvbjtcbmV4cG9ydHMuYXZlcmFnZSA9IGF2ZXJhZ2U7XG5leHBvcnRzLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuZXhwb3J0cy5pc0VsZWN0cm9uID0gaXNFbGVjdHJvbjtcbmV4cG9ydHMuaXNDaHJvbWUgPSBpc0Nocm9tZTtcbmV4cG9ydHMuaXNGaXJlZm94ID0gaXNGaXJlZm94O1xuZXhwb3J0cy5pc0xlZ2FjeUVkZ2UgPSBpc0xlZ2FjeUVkZ2U7XG5leHBvcnRzLmlzU2FmYXJpID0gaXNTYWZhcmk7XG5leHBvcnRzLmlzVW5pZmllZFBsYW5EZWZhdWx0ID0gaXNVbmlmaWVkUGxhbkRlZmF1bHQ7XG5leHBvcnRzLnF1ZXJ5VG9Kc29uID0gcXVlcnlUb0pzb247XG5leHBvcnRzLmZsYXRNYXAgPSBmbGF0TWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/util.js\n")},"./node_modules/twilio-client/es5/twilio/wstransport.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nvar WebSocket = __webpack_require__(/*! ws */ \"./node_modules/twilio-client/browser/ws.js\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./node_modules/twilio-client/es5/twilio/errors/index.js\");\nvar log_1 = __webpack_require__(/*! ./log */ \"./node_modules/twilio-client/es5/twilio/log.js\");\n// tslint:disable-next-line\nvar Backoff = __webpack_require__(/*! backoff */ \"./node_modules/backoff/index.js\");\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\n/**\n * All possible states of WSTransport.\n */\nvar WSTransportState;\n(function (WSTransportState) {\n    /**\n     * The WebSocket is not open but is trying to connect.\n     */\n    WSTransportState[\"Connecting\"] = \"connecting\";\n    /**\n     * The WebSocket is not open and is not trying to connect.\n     */\n    WSTransportState[\"Closed\"] = \"closed\";\n    /**\n     * The underlying WebSocket is open and active.\n     */\n    WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\nvar WSTransport = /** @class */ (function (_super) {\n    __extends(WSTransport, _super);\n    /**\n     * @constructor\n     * @param uris - List of URI of the endpoints to connect to.\n     * @param [options] - Constructor options.\n     */\n    function WSTransport(uris, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        /**\n         * The current state of the WSTransport.\n         */\n        _this.state = WSTransportState.Closed;\n        /**\n         * An instance of Logger to use.\n         */\n        _this._log = log_1.default.getInstance();\n        /**\n         * Whether we should attempt to fallback if we receive an applicable error\n         * when trying to connect to a signaling endpoint.\n         */\n        _this._shouldFallback = false;\n        /**\n         * The current uri index that the transport is connected to.\n         */\n        _this._uriIndex = 0;\n        /**\n         * Move the uri index to the next index\n         * If the index is at the end, the index goes back to the first one.\n         */\n        _this._moveUriIndex = function () {\n            _this._uriIndex++;\n            if (_this._uriIndex >= _this._uris.length) {\n                _this._uriIndex = 0;\n            }\n        };\n        /**\n         * Called in response to WebSocket#close event.\n         */\n        _this._onSocketClose = function (event) {\n            _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason);\n            // 1006: Abnormal close. When the server is unreacheable\n            // 1015: TLS Handshake error\n            if (event.code === 1006 || event.code === 1015) {\n                _this.emit('error', {\n                    code: 31005,\n                    message: event.reason ||\n                        'Websocket connection to Twilio\\'s signaling servers were ' +\n                            'unexpectedly ended. If this is happening consistently, there may ' +\n                            'be an issue resolving the hostname provided. If a region or an ' +\n                            'edge is being specified in Device setup, ensure it is valid.',\n                    twilioError: new errors_1.SignalingErrors.ConnectionError(),\n                });\n                var wasConnected = (\n                // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n                // Let's check current state if it's open, meaning we should not fallback\n                // because we're coming from a previously connected session\n                _this.state === WSTransportState.Open ||\n                    // But on other browsers, websocket doesn't drop\n                    // but our heartbeat catches it, setting the internal state to \"Connecting\".\n                    // With this, we should check the previous state instead.\n                    _this._previousState === WSTransportState.Open);\n                // Only fallback if this is not the first error\n                // and if we were not connected previously\n                if (_this._shouldFallback || !wasConnected) {\n                    _this._moveUriIndex();\n                }\n                _this._shouldFallback = true;\n            }\n            _this._closeSocket();\n        };\n        /**\n         * Called in response to WebSocket#error event.\n         */\n        _this._onSocketError = function (err) {\n            _this._log.info(\"WebSocket received error: \" + err.message);\n            _this.emit('error', {\n                code: 31000,\n                message: err.message || 'WSTransport socket error',\n                twilioError: new errors_1.SignalingErrors.ConnectionDisconnected(),\n            });\n        };\n        /**\n         * Called in response to WebSocket#message event.\n         */\n        _this._onSocketMessage = function (message) {\n            // Clear heartbeat timeout on any incoming message, as they\n            // all indicate an active connection.\n            _this._setHeartbeatTimeout();\n            // Filter and respond to heartbeats\n            if (_this._socket && message.data === '\\n') {\n                _this._socket.send('\\n');\n                return;\n            }\n            _this.emit('message', message);\n        };\n        /**\n         * Called in response to WebSocket#open event.\n         */\n        _this._onSocketOpen = function () {\n            _this._log.info('WebSocket opened successfully.');\n            _this._timeOpened = Date.now();\n            _this._shouldFallback = false;\n            _this._setState(WSTransportState.Open);\n            clearTimeout(_this._connectTimeout);\n            _this._setHeartbeatTimeout();\n            _this.emit('open');\n        };\n        _this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n        var initialDelay = 100;\n        if (uris && uris.length > 1) {\n            // We only want a random initial delay if there are any fallback edges\n            // Initial delay between 1s and 5s both inclusive\n            initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n        }\n        var backoffConfig = {\n            factor: 2.0,\n            initialDelay: initialDelay,\n            maxDelay: typeof options.backoffMaxMs === 'number'\n                ? Math.max(options.backoffMaxMs, 3000)\n                : 20000,\n            randomisationFactor: 0.40,\n        };\n        _this._log.info('Initializing transport backoff using config: ', backoffConfig);\n        _this._backoff = Backoff.exponential(backoffConfig);\n        _this._uris = uris;\n        _this._WebSocket = options.WebSocket || WebSocket;\n        // Called when a backoff timer is started.\n        _this._backoff.on('backoff', function (_, delay) {\n            if (_this.state === WSTransportState.Closed) {\n                return;\n            }\n            _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n        });\n        // Called when a backoff timer ends. We want to try to reconnect\n        // the WebSocket at this point.\n        _this._backoff.on('ready', function (attempt) {\n            if (_this.state === WSTransportState.Closed) {\n                return;\n            }\n            _this._connect(attempt + 1);\n        });\n        return _this;\n    }\n    /**\n     * Close the WebSocket, and don't try to reconnect.\n     */\n    WSTransport.prototype.close = function () {\n        this._log.info('WSTransport.close() called...');\n        this._close();\n    };\n    /**\n     * Attempt to open a WebSocket connection.\n     */\n    WSTransport.prototype.open = function () {\n        this._log.info('WSTransport.open() called...');\n        if (this._socket &&\n            (this._socket.readyState === WebSocket.CONNECTING ||\n                this._socket.readyState === WebSocket.OPEN)) {\n            this._log.info('WebSocket already open.');\n            return;\n        }\n        this._connect();\n    };\n    /**\n     * Send a message through the WebSocket connection.\n     * @param message - A message to send to the endpoint.\n     * @returns Whether the message was sent.\n     */\n    WSTransport.prototype.send = function (message) {\n        // We can't send the message if the WebSocket isn't open\n        if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n            return false;\n        }\n        try {\n            this._socket.send(message);\n        }\n        catch (e) {\n            // Some unknown error occurred. Reset the socket to get a fresh session.\n            this._log.info('Error while sending message:', e.message);\n            this._closeSocket();\n            return false;\n        }\n        return true;\n    };\n    /**\n     * Close the WebSocket, and don't try to reconnect.\n     */\n    WSTransport.prototype._close = function () {\n        this._setState(WSTransportState.Closed);\n        this._closeSocket();\n    };\n    /**\n     * Close the WebSocket and remove all event listeners.\n     */\n    WSTransport.prototype._closeSocket = function () {\n        clearTimeout(this._connectTimeout);\n        clearTimeout(this._heartbeatTimeout);\n        this._log.info('Closing and cleaning up WebSocket...');\n        if (!this._socket) {\n            this._log.info('No WebSocket to clean up.');\n            return;\n        }\n        this._socket.removeEventListener('close', this._onSocketClose);\n        this._socket.removeEventListener('error', this._onSocketError);\n        this._socket.removeEventListener('message', this._onSocketMessage);\n        this._socket.removeEventListener('open', this._onSocketOpen);\n        if (this._socket.readyState === WebSocket.CONNECTING ||\n            this._socket.readyState === WebSocket.OPEN) {\n            this._socket.close();\n        }\n        // Reset backoff counter if connection was open for long enough to be considered successful\n        if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n            this._backoff.reset();\n        }\n        this._backoff.backoff();\n        delete this._socket;\n        this.emit('close');\n    };\n    /**\n     * Attempt to connect to the endpoint via WebSocket.\n     * @param [retryCount] - Retry number, if this is a retry. Undefined if\n     *   first attempt, 1+ if a retry.\n     */\n    WSTransport.prototype._connect = function (retryCount) {\n        var _this = this;\n        if (retryCount) {\n            this._log.info(\"Attempting to reconnect (retry #\" + retryCount + \")...\");\n        }\n        else {\n            this._log.info('Attempting to connect...');\n        }\n        this._closeSocket();\n        this._setState(WSTransportState.Connecting);\n        var socket = null;\n        try {\n            socket = new this._WebSocket(this._uris[this._uriIndex]);\n        }\n        catch (e) {\n            this._log.info('Could not connect to endpoint:', e.message);\n            this._close();\n            this.emit('error', {\n                code: 31000,\n                message: e.message || \"Could not connect to \" + this._uris[this._uriIndex],\n                twilioError: new errors_1.SignalingErrors.ConnectionDisconnected(),\n            });\n            return;\n        }\n        delete this._timeOpened;\n        this._connectTimeout = setTimeout(function () {\n            _this._log.info('WebSocket connection attempt timed out.');\n            _this._moveUriIndex();\n            _this._closeSocket();\n        }, this._connectTimeoutMs);\n        socket.addEventListener('close', this._onSocketClose);\n        socket.addEventListener('error', this._onSocketError);\n        socket.addEventListener('message', this._onSocketMessage);\n        socket.addEventListener('open', this._onSocketOpen);\n        this._socket = socket;\n    };\n    /**\n     * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n     *   have passed without receiving a message over the WebSocket.\n     */\n    WSTransport.prototype._setHeartbeatTimeout = function () {\n        var _this = this;\n        clearTimeout(this._heartbeatTimeout);\n        this._heartbeatTimeout = setTimeout(function () {\n            _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n            _this._shouldFallback = true;\n            _this._closeSocket();\n        }, HEARTBEAT_TIMEOUT);\n    };\n    /**\n     * Set the current and previous state\n     */\n    WSTransport.prototype._setState = function (state) {\n        this._previousState = this.state;\n        this.state = state;\n    };\n    Object.defineProperty(WSTransport.prototype, \"uri\", {\n        /**\n         * The uri the transport is currently connected to\n         */\n        get: function () {\n            return this._uris[this._uriIndex];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return WSTransport;\n}(events_1.EventEmitter));\nexports.default = WSTransport;\n//# sourceMappingURL=wstransport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdHdpbGlvLWNsaWVudC9lczUvdHdpbGlvL3dzdHJhbnNwb3J0LmpzPzBjY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQ3ZGLDZCQUE2Qix1REFBdUQ7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQywrQ0FBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxzREFBSTtBQUM1QixlQUFlLG1CQUFPLENBQUMseUVBQVU7QUFDakMsWUFBWSxtQkFBTyxDQUFDLDZEQUFPO0FBQzNCO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRCx3QkFBd0IsS0FBSztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0QsZUFBZTtBQUNmIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3R3aWxpby1jbGllbnQvZXM1L3R3aWxpby93c3RyYW5zcG9ydC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgVG9vbHNcbiAqIEBpbnRlcm5hbGFwaVxuICovXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgV2ViU29ja2V0ID0gcmVxdWlyZShcIndzXCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIGxvZ18xID0gcmVxdWlyZShcIi4vbG9nXCIpO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvZmYnKTtcbnZhciBDT05ORUNUX1NVQ0NFU1NfVElNRU9VVCA9IDEwMDAwO1xudmFyIENPTk5FQ1RfVElNRU9VVCA9IDUwMDA7XG52YXIgSEVBUlRCRUFUX1RJTUVPVVQgPSAxNTAwMDtcbi8qKlxuICogQWxsIHBvc3NpYmxlIHN0YXRlcyBvZiBXU1RyYW5zcG9ydC5cbiAqL1xudmFyIFdTVHJhbnNwb3J0U3RhdGU7XG4oZnVuY3Rpb24gKFdTVHJhbnNwb3J0U3RhdGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgV2ViU29ja2V0IGlzIG5vdCBvcGVuIGJ1dCBpcyB0cnlpbmcgdG8gY29ubmVjdC5cbiAgICAgKi9cbiAgICBXU1RyYW5zcG9ydFN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBXZWJTb2NrZXQgaXMgbm90IG9wZW4gYW5kIGlzIG5vdCB0cnlpbmcgdG8gY29ubmVjdC5cbiAgICAgKi9cbiAgICBXU1RyYW5zcG9ydFN0YXRlW1wiQ2xvc2VkXCJdID0gXCJjbG9zZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdW5kZXJseWluZyBXZWJTb2NrZXQgaXMgb3BlbiBhbmQgYWN0aXZlLlxuICAgICAqL1xuICAgIFdTVHJhbnNwb3J0U3RhdGVbXCJPcGVuXCJdID0gXCJvcGVuXCI7XG59KShXU1RyYW5zcG9ydFN0YXRlID0gZXhwb3J0cy5XU1RyYW5zcG9ydFN0YXRlIHx8IChleHBvcnRzLldTVHJhbnNwb3J0U3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBXZWJTb2NrZXQgVHJhbnNwb3J0XG4gKi9cbnZhciBXU1RyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV1NUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHVyaXMgLSBMaXN0IG9mIFVSSSBvZiB0aGUgZW5kcG9pbnRzIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIFtvcHRpb25zXSAtIENvbnN0cnVjdG9yIG9wdGlvbnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gV1NUcmFuc3BvcnQodXJpcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFdTVHJhbnNwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuc3RhdGUgPSBXU1RyYW5zcG9ydFN0YXRlLkNsb3NlZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGluc3RhbmNlIG9mIExvZ2dlciB0byB1c2UuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbG9nID0gbG9nXzEuZGVmYXVsdC5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB3ZSBzaG91bGQgYXR0ZW1wdCB0byBmYWxsYmFjayBpZiB3ZSByZWNlaXZlIGFuIGFwcGxpY2FibGUgZXJyb3JcbiAgICAgICAgICogd2hlbiB0cnlpbmcgdG8gY29ubmVjdCB0byBhIHNpZ25hbGluZyBlbmRwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9zaG91bGRGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgdXJpIGluZGV4IHRoYXQgdGhlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQgdG8uXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fdXJpSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSB0aGUgdXJpIGluZGV4IHRvIHRoZSBuZXh0IGluZGV4XG4gICAgICAgICAqIElmIHRoZSBpbmRleCBpcyBhdCB0aGUgZW5kLCB0aGUgaW5kZXggZ29lcyBiYWNrIHRvIHRoZSBmaXJzdCBvbmUuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fbW92ZVVyaUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuX3VyaUluZGV4Kys7XG4gICAgICAgICAgICBpZiAoX3RoaXMuX3VyaUluZGV4ID49IF90aGlzLl91cmlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl91cmlJbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgaW4gcmVzcG9uc2UgdG8gV2ViU29ja2V0I2Nsb3NlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uU29ja2V0Q2xvc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhcIlJlY2VpdmVkIHdlYnNvY2tldCBjbG9zZSBldmVudCBjb2RlOiBcIiArIGV2ZW50LmNvZGUgKyBcIi4gUmVhc29uOiBcIiArIGV2ZW50LnJlYXNvbik7XG4gICAgICAgICAgICAvLyAxMDA2OiBBYm5vcm1hbCBjbG9zZS4gV2hlbiB0aGUgc2VydmVyIGlzIHVucmVhY2hlYWJsZVxuICAgICAgICAgICAgLy8gMTAxNTogVExTIEhhbmRzaGFrZSBlcnJvclxuICAgICAgICAgICAgaWYgKGV2ZW50LmNvZGUgPT09IDEwMDYgfHwgZXZlbnQuY29kZSA9PT0gMTAxNSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiAzMTAwNSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQucmVhc29uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAnV2Vic29ja2V0IGNvbm5lY3Rpb24gdG8gVHdpbGlvXFwncyBzaWduYWxpbmcgc2VydmVycyB3ZXJlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1bmV4cGVjdGVkbHkgZW5kZWQuIElmIHRoaXMgaXMgaGFwcGVuaW5nIGNvbnNpc3RlbnRseSwgdGhlcmUgbWF5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiZSBhbiBpc3N1ZSByZXNvbHZpbmcgdGhlIGhvc3RuYW1lIHByb3ZpZGVkLiBJZiBhIHJlZ2lvbiBvciBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZWRnZSBpcyBiZWluZyBzcGVjaWZpZWQgaW4gRGV2aWNlIHNldHVwLCBlbnN1cmUgaXQgaXMgdmFsaWQuJyxcbiAgICAgICAgICAgICAgICAgICAgdHdpbGlvRXJyb3I6IG5ldyBlcnJvcnNfMS5TaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkVycm9yKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIHdhc0Nvbm5lY3RlZCA9IChcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGluIFNhZmFyaSBhbmQgY2VydGFpbiBGaXJlZm94IHZlcnNpb25zLCBvbiBuZXR3b3JrIGludGVycnVwdGlvbiwgd2Vic29ja2V0IGRyb3BzIHJpZ2h0IGF3YXkgd2l0aCAxMDA2XG4gICAgICAgICAgICAgICAgLy8gTGV0J3MgY2hlY2sgY3VycmVudCBzdGF0ZSBpZiBpdCdzIG9wZW4sIG1lYW5pbmcgd2Ugc2hvdWxkIG5vdCBmYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UncmUgY29taW5nIGZyb20gYSBwcmV2aW91c2x5IGNvbm5lY3RlZCBzZXNzaW9uXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPT09IFdTVHJhbnNwb3J0U3RhdGUuT3BlbiB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgb24gb3RoZXIgYnJvd3NlcnMsIHdlYnNvY2tldCBkb2Vzbid0IGRyb3BcbiAgICAgICAgICAgICAgICAgICAgLy8gYnV0IG91ciBoZWFydGJlYXQgY2F0Y2hlcyBpdCwgc2V0dGluZyB0aGUgaW50ZXJuYWwgc3RhdGUgdG8gXCJDb25uZWN0aW5nXCIuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdpdGggdGhpcywgd2Ugc2hvdWxkIGNoZWNrIHRoZSBwcmV2aW91cyBzdGF0ZSBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcHJldmlvdXNTdGF0ZSA9PT0gV1NUcmFuc3BvcnRTdGF0ZS5PcGVuKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGZhbGxiYWNrIGlmIHRoaXMgaXMgbm90IHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgIC8vIGFuZCBpZiB3ZSB3ZXJlIG5vdCBjb25uZWN0ZWQgcHJldmlvdXNseVxuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fc2hvdWxkRmFsbGJhY2sgfHwgIXdhc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbW92ZVVyaUluZGV4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLl9zaG91bGRGYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fY2xvc2VTb2NrZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBpbiByZXNwb25zZSB0byBXZWJTb2NrZXQjZXJyb3IgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5fb25Tb2NrZXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhcIldlYlNvY2tldCByZWNlaXZlZCBlcnJvcjogXCIgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiAzMTAwMCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSB8fCAnV1NUcmFuc3BvcnQgc29ja2V0IGVycm9yJyxcbiAgICAgICAgICAgICAgICB0d2lsaW9FcnJvcjogbmV3IGVycm9yc18xLlNpZ25hbGluZ0Vycm9ycy5Db25uZWN0aW9uRGlzY29ubmVjdGVkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBpbiByZXNwb25zZSB0byBXZWJTb2NrZXQjbWVzc2FnZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLl9vblNvY2tldE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgaGVhcnRiZWF0IHRpbWVvdXQgb24gYW55IGluY29taW5nIG1lc3NhZ2UsIGFzIHRoZXlcbiAgICAgICAgICAgIC8vIGFsbCBpbmRpY2F0ZSBhbiBhY3RpdmUgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIF90aGlzLl9zZXRIZWFydGJlYXRUaW1lb3V0KCk7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgYW5kIHJlc3BvbmQgdG8gaGVhcnRiZWF0c1xuICAgICAgICAgICAgaWYgKF90aGlzLl9zb2NrZXQgJiYgbWVzc2FnZS5kYXRhID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zb2NrZXQuc2VuZCgnXFxuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGluIHJlc3BvbnNlIHRvIFdlYlNvY2tldCNvcGVuIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuX29uU29ja2V0T3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbygnV2ViU29ja2V0IG9wZW5lZCBzdWNjZXNzZnVsbHkuJyk7XG4gICAgICAgICAgICBfdGhpcy5fdGltZU9wZW5lZCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBfdGhpcy5fc2hvdWxkRmFsbGJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9zZXRTdGF0ZShXU1RyYW5zcG9ydFN0YXRlLk9wZW4pO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLl9jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICBfdGhpcy5fc2V0SGVhcnRiZWF0VGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgnb3BlbicpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fY29ubmVjdFRpbWVvdXRNcyA9IG9wdGlvbnMuY29ubmVjdFRpbWVvdXRNcyB8fCBDT05ORUNUX1RJTUVPVVQ7XG4gICAgICAgIHZhciBpbml0aWFsRGVsYXkgPSAxMDA7XG4gICAgICAgIGlmICh1cmlzICYmIHVyaXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IGEgcmFuZG9tIGluaXRpYWwgZGVsYXkgaWYgdGhlcmUgYXJlIGFueSBmYWxsYmFjayBlZGdlc1xuICAgICAgICAgICAgLy8gSW5pdGlhbCBkZWxheSBiZXR3ZWVuIDFzIGFuZCA1cyBib3RoIGluY2x1c2l2ZVxuICAgICAgICAgICAgaW5pdGlhbERlbGF5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDUwMDAgLSAxMDAwICsgMSkpICsgMTAwMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFja29mZkNvbmZpZyA9IHtcbiAgICAgICAgICAgIGZhY3RvcjogMi4wLFxuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBpbml0aWFsRGVsYXksXG4gICAgICAgICAgICBtYXhEZWxheTogdHlwZW9mIG9wdGlvbnMuYmFja29mZk1heE1zID09PSAnbnVtYmVyJ1xuICAgICAgICAgICAgICAgID8gTWF0aC5tYXgob3B0aW9ucy5iYWNrb2ZmTWF4TXMsIDMwMDApXG4gICAgICAgICAgICAgICAgOiAyMDAwMCxcbiAgICAgICAgICAgIHJhbmRvbWlzYXRpb25GYWN0b3I6IDAuNDAsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLl9sb2cuaW5mbygnSW5pdGlhbGl6aW5nIHRyYW5zcG9ydCBiYWNrb2ZmIHVzaW5nIGNvbmZpZzogJywgYmFja29mZkNvbmZpZyk7XG4gICAgICAgIF90aGlzLl9iYWNrb2ZmID0gQmFja29mZi5leHBvbmVudGlhbChiYWNrb2ZmQ29uZmlnKTtcbiAgICAgICAgX3RoaXMuX3VyaXMgPSB1cmlzO1xuICAgICAgICBfdGhpcy5fV2ViU29ja2V0ID0gb3B0aW9ucy5XZWJTb2NrZXQgfHwgV2ViU29ja2V0O1xuICAgICAgICAvLyBDYWxsZWQgd2hlbiBhIGJhY2tvZmYgdGltZXIgaXMgc3RhcnRlZC5cbiAgICAgICAgX3RoaXMuX2JhY2tvZmYub24oJ2JhY2tvZmYnLCBmdW5jdGlvbiAoXywgZGVsYXkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gV1NUcmFuc3BvcnRTdGF0ZS5DbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oXCJXaWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IFdlYlNvY2tldCBpbiBcIiArIGRlbGF5ICsgXCJtc1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhbGxlZCB3aGVuIGEgYmFja29mZiB0aW1lciBlbmRzLiBXZSB3YW50IHRvIHRyeSB0byByZWNvbm5lY3RcbiAgICAgICAgLy8gdGhlIFdlYlNvY2tldCBhdCB0aGlzIHBvaW50LlxuICAgICAgICBfdGhpcy5fYmFja29mZi5vbigncmVhZHknLCBmdW5jdGlvbiAoYXR0ZW1wdCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09PSBXU1RyYW5zcG9ydFN0YXRlLkNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLl9jb25uZWN0KGF0dGVtcHQgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIFdlYlNvY2tldCwgYW5kIGRvbid0IHRyeSB0byByZWNvbm5lY3QuXG4gICAgICovXG4gICAgV1NUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cuaW5mbygnV1NUcmFuc3BvcnQuY2xvc2UoKSBjYWxsZWQuLi4nKTtcbiAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gb3BlbiBhIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIFdTVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9sb2cuaW5mbygnV1NUcmFuc3BvcnQub3BlbigpIGNhbGxlZC4uLicpO1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0ICYmXG4gICAgICAgICAgICAodGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oJ1dlYlNvY2tldCBhbHJlYWR5IG9wZW4uJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdGhyb3VnaCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBBIG1lc3NhZ2UgdG8gc2VuZCB0byB0aGUgZW5kcG9pbnQuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgbWVzc2FnZSB3YXMgc2VudC5cbiAgICAgKi9cbiAgICBXU1RyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IHNlbmQgdGhlIG1lc3NhZ2UgaWYgdGhlIFdlYlNvY2tldCBpc24ndCBvcGVuXG4gICAgICAgIGlmICghdGhpcy5fc29ja2V0IHx8IHRoaXMuX3NvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gU29tZSB1bmtub3duIGVycm9yIG9jY3VycmVkLiBSZXNldCB0aGUgc29ja2V0IHRvIGdldCBhIGZyZXNoIHNlc3Npb24uXG4gICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnRXJyb3Igd2hpbGUgc2VuZGluZyBtZXNzYWdlOicsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIFdlYlNvY2tldCwgYW5kIGRvbid0IHRyeSB0byByZWNvbm5lY3QuXG4gICAgICovXG4gICAgV1NUcmFuc3BvcnQucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoV1NUcmFuc3BvcnRTdGF0ZS5DbG9zZWQpO1xuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIFdlYlNvY2tldCBhbmQgcmVtb3ZlIGFsbCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgV1NUcmFuc3BvcnQucHJvdG90eXBlLl9jbG9zZVNvY2tldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hlYXJ0YmVhdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9sb2cuaW5mbygnQ2xvc2luZyBhbmQgY2xlYW5pbmcgdXAgV2ViU29ja2V0Li4uJyk7XG4gICAgICAgIGlmICghdGhpcy5fc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnTm8gV2ViU29ja2V0IHRvIGNsZWFuIHVwLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uU29ja2V0Q2xvc2UpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vblNvY2tldEVycm9yKTtcbiAgICAgICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vblNvY2tldE1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuX29uU29ja2V0T3Blbik7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcgfHxcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgYmFja29mZiBjb3VudGVyIGlmIGNvbm5lY3Rpb24gd2FzIG9wZW4gZm9yIGxvbmcgZW5vdWdoIHRvIGJlIGNvbnNpZGVyZWQgc3VjY2Vzc2Z1bFxuICAgICAgICBpZiAodGhpcy5fdGltZU9wZW5lZCAmJiBEYXRlLm5vdygpIC0gdGhpcy5fdGltZU9wZW5lZCA+IENPTk5FQ1RfU1VDQ0VTU19USU1FT1VUKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYmFja29mZi5iYWNrb2ZmKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zb2NrZXQ7XG4gICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gY29ubmVjdCB0byB0aGUgZW5kcG9pbnQgdmlhIFdlYlNvY2tldC5cbiAgICAgKiBAcGFyYW0gW3JldHJ5Q291bnRdIC0gUmV0cnkgbnVtYmVyLCBpZiB0aGlzIGlzIGEgcmV0cnkuIFVuZGVmaW5lZCBpZlxuICAgICAqICAgZmlyc3QgYXR0ZW1wdCwgMSsgaWYgYSByZXRyeS5cbiAgICAgKi9cbiAgICBXU1RyYW5zcG9ydC5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbiAocmV0cnlDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAocmV0cnlDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fbG9nLmluZm8oXCJBdHRlbXB0aW5nIHRvIHJlY29ubmVjdCAocmV0cnkgI1wiICsgcmV0cnlDb3VudCArIFwiKS4uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvZy5pbmZvKCdBdHRlbXB0aW5nIHRvIGNvbm5lY3QuLi4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgICAgICB0aGlzLl9zZXRTdGF0ZShXU1RyYW5zcG9ydFN0YXRlLkNvbm5lY3RpbmcpO1xuICAgICAgICB2YXIgc29ja2V0ID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvY2tldCA9IG5ldyB0aGlzLl9XZWJTb2NrZXQodGhpcy5fdXJpc1t0aGlzLl91cmlJbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2cuaW5mbygnQ291bGQgbm90IGNvbm5lY3QgdG8gZW5kcG9pbnQ6JywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGNvZGU6IDMxMDAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUubWVzc2FnZSB8fCBcIkNvdWxkIG5vdCBjb25uZWN0IHRvIFwiICsgdGhpcy5fdXJpc1t0aGlzLl91cmlJbmRleF0sXG4gICAgICAgICAgICAgICAgdHdpbGlvRXJyb3I6IG5ldyBlcnJvcnNfMS5TaWduYWxpbmdFcnJvcnMuQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX3RpbWVPcGVuZWQ7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nLmluZm8oJ1dlYlNvY2tldCBjb25uZWN0aW9uIGF0dGVtcHQgdGltZWQgb3V0LicpO1xuICAgICAgICAgICAgX3RoaXMuX21vdmVVcmlJbmRleCgpO1xuICAgICAgICAgICAgX3RoaXMuX2Nsb3NlU29ja2V0KCk7XG4gICAgICAgIH0sIHRoaXMuX2Nvbm5lY3RUaW1lb3V0TXMpO1xuICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLl9vblNvY2tldENsb3NlKTtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25Tb2NrZXRFcnJvcik7XG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25Tb2NrZXRNZXNzYWdlKTtcbiAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLl9vblNvY2tldE9wZW4pO1xuICAgICAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgYSB0aW1lb3V0IHRvIHJlY29ubmVjdCBhZnRlciBIRUFSVEJFQVRfVElNRU9VVCBtaWxsaXNlY29uZHNcbiAgICAgKiAgIGhhdmUgcGFzc2VkIHdpdGhvdXQgcmVjZWl2aW5nIGEgbWVzc2FnZSBvdmVyIHRoZSBXZWJTb2NrZXQuXG4gICAgICovXG4gICAgV1NUcmFuc3BvcnQucHJvdG90eXBlLl9zZXRIZWFydGJlYXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5faGVhcnRiZWF0VGltZW91dCk7XG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9sb2cuaW5mbyhcIk5vIG1lc3NhZ2VzIHJlY2VpdmVkIGluIFwiICsgSEVBUlRCRUFUX1RJTUVPVVQgLyAxMDAwICsgXCIgc2Vjb25kcy4gUmVjb25uZWN0aW5nLi4uXCIpO1xuICAgICAgICAgICAgX3RoaXMuX3Nob3VsZEZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLl9jbG9zZVNvY2tldCgpO1xuICAgICAgICB9LCBIRUFSVEJFQVRfVElNRU9VVCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGN1cnJlbnQgYW5kIHByZXZpb3VzIHN0YXRlXG4gICAgICovXG4gICAgV1NUcmFuc3BvcnQucHJvdG90eXBlLl9zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB0aGlzLl9wcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdTVHJhbnNwb3J0LnByb3RvdHlwZSwgXCJ1cmlcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVyaSB0aGUgdHJhbnNwb3J0IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgdG9cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3VyaXNbdGhpcy5fdXJpSW5kZXhdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gV1NUcmFuc3BvcnQ7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV1NUcmFuc3BvcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13c3RyYW5zcG9ydC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/twilio-client/es5/twilio/wstransport.js\n")},"./node_modules/util/support/isBufferBrowser.js":module=>{eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L2lzQnVmZmVyQnJvd3Nlci5qcz9kNjBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/util/support/isBufferBrowser.js\n")},"./node_modules/util/support/types.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("// Currently in sync with Node.js lib/internal/util/types.js\n// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9\n\n\n\nvar isArgumentsObject = __webpack_require__(/*! is-arguments */ \"./node_modules/is-arguments/index.js\");\nvar isGeneratorFunction = __webpack_require__(/*! is-generator-function */ \"./node_modules/is-generator-function/index.js\");\nvar whichTypedArray = __webpack_require__(/*! which-typed-array */ \"./node_modules/which-typed-array/index.js\");\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nfunction uncurryThis(f) {\n  return f.call.bind(f);\n}\n\nvar BigIntSupported = typeof BigInt !== 'undefined';\nvar SymbolSupported = typeof Symbol !== 'undefined';\n\nvar ObjectToString = uncurryThis(Object.prototype.toString);\n\nvar numberValue = uncurryThis(Number.prototype.valueOf);\nvar stringValue = uncurryThis(String.prototype.valueOf);\nvar booleanValue = uncurryThis(Boolean.prototype.valueOf);\n\nif (BigIntSupported) {\n  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);\n}\n\nif (SymbolSupported) {\n  var symbolValue = uncurryThis(Symbol.prototype.valueOf);\n}\n\nfunction checkBoxedPrimitive(value, prototypeValueOf) {\n  if (typeof value !== 'object') {\n    return false;\n  }\n  try {\n    prototypeValueOf(value);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\nexports.isArgumentsObject = isArgumentsObject;\nexports.isGeneratorFunction = isGeneratorFunction;\nexports.isTypedArray = isTypedArray;\n\n// Taken from here and modified for better browser support\n// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js\nfunction isPromise(input) {\n\treturn (\n\t\t(\n\t\t\ttypeof Promise !== 'undefined' &&\n\t\t\tinput instanceof Promise\n\t\t) ||\n\t\t(\n\t\t\tinput !== null &&\n\t\t\ttypeof input === 'object' &&\n\t\t\ttypeof input.then === 'function' &&\n\t\t\ttypeof input.catch === 'function'\n\t\t)\n\t);\n}\nexports.isPromise = isPromise;\n\nfunction isArrayBufferView(value) {\n  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {\n    return ArrayBuffer.isView(value);\n  }\n\n  return (\n    isTypedArray(value) ||\n    isDataView(value)\n  );\n}\nexports.isArrayBufferView = isArrayBufferView;\n\n\nfunction isUint8Array(value) {\n  return whichTypedArray(value) === 'Uint8Array';\n}\nexports.isUint8Array = isUint8Array;\n\nfunction isUint8ClampedArray(value) {\n  return whichTypedArray(value) === 'Uint8ClampedArray';\n}\nexports.isUint8ClampedArray = isUint8ClampedArray;\n\nfunction isUint16Array(value) {\n  return whichTypedArray(value) === 'Uint16Array';\n}\nexports.isUint16Array = isUint16Array;\n\nfunction isUint32Array(value) {\n  return whichTypedArray(value) === 'Uint32Array';\n}\nexports.isUint32Array = isUint32Array;\n\nfunction isInt8Array(value) {\n  return whichTypedArray(value) === 'Int8Array';\n}\nexports.isInt8Array = isInt8Array;\n\nfunction isInt16Array(value) {\n  return whichTypedArray(value) === 'Int16Array';\n}\nexports.isInt16Array = isInt16Array;\n\nfunction isInt32Array(value) {\n  return whichTypedArray(value) === 'Int32Array';\n}\nexports.isInt32Array = isInt32Array;\n\nfunction isFloat32Array(value) {\n  return whichTypedArray(value) === 'Float32Array';\n}\nexports.isFloat32Array = isFloat32Array;\n\nfunction isFloat64Array(value) {\n  return whichTypedArray(value) === 'Float64Array';\n}\nexports.isFloat64Array = isFloat64Array;\n\nfunction isBigInt64Array(value) {\n  return whichTypedArray(value) === 'BigInt64Array';\n}\nexports.isBigInt64Array = isBigInt64Array;\n\nfunction isBigUint64Array(value) {\n  return whichTypedArray(value) === 'BigUint64Array';\n}\nexports.isBigUint64Array = isBigUint64Array;\n\nfunction isMapToString(value) {\n  return ObjectToString(value) === '[object Map]';\n}\nisMapToString.working = (\n  typeof Map !== 'undefined' &&\n  isMapToString(new Map())\n);\n\nfunction isMap(value) {\n  if (typeof Map === 'undefined') {\n    return false;\n  }\n\n  return isMapToString.working\n    ? isMapToString(value)\n    : value instanceof Map;\n}\nexports.isMap = isMap;\n\nfunction isSetToString(value) {\n  return ObjectToString(value) === '[object Set]';\n}\nisSetToString.working = (\n  typeof Set !== 'undefined' &&\n  isSetToString(new Set())\n);\nfunction isSet(value) {\n  if (typeof Set === 'undefined') {\n    return false;\n  }\n\n  return isSetToString.working\n    ? isSetToString(value)\n    : value instanceof Set;\n}\nexports.isSet = isSet;\n\nfunction isWeakMapToString(value) {\n  return ObjectToString(value) === '[object WeakMap]';\n}\nisWeakMapToString.working = (\n  typeof WeakMap !== 'undefined' &&\n  isWeakMapToString(new WeakMap())\n);\nfunction isWeakMap(value) {\n  if (typeof WeakMap === 'undefined') {\n    return false;\n  }\n\n  return isWeakMapToString.working\n    ? isWeakMapToString(value)\n    : value instanceof WeakMap;\n}\nexports.isWeakMap = isWeakMap;\n\nfunction isWeakSetToString(value) {\n  return ObjectToString(value) === '[object WeakSet]';\n}\nisWeakSetToString.working = (\n  typeof WeakSet !== 'undefined' &&\n  isWeakSetToString(new WeakSet())\n);\nfunction isWeakSet(value) {\n  return isWeakSetToString(value);\n}\nexports.isWeakSet = isWeakSet;\n\nfunction isArrayBufferToString(value) {\n  return ObjectToString(value) === '[object ArrayBuffer]';\n}\nisArrayBufferToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  isArrayBufferToString(new ArrayBuffer())\n);\nfunction isArrayBuffer(value) {\n  if (typeof ArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isArrayBufferToString.working\n    ? isArrayBufferToString(value)\n    : value instanceof ArrayBuffer;\n}\nexports.isArrayBuffer = isArrayBuffer;\n\nfunction isDataViewToString(value) {\n  return ObjectToString(value) === '[object DataView]';\n}\nisDataViewToString.working = (\n  typeof ArrayBuffer !== 'undefined' &&\n  typeof DataView !== 'undefined' &&\n  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))\n);\nfunction isDataView(value) {\n  if (typeof DataView === 'undefined') {\n    return false;\n  }\n\n  return isDataViewToString.working\n    ? isDataViewToString(value)\n    : value instanceof DataView;\n}\nexports.isDataView = isDataView;\n\nfunction isSharedArrayBufferToString(value) {\n  return ObjectToString(value) === '[object SharedArrayBuffer]';\n}\nisSharedArrayBufferToString.working = (\n  typeof SharedArrayBuffer !== 'undefined' &&\n  isSharedArrayBufferToString(new SharedArrayBuffer())\n);\nfunction isSharedArrayBuffer(value) {\n  if (typeof SharedArrayBuffer === 'undefined') {\n    return false;\n  }\n\n  return isSharedArrayBufferToString.working\n    ? isSharedArrayBufferToString(value)\n    : value instanceof SharedArrayBuffer;\n}\nexports.isSharedArrayBuffer = isSharedArrayBuffer;\n\nfunction isAsyncFunction(value) {\n  return ObjectToString(value) === '[object AsyncFunction]';\n}\nexports.isAsyncFunction = isAsyncFunction;\n\nfunction isMapIterator(value) {\n  return ObjectToString(value) === '[object Map Iterator]';\n}\nexports.isMapIterator = isMapIterator;\n\nfunction isSetIterator(value) {\n  return ObjectToString(value) === '[object Set Iterator]';\n}\nexports.isSetIterator = isSetIterator;\n\nfunction isGeneratorObject(value) {\n  return ObjectToString(value) === '[object Generator]';\n}\nexports.isGeneratorObject = isGeneratorObject;\n\nfunction isWebAssemblyCompiledModule(value) {\n  return ObjectToString(value) === '[object WebAssembly.Module]';\n}\nexports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n\nfunction isNumberObject(value) {\n  return checkBoxedPrimitive(value, numberValue);\n}\nexports.isNumberObject = isNumberObject;\n\nfunction isStringObject(value) {\n  return checkBoxedPrimitive(value, stringValue);\n}\nexports.isStringObject = isStringObject;\n\nfunction isBooleanObject(value) {\n  return checkBoxedPrimitive(value, booleanValue);\n}\nexports.isBooleanObject = isBooleanObject;\n\nfunction isBigIntObject(value) {\n  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);\n}\nexports.isBigIntObject = isBigIntObject;\n\nfunction isSymbolObject(value) {\n  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);\n}\nexports.isSymbolObject = isSymbolObject;\n\nfunction isBoxedPrimitive(value) {\n  return (\n    isNumberObject(value) ||\n    isStringObject(value) ||\n    isBooleanObject(value) ||\n    isBigIntObject(value) ||\n    isSymbolObject(value)\n  );\n}\nexports.isBoxedPrimitive = isBoxedPrimitive;\n\nfunction isAnyArrayBuffer(value) {\n  return typeof Uint8Array !== 'undefined' && (\n    isArrayBuffer(value) ||\n    isSharedArrayBuffer(value)\n  );\n}\nexports.isAnyArrayBuffer = isAnyArrayBuffer;\n\n['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {\n  Object.defineProperty(exports, method, {\n    enumerable: false,\n    value: function() {\n      throw new Error(method + ' is not supported in userland');\n    }\n  });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzP2JkNTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYix3QkFBd0IsbUJBQU8sQ0FBQywwREFBYztBQUM5QywwQkFBMEIsbUJBQU8sQ0FBQyw0RUFBdUI7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsb0VBQW1CO0FBQ2pELG1CQUFtQixtQkFBTyxDQUFDLDhEQUFnQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0Isb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7O0FBR3pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC9zdXBwb3J0L3R5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ3VycmVudGx5IGluIHN5bmMgd2l0aCBOb2RlLmpzIGxpYi9pbnRlcm5hbC91dGlsL3R5cGVzLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvY29tbWl0LzExMmNjN2MyNzU1MTI1NGFhMmIxNzA5OGZiNzc0ODY3ZjA1ZWQwZDlcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBcmd1bWVudHNPYmplY3QgPSByZXF1aXJlKCdpcy1hcmd1bWVudHMnKTtcbnZhciBpc0dlbmVyYXRvckZ1bmN0aW9uID0gcmVxdWlyZSgnaXMtZ2VuZXJhdG9yLWZ1bmN0aW9uJyk7XG52YXIgd2hpY2hUeXBlZEFycmF5ID0gcmVxdWlyZSgnd2hpY2gtdHlwZWQtYXJyYXknKTtcbnZhciBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCdpcy10eXBlZC1hcnJheScpO1xuXG5mdW5jdGlvbiB1bmN1cnJ5VGhpcyhmKSB7XG4gIHJldHVybiBmLmNhbGwuYmluZChmKTtcbn1cblxudmFyIEJpZ0ludFN1cHBvcnRlZCA9IHR5cGVvZiBCaWdJbnQgIT09ICd1bmRlZmluZWQnO1xudmFyIFN5bWJvbFN1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgT2JqZWN0VG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyhPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcblxudmFyIG51bWJlclZhbHVlID0gdW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTtcbnZhciBzdHJpbmdWYWx1ZSA9IHVuY3VycnlUaGlzKFN0cmluZy5wcm90b3R5cGUudmFsdWVPZik7XG52YXIgYm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXMoQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZik7XG5cbmlmIChCaWdJbnRTdXBwb3J0ZWQpIHtcbiAgdmFyIGJpZ0ludFZhbHVlID0gdW5jdXJyeVRoaXMoQmlnSW50LnByb3RvdHlwZS52YWx1ZU9mKTtcbn1cblxuaWYgKFN5bWJvbFN1cHBvcnRlZCkge1xuICB2YXIgc3ltYm9sVmFsdWUgPSB1bmN1cnJ5VGhpcyhTeW1ib2wucHJvdG90eXBlLnZhbHVlT2YpO1xufVxuXG5mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBwcm90b3R5cGVWYWx1ZU9mKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICAgcHJvdG90eXBlVmFsdWVPZih2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnRzLmlzQXJndW1lbnRzT2JqZWN0ID0gaXNBcmd1bWVudHNPYmplY3Q7XG5leHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBpc0dlbmVyYXRvckZ1bmN0aW9uO1xuZXhwb3J0cy5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG5cbi8vIFRha2VuIGZyb20gaGVyZSBhbmQgbW9kaWZpZWQgZm9yIGJldHRlciBicm93c2VyIHN1cHBvcnRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcC1pcy1wcm9taXNlL2Jsb2IvY2RhMzVhNTEzYmRhMDNmOTc3YWQ1Y2RlM2EwNzlkMjM3ZTgyZDdlZi9pbmRleC5qc1xuZnVuY3Rpb24gaXNQcm9taXNlKGlucHV0KSB7XG5cdHJldHVybiAoXG5cdFx0KFxuXHRcdFx0dHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRpbnB1dCBpbnN0YW5jZW9mIFByb21pc2Vcblx0XHQpIHx8XG5cdFx0KFxuXHRcdFx0aW5wdXQgIT09IG51bGwgJiZcblx0XHRcdHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiZcblx0XHRcdHR5cGVvZiBpbnB1dC50aGVuID09PSAnZnVuY3Rpb24nICYmXG5cdFx0XHR0eXBlb2YgaW5wdXQuY2F0Y2ggPT09ICdmdW5jdGlvbidcblx0XHQpXG5cdCk7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KSB7XG4gICAgcmV0dXJuIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIGlzVHlwZWRBcnJheSh2YWx1ZSkgfHxcbiAgICBpc0RhdGFWaWV3KHZhbHVlKVxuICApO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyVmlldyA9IGlzQXJyYXlCdWZmZXJWaWV3O1xuXG5cbmZ1bmN0aW9uIGlzVWludDhBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQ4QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQ4QXJyYXkgPSBpc1VpbnQ4QXJyYXk7XG5cbmZ1bmN0aW9uIGlzVWludDhDbGFtcGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdVaW50OENsYW1wZWRBcnJheSc7XG59XG5leHBvcnRzLmlzVWludDhDbGFtcGVkQXJyYXkgPSBpc1VpbnQ4Q2xhbXBlZEFycmF5O1xuXG5mdW5jdGlvbiBpc1VpbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnVWludDE2QXJyYXknO1xufVxuZXhwb3J0cy5pc1VpbnQxNkFycmF5ID0gaXNVaW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNVaW50MzJBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ1VpbnQzMkFycmF5Jztcbn1cbmV4cG9ydHMuaXNVaW50MzJBcnJheSA9IGlzVWludDMyQXJyYXk7XG5cbmZ1bmN0aW9uIGlzSW50OEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50OEFycmF5Jztcbn1cbmV4cG9ydHMuaXNJbnQ4QXJyYXkgPSBpc0ludDhBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQxNkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MTZBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MTZBcnJheSA9IGlzSW50MTZBcnJheTtcblxuZnVuY3Rpb24gaXNJbnQzMkFycmF5KHZhbHVlKSB7XG4gIHJldHVybiB3aGljaFR5cGVkQXJyYXkodmFsdWUpID09PSAnSW50MzJBcnJheSc7XG59XG5leHBvcnRzLmlzSW50MzJBcnJheSA9IGlzSW50MzJBcnJheTtcblxuZnVuY3Rpb24gaXNGbG9hdDMyQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdGbG9hdDMyQXJyYXknO1xufVxuZXhwb3J0cy5pc0Zsb2F0MzJBcnJheSA9IGlzRmxvYXQzMkFycmF5O1xuXG5mdW5jdGlvbiBpc0Zsb2F0NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0Zsb2F0NjRBcnJheSc7XG59XG5leHBvcnRzLmlzRmxvYXQ2NEFycmF5ID0gaXNGbG9hdDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnSW50NjRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gd2hpY2hUeXBlZEFycmF5KHZhbHVlKSA9PT0gJ0JpZ0ludDY0QXJyYXknO1xufVxuZXhwb3J0cy5pc0JpZ0ludDY0QXJyYXkgPSBpc0JpZ0ludDY0QXJyYXk7XG5cbmZ1bmN0aW9uIGlzQmlnVWludDY0QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIHdoaWNoVHlwZWRBcnJheSh2YWx1ZSkgPT09ICdCaWdVaW50NjRBcnJheSc7XG59XG5leHBvcnRzLmlzQmlnVWludDY0QXJyYXkgPSBpc0JpZ1VpbnQ2NEFycmF5O1xuXG5mdW5jdGlvbiBpc01hcFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IE1hcF0nO1xufVxuaXNNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgTWFwICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc01hcFRvU3RyaW5nKG5ldyBNYXAoKSlcbik7XG5cbmZ1bmN0aW9uIGlzTWFwKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc01hcFRvU3RyaW5nLndvcmtpbmdcbiAgICA/IGlzTWFwVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIE1hcDtcbn1cbmV4cG9ydHMuaXNNYXAgPSBpc01hcDtcblxuZnVuY3Rpb24gaXNTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBTZXRdJztcbn1cbmlzU2V0VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNTZXRUb1N0cmluZyhuZXcgU2V0KCkpXG4pO1xuZnVuY3Rpb24gaXNTZXQodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzU2V0VG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTZXRUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgU2V0O1xufVxuZXhwb3J0cy5pc1NldCA9IGlzU2V0O1xuXG5mdW5jdGlvbiBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrTWFwXSc7XG59XG5pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXAoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1dlYWtNYXBUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc1dlYWtNYXBUb1N0cmluZyh2YWx1ZSlcbiAgICA6IHZhbHVlIGluc3RhbmNlb2YgV2Vha01hcDtcbn1cbmV4cG9ydHMuaXNXZWFrTWFwID0gaXNXZWFrTWFwO1xuXG5mdW5jdGlvbiBpc1dlYWtTZXRUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBXZWFrU2V0XSc7XG59XG5pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgV2Vha1NldCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQoKSlcbik7XG5mdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzV2Vha1NldFRvU3RyaW5nKHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cbmlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nID0gKFxuICB0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhuZXcgQXJyYXlCdWZmZXIoKSlcbik7XG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0FycmF5QnVmZmVyVG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufVxuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcblxuZnVuY3Rpb24gaXNEYXRhVmlld1RvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IERhdGFWaWV3XSc7XG59XG5pc0RhdGFWaWV3VG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgRGF0YVZpZXcgIT09ICd1bmRlZmluZWQnICYmXG4gIGlzRGF0YVZpZXdUb1N0cmluZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpLCAwLCAxKSlcbik7XG5mdW5jdGlvbiBpc0RhdGFWaWV3KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgRGF0YVZpZXcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nXG4gICAgPyBpc0RhdGFWaWV3VG9TdHJpbmcodmFsdWUpXG4gICAgOiB2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3O1xufVxuZXhwb3J0cy5pc0RhdGFWaWV3ID0gaXNEYXRhVmlldztcblxuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSc7XG59XG5pc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZyA9IChcbiAgdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcobmV3IFNoYXJlZEFycmF5QnVmZmVyKCkpXG4pO1xuZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpc1NoYXJlZEFycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZ1xuICAgID8gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHZhbHVlKVxuICAgIDogdmFsdWUgaW5zdGFuY2VvZiBTaGFyZWRBcnJheUJ1ZmZlcjtcbn1cbmV4cG9ydHMuaXNTaGFyZWRBcnJheUJ1ZmZlciA9IGlzU2hhcmVkQXJyYXlCdWZmZXI7XG5cbmZ1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXSc7XG59XG5leHBvcnRzLmlzQXN5bmNGdW5jdGlvbiA9IGlzQXN5bmNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNNYXBJdGVyYXRvcih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBNYXAgSXRlcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNNYXBJdGVyYXRvciA9IGlzTWFwSXRlcmF0b3I7XG5cbmZ1bmN0aW9uIGlzU2V0SXRlcmF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdFRvU3RyaW5nKHZhbHVlKSA9PT0gJ1tvYmplY3QgU2V0IEl0ZXJhdG9yXSc7XG59XG5leHBvcnRzLmlzU2V0SXRlcmF0b3IgPSBpc1NldEl0ZXJhdG9yO1xuXG5mdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0VG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBHZW5lcmF0b3JdJztcbn1cbmV4cG9ydHMuaXNHZW5lcmF0b3JPYmplY3QgPSBpc0dlbmVyYXRvck9iamVjdDtcblxuZnVuY3Rpb24gaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFdlYkFzc2VtYmx5Lk1vZHVsZV0nO1xufVxuZXhwb3J0cy5pc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUgPSBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGU7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBudW1iZXJWYWx1ZSk7XG59XG5leHBvcnRzLmlzTnVtYmVyT2JqZWN0ID0gaXNOdW1iZXJPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzdHJpbmdWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3RyaW5nT2JqZWN0ID0gaXNTdHJpbmdPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZSh2YWx1ZSwgYm9vbGVhblZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCb29sZWFuT2JqZWN0ID0gaXNCb29sZWFuT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0JpZ0ludE9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gQmlnSW50U3VwcG9ydGVkICYmIGNoZWNrQm94ZWRQcmltaXRpdmUodmFsdWUsIGJpZ0ludFZhbHVlKTtcbn1cbmV4cG9ydHMuaXNCaWdJbnRPYmplY3QgPSBpc0JpZ0ludE9iamVjdDtcblxuZnVuY3Rpb24gaXNTeW1ib2xPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIFN5bWJvbFN1cHBvcnRlZCAmJiBjaGVja0JveGVkUHJpbWl0aXZlKHZhbHVlLCBzeW1ib2xWYWx1ZSk7XG59XG5leHBvcnRzLmlzU3ltYm9sT2JqZWN0ID0gaXNTeW1ib2xPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICBpc051bWJlck9iamVjdCh2YWx1ZSkgfHxcbiAgICBpc1N0cmluZ09iamVjdCh2YWx1ZSkgfHxcbiAgICBpc0Jvb2xlYW5PYmplY3QodmFsdWUpIHx8XG4gICAgaXNCaWdJbnRPYmplY3QodmFsdWUpIHx8XG4gICAgaXNTeW1ib2xPYmplY3QodmFsdWUpXG4gICk7XG59XG5leHBvcnRzLmlzQm94ZWRQcmltaXRpdmUgPSBpc0JveGVkUHJpbWl0aXZlO1xuXG5mdW5jdGlvbiBpc0FueUFycmF5QnVmZmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICAgIGlzQXJyYXlCdWZmZXIodmFsdWUpIHx8XG4gICAgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZSlcbiAgKTtcbn1cbmV4cG9ydHMuaXNBbnlBcnJheUJ1ZmZlciA9IGlzQW55QXJyYXlCdWZmZXI7XG5cblsnaXNQcm94eScsICdpc0V4dGVybmFsJywgJ2lzTW9kdWxlTmFtZXNwYWNlT2JqZWN0J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG1ldGhvZCwge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util/support/types.js\n")},"./node_modules/util/util.js":(__unused_webpack_module,exports,__webpack_require__)=>{eval("/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnvRegex = /^$/;\n\nif (process.env.NODE_DEBUG) {\n  var debugEnv = process.env.NODE_DEBUG;\n  debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g, '\\\\$&')\n    .replace(/\\*/g, '.*')\n    .replace(/,/g, '$|^')\n    .toUpperCase();\n  debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');\n}\nexports.debuglog = function(set) {\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (debugEnvRegex.test(set)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nexports.types = __webpack_require__(/*! ./support/types */ \"./node_modules/util/support/types.js\");\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\nexports.types.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\nexports.types.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\nexports.types.isNativeError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb.bind(null, null, ret)) },\n            function(rej) { process.nextTick(callbackifyOnRejected.bind(null, rej, cb)) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzPzMwMjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWEsT0FBTyxvQkFBb0IsT0FBTztBQUMvQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBLE9BQU8sVUFBVSxPQUFPO0FBQ3hCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLElBQUksT0FBTztBQUNYLGlCQUFpQixPQUFPO0FBQ3hCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixDQUFDLE9BQU8scUNBQXFDO0FBQ3hFLDJCQUEyQixDQUFDLE9BQU8sc0RBQXNEO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0VudlJlZ2V4ID0gL14kLztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfREVCVUcpIHtcbiAgdmFyIGRlYnVnRW52ID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRztcbiAgZGVidWdFbnYgPSBkZWJ1Z0Vudi5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLCAnXFxcXCQmJylcbiAgICAucmVwbGFjZSgvXFwqL2csICcuKicpXG4gICAgLnJlcGxhY2UoLywvZywgJyR8XicpXG4gICAgLnRvVXBwZXJDYXNlKCk7XG4gIGRlYnVnRW52UmVnZXggPSBuZXcgUmVnRXhwKCdeJyArIGRlYnVnRW52ICsgJyQnLCAnaScpO1xufVxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChkZWJ1Z0VudlJlZ2V4LnRlc3Qoc2V0KSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9zdXBwb3J0L3R5cGVzJyk7XG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5leHBvcnRzLnR5cGVzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuZXhwb3J0cy50eXBlcy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcbmV4cG9ydHMudHlwZXMuaXNOYXRpdmVFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbCgndXRpbC5wcm9taXNpZnkuY3VzdG9tJykgOiB1bmRlZmluZWQ7XG5cbmV4cG9ydHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24gcHJvbWlzaWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sICYmIG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF0pIHtcbiAgICB2YXIgZm4gPSBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdO1xuICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBmdW5jdGlvbiBmbigpIHtcbiAgICB2YXIgcHJvbWlzZVJlc29sdmUsIHByb21pc2VSZWplY3Q7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBwcm9taXNlUmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICBwcm9taXNlUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCB2YWx1ZSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBwcm9taXNlUmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZm4sIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgdmFsdWU6IGZuLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IGZhbHNlLCBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhcbiAgICBmbixcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKVxuICApO1xufVxuXG5leHBvcnRzLnByb21pc2lmeS5jdXN0b20gPSBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xcblxuZnVuY3Rpb24gY2FsbGJhY2tpZnlPblJlamVjdGVkKHJlYXNvbiwgY2IpIHtcbiAgLy8gYCFyZWFzb25gIGd1YXJkIGluc3BpcmVkIGJ5IGJsdWViaXJkIChSZWY6IGh0dHBzOi8vZ29vLmdsL3Q1SVM2TSkuXG4gIC8vIEJlY2F1c2UgYG51bGxgIGlzIGEgc3BlY2lhbCBlcnJvciB2YWx1ZSBpbiBjYWxsYmFja3Mgd2hpY2ggbWVhbnMgXCJubyBlcnJvclxuICAvLyBvY2N1cnJlZFwiLCB3ZSBlcnJvci13cmFwIHNvIHRoZSBjYWxsYmFjayBjb25zdW1lciBjYW4gZGlzdGluZ3Vpc2ggYmV0d2VlblxuICAvLyBcInRoZSBwcm9taXNlIHJlamVjdGVkIHdpdGggbnVsbFwiIG9yIFwidGhlIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdW5kZWZpbmVkXCIuXG4gIGlmICghcmVhc29uKSB7XG4gICAgdmFyIG5ld1JlYXNvbiA9IG5ldyBFcnJvcignUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlJyk7XG4gICAgbmV3UmVhc29uLnJlYXNvbiA9IHJlYXNvbjtcbiAgICByZWFzb24gPSBuZXdSZWFzb247XG4gIH1cbiAgcmV0dXJuIGNiKHJlYXNvbik7XG59XG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5KG9yaWdpbmFsKSB7XG4gIGlmICh0eXBlb2Ygb3JpZ2luYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gV2UgRE8gTk9UIHJldHVybiB0aGUgcHJvbWlzZSBhcyBpdCBnaXZlcyB0aGUgdXNlciBhIGZhbHNlIHNlbnNlIHRoYXRcbiAgLy8gdGhlIHByb21pc2UgaXMgYWN0dWFsbHkgc29tZWhvdyByZWxhdGVkIHRvIHRoZSBjYWxsYmFjaydzIGV4ZWN1dGlvblxuICAvLyBhbmQgdGhhdCB0aGUgY2FsbGJhY2sgdGhyb3dpbmcgd2lsbCByZWplY3QgdGhlIHByb21pc2UuXG4gIGZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG1heWJlQ2IgPSBhcmdzLnBvcCgpO1xuICAgIGlmICh0eXBlb2YgbWF5YmVDYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBtYXliZUNiLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICAvLyBJbiB0cnVlIG5vZGUgc3R5bGUgd2UgcHJvY2VzcyB0aGUgY2FsbGJhY2sgb24gYG5leHRUaWNrYCB3aXRoIGFsbCB0aGVcbiAgICAvLyBpbXBsaWNhdGlvbnMgKHN0YWNrLCBgdW5jYXVnaHRFeGNlcHRpb25gLCBgYXN5bmNfaG9va3NgKVxuICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAudGhlbihmdW5jdGlvbihyZXQpIHsgcHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsIG51bGwsIHJldCkpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLCByZWosIGNiKSkgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/util/util.js\n")},"./node_modules/which-typed-array/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar forEach = __webpack_require__(/*! foreach */ \"./node_modules/foreach/index.js\");\nvar availableTypedArrays = __webpack_require__(/*! available-typed-arrays */ \"./node_modules/available-typed-arrays/index.js\");\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \"./node_modules/call-bind/callBound.js\");\n\nvar $toString = callBound('Object.prototype.toString');\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \"./node_modules/has-symbols/index.js\")();\nvar hasToStringTag = hasSymbols && typeof Symbol.toStringTag === 'symbol';\n\nvar typedArrays = availableTypedArrays();\n\nvar $slice = callBound('String.prototype.slice');\nvar toStrTags = {};\nvar gOPD = __webpack_require__(/*! es-abstract/helpers/getOwnPropertyDescriptor */ \"./node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js\");\nvar getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');\nif (hasToStringTag && gOPD && getPrototypeOf) {\n\tforEach(typedArrays, function (typedArray) {\n\t\tif (typeof __webpack_require__.g[typedArray] === 'function') {\n\t\t\tvar arr = new __webpack_require__.g[typedArray]();\n\t\t\tif (!(Symbol.toStringTag in arr)) {\n\t\t\t\tthrow new EvalError('this engine has support for Symbol.toStringTag, but ' + typedArray + ' does not have the property! Please report this.');\n\t\t\t}\n\t\t\tvar proto = getPrototypeOf(arr);\n\t\t\tvar descriptor = gOPD(proto, Symbol.toStringTag);\n\t\t\tif (!descriptor) {\n\t\t\t\tvar superProto = getPrototypeOf(proto);\n\t\t\t\tdescriptor = gOPD(superProto, Symbol.toStringTag);\n\t\t\t}\n\t\t\ttoStrTags[typedArray] = descriptor.get;\n\t\t}\n\t});\n}\n\nvar tryTypedArrays = function tryAllTypedArrays(value) {\n\tvar foundName = false;\n\tforEach(toStrTags, function (getter, typedArray) {\n\t\tif (!foundName) {\n\t\t\ttry {\n\t\t\t\tvar name = getter.call(value);\n\t\t\t\tif (name === typedArray) {\n\t\t\t\t\tfoundName = name;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\t});\n\treturn foundName;\n};\n\nvar isTypedArray = __webpack_require__(/*! is-typed-array */ \"./node_modules/is-typed-array/index.js\");\n\nmodule.exports = function whichTypedArray(value) {\n\tif (!isTypedArray(value)) { return false; }\n\tif (!hasToStringTag) { return $slice($toString(value), 8, -1); }\n\treturn tryTypedArrays(value);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Db0NyZWF0ZS50d2lsaW8vLi9ub2RlX21vZHVsZXMvd2hpY2gtdHlwZWQtYXJyYXkvaW5kZXguanM/ZWRjNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7QUFDL0IsMkJBQTJCLG1CQUFPLENBQUMsOEVBQXdCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLGtFQUFxQjs7QUFFN0M7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx3REFBYTtBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLG9IQUE4QztBQUNqRSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBLGFBQWEscUJBQU07QUFDbkIsaUJBQWlCLHFCQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsOERBQWdCOztBQUUzQztBQUNBLDRCQUE0QixjQUFjO0FBQzFDLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy93aGljaC10eXBlZC1hcnJheS9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGZvckVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG52YXIgYXZhaWxhYmxlVHlwZWRBcnJheXMgPSByZXF1aXJlKCdhdmFpbGFibGUtdHlwZWQtYXJyYXlzJyk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzJykoKTtcbnZhciBoYXNUb1N0cmluZ1RhZyA9IGhhc1N5bWJvbHMgJiYgdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCc7XG5cbnZhciB0eXBlZEFycmF5cyA9IGF2YWlsYWJsZVR5cGVkQXJyYXlzKCk7XG5cbnZhciAkc2xpY2UgPSBjYWxsQm91bmQoJ1N0cmluZy5wcm90b3R5cGUuc2xpY2UnKTtcbnZhciB0b1N0clRhZ3MgPSB7fTtcbnZhciBnT1BEID0gcmVxdWlyZSgnZXMtYWJzdHJhY3QvaGVscGVycy9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjsgLy8gcmVxdWlyZSgnZ2V0cHJvdG90eXBlb2YnKTtcbmlmIChoYXNUb1N0cmluZ1RhZyAmJiBnT1BEICYmIGdldFByb3RvdHlwZU9mKSB7XG5cdGZvckVhY2godHlwZWRBcnJheXMsIGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG5cdFx0aWYgKHR5cGVvZiBnbG9iYWxbdHlwZWRBcnJheV0gPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHZhciBhcnIgPSBuZXcgZ2xvYmFsW3R5cGVkQXJyYXldKCk7XG5cdFx0XHRpZiAoIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gYXJyKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXZhbEVycm9yKCd0aGlzIGVuZ2luZSBoYXMgc3VwcG9ydCBmb3IgU3ltYm9sLnRvU3RyaW5nVGFnLCBidXQgJyArIHR5cGVkQXJyYXkgKyAnIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuJyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihhcnIpO1xuXHRcdFx0dmFyIGRlc2NyaXB0b3IgPSBnT1BEKHByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0aWYgKCFkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBzdXBlclByb3RvID0gZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuXHRcdFx0XHRkZXNjcmlwdG9yID0gZ09QRChzdXBlclByb3RvLCBTeW1ib2wudG9TdHJpbmdUYWcpO1xuXHRcdFx0fVxuXHRcdFx0dG9TdHJUYWdzW3R5cGVkQXJyYXldID0gZGVzY3JpcHRvci5nZXQ7XG5cdFx0fVxuXHR9KTtcbn1cblxudmFyIHRyeVR5cGVkQXJyYXlzID0gZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXModmFsdWUpIHtcblx0dmFyIGZvdW5kTmFtZSA9IGZhbHNlO1xuXHRmb3JFYWNoKHRvU3RyVGFncywgZnVuY3Rpb24gKGdldHRlciwgdHlwZWRBcnJheSkge1xuXHRcdGlmICghZm91bmROYW1lKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IGdldHRlci5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKG5hbWUgPT09IHR5cGVkQXJyYXkpIHtcblx0XHRcdFx0XHRmb3VuZE5hbWUgPSBuYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblx0fSk7XG5cdHJldHVybiBmb3VuZE5hbWU7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnaXMtdHlwZWQtYXJyYXknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGljaFR5cGVkQXJyYXkodmFsdWUpIHtcblx0aWYgKCFpc1R5cGVkQXJyYXkodmFsdWUpKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAoIWhhc1RvU3RyaW5nVGFnKSB7IHJldHVybiAkc2xpY2UoJHRvU3RyaW5nKHZhbHVlKSwgOCwgLTEpOyB9XG5cdHJldHVybiB0cnlUeXBlZEFycmF5cyh2YWx1ZSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/which-typed-array/index.js\n")}},__webpack_module_cache__={};function __webpack_require__(n){var e=__webpack_module_cache__[n];if(void 0!==e)return e.exports;var I=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n].call(I.exports,I,I.exports,__webpack_require__),I.exports}__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}();var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));